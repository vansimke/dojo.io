{"dependencies":{"production":{"@dojo/core":"~0.2.1","@dojo/has":"~0.1.0","@dojo/routing":"~0.2.0","@dojo/shim":"~0.2.2","@dojo/widget-core":"~0.3.0","@dojo/i18n":"~0.2.0","@dojo/widgets":"~0.2.1","intersection-observer":"^0.4.2","pepjs":"^0.4.2","tslib":"^1.7.1","web-animations-js":"^2.3.1","globalize":"1.3.0","cldrjs":"^0.4.6"},"development":{"@dojo/cli-build-webpack":"~0.2.0","@dojo/cli-test-intern":"~0.2.0","@dojo/interfaces":"~0.2.0","@dojo/loader":"~0.1.0","@dojo/test-extras":"~0.2.0","@types/glob":"~5.0.0","@types/grunt":"~0.4.0","@types/node":"*","@types/sinon":"^1.16.35","chai":"~4.1.2","intern":"~4.1.0","sinon":"^1.17.5","typescript":">=2.0.0 || >=2.0.0-dev || >=2.1.0-dev || >=2.2.0-dev || >=2.3.0-dev || >= 2.4.0-dev","@dojo/core":"~0.3.0","@dojo/has":"~0.1.1","@dojo/i18n":"~0.2.0","@dojo/shim":"~0.2.3","@dojo/webpack-contrib":"~0.1.1","auto-require-webpack-plugin":"1.0.1","bundle-loader":"0.5.5","copy-webpack-plugin":"4.0.1","css-loader":"0.26.4","extract-text-webpack-plugin":"2.1.2","file-loader":"0.10.1","html-loader":"0.4.5","html-webpack-include-assets-plugin":"0.0.7","html-webpack-plugin":"2.29.0","imports-loader":"0.7.1","istanbul-lib-instrument":"~1.7.3","json-css-module-loader":"1.0.2","loader-utils":"^0.2.16","optimize-css-assets-webpack-plugin":"1.3.2","pkg-dir":"^1.0.0","postcss-cssnext":"2.11.0","postcss-import":"10.0.0","postcss-loader":"2.0.6","promise-loader":"^1.0.0","source-map-loader-cli":"0.0.1","style-loader":"0.13.2","ts-loader":"2.3.1","tslint":">=4.0.0","tslint-loader":"3.5.3","typed-css-modules":"0.2.0","umd-compat-loader":"2.1.1","webpack":"^1.0.0 || ^2.0.0 || ^3.0.0","webpack-bundle-analyzer-sunburst":"1.3.0","webpack-dev-server":"2.6.1","chalk":"^1.1.3","codecov.io":"0.1.6","cross-spawn":"^5.0.1","mockery":"^1.7.0","@dojo/widget-core":"~0.3.0","jsdom":"^10.0.0","pepjs":"^0.4.2","@types/events":"*","@types/minimatch":"*","assertion-error":"^1.0.1","deep-eql":"^0.1.3","type-detect":"^4.0.0","@theintern/digdug":"~2.0.4","@theintern/leadfoot":"~2.0.3","@types/benchmark":"~1.0.30","@types/chai":"~4.0.7","@types/charm":"~1.0.0","@types/diff":"~3.2.0","@types/express":"*","@types/http-errors":"~1.5.34","@types/istanbul-lib-coverage":"*","@types/istanbul-lib-hook":"~1.0.0","@types/istanbul-lib-instrument":"~1.7.0","@types/istanbul-lib-report":"*","@types/istanbul-lib-source-maps":"~1.2.0","@types/istanbul-reports":"~1.1.0","@types/lodash":"~4.14.65","@types/mime-types":"~2.1.0","@types/platform":"~1.3.0","@types/resolve":"0.0.4","@types/shell-quote":"~1.6.0","@types/source-map":"~0.1.29","@types/statuses":"~1.2.28","@types/ws":"~0.0.38","benchmark":"~2.1.4","body-parser":"1.18.2","charm":"~1.0.2","diff":"^3.0.1","express":"^4.13.3","glob":"^7.0.3","http-errors":"~1.6.2","istanbul-lib-coverage":"^1.1.1","istanbul-lib-hook":"~1.0.7","istanbul-lib-report":"~1.1.1","istanbul-lib-source-maps":"~1.2.1","istanbul-reports":"~1.1.1","lodash":"^4.13.1","mime-types":"^2.1.12","minimatch":"^3.0.2","platform":"^1.3.3","resolve":"^1.1.7","shell-quote":"~1.6.1","source-map":"^0.5.3","statuses":"~1.3.1","tslib":"~1.8.0","ws":"~2.3.1","formatio":"1.2.0","lolex":"^1.6.0","native-promise-only":"^0.8.1","path-to-regexp":"0.1.7","samsam":"~1.1","text-encoding":"0.6.4","globalize":"1.3.0","intersection-observer":"^0.4.2","recast":"~0.11.12","bluebird":"^3.4.7","fs-extra":"^0.26.4","is-glob":"^2.0.0","node-dir":"^0.1.10","babel-code-frame":"^6.26.0","css-selector-tokenizer":"^0.7.0","cssnano":"^3.4.0","lodash.camelcase":"^4.3.0","object-assign":"^4.1.0","postcss":"^5.0.4","postcss-modules-extract-imports":"1.1.0","postcss-modules-local-by-default":"1.2.0","postcss-modules-scope":"1.1.0","postcss-modules-values":"1.3.0","source-list-map":"^2.0.0","async":"^1.4.0","schema-utils":"^0.3.0","webpack-sources":"^1.0.1","es6-templates":"^0.2.2","fastparse":"^1.1.1","html-minifier":"^3.2.3","pretty-error":"^2.0.2","toposort":"^1.0.0","babel-generator":"^6.18.0","babel-template":"^6.16.0","babel-traverse":"^6.26.0","babel-types":"^6.26.0","babylon":"^6.18.0","semver":"2 || 3 || 4 || 5","big.js":"^3.1.3","emojis-list":"^2.0.0","json5":"^0.5.1","underscore":"^1.8.3","find-up":"^1.0.0","caniuse-db":"^1.0.30000639","autoprefixer":"^6.3.1","caniuse-api":"^1.5.2","pixrem":"^3.0.0","pleeease-filters":"^3.0.0","postcss-apply":"^0.3.0","postcss-attribute-case-insensitive":"^1.0.1","postcss-calc":"^5.2.0","postcss-color-function":"^2.0.0","postcss-color-gray":"^3.0.0","postcss-color-hex-alpha":"^2.0.0","postcss-color-hsl":"^1.0.5","postcss-color-hwb":"^2.0.0","postcss-color-rebeccapurple":"^2.0.0","postcss-color-rgb":"^1.1.4","postcss-color-rgba-fallback":"^2.0.0","postcss-custom-media":"^5.0.0","postcss-custom-properties":"^5.0.0","postcss-custom-selectors":"^3.0.0","postcss-font-family-system-ui":"^1.0.1","postcss-font-variant":"^2.0.0","postcss-image-set-polyfill":"^0.3.3","postcss-initial":"^1.3.1","postcss-media-minmax":"^2.1.0","postcss-nesting":"^2.0.5","postcss-pseudo-class-any-link":"^1.0.0","postcss-pseudoelements":"^3.0.0","postcss-replace-overflow-wrap":"^1.0.0","postcss-selector-matches":"^2.0.0","postcss-selector-not":"^2.0.0","postcss-value-parser":"^3.2.3","read-cache":"^1.0.0","postcss-load-config":"^1.2.0","enhanced-resolve":"^3.3.0","colors":"~1.1.2","findup-sync":"~0.3.0","optimist":"^0.6.1","tsutils":"^1.1.0","update-notifier":"^2.0.0","mkdirp":"~0.5.1","rimraf":"^2.2.8","camelcase":"^2.0.0","css-modules-loader-core":"^1.0.0","gaze":"^1.1.1","is-there":"^4.3.1","yargs":"^6.0.0","ast-types":"0.10.1","acorn":"^4.0.4","acorn-dynamic-import":"^2.0.0","ajv":"^5.1.0","ajv-keywords":"^1.1.1","interpret":"^1.0.0","json-loader":"^0.5.4","loader-runner":"^2.3.0","memory-fs":"~0.4.1","node-libs-browser":"^2.0.0","supports-color":"^3.2.3","tapable":"^0.2.7","uglify-js":"^2.6","watchpack":"^1.3.1","commander":"~2.8.1","ejs":"^2.5.2","filesize":"^3.3.0","gzip-size":"^3.0.0","opener":"^1.4.2","ansi-html":"0.0.7","bonjour":"^3.5.0","chokidar":"^1.7.0","compression":"^1.5.2","connect-history-api-fallback":"^1.3.0","del":"^3.0.0","html-entities":"^1.2.0","http-proxy-middleware":"~0.17.4","internal-ip":"^1.2.0","loglevel":"^1.4.1","opn":"4.0.2","portfinder":"^1.0.9","selfsigned":"^1.9.1","serve-index":"^1.7.2","sockjs":"0.3.18","sockjs-client":"1.1.4","spdy":"^3.4.1","strip-ansi":"^3.0.1","webpack-dev-middleware":"^1.11.0","ansi-styles":"^2.2.1","escape-string-regexp":"^1.0.2","has-ansi":"^2.0.0","request":"^2.34","urlgrey":"0.4.0","lru-cache":"^4.0.1","shebang-command":"^1.2.0","which":"^1.2.9","web-animations-js":"^2.3.1","abab":"^1.0.3","acorn-globals":"^3.1.0","array-equal":"^1.0.0","content-type-parser":"^1.0.1","cssom":"0.3.x","cssstyle":">= 0.2.37 < 0.3.0","escodegen":"^1.6.1","html-encoding-sniffer":"^1.0.1","nwmatcher":">= 1.3.9 < 2.0.0","parse5":"^1.5.1","pn":"^1.0.0","request-promise-native":"^1.0.3","sax":"~1.2.1","symbol-tree":"^3.2.1","tough-cookie":">=2.3.3","webidl-conversions":"^3.0.0","whatwg-encoding":"^1.0.1","whatwg-url":"^4.3.0","xml-name-validator":"^2.0.1","decompress":"~4.2.0","@types/jszip":"0.0.33","jszip":"~3.1.3","@types/body-parser":"*","@types/express-serve-static-core":"*","@types/serve-static":"*","@types/babel-types":"*","bytes":"3.0.0","content-type":"~1.0.4","debug":"^2.6.8","depd":"~1.1.1","iconv-lite":"0.4.19","on-finished":"~2.3.0","qs":"~6.5.1","raw-body":"2.3.2","type-is":"~1.6.15","inherits":"^2.0.1","accepts":"~1.3.4","array-flatten":"^2.1.0","content-disposition":"0.5.2","cookie":"0.3.1","cookie-signature":"1.0.6","encodeurl":"~1.0.1","escape-html":"~1.0.3","etag":"~1.8.1","finalhandler":"1.1.0","fresh":"0.5.2","merge-descriptors":"1.0.1","methods":"~1.1.2","parseurl":"~1.3.2","proxy-addr":"~2.0.2","range-parser":"~1.2.0","safe-buffer":"^5.0.1","send":"0.16.1","serve-static":"1.13.1","setprototypeof":"1.0.3","utils-merge":"1.0.1","vary":"~1.1.2","inflight":"^1.0.4","once":"^1.4.0","path-is-absolute":"^1.0.0","append-transform":"^0.4.0","path-parse":"^1.0.5","handlebars":"^4.0.3","mime-db":">= 1.30.0 < 2","brace-expansion":"^1.1.7","array-filter":"~0.0.0","array-map":"~0.0.0","array-reduce":"~0.0.0","jsonify":"~0.0.0","ultron":"~1.1.0","cldrjs":"^0.4.6","core-js":"^2.4.0","esprima":"^2.6.0","private":"~0.1.5","graceful-fs":"^4.1.2","jsonfile":"^2.1.0","klaw":"^1.0.0","is-extglob":"^1.0.0","esutils":"^2.0.2","js-tokens":"^3.0.0","cssesc":"^0.1.0","regexpu-core":"^1.0.0","decamelize":"^1.1.2","defined":"~0.0.0","has":"^1.0.1","postcss-colormin":"^2.1.8","postcss-convert-values":"^2.3.4","postcss-discard-comments":"^2.0.4","postcss-discard-duplicates":"^2.0.1","postcss-discard-empty":"^2.0.1","postcss-discard-overridden":"^0.1.1","postcss-discard-unused":"^2.2.1","postcss-filter-plugins":"^2.0.0","postcss-merge-idents":"^2.1.5","postcss-merge-longhand":"^2.0.1","postcss-merge-rules":"^2.0.3","postcss-minify-font-values":"^1.0.2","postcss-minify-gradients":"^1.0.1","postcss-minify-params":"^1.0.4","postcss-minify-selectors":"^2.0.4","postcss-normalize-charset":"^1.1.0","postcss-normalize-url":"^3.0.7","postcss-ordered-values":"^2.1.0","postcss-reduce-idents":"^2.2.2","postcss-reduce-initial":"^1.0.0","postcss-reduce-transforms":"^1.0.3","postcss-svgo":"^2.1.1","postcss-unique-selectors":"^2.0.2","postcss-zindex":"^2.0.1","js-base64":"^2.1.9","icss-replace-symbols":"1.1.0","through":"^2.3.6","camel-case":"3.0.x","clean-css":"4.1.x","he":"1.1.x","ncname":"1.0.x","param-case":"2.1.x","relateurl":"0.2.x","renderkid":"^2.0.1","utila":"~0.3","babel-messages":"^6.23.0","babel-runtime":"^6.22.0","detect-indent":"^4.0.0","jsesc":"~0.5.0","trim-right":"^1.0.1","globals":"^9.18.0","invariant":"^2.2.2","to-fast-properties":"^1.0.3","path-exists":"^2.0.0","pinkie-promise":"^2.0.0","browserslist":"^1.5.2","normalize-range":"^0.1.2","num2fraction":"^1.2.2","lodash.memoize":"^4.1.2","lodash.uniq":"^4.5.0","reduce-css-calc":"^1.2.6","onecolor":"~2.4.0","balanced-match":"^0.4.2","postcss-selector-parser":"^2.0.0","postcss-message-helpers":"^2.0.0","css-color-function":"^1.2.0","color":"^0.11.0","reduce-function-call":"^1.0.1","units-css":"^0.4.0","rgb-hex":"^1.0.0","postcss-media-query-parser":"^0.2.3","lodash.template":"^4.2.4","pify":"^2.0.0","cosmiconfig":"^2.1.1","postcss-load-options":"^1.2.0","postcss-load-plugins":"^2.3.0","minimist":"^1.2.0","wordwrap":"~1.0.0","boxen":"^1.2.1","configstore":"^3.0.0","import-lazy":"^2.1.0","is-installed-globally":"^0.1.0","is-npm":"^1.0.0","latest-version":"^3.0.0","semver-diff":"^2.0.0","xdg-basedir":"^3.0.0","globule":"^1.0.0","cliui":"^3.0.3","os-locale":"^1.4.0","string-width":"^1.0.1","window-size":"^0.1.4","y18n":"^3.2.0","co":"^4.6.0","fast-deep-equal":"^1.0.0","fast-json-stable-stringify":"^2.0.0","json-schema-traverse":"^0.3.0","errno":"^0.1.3","readable-stream":"~1.0.26","assert":"^1.1.1","browserify-zlib":"^0.2.0","buffer":"^3.0.1","console-browserify":"^1.1.0","constants-browserify":"^1.0.0","crypto-browserify":"^3.11.0","domain-browser":"^1.1.1","events":"^1.0.0","https-browserify":"^1.0.0","os-browserify":"^0.3.0","path-browserify":"0.0.0","process":"^0.11.10","punycode":"1.3.2","querystring-es3":"^0.2.0","stream-browserify":"^2.0.1","stream-http":"^2.7.2","string_decoder":"~0.10.x","timers-browserify":"^2.0.4","tty-browserify":"0.0.0","url":"^0.11.0","util":"0.10.3","vm-browserify":"0.0.4","duplexer":"~0.1.1","deep-equal":"~0.1.0","dns-equal":"^1.0.0","dns-txt":"^2.0.2","multicast-dns":"^6.0.1","multicast-dns-service-types":"^1.1.0","anymatch":"^1.3.0","async-each":"^1.0.0","fsevents":"^1.0.0","glob-parent":"^2.0.0","is-binary-path":"^1.0.0","readdirp":"^2.0.0","compressible":"~2.0.11","on-headers":"~1.0.1","globby":"^6.1.0","is-path-cwd":"^1.0.0","is-path-in-cwd":"^1.0.0","p-map":"^1.1.1","http-proxy":"^1.16.2","micromatch":"^2.1.5","meow":"^3.3.0","node-forge":"0.6.33","batch":"0.6.1","faye-websocket":"~0.11.0","uuid":"^3.1.0","eventsource":"0.1.6","json3":"^3.3.2","url-parse":"1.0.x","handle-thing":"^1.2.5","http-deceiver":"^1.2.7","select-hose":"^2.0.0","spdy-transport":"^2.0.18","ansi-regex":"^2.0.0","mime":"1.4.1","time-stamp":"^2.0.0","aws-sign2":"~0.7.0","aws4":"^1.6.0","caseless":"~0.12.0","combined-stream":"^1.0.5","extend":"~3.0.1","forever-agent":"~0.6.1","form-data":"~2.3.1","har-validator":"~5.0.3","hawk":"~6.0.2","http-signature":"~1.2.0","is-typedarray":"~1.0.0","isstream":"~0.1.2","json-stringify-safe":"~5.0.1","oauth-sign":"~0.8.2","performance-now":"^2.1.0","stringstream":"~0.0.5","tunnel-agent":"^0.6.0","tape":"2.3.0","pseudomap":"^1.0.2","yallist":"^2.1.2","shebang-regex":"^1.0.0","isexe":"^2.0.0","estraverse":"^4.2.0","optionator":"^0.8.1","request-promise-core":"1.1.1","stealthy-require":"^1.1.0","tr46":"~0.0.3","decompress-tar":"^4.1.1","decompress-tarbz2":"^4.0.0","decompress-targz":"^4.0.0","decompress-unzip":"^4.0.1","make-dir":"^1.0.0","strip-dirs":"^2.0.0","es6-promise":"~3.0.2","lie":"~3.1.0","pako":"~1.0.5","@types/mime":"*","ms":"2.0.0","ee-first":"1.1.1","unpipe":"~1.0.0","media-typer":"0.3.0","negotiator":"0.6.1","forwarded":"~0.1.2","ipaddr.js":"1.5.2","destroy":"~1.0.4","wrappy":"1","default-require-extensions":"^1.0.0","concat-map":"0.0.1","regenerate":"^1.2.1","regjsgen":"^0.2.0","regjsparser":"^0.1.4","function-bind":"^1.0.2","colormin":"^1.0.5","uniqs":"^2.0.0","uniqid":"^4.0.0","vendors":"^1.0.0","alphanum-sort":"^1.0.1","is-absolute-url":"^2.0.0","normalize-url":"^1.4.0","is-svg":"^2.0.0","svgo":"^0.7.0","no-case":"^2.2.0","upper-case":"^1.1.1","xml-char-classes":"^1.0.0","css-select":"^1.1.0","dom-converter":"~0.1","htmlparser2":"~3.3.0","regenerator-runtime":"^0.11.0","repeating":"^2.0.0","loose-envify":"^1.0.0","pinkie":"^2.0.0","electron-to-chromium":"^1.2.7","math-expression-evaluator":"^1.2.14","flatten":"^1.0.2","indexes-of":"^1.0.1","uniq":"^1.0.1","rgb":"~0.1.0","clone":"^1.0.2","color-convert":"^1.3.0","color-string":"^0.3.0","isnumeric":"^0.2.0","viewport-dimensions":"^0.2.0","lodash._reinterpolate":"~3.0.0","lodash.templatesettings":"^4.0.0","is-directory":"^0.3.1","js-yaml":"~3.7.0","os-homedir":"^1.0.1","parse-json":"^2.2.0","require-from-string":"^1.1.0","ansi-align":"^2.0.0","cli-boxes":"^1.0.0","term-size":"^1.2.0","widest-line":"^2.0.0","dot-prop":"^4.1.0","unique-string":"^1.0.0","write-file-atomic":"^2.0.0","global-dirs":"^0.1.0","is-path-inside":"^1.0.0","package-json":"^4.0.0","wrap-ansi":"^2.0.0","lcid":"^1.0.0","is-fullwidth-code-point":"^2.0.0","prr":"~1.0.1","core-util-is":"1.0.2","isarray":"1.0.0","base64-js":"^1.0.2","ieee754":"^1.1.4","date-now":"^0.1.4","browserify-cipher":"^1.0.0","browserify-sign":"^4.0.0","create-ecdh":"^4.0.0","create-hash":"^1.1.0","create-hmac":"^1.1.4","diffie-hellman":"^5.0.0","pbkdf2":"^3.0.3","public-encrypt":"^4.0.0","randombytes":"^2.0.1","randomfill":"^1.0.3","builtin-status-codes":"^3.0.0","to-arraybuffer":"^1.0.0","xtend":"^4.0.0","setimmediate":"^1.0.4","querystring":"0.2.0","indexof":"0.0.1","buffer-indexof":"^1.0.0","dns-packet":"^1.0.1","thunky":"^0.1.0","normalize-path":"^2.0.1","nan":"^2.3.0","node-pre-gyp":"^0.6.39","binary-extensions":"^1.0.0","set-immediate-shim":"^1.0.1","array-union":"^1.0.1","eventemitter3":"1.x.x","requires-port":"~1.0.0","arr-diff":"^2.0.0","array-unique":"^0.2.1","braces":"^1.8.2","expand-brackets":"^0.1.4","extglob":"^0.3.1","filename-regex":"^2.0.0","kind-of":"^4.0.0","object.omit":"^2.0.0","parse-glob":"^3.0.4","regex-cache":"^0.4.2","camelcase-keys":"^2.0.0","loud-rejection":"^1.0.0","map-obj":"^1.0.0","normalize-package-data":"^2.3.2","read-pkg-up":"^1.0.1","redent":"^1.0.0","trim-newlines":"^1.0.0","websocket-driver":">=0.5.1","original":">=0.0.5","querystringify":"~1.0.0","detect-node":"^2.0.3","hpack.js":"^2.1.6","obuf":"^1.0.0","wbuf":"^1.1.0","delayed-stream":"~1.0.0","asynckit":"^0.4.0","har-schema":"^2.0.0","boom":"5.x.x","cryptiles":"3.x.x","hoek":"4.x.x","sntp":"2.x.x","assert-plus":"^1.0.0","jsprim":"^1.2.2","sshpk":"^1.7.0","resumer":"~0.0.0","split":"~0.2.10","stream-combiner":"~0.0.2","deep-is":"~0.1.3","fast-levenshtein":"~2.0.4","levn":"~0.3.0","prelude-ls":"~1.1.2","type-check":"~0.3.2","file-type":"^3.8.0","is-stream":"^1.0.0","tar-stream":"^1.5.2","seek-bzip":"^1.0.5","unbzip2-stream":"^1.0.9","get-stream":"^3.0.0","yauzl":"^2.4.2","is-natural-number":"^4.0.1","immediate":"~3.0.5","strip-bom":"^2.0.0","css-color-names":"0.0.4","macaddress":"^0.2.8","prepend-http":"^1.0.1","query-string":"^4.1.0","sort-keys":"^1.0.0","html-comment-regex":"^1.1.0","coa":"~1.0.1","csso":"~2.3.1","whet.extend":"~0.9.9","lower-case":"^1.1.1","boolbase":"~1.0.0","css-what":"2.1","domutils":"1.1","nth-check":"~1.0.1","domelementtype":"~1.1.1","domhandler":"2.1","is-finite":"^1.0.0","electron-releases":"^2.1.0","color-name":"^1.0.0","argparse":"^1.0.7","error-ex":"^1.2.0","execa":"^0.7.0","is-obj":"^1.0.0","crypto-random-string":"^1.0.0","imurmurhash":"^0.1.4","signal-exit":"^3.0.0","ini":"~1.3.0","path-is-inside":"^1.0.1","got":"^6.7.1","registry-auth-token":"^3.0.1","registry-url":"^3.0.3","invert-kv":"^1.0.0","browserify-aes":"^1.0.0","browserify-des":"^1.0.0","evp_bytestokey":"^1.0.0","bn.js":"^4.0.0","browserify-rsa":"^4.0.0","elliptic":"^6.0.0","parse-asn1":"^5.0.0","cipher-base":"^1.0.1","ripemd160":"^2.0.1","sha.js":"^2.4.8","miller-rabin":"^4.0.0","ip":"^1.1.0","remove-trailing-separator":"^1.0.1","array-uniq":"^1.0.1","arr-flatten":"^1.0.1","expand-range":"^1.8.1","preserve":"^0.2.0","repeat-element":"^1.1.2","is-posix-bracket":"^0.1.0","is-buffer":"^1.1.5","for-own":"^0.1.4","is-extendable":"^0.1.1","glob-base":"^0.3.0","is-dotfile":"^1.0.0","is-equal-shallow":"^0.1.3","currently-unhandled":"^0.4.1","hosted-git-info":"^2.1.4","is-builtin-module":"^1.0.0","validate-npm-package-license":"^3.0.1","read-pkg":"^1.0.0","indent-string":"^2.1.0","strip-indent":"^1.0.1","http-parser-js":">=0.4.0","websocket-extensions":">=0.1.1","minimalistic-assert":"^1.0.0","extsprintf":"^1.2.0","json-schema":"0.2.3","verror":"1.10.0","asn1":"~0.2.3","bcrypt-pbkdf":"^1.0.0","dashdash":"^1.12.0","ecc-jsbn":"~0.1.1","getpass":"^0.1.1","jsbn":"~0.1.0","tweetnacl":"^0.14.3","bl":"^1.0.0","end-of-stream":"^1.0.0","buffer-crc32":"~0.2.3","fd-slicer":"~1.0.1","is-utf8":"^0.2.0","strict-uri-encode":"^1.0.0","is-plain-obj":"^1.0.0","q":"^1.1.2","clap":"^1.0.9","dom-serializer":"0","number-is-nan":"^1.0.0","sprintf-js":"~1.0.2","is-arrayish":"^0.2.1","npm-run-path":"^2.0.0","p-finally":"^1.0.0","strip-eof":"^1.0.0","create-error-class":"^3.0.0","duplexer3":"^0.1.4","is-redirect":"^1.0.0","is-retry-allowed":"^1.0.0","lowercase-keys":"^1.0.0","timed-out":"^4.0.0","unzip-response":"^2.0.1","url-parse-lax":"^1.0.0","rc":"^1.0.1","buffer-xor":"^1.0.3","des.js":"^1.0.0","md5.js":"^1.3.4","brorand":"^1.0.1","hash.js":"^1.0.3","hmac-drbg":"^1.0.0","minimalistic-crypto-utils":"^1.0.1","asn1.js":"^4.0.0","hash-base":"^3.0.0","fill-range":"^2.1.0","for-in":"^1.0.1","is-primitive":"^2.0.0","array-find-index":"^1.0.1","builtin-modules":"^1.0.0","spdx-correct":"~1.0.0","spdx-expression-parse":"~1.0.0","load-json-file":"^1.0.0","path-type":"^1.0.0","get-stdin":"^4.0.1","pend":"~1.2.0","entities":"~1.1.1","path-key":"^2.0.0","capture-stack-trace":"^1.0.0","deep-extend":"~0.4.0","strip-json-comments":"~2.0.1","is-number":"^3.0.0","isobject":"^2.0.0","randomatic":"^1.1.3","repeat-string":"^1.5.2","spdx-license-ids":"^1.0.2"}},"environmentFiles":[{"name":"lib.es2015.promise.d.ts","text":"/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib=\"true\"/>\n\n\ninterface PromiseConstructor {\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: Promise<any>;\n\n    /**\n     * Creates a new Promise.\n     * @param executor A callback used to initialize the promise. This callback is passed two arguments:\n     * a resolve callback used resolve the promise with a value or the result of another promise,\n     * and a reject callback used to reject the promise with a provided reason or error.\n     */\n    new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<[T1, T2, T3, T4, T5, T6, T7]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<[T1, T2, T3, T4, T5, T6]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>]): Promise<[T1, T2, T3, T4, T5]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>]): Promise<[T1, T2, T3, T4]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<[T1, T2, T3]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<[T1, T2]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T>(values: (T | PromiseLike<T>)[]): Promise<T[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<T1 | T2 | T3 | T4 | T5 | T6>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>]): Promise<T1 | T2 | T3 | T4 | T5>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>]): Promise<T1 | T2 | T3 | T4>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<T1 | T2 | T3>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<T1 | T2>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T>(values: (T | PromiseLike<T>)[]): Promise<T>;\n\n    /**\n     * Creates a new rejected promise for the provided reason.\n     * @param reason The reason the promise was rejected.\n     * @returns A new rejected Promise.\n     */\n    reject(reason: any): Promise<never>;\n\n    /**\n     * Creates a new rejected promise for the provided reason.\n     * @param reason The reason the promise was rejected.\n     * @returns A new rejected Promise.\n     */\n    reject<T>(reason: any): Promise<T>;\n\n    /**\n     * Creates a new resolved promise for the provided value.\n     * @param value A promise.\n     * @returns A promise whose internal state matches the provided promise.\n     */\n    resolve<T>(value: T | PromiseLike<T>): Promise<T>;\n\n    /**\n     * Creates a new resolved promise .\n     * @returns A resolved promise.\n     */\n    resolve(): Promise<void>;\n}\n\ndeclare var Promise: PromiseConstructor;","type":3},{"name":"lib.es2015.iterable.d.ts","text":"/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib=\"true\"/>\n\n\n/// <reference path=\"lib.es2015.symbol.d.ts\" />\n\ninterface SymbolConstructor {\n    /**\n     * A method that returns the default iterator for an object. Called by the semantics of the\n     * for-of statement.\n     */\n    readonly iterator: symbol;\n}\n\ninterface IteratorResult<T> {\n    done: boolean;\n    value: T;\n}\n\ninterface Iterator<T> {\n    next(value?: any): IteratorResult<T>;\n    return?(value?: any): IteratorResult<T>;\n    throw?(e?: any): IteratorResult<T>;\n}\n\ninterface Iterable<T> {\n    [Symbol.iterator](): Iterator<T>;\n}\n\ninterface IterableIterator<T> extends Iterator<T> {\n    [Symbol.iterator](): IterableIterator<T>;\n}\n\ninterface Array<T> {\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, T]>;\n\n    /**\n     * Returns an iterable of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an iterable of values in the array\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface ArrayConstructor {\n    /**\n     * Creates an array from an iterable object.\n     * @param iterable An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T, U>(iterable: Iterable<T>, mapfn: (this: void, v: T, k: number) => U): Array<U>;\n    from<T, U>(iterable: Iterable<T>, mapfn: (this: void, v: T, k: number) => U, thisArg: undefined): Array<U>;\n    from<Z, T, U>(iterable: Iterable<T>, mapfn: (this: Z, v: T, k: number) => U, thisArg: Z): Array<U>;\n\n    /**\n     * Creates an array from an iterable object.\n     * @param iterable An iterable object to convert to an array.\n     */\n    from<T>(iterable: Iterable<T>): Array<T>;\n}\n\ninterface ReadonlyArray<T> {\n    /** Iterator of values in the array. */\n    [Symbol.iterator](): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, T]>;\n\n    /**\n     * Returns an iterable of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an iterable of values in the array\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface IArguments {\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<any>;\n}\n\ninterface Map<K, V> {\n    /** Returns an iterable of entries in the map. */\n    [Symbol.iterator](): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the map.\n     */\n    entries(): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of keys in the map\n     */\n    keys(): IterableIterator<K>;\n\n    /**\n     * Returns an iterable of values in the map\n     */\n    values(): IterableIterator<V>;\n}\n\ninterface ReadonlyMap<K, V> {\n    /** Returns an iterable of entries in the map. */\n    [Symbol.iterator](): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the map.\n     */\n    entries(): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of keys in the map\n     */\n    keys(): IterableIterator<K>;\n\n    /**\n     * Returns an iterable of values in the map\n     */\n    values(): IterableIterator<V>;\n}\n\ninterface MapConstructor {\n    new <K, V>(iterable: Iterable<[K, V]>): Map<K, V>;\n}\n\ninterface WeakMap<K extends object, V> { }\n\ninterface WeakMapConstructor {\n    new <K extends object, V>(iterable: Iterable<[K, V]>): WeakMap<K, V>;\n}\n\ninterface Set<T> {\n    /** Iterates over values in the set. */\n    [Symbol.iterator](): IterableIterator<T>;\n    /**\n     * Returns an iterable of [v,v] pairs for every value `v` in the set.\n     */\n    entries(): IterableIterator<[T, T]>;\n    /**\n     * Despite its name, returns an iterable of the values in the set,\n     */\n    keys(): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of values in the set.\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface ReadonlySet<T> {\n    /** Iterates over values in the set. */\n    [Symbol.iterator](): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of [v,v] pairs for every value `v` in the set.\n     */\n    entries(): IterableIterator<[T, T]>;\n\n    /**\n     * Despite its name, returns an iterable of the values in the set,\n     */\n    keys(): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of values in the set.\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface SetConstructor {\n    new <T>(iterable: Iterable<T>): Set<T>;\n}\n\ninterface WeakSet<T> { }\n\ninterface WeakSetConstructor {\n    new <T extends object>(iterable: Iterable<T>): WeakSet<T>;\n}\n\ninterface Promise<T> { }\n\ninterface PromiseConstructor {\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<TAll>(values: Iterable<TAll | PromiseLike<TAll>>): Promise<TAll[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T>(values: Iterable<T | PromiseLike<T>>): Promise<T>;\n}\n\ndeclare namespace Reflect {\n    function enumerate(target: object): IterableIterator<any>;\n}\n\ninterface String {\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<string>;\n}\n\n/**\n * A typed array of 8-bit integer values. The contents are initialized to 0. If the requested\n * number of bytes could not be allocated an exception is raised.\n */\ninterface Int8Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Int8ArrayConstructor {\n    new (elements: Iterable<number>): Int8Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number): Int8Array;\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number, thisArg: undefined): Int8Array;\n    from<Z>(arrayLike: Iterable<number>, mapfn: (this: Z, v: number, k: number) => number, thisArg: Z): Int8Array;\n\n    from(arrayLike: Iterable<number>): Int8Array;\n}\n\n/**\n * A typed array of 8-bit unsigned integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Uint8Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint8ArrayConstructor {\n    new (elements: Iterable<number>): Uint8Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number): Uint8Array;\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number, thisArg: undefined): Uint8Array;\n    from<Z>(arrayLike: Iterable<number>, mapfn: (this: Z, v: number, k: number) => number, thisArg: Z): Uint8Array;\n\n    from(arrayLike: Iterable<number>): Uint8Array;\n}\n\n/**\n * A typed array of 8-bit unsigned integer (clamped) values. The contents are initialized to 0.\n * If the requested number of bytes could not be allocated an exception is raised.\n */\ninterface Uint8ClampedArray {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint8ClampedArrayConstructor {\n    new (elements: Iterable<number>): Uint8ClampedArray;\n\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number): Uint8ClampedArray;\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number, thisArg: undefined): Uint8ClampedArray;\n    from<Z>(arrayLike: Iterable<number>, mapfn: (this: Z, v: number, k: number) => number, thisArg: Z): Uint8ClampedArray;\n\n    from(arrayLike: Iterable<number>): Uint8ClampedArray;\n}\n\n/**\n * A typed array of 16-bit signed integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Int16Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Int16ArrayConstructor {\n    new (elements: Iterable<number>): Int16Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number): Int16Array;\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number, thisArg: undefined): Int16Array;\n    from<Z>(arrayLike: Iterable<number>, mapfn: (this: Z, v: number, k: number) => number, thisArg: Z): Int16Array;\n\n    from(arrayLike: Iterable<number>): Int16Array;\n}\n\n/**\n * A typed array of 16-bit unsigned integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Uint16Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint16ArrayConstructor {\n    new (elements: Iterable<number>): Uint16Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number): Uint16Array;\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number, thisArg: undefined): Uint16Array;\n    from<Z>(arrayLike: Iterable<number>, mapfn: (this: Z, v: number, k: number) => number, thisArg: Z): Uint16Array;\n\n    from(arrayLike: Iterable<number>): Uint16Array;\n}\n\n/**\n * A typed array of 32-bit signed integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Int32Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Int32ArrayConstructor {\n    new (elements: Iterable<number>): Int32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number): Int32Array;\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number, thisArg: undefined): Int32Array;\n    from<Z>(arrayLike: Iterable<number>, mapfn: (this: Z, v: number, k: number) => number, thisArg: Z): Int32Array;\n\n    from(arrayLike: Iterable<number>): Int32Array;\n}\n\n/**\n * A typed array of 32-bit unsigned integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Uint32Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint32ArrayConstructor {\n    new (elements: Iterable<number>): Uint32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number): Uint32Array;\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number, thisArg: undefined): Uint32Array;\n    from<Z>(arrayLike: Iterable<number>, mapfn: (this: Z, v: number, k: number) => number, thisArg: Z): Uint32Array;\n\n    from(arrayLike: Iterable<number>): Uint32Array;\n}\n\n/**\n * A typed array of 32-bit float values. The contents are initialized to 0. If the requested number\n * of bytes could not be allocated an exception is raised.\n */\ninterface Float32Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Float32ArrayConstructor {\n    new (elements: Iterable<number>): Float32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number): Float32Array;\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number, thisArg: undefined): Float32Array;\n    from<Z>(arrayLike: Iterable<number>, mapfn: (this: Z, v: number, k: number) => number, thisArg: Z): Float32Array;\n\n    from(arrayLike: Iterable<number>): Float32Array;\n}\n\n/**\n * A typed array of 64-bit float values. The contents are initialized to 0. If the requested\n * number of bytes could not be allocated an exception is raised.\n */\ninterface Float64Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Float64ArrayConstructor {\n    new (elements: Iterable<number>): Float64Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number): Float64Array;\n    from(arrayLike: Iterable<number>, mapfn: (this: void, v: number, k: number) => number, thisArg: undefined): Float64Array;\n    from<Z>(arrayLike: Iterable<number>, mapfn: (this: Z, v: number, k: number) => number, thisArg: Z): Float64Array;\n\n    from(arrayLike: Iterable<number>): Float64Array;\n}\n","type":3},{"name":"node_modules/intern/package.json","text":"{\"_args\":[[{\"raw\":\"intern@~4.1.0\",\"scope\":null,\"escapedName\":\"intern\",\"name\":\"intern\",\"rawSpec\":\"~4.1.0\",\"spec\":\">=4.1.0 <4.2.0\",\"type\":\"range\"},\"/Users/michaelvansickle/Documents/source/dojo.io/site/source/tutorials/1015_form_validation/demo/initial/biz-e-corp\"]],\"_from\":\"intern@>=4.1.0 <4.2.0\",\"_id\":\"intern@4.1.4\",\"_inCache\":true,\"_location\":\"/intern\",\"_nodeVersion\":\"8.9.1\",\"_npmOperationalInternal\":{\"host\":\"s3://npm-registry-packages\",\"tmp\":\"tmp/intern-4.1.4.tgz_1512508139919_0.22924068965949118\"},\"_npmUser\":{\"name\":\"jason0x43\",\"email\":\"j.cheatham@gmail.com\"},\"_npmVersion\":\"5.6.0\",\"_phantomChildren\":{\"@types/yargs\":\"8.0.3\",\"accepts\":\"1.3.4\",\"array-flatten\":\"1.1.1\",\"assertion-error\":\"1.0.2\",\"babel-generator\":\"6.26.0\",\"babel-template\":\"6.26.0\",\"babel-traverse\":\"6.26.0\",\"babel-types\":\"6.26.0\",\"babylon\":\"6.18.0\",\"check-error\":\"1.0.2\",\"content-disposition\":\"0.5.2\",\"content-type\":\"1.0.4\",\"cookie\":\"0.3.1\",\"cookie-signature\":\"1.0.6\",\"deep-eql\":\"3.0.1\",\"depd\":\"1.1.1\",\"destroy\":\"1.0.4\",\"encodeurl\":\"1.0.1\",\"escape-html\":\"1.0.3\",\"etag\":\"1.8.1\",\"forwarded\":\"0.1.2\",\"fresh\":\"0.5.2\",\"fs.realpath\":\"1.0.0\",\"get-func-name\":\"2.0.0\",\"http-errors\":\"1.6.2\",\"inflight\":\"1.0.6\",\"inherits\":\"2.0.3\",\"istanbul-lib-coverage\":\"1.1.1\",\"merge-descriptors\":\"1.0.1\",\"methods\":\"1.1.2\",\"minimatch\":\"3.0.4\",\"ms\":\"2.0.0\",\"on-finished\":\"2.3.0\",\"once\":\"1.4.0\",\"parseurl\":\"1.3.2\",\"path-is-absolute\":\"1.0.1\",\"path-parse\":\"1.0.5\",\"path-to-regexp\":\"0.1.7\",\"pathval\":\"1.1.0\",\"range-parser\":\"1.2.0\",\"semver\":\"5.4.1\",\"statuses\":\"1.3.1\",\"type-detect\":\"4.0.5\",\"type-is\":\"1.6.15\",\"unpipe\":\"1.0.0\",\"vary\":\"1.1.2\"},\"_requested\":{\"raw\":\"intern@~4.1.0\",\"scope\":null,\"escapedName\":\"intern\",\"name\":\"intern\",\"rawSpec\":\"~4.1.0\",\"spec\":\">=4.1.0 <4.2.0\",\"type\":\"range\"},\"_requiredBy\":[\"#DEV:/\",\"/@dojo/cli-test-intern\"],\"_resolved\":\"https://registry.npmjs.org/intern/-/intern-4.1.4.tgz\",\"_shasum\":\"56e1146d0ecc466566e35d217a199f3d1390f321\",\"_shrinkwrap\":null,\"_spec\":\"intern@~4.1.0\",\"_where\":\"/Users/michaelvansickle/Documents/source/dojo.io/site/source/tutorials/1015_form_validation/demo/initial/biz-e-corp\",\"bin\":{\"intern\":\"./bin/intern.js\"},\"bugs\":{\"url\":\"https://github.com/theintern/intern/issues\"},\"dependencies\":{\"@dojo/core\":\"~0.3.0\",\"@dojo/has\":\"~0.1.1\",\"@dojo/interfaces\":\"~0.2.0\",\"@dojo/shim\":\"~0.2.3\",\"@theintern/digdug\":\"~2.0.4\",\"@theintern/leadfoot\":\"~2.0.3\",\"@types/benchmark\":\"~1.0.30\",\"@types/chai\":\"~4.0.7\",\"@types/charm\":\"~1.0.0\",\"@types/diff\":\"~3.2.0\",\"@types/express\":\"~4.0.39\",\"@types/http-errors\":\"~1.5.34\",\"@types/istanbul-lib-coverage\":\"~1.1.0\",\"@types/istanbul-lib-hook\":\"~1.0.0\",\"@types/istanbul-lib-instrument\":\"~1.7.0\",\"@types/istanbul-lib-report\":\"~1.1.0\",\"@types/istanbul-lib-source-maps\":\"~1.2.0\",\"@types/istanbul-reports\":\"~1.1.0\",\"@types/lodash\":\"~4.14.65\",\"@types/mime-types\":\"~2.1.0\",\"@types/platform\":\"~1.3.0\",\"@types/resolve\":\"0.0.4\",\"@types/shell-quote\":\"~1.6.0\",\"@types/source-map\":\"~0.1.29\",\"@types/statuses\":\"~1.2.28\",\"@types/ws\":\"~0.0.38\",\"benchmark\":\"~2.1.4\",\"body-parser\":\"~1.17.2\",\"chai\":\"~4.1.2\",\"charm\":\"~1.0.2\",\"diff\":\"~3.2.0\",\"express\":\"~4.15.3\",\"glob\":\"~7.1.1\",\"http-errors\":\"~1.6.1\",\"istanbul-lib-coverage\":\"~1.1.1\",\"istanbul-lib-hook\":\"~1.0.7\",\"istanbul-lib-instrument\":\"~1.7.3\",\"istanbul-lib-report\":\"~1.1.1\",\"istanbul-lib-source-maps\":\"~1.2.1\",\"istanbul-reports\":\"~1.1.1\",\"lodash\":\"~4.17.4\",\"mime-types\":\"~2.1.15\",\"minimatch\":\"~3.0.4\",\"platform\":\"~1.3.4\",\"resolve\":\"~1.4.0\",\"shell-quote\":\"~1.6.1\",\"source-map\":\"~0.5.6\",\"statuses\":\"~1.3.1\",\"tslib\":\"~1.8.0\",\"ws\":\"~2.3.1\"},\"description\":\"Intern. A next-generation code testing stack for JavaScript.\",\"devDependencies\":{\"@dojo/loader\":\"~0.1.1\",\"@theintern/dev\":\"~0.6.1\",\"@types/body-parser\":\"~1.16.4\",\"@types/chalk\":\"~0.4.31\",\"@types/glob\":\"~5.0.30\",\"@types/grunt\":\"~0.4.21\",\"@types/jsdom\":\"~11.0.2\",\"@types/node\":\"~8.0.8\",\"@types/shelljs\":\"~0.7.2\",\"@types/sinon\":\"~2.3.2\",\"@types/systemjs\":\"~0.20.2\",\"@types/webpack\":\"~3.0.1\",\"ajv\":\"~5.2.0\",\"concurrently\":\"~3.5.0\",\"css-loader\":\"~0.28.4\",\"jsdom\":\"~11.2.0\",\"sinon\":\"~2.3.6\",\"source-map-support\":\"~0.4.18\",\"style-loader\":\"~0.18.2\",\"stylus\":\"~0.54.5\",\"stylus-loader\":\"~3.0.1\",\"ts-loader\":\"~2.3.7\",\"ts-node\":\"~3.2.0\",\"umd-compat-loader\":\"~2.1.0\",\"webpack\":\"~3.0.0\"},\"directories\":{},\"dist\":{\"integrity\":\"sha512-QL5+pVjpjNVtp5mB2QwTgf3fuG3l+lA3UzhHTxjhahWt0Z84LfdFfHFXN6UeB72IYQq7LDhjStO6I51rsTjb6Q==\",\"shasum\":\"56e1146d0ecc466566e35d217a199f3d1390f321\",\"tarball\":\"https://registry.npmjs.org/intern/-/intern-4.1.4.tgz\"},\"files\":[\"index.*\",\"*.js\",\"*.js.map\",\"bin/*.js\",\"favicon.*\",\"browser/*.html\",\"browser/config.js\",\"browser/intern.js\",\"browser/remote.js\",\"lib\",\"loaders\",\"tasks\",\"tests\",\"types\"],\"homepage\":\"http://theintern.io/\",\"internDev\":{\"configs\":[\"tsconfig.json\",\"tests/tsconfig.json\",\"tests/examples/tsconfig.json\"],\"resources\":{\"_build\":[\"src/**/*.{styl,d.ts,html,js,png}\",\"src/**/!(tsconfig).json\"],\"_build/src\":[\"types/**\",\"bin/**\"],\"_tests\":[\"tests/**/*.{xml,d.ts,js}\",\"src/**/*.{styl,d.ts,html,js,png}\"]}},\"keywords\":[\"javascript\",\"test\",\"unit\",\"testing\",\"ci\",\"continuous integration\",\"bdd\",\"tdd\",\"xunit\",\"istanbul\",\"chai\",\"dojo\",\"toolkit\",\"selenium\",\"sauce labs\",\"code coverage\"],\"license\":\"BSD-3-Clause\",\"maintainers\":[{\"name\":\"csnover\",\"email\":\"npm@zetafleet.com\"},{\"name\":\"sitepen\",\"email\":\"labs@sitepen.com\"},{\"name\":\"jason0x43\",\"email\":\"j.cheatham@gmail.com\"}],\"name\":\"intern\",\"optionalDependencies\":{},\"prettier\":{\"singleQuote\":true,\"tabWidth\":4,\"useTabs\":true},\"readme\":\"ERROR: No README data found!\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/theintern/intern.git\"},\"scripts\":{\"build\":\"intern-dev-clean && concurrently intern-dev-build intern-dev-api\",\"ci\":\"npm test config=@ci\",\"clean\":\"intern-dev-clean\",\"devpack\":\"intern-dev-build && cd _build/src && npm pack && cp *.tgz ../../\",\"lint\":\"intern-dev-lint\",\"preci\":\"intern-dev-build\",\"release\":\"INTERN_BUILD=release intern-dev-release\",\"start\":\"NODE_PATH=_build node _tests/src/bin/intern.js serveOnly\",\"test\":\"NODE_PATH=_build node _tests/src/bin/intern.js\",\"watch\":\"intern-dev-build watch\"},\"version\":\"4.1.4\"}","type":8},{"name":"lib.es2015.symbol.d.ts","text":"/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib=\"true\"/>\n\n\ninterface Symbol {\n    /** Returns a string representation of an object. */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): symbol;\n}\n\ninterface SymbolConstructor {\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: Symbol;\n\n    /**\n     * Returns a new unique Symbol value.\n     * @param  description Description of the new Symbol object.\n     */\n    (description?: string | number): symbol;\n\n    /**\n     * Returns a Symbol object from the global symbol registry matching the given key if found.\n     * Otherwise, returns a new symbol with this key.\n     * @param key key to search for.\n     */\n    for(key: string): symbol;\n\n    /**\n     * Returns a key from the global symbol registry matching the given Symbol if found.\n     * Otherwise, returns a undefined.\n     * @param sym Symbol to find the key for.\n     */\n    keyFor(sym: symbol): string | undefined;\n}\n\ndeclare var Symbol: SymbolConstructor;","type":3},{"name":"lib.es2015.symbol.wellknown.d.ts","text":"/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib=\"true\"/>\n\n\n/// <reference path=\"lib.es2015.symbol.d.ts\" />\n\ninterface SymbolConstructor {\n    /**\n     * A method that determines if a constructor object recognizes an object as one of the\n     * constructor’s instances. Called by the semantics of the instanceof operator.\n     */\n    readonly hasInstance: symbol;\n\n    /**\n     * A Boolean value that if true indicates that an object should flatten to its array elements\n     * by Array.prototype.concat.\n     */\n    readonly isConcatSpreadable: symbol;\n\n    /**\n     * A regular expression method that matches the regular expression against a string. Called\n     * by the String.prototype.match method.\n     */\n    readonly match: symbol;\n\n    /**\n     * A regular expression method that replaces matched substrings of a string. Called by the\n     * String.prototype.replace method.\n     */\n    readonly replace: symbol;\n\n    /**\n     * A regular expression method that returns the index within a string that matches the\n     * regular expression. Called by the String.prototype.search method.\n     */\n    readonly search: symbol;\n\n    /**\n     * A function valued property that is the constructor function that is used to create\n     * derived objects.\n     */\n    readonly species: symbol;\n\n    /**\n     * A regular expression method that splits a string at the indices that match the regular\n     * expression. Called by the String.prototype.split method.\n     */\n    readonly split: symbol;\n\n    /**\n     * A method that converts an object to a corresponding primitive value.\n     * Called by the ToPrimitive abstract operation.\n     */\n    readonly toPrimitive: symbol;\n\n    /**\n     * A String value that is used in the creation of the default string description of an object.\n     * Called by the built-in method Object.prototype.toString.\n     */\n    readonly toStringTag: symbol;\n\n    /**\n     * An Object whose own property names are property names that are excluded from the 'with'\n     * environment bindings of the associated objects.\n     */\n    readonly unscopables: symbol;\n}\n\ninterface Symbol {\n    readonly [Symbol.toStringTag]: \"Symbol\";\n}\n\ninterface Array<T> {\n    /**\n     * Returns an object whose properties have the value 'true'\n     * when they will be absent when used in a 'with' statement.\n     */\n    [Symbol.unscopables](): {\n        copyWithin: boolean;\n        entries: boolean;\n        fill: boolean;\n        find: boolean;\n        findIndex: boolean;\n        keys: boolean;\n        values: boolean;\n    };\n}\n\ninterface Date {\n    /**\n     * Converts a Date object to a string.\n     */\n    [Symbol.toPrimitive](hint: \"default\"): string;\n    /**\n     * Converts a Date object to a string.\n     */\n    [Symbol.toPrimitive](hint: \"string\"): string;\n    /**\n     * Converts a Date object to a number.\n     */\n    [Symbol.toPrimitive](hint: \"number\"): number;\n    /**\n     * Converts a Date object to a string or number.\n     *\n     * @param hint The strings \"number\", \"string\", or \"default\" to specify what primitive to return.\n     *\n     * @throws {TypeError} If 'hint' was given something other than \"number\", \"string\", or \"default\".\n     * @returns A number if 'hint' was \"number\", a string if 'hint' was \"string\" or \"default\".\n     */\n    [Symbol.toPrimitive](hint: string): string | number;\n}\n\ninterface Map<K, V> {\n    readonly [Symbol.toStringTag]: \"Map\";\n}\n\ninterface WeakMap<K extends object, V>{\n    readonly [Symbol.toStringTag]: \"WeakMap\";\n}\n\ninterface Set<T> {\n    readonly [Symbol.toStringTag]: \"Set\";\n}\n\ninterface WeakSet<T> {\n    readonly [Symbol.toStringTag]: \"WeakSet\";\n}\n\ninterface JSON {\n    readonly [Symbol.toStringTag]: \"JSON\";\n}\n\ninterface Function {\n    /**\n     * Determines whether the given value inherits from this function if this function was used\n     * as a constructor function.\n     *\n     * A constructor function can control which objects are recognized as its instances by\n     * 'instanceof' by overriding this method.\n     */\n    [Symbol.hasInstance](value: any): boolean;\n}\n\ninterface GeneratorFunction {\n    readonly [Symbol.toStringTag]: \"GeneratorFunction\";\n}\n\ninterface Math {\n    readonly [Symbol.toStringTag]: \"Math\";\n}\n\ninterface Promise<T> {\n    readonly [Symbol.toStringTag]: \"Promise\";\n}\n\ninterface PromiseConstructor {\n    readonly [Symbol.species]: Function;\n}\n\ninterface RegExp {\n    /**\n     * Matches a string with this regular expression, and returns an array containing the results of\n     * that search.\n     * @param string A string to search within.\n     */\n    [Symbol.match](string: string): RegExpMatchArray | null;\n\n    /**\n     * Replaces text in a string, using this regular expression.\n     * @param string A String object or string literal whose contents matching against\n     *               this regular expression will be replaced\n     * @param replaceValue A String object or string literal containing the text to replace for every\n     *                     successful match of this regular expression.\n     */\n    [Symbol.replace](string: string, replaceValue: string): string;\n\n    /**\n     * Replaces text in a string, using this regular expression.\n     * @param string A String object or string literal whose contents matching against\n     *               this regular expression will be replaced\n     * @param replacer A function that returns the replacement text.\n     */\n    [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n     * Finds the position beginning first substring match in a regular expression search\n     * using this regular expression.\n     *\n     * @param string The string to search within.\n     */\n    [Symbol.search](string: string): number;\n\n    /**\n     * Returns an array of substrings that were delimited by strings in the original input that\n     * match against this regular expression.\n     *\n     * If the regular expression contains capturing parentheses, then each time this\n     * regular expression matches, the results (including any undefined results) of the\n     * capturing parentheses are spliced.\n     *\n     * @param string string value to split\n     * @param limit if not undefined, the output array is truncated so that it contains no more\n     * than 'limit' elements.\n     */\n    [Symbol.split](string: string, limit?: number): string[];\n}\n\ninterface RegExpConstructor {\n    [Symbol.species](): RegExpConstructor;\n}\n\ninterface String {\n    /**\n     * Matches a string an object that supports being matched against, and returns an array containing the results of that search.\n     * @param matcher An object that supports being matched against.\n     */\n    match(matcher: { [Symbol.match](string: string): RegExpMatchArray | null; }): RegExpMatchArray | null;\n\n    /**\n     * Replaces text in a string, using an object that supports replacement within a string.\n     * @param searchValue A object can search for and replace matches within a string.\n     * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.\n     */\n    replace(searchValue: { [Symbol.replace](string: string, replaceValue: string): string; }, replaceValue: string): string;\n\n    /**\n     * Replaces text in a string, using an object that supports replacement within a string.\n     * @param searchValue A object can search for and replace matches within a string.\n     * @param replacer A function that returns the replacement text.\n     */\n    replace(searchValue: { [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string; }, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n     * Finds the first substring match in a regular expression search.\n     * @param searcher An object which supports searching within a string.\n     */\n    search(searcher: { [Symbol.search](string: string): number; }): number;\n\n    /**\n     * Split a string into substrings using the specified separator and return them as an array.\n     * @param splitter An object that can split a string.\n     * @param limit A value used to limit the number of elements returned in the array.\n     */\n    split(splitter: { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number): string[];\n}\n\n/**\n * Represents a raw buffer of binary data, which is used to store data for the\n * different typed arrays. ArrayBuffers cannot be read from or written to directly,\n * but can be passed to a typed array or DataView Object to interpret the raw\n * buffer as needed.\n */\ninterface ArrayBuffer {\n    readonly [Symbol.toStringTag]: \"ArrayBuffer\";\n}\n\ninterface DataView {\n    readonly [Symbol.toStringTag]: \"DataView\";\n}\n\n/**\n * A typed array of 8-bit integer values. The contents are initialized to 0. If the requested\n * number of bytes could not be allocated an exception is raised.\n */\ninterface Int8Array {\n    readonly [Symbol.toStringTag]: \"Int8Array\";\n}\n\n/**\n * A typed array of 8-bit unsigned integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Uint8Array {\n    readonly [Symbol.toStringTag]: \"UInt8Array\";\n}\n\n/**\n * A typed array of 8-bit unsigned integer (clamped) values. The contents are initialized to 0.\n * If the requested number of bytes could not be allocated an exception is raised.\n */\ninterface Uint8ClampedArray {\n    readonly [Symbol.toStringTag]: \"Uint8ClampedArray\";\n}\n\n/**\n * A typed array of 16-bit signed integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Int16Array {\n    readonly [Symbol.toStringTag]: \"Int16Array\";\n}\n\n/**\n * A typed array of 16-bit unsigned integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Uint16Array {\n    readonly [Symbol.toStringTag]: \"Uint16Array\";\n}\n\n/**\n * A typed array of 32-bit signed integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Int32Array {\n    readonly [Symbol.toStringTag]: \"Int32Array\";\n}\n\n/**\n * A typed array of 32-bit unsigned integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Uint32Array {\n    readonly [Symbol.toStringTag]: \"Uint32Array\";\n}\n\n/**\n * A typed array of 32-bit float values. The contents are initialized to 0. If the requested number\n * of bytes could not be allocated an exception is raised.\n */\ninterface Float32Array {\n    readonly [Symbol.toStringTag]: \"Float32Array\";\n}\n\n/**\n * A typed array of 64-bit float values. The contents are initialized to 0. If the requested\n * number of bytes could not be allocated an exception is raised.\n */\ninterface Float64Array {\n    readonly [Symbol.toStringTag]: \"Float64Array\";\n}\n","type":3},{"name":"lib.es5.d.ts","text":"/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib=\"true\"/>\n\n\n/////////////////////////////\n/// ECMAScript APIs\n/////////////////////////////\n\ndeclare const NaN: number;\ndeclare const Infinity: number;\n\n/**\n  * Evaluates JavaScript code and executes it.\n  * @param x A String value that contains valid JavaScript code.\n  */\ndeclare function eval(x: string): any;\n\n/**\n  * Converts A string to an integer.\n  * @param s A string to convert into a number.\n  * @param radix A value between 2 and 36 that specifies the base of the number in numString.\n  * If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.\n  * All other strings are considered decimal.\n  */\ndeclare function parseInt(s: string, radix?: number): number;\n\n/**\n  * Converts a string to a floating-point number.\n  * @param string A string that contains a floating-point number.\n  */\ndeclare function parseFloat(string: string): number;\n\n/**\n  * Returns a Boolean value that indicates whether a value is the reserved value NaN (not a number).\n  * @param number A numeric value.\n  */\ndeclare function isNaN(number: number): boolean;\n\n/**\n  * Determines whether a supplied number is finite.\n  * @param number Any numeric value.\n  */\ndeclare function isFinite(number: number): boolean;\n\n/**\n  * Gets the unencoded version of an encoded Uniform Resource Identifier (URI).\n  * @param encodedURI A value representing an encoded URI.\n  */\ndeclare function decodeURI(encodedURI: string): string;\n\n/**\n  * Gets the unencoded version of an encoded component of a Uniform Resource Identifier (URI).\n  * @param encodedURIComponent A value representing an encoded URI component.\n  */\ndeclare function decodeURIComponent(encodedURIComponent: string): string;\n\n/**\n  * Encodes a text string as a valid Uniform Resource Identifier (URI)\n  * @param uri A value representing an encoded URI.\n  */\ndeclare function encodeURI(uri: string): string;\n\n/**\n  * Encodes a text string as a valid component of a Uniform Resource Identifier (URI).\n  * @param uriComponent A value representing an encoded URI component.\n  */\ndeclare function encodeURIComponent(uriComponent: string): string;\n\ninterface PropertyDescriptor {\n    configurable?: boolean;\n    enumerable?: boolean;\n    value?: any;\n    writable?: boolean;\n    get?(): any;\n    set?(v: any): void;\n}\n\ninterface PropertyDescriptorMap {\n    [s: string]: PropertyDescriptor;\n}\n\ninterface Object {\n    /** The initial value of Object.prototype.constructor is the standard built-in Object constructor. */\n    constructor: Function;\n\n    /** Returns a string representation of an object. */\n    toString(): string;\n\n    /** Returns a date converted to a string using the current locale. */\n    toLocaleString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Object;\n\n    /**\n      * Determines whether an object has a property with the specified name.\n      * @param v A property name.\n      */\n    hasOwnProperty(v: string): boolean;\n\n    /**\n      * Determines whether an object exists in another object's prototype chain.\n      * @param v Another object whose prototype chain is to be checked.\n      */\n    isPrototypeOf(v: Object): boolean;\n\n    /**\n      * Determines whether a specified property is enumerable.\n      * @param v A property name.\n      */\n    propertyIsEnumerable(v: string): boolean;\n}\n\ninterface ObjectConstructor {\n    new(value?: any): Object;\n    (): any;\n    (value: any): any;\n\n    /** A reference to the prototype for a class of objects. */\n    readonly prototype: Object;\n\n    /**\n      * Returns the prototype of an object.\n      * @param o The object that references the prototype.\n      */\n    getPrototypeOf(o: any): any;\n\n    /**\n      * Gets the own property descriptor of the specified object.\n      * An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype.\n      * @param o Object that contains the property.\n      * @param p Name of the property.\n    */\n    getOwnPropertyDescriptor(o: any, p: string): PropertyDescriptor;\n\n    /**\n      * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly\n      * on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions.\n      * @param o Object that contains the own properties.\n      */\n    getOwnPropertyNames(o: any): string[];\n\n    /**\n      * Creates an object that has the specified prototype or that has null prototype.\n      * @param o Object to use as a prototype. May be null.\n      */\n    create(o: object | null): any;\n\n    /**\n      * Creates an object that has the specified prototype, and that optionally contains specified properties.\n      * @param o Object to use as a prototype. May be null\n      * @param properties JavaScript object that contains one or more property descriptors.\n      */\n    create(o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;\n\n    /**\n      * Adds a property to an object, or modifies attributes of an existing property.\n      * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object.\n      * @param p The property name.\n      * @param attributes Descriptor for the property. It can be for a data property or an accessor property.\n      */\n    defineProperty(o: any, p: string, attributes: PropertyDescriptor & ThisType<any>): any;\n\n    /**\n      * Adds one or more properties to an object, and/or modifies attributes of existing properties.\n      * @param o Object on which to add or modify the properties. This can be a native JavaScript object or a DOM object.\n      * @param properties JavaScript object that contains one or more descriptor objects. Each descriptor object describes a data property or an accessor property.\n      */\n    defineProperties(o: any, properties: PropertyDescriptorMap & ThisType<any>): any;\n\n    /**\n      * Prevents the modification of attributes of existing properties, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    seal<T>(o: T): T;\n\n    /**\n      * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    freeze<T>(a: T[]): ReadonlyArray<T>;\n\n    /**\n      * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    freeze<T extends Function>(f: T): T;\n\n    /**\n      * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    freeze<T>(o: T): Readonly<T>;\n\n    /**\n      * Prevents the addition of new properties to an object.\n      * @param o Object to make non-extensible.\n      */\n    preventExtensions<T>(o: T): T;\n\n    /**\n      * Returns true if existing property attributes cannot be modified in an object and new properties cannot be added to the object.\n      * @param o Object to test.\n      */\n    isSealed(o: any): boolean;\n\n    /**\n      * Returns true if existing property attributes and values cannot be modified in an object, and new properties cannot be added to the object.\n      * @param o Object to test.\n      */\n    isFrozen(o: any): boolean;\n\n    /**\n      * Returns a value that indicates whether new properties can be added to an object.\n      * @param o Object to test.\n      */\n    isExtensible(o: any): boolean;\n\n    /**\n      * Returns the names of the enumerable properties and methods of an object.\n      * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n      */\n    keys(o: any): string[];\n}\n\n/**\n  * Provides functionality common to all JavaScript objects.\n  */\ndeclare const Object: ObjectConstructor;\n\n/**\n  * Creates a new function.\n  */\ninterface Function {\n    /**\n      * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n      * @param thisArg The object to be used as the this object.\n      * @param argArray A set of arguments to be passed to the function.\n      */\n    apply(this: Function, thisArg: any, argArray?: any): any;\n\n    /**\n      * Calls a method of an object, substituting another object for the current object.\n      * @param thisArg The object to be used as the current object.\n      * @param argArray A list of arguments to be passed to the method.\n      */\n    call(this: Function, thisArg: any, ...argArray: any[]): any;\n\n    /**\n      * For a given function, creates a bound function that has the same body as the original function.\n      * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n      * @param thisArg An object to which the this keyword can refer inside the new function.\n      * @param argArray A list of arguments to be passed to the new function.\n      */\n    bind(this: Function, thisArg: any, ...argArray: any[]): any;\n\n    /** Returns a string representation of a function. */\n    toString(): string;\n\n    prototype: any;\n    readonly length: number;\n\n    // Non-standard extensions\n    arguments: any;\n    caller: Function;\n}\n\ninterface FunctionConstructor {\n    /**\n      * Creates a new function.\n      * @param args A list of arguments the function accepts.\n      */\n    new(...args: string[]): Function;\n    (...args: string[]): Function;\n    readonly prototype: Function;\n}\n\ndeclare const Function: FunctionConstructor;\n\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n\ninterface String {\n    /** Returns a string representation of a string. */\n    toString(): string;\n\n    /**\n      * Returns the character at the specified index.\n      * @param pos The zero-based index of the desired character.\n      */\n    charAt(pos: number): string;\n\n    /**\n      * Returns the Unicode value of the character at the specified location.\n      * @param index The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.\n      */\n    charCodeAt(index: number): number;\n\n    /**\n      * Returns a string that contains the concatenation of two or more strings.\n      * @param strings The strings to append to the end of the string.\n      */\n    concat(...strings: string[]): string;\n\n    /**\n      * Returns the position of the first occurrence of a substring.\n      * @param searchString The substring to search for in the string\n      * @param position The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.\n      */\n    indexOf(searchString: string, position?: number): number;\n\n    /**\n      * Returns the last occurrence of a substring in the string.\n      * @param searchString The substring to search for.\n      * @param position The index at which to begin searching. If omitted, the search begins at the end of the string.\n      */\n    lastIndexOf(searchString: string, position?: number): number;\n\n    /**\n      * Determines whether two strings are equivalent in the current locale.\n      * @param that String to compare to target string\n      */\n    localeCompare(that: string): number;\n\n    /**\n      * Matches a string with a regular expression, and returns an array containing the results of that search.\n      * @param regexp A variable name or string literal containing the regular expression pattern and flags.\n      */\n    match(regexp: string | RegExp): RegExpMatchArray | null;\n\n    /**\n      * Replaces text in a string, using a regular expression or search string.\n      * @param searchValue A string to search for.\n      * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.\n      */\n    replace(searchValue: string | RegExp, replaceValue: string): string;\n\n    /**\n      * Replaces text in a string, using a regular expression or search string.\n      * @param searchValue A string to search for.\n      * @param replacer A function that returns the replacement text.\n      */\n    replace(searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n      * Finds the first substring match in a regular expression search.\n      * @param regexp The regular expression pattern and applicable flags.\n      */\n    search(regexp: string | RegExp): number;\n\n    /**\n      * Returns a section of a string.\n      * @param start The index to the beginning of the specified portion of stringObj.\n      * @param end The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.\n      * If this value is not specified, the substring continues to the end of stringObj.\n      */\n    slice(start?: number, end?: number): string;\n\n    /**\n      * Split a string into substrings using the specified separator and return them as an array.\n      * @param separator A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned.\n      * @param limit A value used to limit the number of elements returned in the array.\n      */\n    split(separator: string | RegExp, limit?: number): string[];\n\n    /**\n      * Returns the substring at the specified location within a String object.\n      * @param start The zero-based index number indicating the beginning of the substring.\n      * @param end Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\n      * If end is omitted, the characters from start through the end of the original string are returned.\n      */\n    substring(start: number, end?: number): string;\n\n    /** Converts all the alphabetic characters in a string to lowercase. */\n    toLowerCase(): string;\n\n    /** Converts all alphabetic characters to lowercase, taking into account the host environment's current locale. */\n    toLocaleLowerCase(): string;\n\n    /** Converts all the alphabetic characters in a string to uppercase. */\n    toUpperCase(): string;\n\n    /** Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale. */\n    toLocaleUpperCase(): string;\n\n    /** Removes the leading and trailing white space and line terminator characters from a string. */\n    trim(): string;\n\n    /** Returns the length of a String object. */\n    readonly length: number;\n\n    // IE extensions\n    /**\n      * Gets a substring beginning at the specified location and having the specified length.\n      * @param from The starting position of the desired substring. The index of the first character in the string is zero.\n      * @param length The number of characters to include in the returned substring.\n      */\n    substr(from: number, length?: number): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): string;\n\n    readonly [index: number]: string;\n}\n\ninterface StringConstructor {\n    new(value?: any): String;\n    (value?: any): string;\n    readonly prototype: String;\n    fromCharCode(...codes: number[]): string;\n}\n\n/**\n  * Allows manipulation and formatting of text strings and determination and location of substrings within strings.\n  */\ndeclare const String: StringConstructor;\n\ninterface Boolean {\n    /** Returns the primitive value of the specified object. */\n    valueOf(): boolean;\n}\n\ninterface BooleanConstructor {\n    new(value?: any): Boolean;\n    (value?: any): boolean;\n    readonly prototype: Boolean;\n}\n\ndeclare const Boolean: BooleanConstructor;\n\ninterface Number {\n    /**\n      * Returns a string representation of an object.\n      * @param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.\n      */\n    toString(radix?: number): string;\n\n    /**\n      * Returns a string representing a number in fixed-point notation.\n      * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\n      */\n    toFixed(fractionDigits?: number): string;\n\n    /**\n      * Returns a string containing a number represented in exponential notation.\n      * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\n      */\n    toExponential(fractionDigits?: number): string;\n\n    /**\n      * Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n      * @param precision Number of significant digits. Must be in the range 1 - 21, inclusive.\n      */\n    toPrecision(precision?: number): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): number;\n}\n\ninterface NumberConstructor {\n    new(value?: any): Number;\n    (value?: any): number;\n    readonly prototype: Number;\n\n    /** The largest number that can be represented in JavaScript. Equal to approximately 1.79E+308. */\n    readonly MAX_VALUE: number;\n\n    /** The closest number to zero that can be represented in JavaScript. Equal to approximately 5.00E-324. */\n    readonly MIN_VALUE: number;\n\n    /**\n      * A value that is not a number.\n      * In equality comparisons, NaN does not equal any value, including itself. To test whether a value is equivalent to NaN, use the isNaN function.\n      */\n    readonly NaN: number;\n\n    /**\n      * A value that is less than the largest negative number that can be represented in JavaScript.\n      * JavaScript displays NEGATIVE_INFINITY values as -infinity.\n      */\n    readonly NEGATIVE_INFINITY: number;\n\n    /**\n      * A value greater than the largest number that can be represented in JavaScript.\n      * JavaScript displays POSITIVE_INFINITY values as infinity.\n      */\n    readonly POSITIVE_INFINITY: number;\n}\n\n/** An object that represents a number of any kind. All JavaScript numbers are 64-bit floating-point numbers. */\ndeclare const Number: NumberConstructor;\n\ninterface TemplateStringsArray extends ReadonlyArray<string> {\n    readonly raw: ReadonlyArray<string>;\n}\n\ninterface Math {\n    /** The mathematical constant e. This is Euler's number, the base of natural logarithms. */\n    readonly E: number;\n    /** The natural logarithm of 10. */\n    readonly LN10: number;\n    /** The natural logarithm of 2. */\n    readonly LN2: number;\n    /** The base-2 logarithm of e. */\n    readonly LOG2E: number;\n    /** The base-10 logarithm of e. */\n    readonly LOG10E: number;\n    /** Pi. This is the ratio of the circumference of a circle to its diameter. */\n    readonly PI: number;\n    /** The square root of 0.5, or, equivalently, one divided by the square root of 2. */\n    readonly SQRT1_2: number;\n    /** The square root of 2. */\n    readonly SQRT2: number;\n    /**\n      * Returns the absolute value of a number (the value without regard to whether it is positive or negative).\n      * For example, the absolute value of -5 is the same as the absolute value of 5.\n      * @param x A numeric expression for which the absolute value is needed.\n      */\n    abs(x: number): number;\n    /**\n      * Returns the arc cosine (or inverse cosine) of a number.\n      * @param x A numeric expression.\n      */\n    acos(x: number): number;\n    /**\n      * Returns the arcsine of a number.\n      * @param x A numeric expression.\n      */\n    asin(x: number): number;\n    /**\n      * Returns the arctangent of a number.\n      * @param x A numeric expression for which the arctangent is needed.\n      */\n    atan(x: number): number;\n    /**\n      * Returns the angle (in radians) from the X axis to a point.\n      * @param y A numeric expression representing the cartesian y-coordinate.\n      * @param x A numeric expression representing the cartesian x-coordinate.\n      */\n    atan2(y: number, x: number): number;\n    /**\n      * Returns the smallest number greater than or equal to its numeric argument.\n      * @param x A numeric expression.\n      */\n    ceil(x: number): number;\n    /**\n      * Returns the cosine of a number.\n      * @param x A numeric expression that contains an angle measured in radians.\n      */\n    cos(x: number): number;\n    /**\n      * Returns e (the base of natural logarithms) raised to a power.\n      * @param x A numeric expression representing the power of e.\n      */\n    exp(x: number): number;\n    /**\n      * Returns the greatest number less than or equal to its numeric argument.\n      * @param x A numeric expression.\n      */\n    floor(x: number): number;\n    /**\n      * Returns the natural logarithm (base e) of a number.\n      * @param x A numeric expression.\n      */\n    log(x: number): number;\n    /**\n      * Returns the larger of a set of supplied numeric expressions.\n      * @param values Numeric expressions to be evaluated.\n      */\n    max(...values: number[]): number;\n    /**\n      * Returns the smaller of a set of supplied numeric expressions.\n      * @param values Numeric expressions to be evaluated.\n      */\n    min(...values: number[]): number;\n    /**\n      * Returns the value of a base expression taken to a specified power.\n      * @param x The base value of the expression.\n      * @param y The exponent value of the expression.\n      */\n    pow(x: number, y: number): number;\n    /** Returns a pseudorandom number between 0 and 1. */\n    random(): number;\n    /**\n      * Returns a supplied numeric expression rounded to the nearest number.\n      * @param x The value to be rounded to the nearest number.\n      */\n    round(x: number): number;\n    /**\n      * Returns the sine of a number.\n      * @param x A numeric expression that contains an angle measured in radians.\n      */\n    sin(x: number): number;\n    /**\n      * Returns the square root of a number.\n      * @param x A numeric expression.\n      */\n    sqrt(x: number): number;\n    /**\n      * Returns the tangent of a number.\n      * @param x A numeric expression that contains an angle measured in radians.\n      */\n    tan(x: number): number;\n}\n/** An intrinsic object that provides basic mathematics functionality and constants. */\ndeclare const Math: Math;\n\n/** Enables basic storage and retrieval of dates and times. */\ninterface Date {\n    /** Returns a string representation of a date. The format of the string depends on the locale. */\n    toString(): string;\n    /** Returns a date as a string value. */\n    toDateString(): string;\n    /** Returns a time as a string value. */\n    toTimeString(): string;\n    /** Returns a value as a string value appropriate to the host environment's current locale. */\n    toLocaleString(): string;\n    /** Returns a date as a string value appropriate to the host environment's current locale. */\n    toLocaleDateString(): string;\n    /** Returns a time as a string value appropriate to the host environment's current locale. */\n    toLocaleTimeString(): string;\n    /** Returns the stored time value in milliseconds since midnight, January 1, 1970 UTC. */\n    valueOf(): number;\n    /** Gets the time value in milliseconds. */\n    getTime(): number;\n    /** Gets the year, using local time. */\n    getFullYear(): number;\n    /** Gets the year using Universal Coordinated Time (UTC). */\n    getUTCFullYear(): number;\n    /** Gets the month, using local time. */\n    getMonth(): number;\n    /** Gets the month of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMonth(): number;\n    /** Gets the day-of-the-month, using local time. */\n    getDate(): number;\n    /** Gets the day-of-the-month, using Universal Coordinated Time (UTC). */\n    getUTCDate(): number;\n    /** Gets the day of the week, using local time. */\n    getDay(): number;\n    /** Gets the day of the week using Universal Coordinated Time (UTC). */\n    getUTCDay(): number;\n    /** Gets the hours in a date, using local time. */\n    getHours(): number;\n    /** Gets the hours value in a Date object using Universal Coordinated Time (UTC). */\n    getUTCHours(): number;\n    /** Gets the minutes of a Date object, using local time. */\n    getMinutes(): number;\n    /** Gets the minutes of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMinutes(): number;\n    /** Gets the seconds of a Date object, using local time. */\n    getSeconds(): number;\n    /** Gets the seconds of a Date object using Universal Coordinated Time (UTC). */\n    getUTCSeconds(): number;\n    /** Gets the milliseconds of a Date, using local time. */\n    getMilliseconds(): number;\n    /** Gets the milliseconds of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMilliseconds(): number;\n    /** Gets the difference in minutes between the time on the local computer and Universal Coordinated Time (UTC). */\n    getTimezoneOffset(): number;\n    /**\n      * Sets the date and time value in the Date object.\n      * @param time A numeric value representing the number of elapsed milliseconds since midnight, January 1, 1970 GMT.\n      */\n    setTime(time: number): number;\n    /**\n      * Sets the milliseconds value in the Date object using local time.\n      * @param ms A numeric value equal to the millisecond value.\n      */\n    setMilliseconds(ms: number): number;\n    /**\n      * Sets the milliseconds value in the Date object using Universal Coordinated Time (UTC).\n      * @param ms A numeric value equal to the millisecond value.\n      */\n    setUTCMilliseconds(ms: number): number;\n\n    /**\n      * Sets the seconds value in the Date object using local time.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setSeconds(sec: number, ms?: number): number;\n    /**\n      * Sets the seconds value in the Date object using Universal Coordinated Time (UTC).\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setUTCSeconds(sec: number, ms?: number): number;\n    /**\n      * Sets the minutes value in the Date object using local time.\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setMinutes(min: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the minutes value in the Date object using Universal Coordinated Time (UTC).\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setUTCMinutes(min: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the hour value in the Date object using local time.\n      * @param hours A numeric value equal to the hours value.\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setHours(hours: number, min?: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the hours value in the Date object using Universal Coordinated Time (UTC).\n      * @param hours A numeric value equal to the hours value.\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setUTCHours(hours: number, min?: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the numeric day-of-the-month value of the Date object using local time.\n      * @param date A numeric value equal to the day of the month.\n      */\n    setDate(date: number): number;\n    /**\n      * Sets the numeric day of the month in the Date object using Universal Coordinated Time (UTC).\n      * @param date A numeric value equal to the day of the month.\n      */\n    setUTCDate(date: number): number;\n    /**\n      * Sets the month value in the Date object using local time.\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively.\n      * @param date A numeric value representing the day of the month. If this value is not supplied, the value from a call to the getDate method is used.\n      */\n    setMonth(month: number, date?: number): number;\n    /**\n      * Sets the month value in the Date object using Universal Coordinated Time (UTC).\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively.\n      * @param date A numeric value representing the day of the month. If it is not supplied, the value from a call to the getUTCDate method is used.\n      */\n    setUTCMonth(month: number, date?: number): number;\n    /**\n      * Sets the year of the Date object using local time.\n      * @param year A numeric value for the year.\n      * @param month A zero-based numeric value for the month (0 for January, 11 for December). Must be specified if numDate is specified.\n      * @param date A numeric value equal for the day of the month.\n      */\n    setFullYear(year: number, month?: number, date?: number): number;\n    /**\n      * Sets the year value in the Date object using Universal Coordinated Time (UTC).\n      * @param year A numeric value equal to the year.\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively. Must be supplied if numDate is supplied.\n      * @param date A numeric value equal to the day of the month.\n      */\n    setUTCFullYear(year: number, month?: number, date?: number): number;\n    /** Returns a date converted to a string using Universal Coordinated Time (UTC). */\n    toUTCString(): string;\n    /** Returns a date as a string value in ISO format. */\n    toISOString(): string;\n    /** Used by the JSON.stringify method to enable the transformation of an object's data for JavaScript Object Notation (JSON) serialization. */\n    toJSON(key?: any): string;\n}\n\ninterface DateConstructor {\n    new(): Date;\n    new(value: number): Date;\n    new(value: string): Date;\n    new(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): Date;\n    (): string;\n    readonly prototype: Date;\n    /**\n      * Parses a string containing a date, and returns the number of milliseconds between that date and midnight, January 1, 1970.\n      * @param s A date string\n      */\n    parse(s: string): number;\n    /**\n      * Returns the number of milliseconds between midnight, January 1, 1970 Universal Coordinated Time (UTC) (or GMT) and the specified date.\n      * @param year The full year designation is required for cross-century date accuracy. If year is between 0 and 99 is used, then year is assumed to be 1900 + year.\n      * @param month The month as an number between 0 and 11 (January to December).\n      * @param date The date as an number between 1 and 31.\n      * @param hours Must be supplied if minutes is supplied. An number from 0 to 23 (midnight to 11pm) that specifies the hour.\n      * @param minutes Must be supplied if seconds is supplied. An number from 0 to 59 that specifies the minutes.\n      * @param seconds Must be supplied if milliseconds is supplied. An number from 0 to 59 that specifies the seconds.\n      * @param ms An number from 0 to 999 that specifies the milliseconds.\n      */\n    UTC(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): number;\n    now(): number;\n}\n\ndeclare const Date: DateConstructor;\n\ninterface RegExpMatchArray extends Array<string> {\n    index?: number;\n    input?: string;\n}\n\ninterface RegExpExecArray extends Array<string> {\n    index: number;\n    input: string;\n}\n\ninterface RegExp {\n    /**\n      * Executes a search on a string using a regular expression pattern, and returns an array containing the results of that search.\n      * @param string The String object or string literal on which to perform the search.\n      */\n    exec(string: string): RegExpExecArray | null;\n\n    /**\n      * Returns a Boolean value that indicates whether or not a pattern exists in a searched string.\n      * @param string String on which to perform the search.\n      */\n    test(string: string): boolean;\n\n    /** Returns a copy of the text of the regular expression pattern. Read-only. The regExp argument is a Regular expression object. It can be a variable name or a literal. */\n    readonly source: string;\n\n    /** Returns a Boolean value indicating the state of the global flag (g) used with a regular expression. Default is false. Read-only. */\n    readonly global: boolean;\n\n    /** Returns a Boolean value indicating the state of the ignoreCase flag (i) used with a regular expression. Default is false. Read-only. */\n    readonly ignoreCase: boolean;\n\n    /** Returns a Boolean value indicating the state of the multiline flag (m) used with a regular expression. Default is false. Read-only. */\n    readonly multiline: boolean;\n\n    lastIndex: number;\n\n    // Non-standard extensions\n    compile(): this;\n}\n\ninterface RegExpConstructor {\n    new(pattern: RegExp | string): RegExp;\n    new(pattern: string, flags?: string): RegExp;\n    (pattern: RegExp | string): RegExp;\n    (pattern: string, flags?: string): RegExp;\n    readonly prototype: RegExp;\n\n    // Non-standard extensions\n    $1: string;\n    $2: string;\n    $3: string;\n    $4: string;\n    $5: string;\n    $6: string;\n    $7: string;\n    $8: string;\n    $9: string;\n    lastMatch: string;\n}\n\ndeclare const RegExp: RegExpConstructor;\n\ninterface Error {\n    name: string;\n    message: string;\n    stack?: string;\n}\n\ninterface ErrorConstructor {\n    new(message?: string): Error;\n    (message?: string): Error;\n    readonly prototype: Error;\n}\n\ndeclare const Error: ErrorConstructor;\n\ninterface EvalError extends Error {\n}\n\ninterface EvalErrorConstructor {\n    new(message?: string): EvalError;\n    (message?: string): EvalError;\n    readonly prototype: EvalError;\n}\n\ndeclare const EvalError: EvalErrorConstructor;\n\ninterface RangeError extends Error {\n}\n\ninterface RangeErrorConstructor {\n    new(message?: string): RangeError;\n    (message?: string): RangeError;\n    readonly prototype: RangeError;\n}\n\ndeclare const RangeError: RangeErrorConstructor;\n\ninterface ReferenceError extends Error {\n}\n\ninterface ReferenceErrorConstructor {\n    new(message?: string): ReferenceError;\n    (message?: string): ReferenceError;\n    readonly prototype: ReferenceError;\n}\n\ndeclare const ReferenceError: ReferenceErrorConstructor;\n\ninterface SyntaxError extends Error {\n}\n\ninterface SyntaxErrorConstructor {\n    new(message?: string): SyntaxError;\n    (message?: string): SyntaxError;\n    readonly prototype: SyntaxError;\n}\n\ndeclare const SyntaxError: SyntaxErrorConstructor;\n\ninterface TypeError extends Error {\n}\n\ninterface TypeErrorConstructor {\n    new(message?: string): TypeError;\n    (message?: string): TypeError;\n    readonly prototype: TypeError;\n}\n\ndeclare const TypeError: TypeErrorConstructor;\n\ninterface URIError extends Error {\n}\n\ninterface URIErrorConstructor {\n    new(message?: string): URIError;\n    (message?: string): URIError;\n    readonly prototype: URIError;\n}\n\ndeclare const URIError: URIErrorConstructor;\n\ninterface JSON {\n    /**\n      * Converts a JavaScript Object Notation (JSON) string into an object.\n      * @param text A valid JSON string.\n      * @param reviver A function that transforms the results. This function is called for each member of the object.\n      * If a member contains nested objects, the nested objects are transformed before the parent object is.\n      */\n    parse(text: string, reviver?: (key: any, value: any) => any): any;\n    /**\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n      * @param value A JavaScript value, usually an object or array, to be converted.\n      * @param replacer A function that transforms the results.\n      * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n      */\n    stringify(value: any, replacer?: (key: string, value: any) => any, space?: string | number): string;\n    /**\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n      * @param value A JavaScript value, usually an object or array, to be converted.\n      * @param replacer An array of strings and numbers that acts as a approved list for selecting the object properties that will be stringified.\n      * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n      */\n    stringify(value: any, replacer?: (number | string)[] | null, space?: string | number): string;\n}\n\n/**\n  * An intrinsic object that provides functions to convert JavaScript values to and from the JavaScript Object Notation (JSON) format.\n  */\ndeclare const JSON: JSON;\n\n\n/////////////////////////////\n/// ECMAScript Array API (specially handled by compiler)\n/////////////////////////////\n\ninterface ReadonlyArray<T> {\n    /**\n      * Gets the length of the array. This is a number one higher than the highest element defined in an array.\n      */\n    readonly length: number;\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n    /**\n      * Returns a string representation of an array. The elements are converted to string using thier toLocalString methods.\n      */\n    toLocaleString(): string;\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: T[][]): T[];\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: (T | T[])[]): T[];\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): T[];\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n      */\n    indexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Returns the index of the last occurrence of a specified value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n      */\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => boolean, thisArg?: any): boolean;\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => boolean, thisArg?: any): boolean;\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => void, thisArg?: any): void;\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    map<U>(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => U, thisArg?: any): U[];\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter<S extends T>(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => value is S, thisArg?: any): S[];\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => any, thisArg?: any): T[];\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T, initialValue?: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => U, initialValue: U): U;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T, initialValue?: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => U, initialValue: U): U;\n\n    readonly [n: number]: T;\n}\n\ninterface Array<T> {\n    /**\n      * Gets or sets the length of the array. This is a number one higher than the highest element defined in an array.\n      */\n    length: number;\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n    /**\n      * Returns a string representation of an array. The elements are converted to string using thier toLocalString methods.\n      */\n    toLocaleString(): string;\n    /**\n      * Appends new elements to an array, and returns the new length of the array.\n      * @param items New elements of the Array.\n      */\n    push(...items: T[]): number;\n    /**\n      * Removes the last element from an array and returns it.\n      */\n    pop(): T | undefined;\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: T[][]): T[];\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: (T | T[])[]): T[];\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): T[];\n    /**\n      * Removes the first element from an array and returns it.\n      */\n    shift(): T | undefined;\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): T[];\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: T, b: T) => number): this;\n    /**\n      * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n      * @param start The zero-based location in the array from which to start removing elements.\n      * @param deleteCount The number of elements to remove.\n      */\n    splice(start: number, deleteCount?: number): T[];\n    /**\n      * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n      * @param start The zero-based location in the array from which to start removing elements.\n      * @param deleteCount The number of elements to remove.\n      * @param items Elements to insert into the array in place of the deleted elements.\n      */\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n    /**\n      * Inserts new elements at the start of an array.\n      * @param items  Elements to insert at the start of the Array.\n      */\n    unshift(...items: T[]): number;\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n      */\n    indexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Returns the index of the last occurrence of a specified value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n      */\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any): T[];\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n\n    [n: number]: T;\n}\n\ninterface ArrayConstructor {\n    new(arrayLength?: number): any[];\n    new <T>(arrayLength: number): T[];\n    new <T>(...items: T[]): T[];\n    (arrayLength?: number): any[];\n    <T>(arrayLength: number): T[];\n    <T>(...items: T[]): T[];\n    isArray(arg: any): arg is Array<any>;\n    readonly prototype: Array<any>;\n}\n\ndeclare const Array: ArrayConstructor;\n\ninterface TypedPropertyDescriptor<T> {\n    enumerable?: boolean;\n    configurable?: boolean;\n    writable?: boolean;\n    value?: T;\n    get?: () => T;\n    set?: (value: T) => void;\n}\n\ndeclare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;\ndeclare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;\ndeclare type MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;\ndeclare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;\n\ndeclare type PromiseConstructorLike = new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void) => PromiseLike<T>;\n\ninterface PromiseLike<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;\n}\n\n/**\n * Represents the completion of an asynchronous operation\n */\ninterface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}\n\ninterface ArrayLike<T> {\n    readonly length: number;\n    readonly [n: number]: T;\n}\n\n/**\n * Make all properties in T optional\n */\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n\n/**\n * Make all properties in T readonly\n */\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\n/**\n * From T pick a set of properties K\n */\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\n/**\n * Construct a type with a set of properties K of type T\n */\ntype Record<K extends string, T> = {\n    [P in K]: T;\n};\n\n/**\n * Marker for contextual 'this' type\n */\ninterface ThisType<T> { }\n\n/**\n  * Represents a raw buffer of binary data, which is used to store data for the\n  * different typed arrays. ArrayBuffers cannot be read from or written to directly,\n  * but can be passed to a typed array or DataView Object to interpret the raw\n  * buffer as needed.\n  */\ninterface ArrayBuffer {\n    /**\n      * Read-only. The length of the ArrayBuffer (in bytes).\n      */\n    readonly byteLength: number;\n\n    /**\n      * Returns a section of an ArrayBuffer.\n      */\n    slice(begin: number, end?: number): ArrayBuffer;\n}\n\n/**\n * Allowed ArrayBuffer types for the buffer of an ArrayBufferView and related Typed Arrays.\n */\ninterface ArrayBufferTypes {\n    ArrayBuffer: ArrayBuffer;\n}\ntype ArrayBufferLike = ArrayBufferTypes[keyof ArrayBufferTypes];\n\ninterface ArrayBufferConstructor {\n    readonly prototype: ArrayBuffer;\n    new(byteLength: number): ArrayBuffer;\n    isView(arg: any): arg is ArrayBufferView;\n}\ndeclare const ArrayBuffer: ArrayBufferConstructor;\n\ninterface ArrayBufferView {\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    byteOffset: number;\n}\n\ninterface DataView {\n    readonly buffer: ArrayBuffer;\n    readonly byteLength: number;\n    readonly byteOffset: number;\n    /**\n      * Gets the Float32 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getFloat32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Float64 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getFloat64(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Int8 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getInt8(byteOffset: number): number;\n\n    /**\n      * Gets the Int16 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getInt16(byteOffset: number, littleEndian?: boolean): number;\n    /**\n      * Gets the Int32 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getInt32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Uint8 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getUint8(byteOffset: number): number;\n\n    /**\n      * Gets the Uint16 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getUint16(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Uint32 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getUint32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Stores an Float32 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setFloat32(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Float64 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setFloat64(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Int8 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      */\n    setInt8(byteOffset: number, value: number): void;\n\n    /**\n      * Stores an Int16 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setInt16(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Int32 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setInt32(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Uint8 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      */\n    setUint8(byteOffset: number, value: number): void;\n\n    /**\n      * Stores an Uint16 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setUint16(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Uint32 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setUint32(byteOffset: number, value: number, littleEndian?: boolean): void;\n}\n\ninterface DataViewConstructor {\n    new(buffer: ArrayBufferLike, byteOffset?: number, byteLength?: number): DataView;\n}\ndeclare const DataView: DataViewConstructor;\n\n/**\n  * A typed array of 8-bit integer values. The contents are initialized to 0. If the requested\n  * number of bytes could not be allocated an exception is raised.\n  */\ninterface Int8Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Int8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Int8Array) => any, thisArg?: any): Int8Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Int8Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (this: void, value: number, index: number, array: Int8Array) => number, thisArg?: any): Int8Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Int8Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Int8Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Int8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Int8Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Int8Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\ninterface Int8ArrayConstructor {\n    readonly prototype: Int8Array;\n    new(length: number): Int8Array;\n    new(array: ArrayLike<number>): Int8Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Int8Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Int8Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int8Array;\n\n\n}\ndeclare const Int8Array: Int8ArrayConstructor;\n\n/**\n  * A typed array of 8-bit unsigned integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint8Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint8Array) => any, thisArg?: any): Uint8Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint8Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (this: void, value: number, index: number, array: Uint8Array) => number, thisArg?: any): Uint8Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint8Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint8Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint8Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint8Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint8ArrayConstructor {\n    readonly prototype: Uint8Array;\n    new(length: number): Uint8Array;\n    new(array: ArrayLike<number>): Uint8Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint8Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint8Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8Array;\n\n}\ndeclare const Uint8Array: Uint8ArrayConstructor;\n\n/**\n  * A typed array of 8-bit unsigned integer (clamped) values. The contents are initialized to 0.\n  * If the requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint8ClampedArray {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => any, thisArg?: any): Uint8ClampedArray;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (this: void, value: number, index: number, array: Uint8ClampedArray) => number, thisArg?: any): Uint8ClampedArray;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint8ClampedArray;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint8ClampedArray;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint8ClampedArray view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint8ClampedArray;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint8ClampedArrayConstructor {\n    readonly prototype: Uint8ClampedArray;\n    new(length: number): Uint8ClampedArray;\n    new(array: ArrayLike<number>): Uint8ClampedArray;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint8ClampedArray;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint8ClampedArray;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8ClampedArray;\n}\ndeclare const Uint8ClampedArray: Uint8ClampedArrayConstructor;\n\n/**\n  * A typed array of 16-bit signed integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Int16Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Int16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (this: void, value: number, index: number, array: Int16Array) => any, thisArg?: any): Int16Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Int16Array) => void, thisArg?: any): void;\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (this: void, value: number, index: number, array: Int16Array) => number, thisArg?: any): Int16Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Int16Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Int16Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Int16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Int16Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Int16Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Int16ArrayConstructor {\n    readonly prototype: Int16Array;\n    new(length: number): Int16Array;\n    new(array: ArrayLike<number>): Int16Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Int16Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Int16Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int16Array;\n\n\n}\ndeclare const Int16Array: Int16ArrayConstructor;\n\n/**\n  * A typed array of 16-bit unsigned integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint16Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint16Array) => any, thisArg?: any): Uint16Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint16Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (this: void, value: number, index: number, array: Uint16Array) => number, thisArg?: any): Uint16Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint16Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint16Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint16Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint16Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint16ArrayConstructor {\n    readonly prototype: Uint16Array;\n    new(length: number): Uint16Array;\n    new(array: ArrayLike<number>): Uint16Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint16Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint16Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint16Array;\n\n\n}\ndeclare const Uint16Array: Uint16ArrayConstructor;\n/**\n  * A typed array of 32-bit signed integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Int32Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Int32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Int32Array) => any, thisArg?: any): Int32Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Int32Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Int32Array) => number, thisArg?: any): Int32Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Int32Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Int32Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Int32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Int32Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Int32Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Int32ArrayConstructor {\n    readonly prototype: Int32Array;\n    new(length: number): Int32Array;\n    new(array: ArrayLike<number>): Int32Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Int32Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Int32Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int32Array;\n\n}\ndeclare const Int32Array: Int32ArrayConstructor;\n\n/**\n  * A typed array of 32-bit unsigned integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint32Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint32Array) => any, thisArg?: any): Uint32Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint32Array) => void, thisArg?: any): void;\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (this: void, value: number, index: number, array: Uint32Array) => number, thisArg?: any): Uint32Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint32Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint32Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint32Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint32Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint32ArrayConstructor {\n    readonly prototype: Uint32Array;\n    new(length: number): Uint32Array;\n    new(array: ArrayLike<number>): Uint32Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint32Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint32Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint32Array;\n\n}\ndeclare const Uint32Array: Uint32ArrayConstructor;\n\n/**\n  * A typed array of 32-bit float values. The contents are initialized to 0. If the requested number\n  * of bytes could not be allocated an exception is raised.\n  */\ninterface Float32Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Float32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Float32Array) => any, thisArg?: any): Float32Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (this: void, value: number, index: number, array: Float32Array) => number, thisArg?: any): Float32Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Float32Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Float32Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Float32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Float32Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Float32Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Float32ArrayConstructor {\n    readonly prototype: Float32Array;\n    new(length: number): Float32Array;\n    new(array: ArrayLike<number>): Float32Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Float32Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Float32Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float32Array;\n\n\n}\ndeclare const Float32Array: Float32ArrayConstructor;\n\n/**\n  * A typed array of 64-bit float values. The contents are initialized to 0. If the requested\n  * number of bytes could not be allocated an exception is raised.\n  */\ninterface Float64Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Float64Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Float64Array) => any, thisArg?: any): Float64Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Array<number>) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Float64Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (this: void, value: number, index: number, array: Float64Array) => number, thisArg?: any): Float64Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number, initialValue?: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Float64Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Float64Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Float64Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Float64Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Float64Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Float64ArrayConstructor {\n    readonly prototype: Float64Array;\n    new(length: number): Float64Array;\n    new(array: ArrayLike<number>): Float64Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Float64Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Float64Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float64Array;\n\n}\ndeclare const Float64Array: Float64ArrayConstructor;\n\n/////////////////////////////\n/// ECMAScript Internationalization API\n/////////////////////////////\n\ndeclare namespace Intl {\n    interface CollatorOptions {\n        usage?: string;\n        localeMatcher?: string;\n        numeric?: boolean;\n        caseFirst?: string;\n        sensitivity?: string;\n        ignorePunctuation?: boolean;\n    }\n\n    interface ResolvedCollatorOptions {\n        locale: string;\n        usage: string;\n        sensitivity: string;\n        ignorePunctuation: boolean;\n        collation: string;\n        caseFirst: string;\n        numeric: boolean;\n    }\n\n    interface Collator {\n        compare(x: string, y: string): number;\n        resolvedOptions(): ResolvedCollatorOptions;\n    }\n    var Collator: {\n        new(locales?: string | string[], options?: CollatorOptions): Collator;\n        (locales?: string | string[], options?: CollatorOptions): Collator;\n        supportedLocalesOf(locales: string | string[], options?: CollatorOptions): string[];\n    };\n\n    interface NumberFormatOptions {\n        localeMatcher?: string;\n        style?: string;\n        currency?: string;\n        currencyDisplay?: string;\n        useGrouping?: boolean;\n        minimumIntegerDigits?: number;\n        minimumFractionDigits?: number;\n        maximumFractionDigits?: number;\n        minimumSignificantDigits?: number;\n        maximumSignificantDigits?: number;\n    }\n\n    interface ResolvedNumberFormatOptions {\n        locale: string;\n        numberingSystem: string;\n        style: string;\n        currency?: string;\n        currencyDisplay?: string;\n        minimumIntegerDigits: number;\n        minimumFractionDigits: number;\n        maximumFractionDigits: number;\n        minimumSignificantDigits?: number;\n        maximumSignificantDigits?: number;\n        useGrouping: boolean;\n    }\n\n    interface NumberFormat {\n        format(value: number): string;\n        resolvedOptions(): ResolvedNumberFormatOptions;\n    }\n    var NumberFormat: {\n        new(locales?: string | string[], options?: NumberFormatOptions): NumberFormat;\n        (locales?: string | string[], options?: NumberFormatOptions): NumberFormat;\n        supportedLocalesOf(locales: string | string[], options?: NumberFormatOptions): string[];\n    };\n\n    interface DateTimeFormatOptions {\n        localeMatcher?: string;\n        weekday?: string;\n        era?: string;\n        year?: string;\n        month?: string;\n        day?: string;\n        hour?: string;\n        minute?: string;\n        second?: string;\n        timeZoneName?: string;\n        formatMatcher?: string;\n        hour12?: boolean;\n        timeZone?: string;\n    }\n\n    interface ResolvedDateTimeFormatOptions {\n        locale: string;\n        calendar: string;\n        numberingSystem: string;\n        timeZone: string;\n        hour12?: boolean;\n        weekday?: string;\n        era?: string;\n        year?: string;\n        month?: string;\n        day?: string;\n        hour?: string;\n        minute?: string;\n        second?: string;\n        timeZoneName?: string;\n    }\n\n    interface DateTimeFormat {\n        format(date?: Date | number): string;\n        resolvedOptions(): ResolvedDateTimeFormatOptions;\n    }\n    var DateTimeFormat: {\n        new(locales?: string | string[], options?: DateTimeFormatOptions): DateTimeFormat;\n        (locales?: string | string[], options?: DateTimeFormatOptions): DateTimeFormat;\n        supportedLocalesOf(locales: string | string[], options?: DateTimeFormatOptions): string[];\n    };\n}\n\ninterface String {\n    /**\n      * Determines whether two strings are equivalent in the current or specified locale.\n      * @param that String to compare to target string\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used. This parameter must conform to BCP 47 standards; see the Intl.Collator object for details.\n      * @param options An object that contains one or more properties that specify comparison options. see the Intl.Collator object for details.\n      */\n    localeCompare(that: string, locales?: string | string[], options?: Intl.CollatorOptions): number;\n}\n\ninterface Number {\n    /**\n      * Converts a number to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleString(locales?: string | string[], options?: Intl.NumberFormatOptions): string;\n}\n\ninterface Date {\n    /**\n      * Converts a date and time to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n    /**\n      * Converts a date to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleDateString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n\n    /**\n      * Converts a time to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleTimeString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n}\n","type":3},{"name":"lib.dom.d.ts","text":"/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib=\"true\"/>\n\n\n\n/////////////////////////////\n/// DOM APIs\n/////////////////////////////\n\ninterface Account {\n    displayName?: string;\n    id?: string;\n    imageURL?: string;\n    name?: string;\n    rpDisplayName?: string;\n}\n\ninterface Algorithm {\n    name: string;\n}\n\ninterface AnimationEventInit extends EventInit {\n    animationName?: string;\n    elapsedTime?: number;\n}\n\ninterface AssertionOptions {\n    allowList?: ScopedCredentialDescriptor[];\n    extensions?: WebAuthnExtensions;\n    rpId?: USVString;\n    timeoutSeconds?: number;\n}\n\ninterface CacheQueryOptions {\n    cacheName?: string;\n    ignoreMethod?: boolean;\n    ignoreSearch?: boolean;\n    ignoreVary?: boolean;\n}\n\ninterface ClientData {\n    challenge?: string;\n    extensions?: WebAuthnExtensions;\n    hashAlg?: string | Algorithm;\n    origin?: string;\n    rpId?: string;\n    tokenBinding?: string;\n}\n\ninterface CloseEventInit extends EventInit {\n    code?: number;\n    reason?: string;\n    wasClean?: boolean;\n}\n\ninterface CompositionEventInit extends UIEventInit {\n    data?: string;\n}\n\ninterface ConfirmSiteSpecificExceptionsInformation extends ExceptionInformation {\n    arrayOfDomainStrings?: string[];\n}\n\ninterface ConstrainBooleanParameters {\n    exact?: boolean;\n    ideal?: boolean;\n}\n\ninterface ConstrainDOMStringParameters {\n    exact?: string | string[];\n    ideal?: string | string[];\n}\n\ninterface ConstrainDoubleRange extends DoubleRange {\n    exact?: number;\n    ideal?: number;\n}\n\ninterface ConstrainLongRange extends LongRange {\n    exact?: number;\n    ideal?: number;\n}\n\ninterface ConstrainVideoFacingModeParameters {\n    exact?: VideoFacingModeEnum | VideoFacingModeEnum[];\n    ideal?: VideoFacingModeEnum | VideoFacingModeEnum[];\n}\n\ninterface CustomEventInit extends EventInit {\n    detail?: any;\n}\n\ninterface DeviceAccelerationDict {\n    x?: number;\n    y?: number;\n    z?: number;\n}\n\ninterface DeviceLightEventInit extends EventInit {\n    value?: number;\n}\n\ninterface DeviceMotionEventInit extends EventInit {\n    acceleration?: DeviceAccelerationDict;\n    accelerationIncludingGravity?: DeviceAccelerationDict;\n    interval?: number;\n    rotationRate?: DeviceRotationRateDict;\n}\n\ninterface DeviceOrientationEventInit extends EventInit {\n    absolute?: boolean;\n    alpha?: number;\n    beta?: number;\n    gamma?: number;\n}\n\ninterface DeviceRotationRateDict {\n    alpha?: number;\n    beta?: number;\n    gamma?: number;\n}\n\ninterface DOMRectInit {\n    height?: any;\n    width?: any;\n    x?: any;\n    y?: any;\n}\n\ninterface DoubleRange {\n    max?: number;\n    min?: number;\n}\n\ninterface ErrorEventInit extends EventInit {\n    colno?: number;\n    error?: any;\n    filename?: string;\n    lineno?: number;\n    message?: string;\n}\n\ninterface EventInit {\n    scoped?: boolean;\n    bubbles?: boolean;\n    cancelable?: boolean;\n}\n\ninterface EventModifierInit extends UIEventInit {\n    altKey?: boolean;\n    ctrlKey?: boolean;\n    metaKey?: boolean;\n    modifierAltGraph?: boolean;\n    modifierCapsLock?: boolean;\n    modifierFn?: boolean;\n    modifierFnLock?: boolean;\n    modifierHyper?: boolean;\n    modifierNumLock?: boolean;\n    modifierOS?: boolean;\n    modifierScrollLock?: boolean;\n    modifierSuper?: boolean;\n    modifierSymbol?: boolean;\n    modifierSymbolLock?: boolean;\n    shiftKey?: boolean;\n}\n\ninterface ExceptionInformation {\n    domain?: string;\n}\n\ninterface FocusEventInit extends UIEventInit {\n    relatedTarget?: EventTarget;\n}\n\ninterface FocusNavigationEventInit extends EventInit {\n    navigationReason?: string;\n    originHeight?: number;\n    originLeft?: number;\n    originTop?: number;\n    originWidth?: number;\n}\n\ninterface FocusNavigationOrigin {\n    originHeight?: number;\n    originLeft?: number;\n    originTop?: number;\n    originWidth?: number;\n}\n\ninterface GamepadEventInit extends EventInit {\n    gamepad?: Gamepad;\n}\n\ninterface GetNotificationOptions {\n    tag?: string;\n}\n\ninterface HashChangeEventInit extends EventInit {\n    newURL?: string;\n    oldURL?: string;\n}\n\ninterface IDBIndexParameters {\n    multiEntry?: boolean;\n    unique?: boolean;\n}\n\ninterface IDBObjectStoreParameters {\n    autoIncrement?: boolean;\n    keyPath?: IDBKeyPath;\n}\n\ninterface IntersectionObserverEntryInit {\n    boundingClientRect?: DOMRectInit;\n    intersectionRect?: DOMRectInit;\n    rootBounds?: DOMRectInit;\n    target?: Element;\n    time?: number;\n}\n\ninterface IntersectionObserverInit {\n    root?: Element;\n    rootMargin?: string;\n    threshold?: number | number[];\n}\n\ninterface KeyAlgorithm {\n    name?: string;\n}\n\ninterface KeyboardEventInit extends EventModifierInit {\n    code?: string;\n    key?: string;\n    location?: number;\n    repeat?: boolean;\n}\n\ninterface LongRange {\n    max?: number;\n    min?: number;\n}\n\ninterface MediaEncryptedEventInit extends EventInit {\n    initData?: ArrayBuffer;\n    initDataType?: string;\n}\n\ninterface MediaKeyMessageEventInit extends EventInit {\n    message?: ArrayBuffer;\n    messageType?: MediaKeyMessageType;\n}\n\ninterface MediaKeySystemConfiguration {\n    audioCapabilities?: MediaKeySystemMediaCapability[];\n    distinctiveIdentifier?: MediaKeysRequirement;\n    initDataTypes?: string[];\n    persistentState?: MediaKeysRequirement;\n    videoCapabilities?: MediaKeySystemMediaCapability[];\n}\n\ninterface MediaKeySystemMediaCapability {\n    contentType?: string;\n    robustness?: string;\n}\n\ninterface MediaStreamConstraints {\n    audio?: boolean | MediaTrackConstraints;\n    video?: boolean | MediaTrackConstraints;\n}\n\ninterface MediaStreamErrorEventInit extends EventInit {\n    error?: MediaStreamError;\n}\n\ninterface MediaStreamEventInit extends EventInit {\n    stream?: MediaStream;\n}\n\ninterface MediaStreamTrackEventInit extends EventInit {\n    track?: MediaStreamTrack;\n}\n\ninterface MediaTrackCapabilities {\n    aspectRatio?: number | DoubleRange;\n    deviceId?: string;\n    echoCancellation?: boolean[];\n    facingMode?: string;\n    frameRate?: number | DoubleRange;\n    groupId?: string;\n    height?: number | LongRange;\n    sampleRate?: number | LongRange;\n    sampleSize?: number | LongRange;\n    volume?: number | DoubleRange;\n    width?: number | LongRange;\n}\n\ninterface MediaTrackConstraints extends MediaTrackConstraintSet {\n    advanced?: MediaTrackConstraintSet[];\n}\n\ninterface MediaTrackConstraintSet {\n    aspectRatio?: number | ConstrainDoubleRange;\n    deviceId?: string | string[] | ConstrainDOMStringParameters;\n    echoCancelation?: boolean | ConstrainBooleanParameters;\n    facingMode?: string | string[] | ConstrainDOMStringParameters;\n    frameRate?: number | ConstrainDoubleRange;\n    groupId?: string | string[] | ConstrainDOMStringParameters;\n    height?: number | ConstrainLongRange;\n    sampleRate?: number | ConstrainLongRange;\n    sampleSize?: number | ConstrainLongRange;\n    volume?: number | ConstrainDoubleRange;\n    width?: number | ConstrainLongRange;\n}\n\ninterface MediaTrackSettings {\n    aspectRatio?: number;\n    deviceId?: string;\n    echoCancellation?: boolean;\n    facingMode?: string;\n    frameRate?: number;\n    groupId?: string;\n    height?: number;\n    sampleRate?: number;\n    sampleSize?: number;\n    volume?: number;\n    width?: number;\n}\n\ninterface MediaTrackSupportedConstraints {\n    aspectRatio?: boolean;\n    deviceId?: boolean;\n    echoCancellation?: boolean;\n    facingMode?: boolean;\n    frameRate?: boolean;\n    groupId?: boolean;\n    height?: boolean;\n    sampleRate?: boolean;\n    sampleSize?: boolean;\n    volume?: boolean;\n    width?: boolean;\n}\n\ninterface MessageEventInit extends EventInit {\n    lastEventId?: string;\n    channel?: string;\n    data?: any;\n    origin?: string;\n    ports?: MessagePort[];\n    source?: Window;\n}\n\ninterface MouseEventInit extends EventModifierInit {\n    button?: number;\n    buttons?: number;\n    clientX?: number;\n    clientY?: number;\n    relatedTarget?: EventTarget;\n    screenX?: number;\n    screenY?: number;\n}\n\ninterface MSAccountInfo {\n    accountImageUri?: string;\n    accountName?: string;\n    rpDisplayName?: string;\n    userDisplayName?: string;\n    userId?: string;\n}\n\ninterface MSAudioLocalClientEvent extends MSLocalClientEventBase {\n    cpuInsufficientEventRatio?: number;\n    deviceCaptureNotFunctioningEventRatio?: number;\n    deviceClippingEventRatio?: number;\n    deviceEchoEventRatio?: number;\n    deviceGlitchesEventRatio?: number;\n    deviceHalfDuplexAECEventRatio?: number;\n    deviceHowlingEventCount?: number;\n    deviceLowSNREventRatio?: number;\n    deviceLowSpeechLevelEventRatio?: number;\n    deviceMultipleEndpointsEventCount?: number;\n    deviceNearEndToEchoRatioEventRatio?: number;\n    deviceRenderMuteEventRatio?: number;\n    deviceRenderNotFunctioningEventRatio?: number;\n    deviceRenderZeroVolumeEventRatio?: number;\n    networkDelayEventRatio?: number;\n    networkSendQualityEventRatio?: number;\n}\n\ninterface MSAudioRecvPayload extends MSPayloadBase {\n    burstLossLength1?: number;\n    burstLossLength2?: number;\n    burstLossLength3?: number;\n    burstLossLength4?: number;\n    burstLossLength5?: number;\n    burstLossLength6?: number;\n    burstLossLength7?: number;\n    burstLossLength8OrHigher?: number;\n    fecRecvDistance1?: number;\n    fecRecvDistance2?: number;\n    fecRecvDistance3?: number;\n    packetReorderDepthAvg?: number;\n    packetReorderDepthMax?: number;\n    packetReorderRatio?: number;\n    ratioCompressedSamplesAvg?: number;\n    ratioConcealedSamplesAvg?: number;\n    ratioStretchedSamplesAvg?: number;\n    samplingRate?: number;\n    signal?: MSAudioRecvSignal;\n}\n\ninterface MSAudioRecvSignal {\n    initialSignalLevelRMS?: number;\n    recvNoiseLevelCh1?: number;\n    recvSignalLevelCh1?: number;\n    renderLoopbackSignalLevel?: number;\n    renderNoiseLevel?: number;\n    renderSignalLevel?: number;\n}\n\ninterface MSAudioSendPayload extends MSPayloadBase {\n    audioFECUsed?: boolean;\n    samplingRate?: number;\n    sendMutePercent?: number;\n    signal?: MSAudioSendSignal;\n}\n\ninterface MSAudioSendSignal {\n    noiseLevel?: number;\n    sendNoiseLevelCh1?: number;\n    sendSignalLevelCh1?: number;\n}\n\ninterface MSConnectivity {\n    iceType?: MSIceType;\n    iceWarningFlags?: MSIceWarningFlags;\n    relayAddress?: MSRelayAddress;\n}\n\ninterface MSCredentialFilter {\n    accept?: MSCredentialSpec[];\n}\n\ninterface MSCredentialParameters {\n    type?: MSCredentialType;\n}\n\ninterface MSCredentialSpec {\n    id?: string;\n    type?: MSCredentialType;\n}\n\ninterface MSDelay {\n    roundTrip?: number;\n    roundTripMax?: number;\n}\n\ninterface MSDescription extends RTCStats {\n    connectivity?: MSConnectivity;\n    deviceDevName?: string;\n    localAddr?: MSIPAddressInfo;\n    networkconnectivity?: MSNetworkConnectivityInfo;\n    reflexiveLocalIPAddr?: MSIPAddressInfo;\n    remoteAddr?: MSIPAddressInfo;\n    transport?: RTCIceProtocol;\n}\n\ninterface MSFIDOCredentialParameters extends MSCredentialParameters {\n    algorithm?: string | Algorithm;\n    authenticators?: AAGUID[];\n}\n\ninterface MSIceWarningFlags {\n    allocationMessageIntegrityFailed?: boolean;\n    alternateServerReceived?: boolean;\n    connCheckMessageIntegrityFailed?: boolean;\n    connCheckOtherError?: boolean;\n    fipsAllocationFailure?: boolean;\n    multipleRelayServersAttempted?: boolean;\n    noRelayServersConfigured?: boolean;\n    portRangeExhausted?: boolean;\n    pseudoTLSFailure?: boolean;\n    tcpNatConnectivityFailed?: boolean;\n    tcpRelayConnectivityFailed?: boolean;\n    turnAuthUnknownUsernameError?: boolean;\n    turnTcpAllocateFailed?: boolean;\n    turnTcpSendFailed?: boolean;\n    turnTcpTimedOut?: boolean;\n    turnTurnTcpConnectivityFailed?: boolean;\n    turnUdpAllocateFailed?: boolean;\n    turnUdpSendFailed?: boolean;\n    udpLocalConnectivityFailed?: boolean;\n    udpNatConnectivityFailed?: boolean;\n    udpRelayConnectivityFailed?: boolean;\n    useCandidateChecksFailed?: boolean;\n}\n\ninterface MSIPAddressInfo {\n    ipAddr?: string;\n    manufacturerMacAddrMask?: string;\n    port?: number;\n}\n\ninterface MSJitter {\n    interArrival?: number;\n    interArrivalMax?: number;\n    interArrivalSD?: number;\n}\n\ninterface MSLocalClientEventBase extends RTCStats {\n    networkBandwidthLowEventRatio?: number;\n    networkReceiveQualityEventRatio?: number;\n}\n\ninterface MSNetwork extends RTCStats {\n    delay?: MSDelay;\n    jitter?: MSJitter;\n    packetLoss?: MSPacketLoss;\n    utilization?: MSUtilization;\n}\n\ninterface MSNetworkConnectivityInfo {\n    linkspeed?: number;\n    networkConnectionDetails?: string;\n    vpn?: boolean;\n}\n\ninterface MSNetworkInterfaceType {\n    interfaceTypeEthernet?: boolean;\n    interfaceTypePPP?: boolean;\n    interfaceTypeTunnel?: boolean;\n    interfaceTypeWireless?: boolean;\n    interfaceTypeWWAN?: boolean;\n}\n\ninterface MSOutboundNetwork extends MSNetwork {\n    appliedBandwidthLimit?: number;\n}\n\ninterface MSPacketLoss {\n    lossRate?: number;\n    lossRateMax?: number;\n}\n\ninterface MSPayloadBase extends RTCStats {\n    payloadDescription?: string;\n}\n\ninterface MSPortRange {\n    max?: number;\n    min?: number;\n}\n\ninterface MSRelayAddress {\n    port?: number;\n    relayAddress?: string;\n}\n\ninterface MSSignatureParameters {\n    userPrompt?: string;\n}\n\ninterface MSTransportDiagnosticsStats extends RTCStats {\n    allocationTimeInMs?: number;\n    baseAddress?: string;\n    baseInterface?: MSNetworkInterfaceType;\n    iceRole?: RTCIceRole;\n    iceWarningFlags?: MSIceWarningFlags;\n    interfaces?: MSNetworkInterfaceType;\n    localAddress?: string;\n    localAddrType?: MSIceAddrType;\n    localInterface?: MSNetworkInterfaceType;\n    localMR?: string;\n    localMRTCPPort?: number;\n    localSite?: string;\n    msRtcEngineVersion?: string;\n    networkName?: string;\n    numConsentReqReceived?: number;\n    numConsentReqSent?: number;\n    numConsentRespReceived?: number;\n    numConsentRespSent?: number;\n    portRangeMax?: number;\n    portRangeMin?: number;\n    protocol?: RTCIceProtocol;\n    remoteAddress?: string;\n    remoteAddrType?: MSIceAddrType;\n    remoteMR?: string;\n    remoteMRTCPPort?: number;\n    remoteSite?: string;\n    rtpRtcpMux?: boolean;\n    stunVer?: number;\n}\n\ninterface MSUtilization {\n    bandwidthEstimation?: number;\n    bandwidthEstimationAvg?: number;\n    bandwidthEstimationMax?: number;\n    bandwidthEstimationMin?: number;\n    bandwidthEstimationStdDev?: number;\n    packets?: number;\n}\n\ninterface MSVideoPayload extends MSPayloadBase {\n    durationSeconds?: number;\n    resolution?: string;\n    videoBitRateAvg?: number;\n    videoBitRateMax?: number;\n    videoFrameRateAvg?: number;\n    videoPacketLossRate?: number;\n}\n\ninterface MSVideoRecvPayload extends MSVideoPayload {\n    lowBitRateCallPercent?: number;\n    lowFrameRateCallPercent?: number;\n    recvBitRateAverage?: number;\n    recvBitRateMaximum?: number;\n    recvCodecType?: string;\n    recvFpsHarmonicAverage?: number;\n    recvFrameRateAverage?: number;\n    recvNumResSwitches?: number;\n    recvReorderBufferMaxSuccessfullyOrderedExtent?: number;\n    recvReorderBufferMaxSuccessfullyOrderedLateTime?: number;\n    recvReorderBufferPacketsDroppedDueToBufferExhaustion?: number;\n    recvReorderBufferPacketsDroppedDueToTimeout?: number;\n    recvReorderBufferReorderedPackets?: number;\n    recvResolutionHeight?: number;\n    recvResolutionWidth?: number;\n    recvVideoStreamsMax?: number;\n    recvVideoStreamsMin?: number;\n    recvVideoStreamsMode?: number;\n    reorderBufferTotalPackets?: number;\n    videoFrameLossRate?: number;\n    videoPostFECPLR?: number;\n    videoResolutions?: MSVideoResolutionDistribution;\n}\n\ninterface MSVideoResolutionDistribution {\n    cifQuality?: number;\n    h1080Quality?: number;\n    h1440Quality?: number;\n    h2160Quality?: number;\n    h720Quality?: number;\n    vgaQuality?: number;\n}\n\ninterface MSVideoSendPayload extends MSVideoPayload {\n    sendBitRateAverage?: number;\n    sendBitRateMaximum?: number;\n    sendFrameRateAverage?: number;\n    sendResolutionHeight?: number;\n    sendResolutionWidth?: number;\n    sendVideoStreamsMax?: number;\n}\n\ninterface MsZoomToOptions {\n    animate?: string;\n    contentX?: number;\n    contentY?: number;\n    scaleFactor?: number;\n    viewportX?: string;\n    viewportY?: string;\n}\n\ninterface MutationObserverInit {\n    attributeFilter?: string[];\n    attributeOldValue?: boolean;\n    attributes?: boolean;\n    characterData?: boolean;\n    characterDataOldValue?: boolean;\n    childList?: boolean;\n    subtree?: boolean;\n}\n\ninterface NotificationOptions {\n    body?: string;\n    dir?: NotificationDirection;\n    icon?: string;\n    lang?: string;\n    tag?: string;\n}\n\ninterface ObjectURLOptions {\n    oneTimeOnly?: boolean;\n}\n\ninterface PaymentCurrencyAmount {\n    currency?: string;\n    currencySystem?: string;\n    value?: string;\n}\n\ninterface PaymentDetails {\n    displayItems?: PaymentItem[];\n    error?: string;\n    modifiers?: PaymentDetailsModifier[];\n    shippingOptions?: PaymentShippingOption[];\n    total?: PaymentItem;\n}\n\ninterface PaymentDetailsModifier {\n    additionalDisplayItems?: PaymentItem[];\n    data?: any;\n    supportedMethods?: string[];\n    total?: PaymentItem;\n}\n\ninterface PaymentItem {\n    amount?: PaymentCurrencyAmount;\n    label?: string;\n    pending?: boolean;\n}\n\ninterface PaymentMethodData {\n    data?: any;\n    supportedMethods?: string[];\n}\n\ninterface PaymentOptions {\n    requestPayerEmail?: boolean;\n    requestPayerName?: boolean;\n    requestPayerPhone?: boolean;\n    requestShipping?: boolean;\n    shippingType?: string;\n}\n\ninterface PaymentRequestUpdateEventInit extends EventInit {\n}\n\ninterface PaymentShippingOption {\n    amount?: PaymentCurrencyAmount;\n    id?: string;\n    label?: string;\n    selected?: boolean;\n}\n\ninterface PeriodicWaveConstraints {\n    disableNormalization?: boolean;\n}\n\ninterface PointerEventInit extends MouseEventInit {\n    height?: number;\n    isPrimary?: boolean;\n    pointerId?: number;\n    pointerType?: string;\n    pressure?: number;\n    tiltX?: number;\n    tiltY?: number;\n    width?: number;\n}\n\ninterface PopStateEventInit extends EventInit {\n    state?: any;\n}\n\ninterface PositionOptions {\n    enableHighAccuracy?: boolean;\n    maximumAge?: number;\n    timeout?: number;\n}\n\ninterface ProgressEventInit extends EventInit {\n    lengthComputable?: boolean;\n    loaded?: number;\n    total?: number;\n}\n\ninterface PushSubscriptionOptionsInit {\n    applicationServerKey?: any;\n    userVisibleOnly?: boolean;\n}\n\ninterface RegistrationOptions {\n    scope?: string;\n}\n\ninterface RequestInit {\n    body?: any;\n    cache?: RequestCache;\n    credentials?: RequestCredentials;\n    headers?: any;\n    integrity?: string;\n    keepalive?: boolean;\n    method?: string;\n    mode?: RequestMode;\n    redirect?: RequestRedirect;\n    referrer?: string;\n    referrerPolicy?: ReferrerPolicy;\n    window?: any;\n}\n\ninterface ResponseInit {\n    headers?: any;\n    status?: number;\n    statusText?: string;\n}\n\ninterface RTCConfiguration {\n    bundlePolicy?: RTCBundlePolicy;\n    iceServers?: RTCIceServer[];\n    iceTransportPolicy?: RTCIceTransportPolicy;\n    peerIdentity?: string;\n}\n\ninterface RTCDtlsFingerprint {\n    algorithm?: string;\n    value?: string;\n}\n\ninterface RTCDtlsParameters {\n    fingerprints?: RTCDtlsFingerprint[];\n    role?: RTCDtlsRole;\n}\n\ninterface RTCDTMFToneChangeEventInit extends EventInit {\n    tone?: string;\n}\n\ninterface RTCIceCandidateAttributes extends RTCStats {\n    addressSourceUrl?: string;\n    candidateType?: RTCStatsIceCandidateType;\n    ipAddress?: string;\n    portNumber?: number;\n    priority?: number;\n    transport?: string;\n}\n\ninterface RTCIceCandidateComplete {\n}\n\ninterface RTCIceCandidateDictionary {\n    foundation?: string;\n    ip?: string;\n    msMTurnSessionId?: string;\n    port?: number;\n    priority?: number;\n    protocol?: RTCIceProtocol;\n    relatedAddress?: string;\n    relatedPort?: number;\n    tcpType?: RTCIceTcpCandidateType;\n    type?: RTCIceCandidateType;\n}\n\ninterface RTCIceCandidateInit {\n    candidate?: string;\n    sdpMid?: string;\n    sdpMLineIndex?: number;\n}\n\ninterface RTCIceCandidatePair {\n    local?: RTCIceCandidateDictionary;\n    remote?: RTCIceCandidateDictionary;\n}\n\ninterface RTCIceCandidatePairStats extends RTCStats {\n    availableIncomingBitrate?: number;\n    availableOutgoingBitrate?: number;\n    bytesReceived?: number;\n    bytesSent?: number;\n    localCandidateId?: string;\n    nominated?: boolean;\n    priority?: number;\n    readable?: boolean;\n    remoteCandidateId?: string;\n    roundTripTime?: number;\n    state?: RTCStatsIceCandidatePairState;\n    transportId?: string;\n    writable?: boolean;\n}\n\ninterface RTCIceGatherOptions {\n    gatherPolicy?: RTCIceGatherPolicy;\n    iceservers?: RTCIceServer[];\n    portRange?: MSPortRange;\n}\n\ninterface RTCIceParameters {\n    iceLite?: boolean;\n    password?: string;\n    usernameFragment?: string;\n}\n\ninterface RTCIceServer {\n    credential?: string;\n    urls?: any;\n    username?: string;\n}\n\ninterface RTCInboundRTPStreamStats extends RTCRTPStreamStats {\n    bytesReceived?: number;\n    fractionLost?: number;\n    jitter?: number;\n    packetsLost?: number;\n    packetsReceived?: number;\n}\n\ninterface RTCMediaStreamTrackStats extends RTCStats {\n    audioLevel?: number;\n    echoReturnLoss?: number;\n    echoReturnLossEnhancement?: number;\n    frameHeight?: number;\n    framesCorrupted?: number;\n    framesDecoded?: number;\n    framesDropped?: number;\n    framesPerSecond?: number;\n    framesReceived?: number;\n    framesSent?: number;\n    frameWidth?: number;\n    remoteSource?: boolean;\n    ssrcIds?: string[];\n    trackIdentifier?: string;\n}\n\ninterface RTCOfferOptions {\n    iceRestart?: boolean;\n    offerToReceiveAudio?: number;\n    offerToReceiveVideo?: number;\n    voiceActivityDetection?: boolean;\n}\n\ninterface RTCOutboundRTPStreamStats extends RTCRTPStreamStats {\n    bytesSent?: number;\n    packetsSent?: number;\n    roundTripTime?: number;\n    targetBitrate?: number;\n}\n\ninterface RTCPeerConnectionIceEventInit extends EventInit {\n    candidate?: RTCIceCandidate;\n}\n\ninterface RTCRtcpFeedback {\n    parameter?: string;\n    type?: string;\n}\n\ninterface RTCRtcpParameters {\n    cname?: string;\n    mux?: boolean;\n    reducedSize?: boolean;\n    ssrc?: number;\n}\n\ninterface RTCRtpCapabilities {\n    codecs?: RTCRtpCodecCapability[];\n    fecMechanisms?: string[];\n    headerExtensions?: RTCRtpHeaderExtension[];\n}\n\ninterface RTCRtpCodecCapability {\n    clockRate?: number;\n    kind?: string;\n    maxptime?: number;\n    maxSpatialLayers?: number;\n    maxTemporalLayers?: number;\n    name?: string;\n    numChannels?: number;\n    options?: any;\n    parameters?: any;\n    preferredPayloadType?: number;\n    ptime?: number;\n    rtcpFeedback?: RTCRtcpFeedback[];\n    svcMultiStreamSupport?: boolean;\n}\n\ninterface RTCRtpCodecParameters {\n    clockRate?: number;\n    maxptime?: number;\n    name?: string;\n    numChannels?: number;\n    parameters?: any;\n    payloadType?: any;\n    ptime?: number;\n    rtcpFeedback?: RTCRtcpFeedback[];\n}\n\ninterface RTCRtpContributingSource {\n    audioLevel?: number;\n    csrc?: number;\n    timestamp?: number;\n}\n\ninterface RTCRtpEncodingParameters {\n    active?: boolean;\n    codecPayloadType?: number;\n    dependencyEncodingIds?: string[];\n    encodingId?: string;\n    fec?: RTCRtpFecParameters;\n    framerateScale?: number;\n    maxBitrate?: number;\n    maxFramerate?: number;\n    minQuality?: number;\n    priority?: number;\n    resolutionScale?: number;\n    rtx?: RTCRtpRtxParameters;\n    ssrc?: number;\n    ssrcRange?: RTCSsrcRange;\n}\n\ninterface RTCRtpFecParameters {\n    mechanism?: string;\n    ssrc?: number;\n}\n\ninterface RTCRtpHeaderExtension {\n    kind?: string;\n    preferredEncrypt?: boolean;\n    preferredId?: number;\n    uri?: string;\n}\n\ninterface RTCRtpHeaderExtensionParameters {\n    encrypt?: boolean;\n    id?: number;\n    uri?: string;\n}\n\ninterface RTCRtpParameters {\n    codecs?: RTCRtpCodecParameters[];\n    degradationPreference?: RTCDegradationPreference;\n    encodings?: RTCRtpEncodingParameters[];\n    headerExtensions?: RTCRtpHeaderExtensionParameters[];\n    muxId?: string;\n    rtcp?: RTCRtcpParameters;\n}\n\ninterface RTCRtpRtxParameters {\n    ssrc?: number;\n}\n\ninterface RTCRTPStreamStats extends RTCStats {\n    associateStatsId?: string;\n    codecId?: string;\n    firCount?: number;\n    isRemote?: boolean;\n    mediaTrackId?: string;\n    nackCount?: number;\n    pliCount?: number;\n    sliCount?: number;\n    ssrc?: string;\n    transportId?: string;\n}\n\ninterface RTCRtpUnhandled {\n    muxId?: string;\n    payloadType?: number;\n    ssrc?: number;\n}\n\ninterface RTCSessionDescriptionInit {\n    sdp?: string;\n    type?: RTCSdpType;\n}\n\ninterface RTCSrtpKeyParam {\n    keyMethod?: string;\n    keySalt?: string;\n    lifetime?: string;\n    mkiLength?: number;\n    mkiValue?: number;\n}\n\ninterface RTCSrtpSdesParameters {\n    cryptoSuite?: string;\n    keyParams?: RTCSrtpKeyParam[];\n    sessionParams?: string[];\n    tag?: number;\n}\n\ninterface RTCSsrcRange {\n    max?: number;\n    min?: number;\n}\n\ninterface RTCStats {\n    id?: string;\n    msType?: MSStatsType;\n    timestamp?: number;\n    type?: RTCStatsType;\n}\n\ninterface RTCStatsReport {\n}\n\ninterface RTCTransportStats extends RTCStats {\n    activeConnection?: boolean;\n    bytesReceived?: number;\n    bytesSent?: number;\n    localCertificateId?: string;\n    remoteCertificateId?: string;\n    rtcpTransportStatsId?: string;\n    selectedCandidatePairId?: string;\n}\n\ninterface ScopedCredentialDescriptor {\n    id?: any;\n    transports?: Transport[];\n    type?: ScopedCredentialType;\n}\n\ninterface ScopedCredentialOptions {\n    excludeList?: ScopedCredentialDescriptor[];\n    extensions?: WebAuthnExtensions;\n    rpId?: USVString;\n    timeoutSeconds?: number;\n}\n\ninterface ScopedCredentialParameters {\n    algorithm?: string | Algorithm;\n    type?: ScopedCredentialType;\n}\n\ninterface ServiceWorkerMessageEventInit extends EventInit {\n    data?: any;\n    lastEventId?: string;\n    origin?: string;\n    ports?: MessagePort[];\n    source?: ServiceWorker | MessagePort;\n}\n\ninterface SpeechSynthesisEventInit extends EventInit {\n    charIndex?: number;\n    elapsedTime?: number;\n    name?: string;\n    utterance?: SpeechSynthesisUtterance;\n}\n\ninterface StoreExceptionsInformation extends ExceptionInformation {\n    detailURI?: string;\n    explanationString?: string;\n    siteName?: string;\n}\n\ninterface StoreSiteSpecificExceptionsInformation extends StoreExceptionsInformation {\n    arrayOfDomainStrings?: string[];\n}\n\ninterface TrackEventInit extends EventInit {\n    track?: VideoTrack | AudioTrack | TextTrack;\n}\n\ninterface TransitionEventInit extends EventInit {\n    elapsedTime?: number;\n    propertyName?: string;\n}\n\ninterface UIEventInit extends EventInit {\n    detail?: number;\n    view?: Window;\n}\n\ninterface WebAuthnExtensions {\n}\n\ninterface WebGLContextAttributes {\n    failIfMajorPerformanceCaveat?: boolean;\n    alpha?: boolean;\n    antialias?: boolean;\n    depth?: boolean;\n    premultipliedAlpha?: boolean;\n    preserveDrawingBuffer?: boolean;\n    stencil?: boolean;\n}\n\ninterface WebGLContextEventInit extends EventInit {\n    statusMessage?: string;\n}\n\ninterface WheelEventInit extends MouseEventInit {\n    deltaMode?: number;\n    deltaX?: number;\n    deltaY?: number;\n    deltaZ?: number;\n}\n\ninterface EventListener {\n    (evt: Event): void;\n}\n\ninterface WebKitEntriesCallback {\n    (evt: Event): void;\n}\n\ninterface WebKitErrorCallback {\n    (evt: Event): void;\n}\n\ninterface WebKitFileCallback {\n    (evt: Event): void;\n}\n\ninterface AnalyserNode extends AudioNode {\n    fftSize: number;\n    readonly frequencyBinCount: number;\n    maxDecibels: number;\n    minDecibels: number;\n    smoothingTimeConstant: number;\n    getByteFrequencyData(array: Uint8Array): void;\n    getByteTimeDomainData(array: Uint8Array): void;\n    getFloatFrequencyData(array: Float32Array): void;\n    getFloatTimeDomainData(array: Float32Array): void;\n}\n\ndeclare var AnalyserNode: {\n    prototype: AnalyserNode;\n    new(): AnalyserNode;\n};\n\ninterface ANGLE_instanced_arrays {\n    drawArraysInstancedANGLE(mode: number, first: number, count: number, primcount: number): void;\n    drawElementsInstancedANGLE(mode: number, count: number, type: number, offset: number, primcount: number): void;\n    vertexAttribDivisorANGLE(index: number, divisor: number): void;\n    readonly VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: number;\n}\n\ndeclare var ANGLE_instanced_arrays: {\n    prototype: ANGLE_instanced_arrays;\n    new(): ANGLE_instanced_arrays;\n    readonly VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: number;\n};\n\ninterface AnimationEvent extends Event {\n    readonly animationName: string;\n    readonly elapsedTime: number;\n    initAnimationEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, animationNameArg: string, elapsedTimeArg: number): void;\n}\n\ndeclare var AnimationEvent: {\n    prototype: AnimationEvent;\n    new(typeArg: string, eventInitDict?: AnimationEventInit): AnimationEvent;\n};\n\ninterface ApplicationCacheEventMap {\n    \"cached\": Event;\n    \"checking\": Event;\n    \"downloading\": Event;\n    \"error\": Event;\n    \"noupdate\": Event;\n    \"obsolete\": Event;\n    \"progress\": ProgressEvent;\n    \"updateready\": Event;\n}\n\ninterface ApplicationCache extends EventTarget {\n    oncached: (this: ApplicationCache, ev: Event) => any;\n    onchecking: (this: ApplicationCache, ev: Event) => any;\n    ondownloading: (this: ApplicationCache, ev: Event) => any;\n    onerror: (this: ApplicationCache, ev: Event) => any;\n    onnoupdate: (this: ApplicationCache, ev: Event) => any;\n    onobsolete: (this: ApplicationCache, ev: Event) => any;\n    onprogress: (this: ApplicationCache, ev: ProgressEvent) => any;\n    onupdateready: (this: ApplicationCache, ev: Event) => any;\n    readonly status: number;\n    abort(): void;\n    swapCache(): void;\n    update(): void;\n    readonly CHECKING: number;\n    readonly DOWNLOADING: number;\n    readonly IDLE: number;\n    readonly OBSOLETE: number;\n    readonly UNCACHED: number;\n    readonly UPDATEREADY: number;\n    addEventListener<K extends keyof ApplicationCacheEventMap>(type: K, listener: (this: ApplicationCache, ev: ApplicationCacheEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var ApplicationCache: {\n    prototype: ApplicationCache;\n    new(): ApplicationCache;\n    readonly CHECKING: number;\n    readonly DOWNLOADING: number;\n    readonly IDLE: number;\n    readonly OBSOLETE: number;\n    readonly UNCACHED: number;\n    readonly UPDATEREADY: number;\n};\n\ninterface Attr extends Node {\n    readonly name: string;\n    readonly ownerElement: Element;\n    readonly prefix: string | null;\n    readonly specified: boolean;\n    value: string;\n}\n\ndeclare var Attr: {\n    prototype: Attr;\n    new(): Attr;\n};\n\ninterface AudioBuffer {\n    readonly duration: number;\n    readonly length: number;\n    readonly numberOfChannels: number;\n    readonly sampleRate: number;\n    copyFromChannel(destination: Float32Array, channelNumber: number, startInChannel?: number): void;\n    copyToChannel(source: Float32Array, channelNumber: number, startInChannel?: number): void;\n    getChannelData(channel: number): Float32Array;\n}\n\ndeclare var AudioBuffer: {\n    prototype: AudioBuffer;\n    new(): AudioBuffer;\n};\n\ninterface AudioBufferSourceNodeEventMap {\n    \"ended\": MediaStreamErrorEvent;\n}\n\ninterface AudioBufferSourceNode extends AudioNode {\n    buffer: AudioBuffer | null;\n    readonly detune: AudioParam;\n    loop: boolean;\n    loopEnd: number;\n    loopStart: number;\n    onended: (this: AudioBufferSourceNode, ev: MediaStreamErrorEvent) => any;\n    readonly playbackRate: AudioParam;\n    start(when?: number, offset?: number, duration?: number): void;\n    stop(when?: number): void;\n    addEventListener<K extends keyof AudioBufferSourceNodeEventMap>(type: K, listener: (this: AudioBufferSourceNode, ev: AudioBufferSourceNodeEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var AudioBufferSourceNode: {\n    prototype: AudioBufferSourceNode;\n    new(): AudioBufferSourceNode;\n};\n\ninterface AudioContextEventMap {\n    \"statechange\": Event;\n}\n\ninterface AudioContextBase extends EventTarget {\n    readonly currentTime: number;\n    readonly destination: AudioDestinationNode;\n    readonly listener: AudioListener;\n    onstatechange: (this: AudioContext, ev: Event) => any;\n    readonly sampleRate: number;\n    readonly state: AudioContextState;\n    close(): Promise<void>;\n    createAnalyser(): AnalyserNode;\n    createBiquadFilter(): BiquadFilterNode;\n    createBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer;\n    createBufferSource(): AudioBufferSourceNode;\n    createChannelMerger(numberOfInputs?: number): ChannelMergerNode;\n    createChannelSplitter(numberOfOutputs?: number): ChannelSplitterNode;\n    createConvolver(): ConvolverNode;\n    createDelay(maxDelayTime?: number): DelayNode;\n    createDynamicsCompressor(): DynamicsCompressorNode;\n    createGain(): GainNode;\n    createIIRFilter(feedforward: number[], feedback: number[]): IIRFilterNode;\n    createMediaElementSource(mediaElement: HTMLMediaElement): MediaElementAudioSourceNode;\n    createMediaStreamSource(mediaStream: MediaStream): MediaStreamAudioSourceNode;\n    createOscillator(): OscillatorNode;\n    createPanner(): PannerNode;\n    createPeriodicWave(real: Float32Array, imag: Float32Array, constraints?: PeriodicWaveConstraints): PeriodicWave;\n    createScriptProcessor(bufferSize?: number, numberOfInputChannels?: number, numberOfOutputChannels?: number): ScriptProcessorNode;\n    createStereoPanner(): StereoPannerNode;\n    createWaveShaper(): WaveShaperNode;\n    decodeAudioData(audioData: ArrayBuffer, successCallback?: DecodeSuccessCallback, errorCallback?: DecodeErrorCallback): Promise<AudioBuffer>;\n    resume(): Promise<void>;\n    addEventListener<K extends keyof AudioContextEventMap>(type: K, listener: (this: AudioContext, ev: AudioContextEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ninterface AudioContext extends AudioContextBase {\n    suspend(): Promise<void>;\n}\n\ndeclare var AudioContext: {\n    prototype: AudioContext;\n    new(): AudioContext;\n};\n\ninterface AudioDestinationNode extends AudioNode {\n    readonly maxChannelCount: number;\n}\n\ndeclare var AudioDestinationNode: {\n    prototype: AudioDestinationNode;\n    new(): AudioDestinationNode;\n};\n\ninterface AudioListener {\n    dopplerFactor: number;\n    speedOfSound: number;\n    setOrientation(x: number, y: number, z: number, xUp: number, yUp: number, zUp: number): void;\n    setPosition(x: number, y: number, z: number): void;\n    setVelocity(x: number, y: number, z: number): void;\n}\n\ndeclare var AudioListener: {\n    prototype: AudioListener;\n    new(): AudioListener;\n};\n\ninterface AudioNode extends EventTarget {\n    channelCount: number;\n    channelCountMode: ChannelCountMode;\n    channelInterpretation: ChannelInterpretation;\n    readonly context: AudioContext;\n    readonly numberOfInputs: number;\n    readonly numberOfOutputs: number;\n    connect(destination: AudioNode, output?: number, input?: number): AudioNode;\n    connect(destination: AudioParam, output?: number): void;\n    disconnect(output?: number): void;\n    disconnect(destination: AudioNode, output?: number, input?: number): void;\n    disconnect(destination: AudioParam, output?: number): void;\n}\n\ndeclare var AudioNode: {\n    prototype: AudioNode;\n    new(): AudioNode;\n};\n\ninterface AudioParam {\n    readonly defaultValue: number;\n    value: number;\n    cancelScheduledValues(startTime: number): AudioParam;\n    exponentialRampToValueAtTime(value: number, endTime: number): AudioParam;\n    linearRampToValueAtTime(value: number, endTime: number): AudioParam;\n    setTargetAtTime(target: number, startTime: number, timeConstant: number): AudioParam;\n    setValueAtTime(value: number, startTime: number): AudioParam;\n    setValueCurveAtTime(values: Float32Array, startTime: number, duration: number): AudioParam;\n}\n\ndeclare var AudioParam: {\n    prototype: AudioParam;\n    new(): AudioParam;\n};\n\ninterface AudioProcessingEvent extends Event {\n    readonly inputBuffer: AudioBuffer;\n    readonly outputBuffer: AudioBuffer;\n    readonly playbackTime: number;\n}\n\ndeclare var AudioProcessingEvent: {\n    prototype: AudioProcessingEvent;\n    new(): AudioProcessingEvent;\n};\n\ninterface AudioTrack {\n    enabled: boolean;\n    readonly id: string;\n    kind: string;\n    readonly label: string;\n    language: string;\n    readonly sourceBuffer: SourceBuffer;\n}\n\ndeclare var AudioTrack: {\n    prototype: AudioTrack;\n    new(): AudioTrack;\n};\n\ninterface AudioTrackListEventMap {\n    \"addtrack\": TrackEvent;\n    \"change\": Event;\n    \"removetrack\": TrackEvent;\n}\n\ninterface AudioTrackList extends EventTarget {\n    readonly length: number;\n    onaddtrack: (this: AudioTrackList, ev: TrackEvent) => any;\n    onchange: (this: AudioTrackList, ev: Event) => any;\n    onremovetrack: (this: AudioTrackList, ev: TrackEvent) => any;\n    getTrackById(id: string): AudioTrack | null;\n    item(index: number): AudioTrack;\n    addEventListener<K extends keyof AudioTrackListEventMap>(type: K, listener: (this: AudioTrackList, ev: AudioTrackListEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n    [index: number]: AudioTrack;\n}\n\ndeclare var AudioTrackList: {\n    prototype: AudioTrackList;\n    new(): AudioTrackList;\n};\n\ninterface BarProp {\n    readonly visible: boolean;\n}\n\ndeclare var BarProp: {\n    prototype: BarProp;\n    new(): BarProp;\n};\n\ninterface BeforeUnloadEvent extends Event {\n    returnValue: any;\n}\n\ndeclare var BeforeUnloadEvent: {\n    prototype: BeforeUnloadEvent;\n    new(): BeforeUnloadEvent;\n};\n\ninterface BiquadFilterNode extends AudioNode {\n    readonly detune: AudioParam;\n    readonly frequency: AudioParam;\n    readonly gain: AudioParam;\n    readonly Q: AudioParam;\n    type: BiquadFilterType;\n    getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void;\n}\n\ndeclare var BiquadFilterNode: {\n    prototype: BiquadFilterNode;\n    new(): BiquadFilterNode;\n};\n\ninterface Blob {\n    readonly size: number;\n    readonly type: string;\n    msClose(): void;\n    msDetachStream(): any;\n    slice(start?: number, end?: number, contentType?: string): Blob;\n}\n\ndeclare var Blob: {\n    prototype: Blob;\n    new (blobParts?: any[], options?: BlobPropertyBag): Blob;\n};\n\ninterface Cache {\n    add(request: RequestInfo): Promise<void>;\n    addAll(requests: RequestInfo[]): Promise<void>;\n    delete(request: RequestInfo, options?: CacheQueryOptions): Promise<boolean>;\n    keys(request?: RequestInfo, options?: CacheQueryOptions): any;\n    match(request: RequestInfo, options?: CacheQueryOptions): Promise<Response>;\n    matchAll(request?: RequestInfo, options?: CacheQueryOptions): any;\n    put(request: RequestInfo, response: Response): Promise<void>;\n}\n\ndeclare var Cache: {\n    prototype: Cache;\n    new(): Cache;\n};\n\ninterface CacheStorage {\n    delete(cacheName: string): Promise<boolean>;\n    has(cacheName: string): Promise<boolean>;\n    keys(): any;\n    match(request: RequestInfo, options?: CacheQueryOptions): Promise<any>;\n    open(cacheName: string): Promise<Cache>;\n}\n\ndeclare var CacheStorage: {\n    prototype: CacheStorage;\n    new(): CacheStorage;\n};\n\ninterface CanvasGradient {\n    addColorStop(offset: number, color: string): void;\n}\n\ndeclare var CanvasGradient: {\n    prototype: CanvasGradient;\n    new(): CanvasGradient;\n};\n\ninterface CanvasPattern {\n    setTransform(matrix: SVGMatrix): void;\n}\n\ndeclare var CanvasPattern: {\n    prototype: CanvasPattern;\n    new(): CanvasPattern;\n};\n\ninterface CanvasRenderingContext2D extends Object, CanvasPathMethods {\n    readonly canvas: HTMLCanvasElement;\n    fillStyle: string | CanvasGradient | CanvasPattern;\n    font: string;\n    globalAlpha: number;\n    globalCompositeOperation: string;\n    imageSmoothingEnabled: boolean;\n    lineCap: string;\n    lineDashOffset: number;\n    lineJoin: string;\n    lineWidth: number;\n    miterLimit: number;\n    msFillRule: CanvasFillRule;\n    shadowBlur: number;\n    shadowColor: string;\n    shadowOffsetX: number;\n    shadowOffsetY: number;\n    strokeStyle: string | CanvasGradient | CanvasPattern;\n    textAlign: string;\n    textBaseline: string;\n    mozImageSmoothingEnabled: boolean;\n    webkitImageSmoothingEnabled: boolean;\n    oImageSmoothingEnabled: boolean;\n    beginPath(): void;\n    clearRect(x: number, y: number, w: number, h: number): void;\n    clip(fillRule?: CanvasFillRule): void;\n    createImageData(imageDataOrSw: number | ImageData, sh?: number): ImageData;\n    createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;\n    createPattern(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, repetition: string): CanvasPattern;\n    createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;\n    drawFocusIfNeeded(element: Element): void;\n    drawImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, dstX: number, dstY: number): void;\n    drawImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, dstX: number, dstY: number, dstW: number, dstH: number): void;\n    drawImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, srcX: number, srcY: number, srcW: number, srcH: number, dstX: number, dstY: number, dstW: number, dstH: number): void;\n    fill(fillRule?: CanvasFillRule): void;\n    fillRect(x: number, y: number, w: number, h: number): void;\n    fillText(text: string, x: number, y: number, maxWidth?: number): void;\n    getImageData(sx: number, sy: number, sw: number, sh: number): ImageData;\n    getLineDash(): number[];\n    isPointInPath(x: number, y: number, fillRule?: CanvasFillRule): boolean;\n    measureText(text: string): TextMetrics;\n    putImageData(imagedata: ImageData, dx: number, dy: number, dirtyX?: number, dirtyY?: number, dirtyWidth?: number, dirtyHeight?: number): void;\n    restore(): void;\n    rotate(angle: number): void;\n    save(): void;\n    scale(x: number, y: number): void;\n    setLineDash(segments: number[]): void;\n    setTransform(m11: number, m12: number, m21: number, m22: number, dx: number, dy: number): void;\n    stroke(path?: Path2D): void;\n    strokeRect(x: number, y: number, w: number, h: number): void;\n    strokeText(text: string, x: number, y: number, maxWidth?: number): void;\n    transform(m11: number, m12: number, m21: number, m22: number, dx: number, dy: number): void;\n    translate(x: number, y: number): void;\n}\n\ndeclare var CanvasRenderingContext2D: {\n    prototype: CanvasRenderingContext2D;\n    new(): CanvasRenderingContext2D;\n};\n\ninterface CDATASection extends Text {\n}\n\ndeclare var CDATASection: {\n    prototype: CDATASection;\n    new(): CDATASection;\n};\n\ninterface ChannelMergerNode extends AudioNode {\n}\n\ndeclare var ChannelMergerNode: {\n    prototype: ChannelMergerNode;\n    new(): ChannelMergerNode;\n};\n\ninterface ChannelSplitterNode extends AudioNode {\n}\n\ndeclare var ChannelSplitterNode: {\n    prototype: ChannelSplitterNode;\n    new(): ChannelSplitterNode;\n};\n\ninterface CharacterData extends Node, ChildNode {\n    data: string;\n    readonly length: number;\n    appendData(arg: string): void;\n    deleteData(offset: number, count: number): void;\n    insertData(offset: number, arg: string): void;\n    replaceData(offset: number, count: number, arg: string): void;\n    substringData(offset: number, count: number): string;\n}\n\ndeclare var CharacterData: {\n    prototype: CharacterData;\n    new(): CharacterData;\n};\n\ninterface ClientRect {\n    bottom: number;\n    readonly height: number;\n    left: number;\n    right: number;\n    top: number;\n    readonly width: number;\n}\n\ndeclare var ClientRect: {\n    prototype: ClientRect;\n    new(): ClientRect;\n};\n\ninterface ClientRectList {\n    readonly length: number;\n    item(index: number): ClientRect;\n    [index: number]: ClientRect;\n}\n\ndeclare var ClientRectList: {\n    prototype: ClientRectList;\n    new(): ClientRectList;\n};\n\ninterface ClipboardEvent extends Event {\n    readonly clipboardData: DataTransfer;\n}\n\ndeclare var ClipboardEvent: {\n    prototype: ClipboardEvent;\n    new(type: string, eventInitDict?: ClipboardEventInit): ClipboardEvent;\n};\n\ninterface CloseEvent extends Event {\n    readonly code: number;\n    readonly reason: string;\n    readonly wasClean: boolean;\n    initCloseEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, wasCleanArg: boolean, codeArg: number, reasonArg: string): void;\n}\n\ndeclare var CloseEvent: {\n    prototype: CloseEvent;\n    new(typeArg: string, eventInitDict?: CloseEventInit): CloseEvent;\n};\n\ninterface Comment extends CharacterData {\n    text: string;\n}\n\ndeclare var Comment: {\n    prototype: Comment;\n    new(): Comment;\n};\n\ninterface CompositionEvent extends UIEvent {\n    readonly data: string;\n    readonly locale: string;\n    initCompositionEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, dataArg: string, locale: string): void;\n}\n\ndeclare var CompositionEvent: {\n    prototype: CompositionEvent;\n    new(typeArg: string, eventInitDict?: CompositionEventInit): CompositionEvent;\n};\n\ninterface Console {\n    assert(test?: boolean, message?: string, ...optionalParams: any[]): void;\n    clear(): void;\n    count(countTitle?: string): void;\n    debug(message?: any, ...optionalParams: any[]): void;\n    dir(value?: any, ...optionalParams: any[]): void;\n    dirxml(value: any): void;\n    error(message?: any, ...optionalParams: any[]): void;\n    exception(message?: string, ...optionalParams: any[]): void;\n    group(groupTitle?: string, ...optionalParams: any[]): void;\n    groupCollapsed(groupTitle?: string, ...optionalParams: any[]): void;\n    groupEnd(): void;\n    info(message?: any, ...optionalParams: any[]): void;\n    log(message?: any, ...optionalParams: any[]): void;\n    msIsIndependentlyComposed(element: Element): boolean;\n    profile(reportName?: string): void;\n    profileEnd(): void;\n    select(element: Element): void;\n    table(...data: any[]): void;\n    time(timerName?: string): void;\n    timeEnd(timerName?: string): void;\n    trace(message?: any, ...optionalParams: any[]): void;\n    warn(message?: any, ...optionalParams: any[]): void;\n}\n\ndeclare var Console: {\n    prototype: Console;\n    new(): Console;\n};\n\ninterface ConvolverNode extends AudioNode {\n    buffer: AudioBuffer | null;\n    normalize: boolean;\n}\n\ndeclare var ConvolverNode: {\n    prototype: ConvolverNode;\n    new(): ConvolverNode;\n};\n\ninterface Coordinates {\n    readonly accuracy: number;\n    readonly altitude: number | null;\n    readonly altitudeAccuracy: number | null;\n    readonly heading: number | null;\n    readonly latitude: number;\n    readonly longitude: number;\n    readonly speed: number | null;\n}\n\ndeclare var Coordinates: {\n    prototype: Coordinates;\n    new(): Coordinates;\n};\n\ninterface Crypto extends Object, RandomSource {\n    readonly subtle: SubtleCrypto;\n}\n\ndeclare var Crypto: {\n    prototype: Crypto;\n    new(): Crypto;\n};\n\ninterface CryptoKey {\n    readonly algorithm: KeyAlgorithm;\n    readonly extractable: boolean;\n    readonly type: string;\n    readonly usages: string[];\n}\n\ndeclare var CryptoKey: {\n    prototype: CryptoKey;\n    new(): CryptoKey;\n};\n\ninterface CryptoKeyPair {\n    privateKey: CryptoKey;\n    publicKey: CryptoKey;\n}\n\ndeclare var CryptoKeyPair: {\n    prototype: CryptoKeyPair;\n    new(): CryptoKeyPair;\n};\n\ninterface CSS {\n    supports(property: string, value?: string): boolean;\n}\ndeclare var CSS: CSS;\n\ninterface CSSConditionRule extends CSSGroupingRule {\n    conditionText: string;\n}\n\ndeclare var CSSConditionRule: {\n    prototype: CSSConditionRule;\n    new(): CSSConditionRule;\n};\n\ninterface CSSFontFaceRule extends CSSRule {\n    readonly style: CSSStyleDeclaration;\n}\n\ndeclare var CSSFontFaceRule: {\n    prototype: CSSFontFaceRule;\n    new(): CSSFontFaceRule;\n};\n\ninterface CSSGroupingRule extends CSSRule {\n    readonly cssRules: CSSRuleList;\n    deleteRule(index: number): void;\n    insertRule(rule: string, index: number): number;\n}\n\ndeclare var CSSGroupingRule: {\n    prototype: CSSGroupingRule;\n    new(): CSSGroupingRule;\n};\n\ninterface CSSImportRule extends CSSRule {\n    readonly href: string;\n    readonly media: MediaList;\n    readonly styleSheet: CSSStyleSheet;\n}\n\ndeclare var CSSImportRule: {\n    prototype: CSSImportRule;\n    new(): CSSImportRule;\n};\n\ninterface CSSKeyframeRule extends CSSRule {\n    keyText: string;\n    readonly style: CSSStyleDeclaration;\n}\n\ndeclare var CSSKeyframeRule: {\n    prototype: CSSKeyframeRule;\n    new(): CSSKeyframeRule;\n};\n\ninterface CSSKeyframesRule extends CSSRule {\n    readonly cssRules: CSSRuleList;\n    name: string;\n    appendRule(rule: string): void;\n    deleteRule(rule: string): void;\n    findRule(rule: string): CSSKeyframeRule;\n}\n\ndeclare var CSSKeyframesRule: {\n    prototype: CSSKeyframesRule;\n    new(): CSSKeyframesRule;\n};\n\ninterface CSSMediaRule extends CSSConditionRule {\n    readonly media: MediaList;\n}\n\ndeclare var CSSMediaRule: {\n    prototype: CSSMediaRule;\n    new(): CSSMediaRule;\n};\n\ninterface CSSNamespaceRule extends CSSRule {\n    readonly namespaceURI: string;\n    readonly prefix: string;\n}\n\ndeclare var CSSNamespaceRule: {\n    prototype: CSSNamespaceRule;\n    new(): CSSNamespaceRule;\n};\n\ninterface CSSPageRule extends CSSRule {\n    readonly pseudoClass: string;\n    readonly selector: string;\n    selectorText: string;\n    readonly style: CSSStyleDeclaration;\n}\n\ndeclare var CSSPageRule: {\n    prototype: CSSPageRule;\n    new(): CSSPageRule;\n};\n\ninterface CSSRule {\n    cssText: string;\n    readonly parentRule: CSSRule;\n    readonly parentStyleSheet: CSSStyleSheet;\n    readonly type: number;\n    readonly CHARSET_RULE: number;\n    readonly FONT_FACE_RULE: number;\n    readonly IMPORT_RULE: number;\n    readonly KEYFRAME_RULE: number;\n    readonly KEYFRAMES_RULE: number;\n    readonly MEDIA_RULE: number;\n    readonly NAMESPACE_RULE: number;\n    readonly PAGE_RULE: number;\n    readonly STYLE_RULE: number;\n    readonly SUPPORTS_RULE: number;\n    readonly UNKNOWN_RULE: number;\n    readonly VIEWPORT_RULE: number;\n}\n\ndeclare var CSSRule: {\n    prototype: CSSRule;\n    new(): CSSRule;\n    readonly CHARSET_RULE: number;\n    readonly FONT_FACE_RULE: number;\n    readonly IMPORT_RULE: number;\n    readonly KEYFRAME_RULE: number;\n    readonly KEYFRAMES_RULE: number;\n    readonly MEDIA_RULE: number;\n    readonly NAMESPACE_RULE: number;\n    readonly PAGE_RULE: number;\n    readonly STYLE_RULE: number;\n    readonly SUPPORTS_RULE: number;\n    readonly UNKNOWN_RULE: number;\n    readonly VIEWPORT_RULE: number;\n};\n\ninterface CSSRuleList {\n    readonly length: number;\n    item(index: number): CSSRule;\n    [index: number]: CSSRule;\n}\n\ndeclare var CSSRuleList: {\n    prototype: CSSRuleList;\n    new(): CSSRuleList;\n};\n\ninterface CSSStyleDeclaration {\n    alignContent: string | null;\n    alignItems: string | null;\n    alignmentBaseline: string | null;\n    alignSelf: string | null;\n    animation: string | null;\n    animationDelay: string | null;\n    animationDirection: string | null;\n    animationDuration: string | null;\n    animationFillMode: string | null;\n    animationIterationCount: string | null;\n    animationName: string | null;\n    animationPlayState: string | null;\n    animationTimingFunction: string | null;\n    backfaceVisibility: string | null;\n    background: string | null;\n    backgroundAttachment: string | null;\n    backgroundClip: string | null;\n    backgroundColor: string | null;\n    backgroundImage: string | null;\n    backgroundOrigin: string | null;\n    backgroundPosition: string | null;\n    backgroundPositionX: string | null;\n    backgroundPositionY: string | null;\n    backgroundRepeat: string | null;\n    backgroundSize: string | null;\n    baselineShift: string | null;\n    border: string | null;\n    borderBottom: string | null;\n    borderBottomColor: string | null;\n    borderBottomLeftRadius: string | null;\n    borderBottomRightRadius: string | null;\n    borderBottomStyle: string | null;\n    borderBottomWidth: string | null;\n    borderCollapse: string | null;\n    borderColor: string | null;\n    borderImage: string | null;\n    borderImageOutset: string | null;\n    borderImageRepeat: string | null;\n    borderImageSlice: string | null;\n    borderImageSource: string | null;\n    borderImageWidth: string | null;\n    borderLeft: string | null;\n    borderLeftColor: string | null;\n    borderLeftStyle: string | null;\n    borderLeftWidth: string | null;\n    borderRadius: string | null;\n    borderRight: string | null;\n    borderRightColor: string | null;\n    borderRightStyle: string | null;\n    borderRightWidth: string | null;\n    borderSpacing: string | null;\n    borderStyle: string | null;\n    borderTop: string | null;\n    borderTopColor: string | null;\n    borderTopLeftRadius: string | null;\n    borderTopRightRadius: string | null;\n    borderTopStyle: string | null;\n    borderTopWidth: string | null;\n    borderWidth: string | null;\n    bottom: string | null;\n    boxShadow: string | null;\n    boxSizing: string | null;\n    breakAfter: string | null;\n    breakBefore: string | null;\n    breakInside: string | null;\n    captionSide: string | null;\n    clear: string | null;\n    clip: string | null;\n    clipPath: string | null;\n    clipRule: string | null;\n    color: string | null;\n    colorInterpolationFilters: string | null;\n    columnCount: any;\n    columnFill: string | null;\n    columnGap: any;\n    columnRule: string | null;\n    columnRuleColor: any;\n    columnRuleStyle: string | null;\n    columnRuleWidth: any;\n    columns: string | null;\n    columnSpan: string | null;\n    columnWidth: any;\n    content: string | null;\n    counterIncrement: string | null;\n    counterReset: string | null;\n    cssFloat: string | null;\n    cssText: string;\n    cursor: string | null;\n    direction: string | null;\n    display: string | null;\n    dominantBaseline: string | null;\n    emptyCells: string | null;\n    enableBackground: string | null;\n    fill: string | null;\n    fillOpacity: string | null;\n    fillRule: string | null;\n    filter: string | null;\n    flex: string | null;\n    flexBasis: string | null;\n    flexDirection: string | null;\n    flexFlow: string | null;\n    flexGrow: string | null;\n    flexShrink: string | null;\n    flexWrap: string | null;\n    floodColor: string | null;\n    floodOpacity: string | null;\n    font: string | null;\n    fontFamily: string | null;\n    fontFeatureSettings: string | null;\n    fontSize: string | null;\n    fontSizeAdjust: string | null;\n    fontStretch: string | null;\n    fontStyle: string | null;\n    fontVariant: string | null;\n    fontWeight: string | null;\n    glyphOrientationHorizontal: string | null;\n    glyphOrientationVertical: string | null;\n    height: string | null;\n    imeMode: string | null;\n    justifyContent: string | null;\n    kerning: string | null;\n    layoutGrid: string | null;\n    layoutGridChar: string | null;\n    layoutGridLine: string | null;\n    layoutGridMode: string | null;\n    layoutGridType: string | null;\n    left: string | null;\n    readonly length: number;\n    letterSpacing: string | null;\n    lightingColor: string | null;\n    lineBreak: string | null;\n    lineHeight: string | null;\n    listStyle: string | null;\n    listStyleImage: string | null;\n    listStylePosition: string | null;\n    listStyleType: string | null;\n    margin: string | null;\n    marginBottom: string | null;\n    marginLeft: string | null;\n    marginRight: string | null;\n    marginTop: string | null;\n    marker: string | null;\n    markerEnd: string | null;\n    markerMid: string | null;\n    markerStart: string | null;\n    mask: string | null;\n    maxHeight: string | null;\n    maxWidth: string | null;\n    minHeight: string | null;\n    minWidth: string | null;\n    msContentZoomChaining: string | null;\n    msContentZooming: string | null;\n    msContentZoomLimit: string | null;\n    msContentZoomLimitMax: any;\n    msContentZoomLimitMin: any;\n    msContentZoomSnap: string | null;\n    msContentZoomSnapPoints: string | null;\n    msContentZoomSnapType: string | null;\n    msFlowFrom: string | null;\n    msFlowInto: string | null;\n    msFontFeatureSettings: string | null;\n    msGridColumn: any;\n    msGridColumnAlign: string | null;\n    msGridColumns: string | null;\n    msGridColumnSpan: any;\n    msGridRow: any;\n    msGridRowAlign: string | null;\n    msGridRows: string | null;\n    msGridRowSpan: any;\n    msHighContrastAdjust: string | null;\n    msHyphenateLimitChars: string | null;\n    msHyphenateLimitLines: any;\n    msHyphenateLimitZone: any;\n    msHyphens: string | null;\n    msImeAlign: string | null;\n    msOverflowStyle: string | null;\n    msScrollChaining: string | null;\n    msScrollLimit: string | null;\n    msScrollLimitXMax: any;\n    msScrollLimitXMin: any;\n    msScrollLimitYMax: any;\n    msScrollLimitYMin: any;\n    msScrollRails: string | null;\n    msScrollSnapPointsX: string | null;\n    msScrollSnapPointsY: string | null;\n    msScrollSnapType: string | null;\n    msScrollSnapX: string | null;\n    msScrollSnapY: string | null;\n    msScrollTranslation: string | null;\n    msTextCombineHorizontal: string | null;\n    msTextSizeAdjust: any;\n    msTouchAction: string | null;\n    msTouchSelect: string | null;\n    msUserSelect: string | null;\n    msWrapFlow: string;\n    msWrapMargin: any;\n    msWrapThrough: string;\n    opacity: string | null;\n    order: string | null;\n    orphans: string | null;\n    outline: string | null;\n    outlineColor: string | null;\n    outlineOffset: string | null;\n    outlineStyle: string | null;\n    outlineWidth: string | null;\n    overflow: string | null;\n    overflowX: string | null;\n    overflowY: string | null;\n    padding: string | null;\n    paddingBottom: string | null;\n    paddingLeft: string | null;\n    paddingRight: string | null;\n    paddingTop: string | null;\n    pageBreakAfter: string | null;\n    pageBreakBefore: string | null;\n    pageBreakInside: string | null;\n    readonly parentRule: CSSRule;\n    perspective: string | null;\n    perspectiveOrigin: string | null;\n    pointerEvents: string | null;\n    position: string | null;\n    quotes: string | null;\n    right: string | null;\n    rotate: string | null;\n    rubyAlign: string | null;\n    rubyOverhang: string | null;\n    rubyPosition: string | null;\n    scale: string | null;\n    stopColor: string | null;\n    stopOpacity: string | null;\n    stroke: string | null;\n    strokeDasharray: string | null;\n    strokeDashoffset: string | null;\n    strokeLinecap: string | null;\n    strokeLinejoin: string | null;\n    strokeMiterlimit: string | null;\n    strokeOpacity: string | null;\n    strokeWidth: string | null;\n    tableLayout: string | null;\n    textAlign: string | null;\n    textAlignLast: string | null;\n    textAnchor: string | null;\n    textDecoration: string | null;\n    textIndent: string | null;\n    textJustify: string | null;\n    textKashida: string | null;\n    textKashidaSpace: string | null;\n    textOverflow: string | null;\n    textShadow: string | null;\n    textTransform: string | null;\n    textUnderlinePosition: string | null;\n    top: string | null;\n    touchAction: string | null;\n    transform: string | null;\n    transformOrigin: string | null;\n    transformStyle: string | null;\n    transition: string | null;\n    transitionDelay: string | null;\n    transitionDuration: string | null;\n    transitionProperty: string | null;\n    transitionTimingFunction: string | null;\n    translate: string | null;\n    unicodeBidi: string | null;\n    verticalAlign: string | null;\n    visibility: string | null;\n    webkitAlignContent: string | null;\n    webkitAlignItems: string | null;\n    webkitAlignSelf: string | null;\n    webkitAnimation: string | null;\n    webkitAnimationDelay: string | null;\n    webkitAnimationDirection: string | null;\n    webkitAnimationDuration: string | null;\n    webkitAnimationFillMode: string | null;\n    webkitAnimationIterationCount: string | null;\n    webkitAnimationName: string | null;\n    webkitAnimationPlayState: string | null;\n    webkitAnimationTimingFunction: string | null;\n    webkitAppearance: string | null;\n    webkitBackfaceVisibility: string | null;\n    webkitBackgroundClip: string | null;\n    webkitBackgroundOrigin: string | null;\n    webkitBackgroundSize: string | null;\n    webkitBorderBottomLeftRadius: string | null;\n    webkitBorderBottomRightRadius: string | null;\n    webkitBorderImage: string | null;\n    webkitBorderRadius: string | null;\n    webkitBorderTopLeftRadius: string | null;\n    webkitBorderTopRightRadius: string | null;\n    webkitBoxAlign: string | null;\n    webkitBoxDirection: string | null;\n    webkitBoxFlex: string | null;\n    webkitBoxOrdinalGroup: string | null;\n    webkitBoxOrient: string | null;\n    webkitBoxPack: string | null;\n    webkitBoxSizing: string | null;\n    webkitColumnBreakAfter: string | null;\n    webkitColumnBreakBefore: string | null;\n    webkitColumnBreakInside: string | null;\n    webkitColumnCount: any;\n    webkitColumnGap: any;\n    webkitColumnRule: string | null;\n    webkitColumnRuleColor: any;\n    webkitColumnRuleStyle: string | null;\n    webkitColumnRuleWidth: any;\n    webkitColumns: string | null;\n    webkitColumnSpan: string | null;\n    webkitColumnWidth: any;\n    webkitFilter: string | null;\n    webkitFlex: string | null;\n    webkitFlexBasis: string | null;\n    webkitFlexDirection: string | null;\n    webkitFlexFlow: string | null;\n    webkitFlexGrow: string | null;\n    webkitFlexShrink: string | null;\n    webkitFlexWrap: string | null;\n    webkitJustifyContent: string | null;\n    webkitOrder: string | null;\n    webkitPerspective: string | null;\n    webkitPerspectiveOrigin: string | null;\n    webkitTapHighlightColor: string | null;\n    webkitTextFillColor: string | null;\n    webkitTextSizeAdjust: any;\n    webkitTextStroke: string | null;\n    webkitTextStrokeColor: string | null;\n    webkitTextStrokeWidth: string | null;\n    webkitTransform: string | null;\n    webkitTransformOrigin: string | null;\n    webkitTransformStyle: string | null;\n    webkitTransition: string | null;\n    webkitTransitionDelay: string | null;\n    webkitTransitionDuration: string | null;\n    webkitTransitionProperty: string | null;\n    webkitTransitionTimingFunction: string | null;\n    webkitUserModify: string | null;\n    webkitUserSelect: string | null;\n    webkitWritingMode: string | null;\n    whiteSpace: string | null;\n    widows: string | null;\n    width: string | null;\n    wordBreak: string | null;\n    wordSpacing: string | null;\n    wordWrap: string | null;\n    writingMode: string | null;\n    zIndex: string | null;\n    zoom: string | null;\n    resize: string | null;\n    userSelect: string | null;\n    getPropertyPriority(propertyName: string): string;\n    getPropertyValue(propertyName: string): string;\n    item(index: number): string;\n    removeProperty(propertyName: string): string;\n    setProperty(propertyName: string, value: string | null, priority?: string): void;\n    [index: number]: string;\n}\n\ndeclare var CSSStyleDeclaration: {\n    prototype: CSSStyleDeclaration;\n    new(): CSSStyleDeclaration;\n};\n\ninterface CSSStyleRule extends CSSRule {\n    readonly readOnly: boolean;\n    selectorText: string;\n    readonly style: CSSStyleDeclaration;\n}\n\ndeclare var CSSStyleRule: {\n    prototype: CSSStyleRule;\n    new(): CSSStyleRule;\n};\n\ninterface CSSStyleSheet extends StyleSheet {\n    readonly cssRules: CSSRuleList;\n    cssText: string;\n    readonly id: string;\n    readonly imports: StyleSheetList;\n    readonly isAlternate: boolean;\n    readonly isPrefAlternate: boolean;\n    readonly ownerRule: CSSRule;\n    readonly owningElement: Element;\n    readonly pages: StyleSheetPageList;\n    readonly readOnly: boolean;\n    readonly rules: CSSRuleList;\n    addImport(bstrURL: string, lIndex?: number): number;\n    addPageRule(bstrSelector: string, bstrStyle: string, lIndex?: number): number;\n    addRule(bstrSelector: string, bstrStyle?: string, lIndex?: number): number;\n    deleteRule(index?: number): void;\n    insertRule(rule: string, index?: number): number;\n    removeImport(lIndex: number): void;\n    removeRule(lIndex: number): void;\n}\n\ndeclare var CSSStyleSheet: {\n    prototype: CSSStyleSheet;\n    new(): CSSStyleSheet;\n};\n\ninterface CSSSupportsRule extends CSSConditionRule {\n}\n\ndeclare var CSSSupportsRule: {\n    prototype: CSSSupportsRule;\n    new(): CSSSupportsRule;\n};\n\ninterface CustomEvent extends Event {\n    readonly detail: any;\n    initCustomEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, detailArg: any): void;\n}\n\ndeclare var CustomEvent: {\n    prototype: CustomEvent;\n    new(typeArg: string, eventInitDict?: CustomEventInit): CustomEvent;\n};\n\ninterface DataCue extends TextTrackCue {\n    data: ArrayBuffer;\n    addEventListener<K extends keyof TextTrackCueEventMap>(type: K, listener: (this: DataCue, ev: TextTrackCueEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var DataCue: {\n    prototype: DataCue;\n    new(): DataCue;\n};\n\ninterface DataTransfer {\n    dropEffect: string;\n    effectAllowed: string;\n    readonly files: FileList;\n    readonly items: DataTransferItemList;\n    readonly types: string[];\n    clearData(format?: string): boolean;\n    getData(format: string): string;\n    setData(format: string, data: string): boolean;\n    setDragImage(image: Element, x: number, y: number): void;\n}\n\ndeclare var DataTransfer: {\n    prototype: DataTransfer;\n    new(): DataTransfer;\n};\n\ninterface DataTransferItem {\n    readonly kind: string;\n    readonly type: string;\n    getAsFile(): File | null;\n    getAsString(_callback: FunctionStringCallback | null): void;\n    webkitGetAsEntry(): any;\n}\n\ndeclare var DataTransferItem: {\n    prototype: DataTransferItem;\n    new(): DataTransferItem;\n};\n\ninterface DataTransferItemList {\n    readonly length: number;\n    add(data: File): DataTransferItem | null;\n    clear(): void;\n    item(index: number): DataTransferItem;\n    remove(index: number): void;\n    [index: number]: DataTransferItem;\n}\n\ndeclare var DataTransferItemList: {\n    prototype: DataTransferItemList;\n    new(): DataTransferItemList;\n};\n\ninterface DeferredPermissionRequest {\n    readonly id: number;\n    readonly type: MSWebViewPermissionType;\n    readonly uri: string;\n    allow(): void;\n    deny(): void;\n}\n\ndeclare var DeferredPermissionRequest: {\n    prototype: DeferredPermissionRequest;\n    new(): DeferredPermissionRequest;\n};\n\ninterface DelayNode extends AudioNode {\n    readonly delayTime: AudioParam;\n}\n\ndeclare var DelayNode: {\n    prototype: DelayNode;\n    new(): DelayNode;\n};\n\ninterface DeviceAcceleration {\n    readonly x: number | null;\n    readonly y: number | null;\n    readonly z: number | null;\n}\n\ndeclare var DeviceAcceleration: {\n    prototype: DeviceAcceleration;\n    new(): DeviceAcceleration;\n};\n\ninterface DeviceLightEvent extends Event {\n    readonly value: number;\n}\n\ndeclare var DeviceLightEvent: {\n    prototype: DeviceLightEvent;\n    new(typeArg: string, eventInitDict?: DeviceLightEventInit): DeviceLightEvent;\n};\n\ninterface DeviceMotionEvent extends Event {\n    readonly acceleration: DeviceAcceleration | null;\n    readonly accelerationIncludingGravity: DeviceAcceleration | null;\n    readonly interval: number | null;\n    readonly rotationRate: DeviceRotationRate | null;\n    initDeviceMotionEvent(type: string, bubbles: boolean, cancelable: boolean, acceleration: DeviceAccelerationDict | null, accelerationIncludingGravity: DeviceAccelerationDict | null, rotationRate: DeviceRotationRateDict | null, interval: number | null): void;\n}\n\ndeclare var DeviceMotionEvent: {\n    prototype: DeviceMotionEvent;\n    new(typeArg: string, eventInitDict?: DeviceMotionEventInit): DeviceMotionEvent;\n};\n\ninterface DeviceOrientationEvent extends Event {\n    readonly absolute: boolean;\n    readonly alpha: number | null;\n    readonly beta: number | null;\n    readonly gamma: number | null;\n    initDeviceOrientationEvent(type: string, bubbles: boolean, cancelable: boolean, alpha: number | null, beta: number | null, gamma: number | null, absolute: boolean): void;\n}\n\ndeclare var DeviceOrientationEvent: {\n    prototype: DeviceOrientationEvent;\n    new(typeArg: string, eventInitDict?: DeviceOrientationEventInit): DeviceOrientationEvent;\n};\n\ninterface DeviceRotationRate {\n    readonly alpha: number | null;\n    readonly beta: number | null;\n    readonly gamma: number | null;\n}\n\ndeclare var DeviceRotationRate: {\n    prototype: DeviceRotationRate;\n    new(): DeviceRotationRate;\n};\n\ninterface DocumentEventMap extends GlobalEventHandlersEventMap {\n    \"abort\": UIEvent;\n    \"activate\": UIEvent;\n    \"beforeactivate\": UIEvent;\n    \"beforedeactivate\": UIEvent;\n    \"blur\": FocusEvent;\n    \"canplay\": Event;\n    \"canplaythrough\": Event;\n    \"change\": Event;\n    \"click\": MouseEvent;\n    \"contextmenu\": PointerEvent;\n    \"dblclick\": MouseEvent;\n    \"deactivate\": UIEvent;\n    \"drag\": DragEvent;\n    \"dragend\": DragEvent;\n    \"dragenter\": DragEvent;\n    \"dragleave\": DragEvent;\n    \"dragover\": DragEvent;\n    \"dragstart\": DragEvent;\n    \"drop\": DragEvent;\n    \"durationchange\": Event;\n    \"emptied\": Event;\n    \"ended\": MediaStreamErrorEvent;\n    \"error\": ErrorEvent;\n    \"focus\": FocusEvent;\n    \"fullscreenchange\": Event;\n    \"fullscreenerror\": Event;\n    \"input\": Event;\n    \"invalid\": Event;\n    \"keydown\": KeyboardEvent;\n    \"keypress\": KeyboardEvent;\n    \"keyup\": KeyboardEvent;\n    \"load\": Event;\n    \"loadeddata\": Event;\n    \"loadedmetadata\": Event;\n    \"loadstart\": Event;\n    \"mousedown\": MouseEvent;\n    \"mousemove\": MouseEvent;\n    \"mouseout\": MouseEvent;\n    \"mouseover\": MouseEvent;\n    \"mouseup\": MouseEvent;\n    \"mousewheel\": WheelEvent;\n    \"MSContentZoom\": UIEvent;\n    \"MSGestureChange\": MSGestureEvent;\n    \"MSGestureDoubleTap\": MSGestureEvent;\n    \"MSGestureEnd\": MSGestureEvent;\n    \"MSGestureHold\": MSGestureEvent;\n    \"MSGestureStart\": MSGestureEvent;\n    \"MSGestureTap\": MSGestureEvent;\n    \"MSInertiaStart\": MSGestureEvent;\n    \"MSManipulationStateChanged\": MSManipulationEvent;\n    \"MSPointerCancel\": MSPointerEvent;\n    \"MSPointerDown\": MSPointerEvent;\n    \"MSPointerEnter\": MSPointerEvent;\n    \"MSPointerLeave\": MSPointerEvent;\n    \"MSPointerMove\": MSPointerEvent;\n    \"MSPointerOut\": MSPointerEvent;\n    \"MSPointerOver\": MSPointerEvent;\n    \"MSPointerUp\": MSPointerEvent;\n    \"mssitemodejumplistitemremoved\": MSSiteModeEvent;\n    \"msthumbnailclick\": MSSiteModeEvent;\n    \"pause\": Event;\n    \"play\": Event;\n    \"playing\": Event;\n    \"pointerlockchange\": Event;\n    \"pointerlockerror\": Event;\n    \"progress\": ProgressEvent;\n    \"ratechange\": Event;\n    \"readystatechange\": Event;\n    \"reset\": Event;\n    \"scroll\": UIEvent;\n    \"seeked\": Event;\n    \"seeking\": Event;\n    \"select\": UIEvent;\n    \"selectionchange\": Event;\n    \"selectstart\": Event;\n    \"stalled\": Event;\n    \"stop\": Event;\n    \"submit\": Event;\n    \"suspend\": Event;\n    \"timeupdate\": Event;\n    \"touchcancel\": TouchEvent;\n    \"touchend\": TouchEvent;\n    \"touchmove\": TouchEvent;\n    \"touchstart\": TouchEvent;\n    \"volumechange\": Event;\n    \"waiting\": Event;\n    \"webkitfullscreenchange\": Event;\n    \"webkitfullscreenerror\": Event;\n}\n\ninterface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent, ParentNode, DocumentOrShadowRoot {\n    /**\n     * Gets the object that has the focus when the parent document has focus.\n     */\n    readonly activeElement: Element;\n    /**\n     * Sets or gets the color of all active links in the document.\n     */\n    alinkColor: string;\n    /**\n     * Returns a reference to the collection of elements contained by the object.\n     */\n    readonly all: HTMLAllCollection;\n    /**\n     * Retrieves a collection of all a objects that have a name and/or id property. Objects in this collection are in HTML source order.\n     */\n    anchors: HTMLCollectionOf<HTMLAnchorElement>;\n    /**\n     * Retrieves a collection of all applet objects in the document.\n     */\n    applets: HTMLCollectionOf<HTMLAppletElement>;\n    /**\n     * Deprecated. Sets or retrieves a value that indicates the background color behind the object.\n     */\n    bgColor: string;\n    /**\n     * Specifies the beginning and end of the document body.\n     */\n    body: HTMLElement;\n    readonly characterSet: string;\n    /**\n     * Gets or sets the character set used to encode the object.\n     */\n    charset: string;\n    /**\n     * Gets a value that indicates whether standards-compliant mode is switched on for the object.\n     */\n    readonly compatMode: string;\n    cookie: string;\n    readonly currentScript: HTMLScriptElement | SVGScriptElement;\n    readonly defaultView: Window;\n    /**\n     * Sets or gets a value that indicates whether the document can be edited.\n     */\n    designMode: string;\n    /**\n     * Sets or retrieves a value that indicates the reading order of the object.\n     */\n    dir: string;\n    /**\n     * Gets an object representing the document type declaration associated with the current document.\n     */\n    readonly doctype: DocumentType;\n    /**\n     * Gets a reference to the root node of the document.\n     */\n    documentElement: HTMLElement;\n    /**\n     * Sets or gets the security domain of the document.\n     */\n    domain: string;\n    /**\n     * Retrieves a collection of all embed objects in the document.\n     */\n    embeds: HTMLCollectionOf<HTMLEmbedElement>;\n    /**\n     * Sets or gets the foreground (text) color of the document.\n     */\n    fgColor: string;\n    /**\n     * Retrieves a collection, in source order, of all form objects in the document.\n     */\n    forms: HTMLCollectionOf<HTMLFormElement>;\n    readonly fullscreenElement: Element | null;\n    readonly fullscreenEnabled: boolean;\n    readonly head: HTMLHeadElement;\n    readonly hidden: boolean;\n    /**\n     * Retrieves a collection, in source order, of img objects in the document.\n     */\n    images: HTMLCollectionOf<HTMLImageElement>;\n    /**\n     * Gets the implementation object of the current document.\n     */\n    readonly implementation: DOMImplementation;\n    /**\n     * Returns the character encoding used to create the webpage that is loaded into the document object.\n     */\n    readonly inputEncoding: string | null;\n    /**\n     * Gets the date that the page was last modified, if the page supplies one.\n     */\n    readonly lastModified: string;\n    /**\n     * Sets or gets the color of the document links.\n     */\n    linkColor: string;\n    /**\n     * Retrieves a collection of all a objects that specify the href property and all area objects in the document.\n     */\n    links: HTMLCollectionOf<HTMLAnchorElement | HTMLAreaElement>;\n    /**\n     * Contains information about the current URL.\n     */\n    readonly location: Location;\n    msCapsLockWarningOff: boolean;\n    msCSSOMElementFloatMetrics: boolean;\n    /**\n     * Fires when the user aborts the download.\n     * @param ev The event.\n     */\n    onabort: (this: Document, ev: UIEvent) => any;\n    /**\n     * Fires when the object is set as the active element.\n     * @param ev The event.\n     */\n    onactivate: (this: Document, ev: UIEvent) => any;\n    /**\n     * Fires immediately before the object is set as the active element.\n     * @param ev The event.\n     */\n    onbeforeactivate: (this: Document, ev: UIEvent) => any;\n    /**\n     * Fires immediately before the activeElement is changed from the current object to another object in the parent document.\n     * @param ev The event.\n     */\n    onbeforedeactivate: (this: Document, ev: UIEvent) => any;\n    /**\n     * Fires when the object loses the input focus.\n     * @param ev The focus event.\n     */\n    onblur: (this: Document, ev: FocusEvent) => any;\n    /**\n     * Occurs when playback is possible, but would require further buffering.\n     * @param ev The event.\n     */\n    oncanplay: (this: Document, ev: Event) => any;\n    oncanplaythrough: (this: Document, ev: Event) => any;\n    /**\n     * Fires when the contents of the object or selection have changed.\n     * @param ev The event.\n     */\n    onchange: (this: Document, ev: Event) => any;\n    /**\n     * Fires when the user clicks the left mouse button on the object\n     * @param ev The mouse event.\n     */\n    onclick: (this: Document, ev: MouseEvent) => any;\n    /**\n     * Fires when the user clicks the right mouse button in the client area, opening the context menu.\n     * @param ev The mouse event.\n     */\n    oncontextmenu: (this: Document, ev: PointerEvent) => any;\n    /**\n     * Fires when the user double-clicks the object.\n     * @param ev The mouse event.\n     */\n    ondblclick: (this: Document, ev: MouseEvent) => any;\n    /**\n     * Fires when the activeElement is changed from the current object to another object in the parent document.\n     * @param ev The UI Event\n     */\n    ondeactivate: (this: Document, ev: UIEvent) => any;\n    /**\n     * Fires on the source object continuously during a drag operation.\n     * @param ev The event.\n     */\n    ondrag: (this: Document, ev: DragEvent) => any;\n    /**\n     * Fires on the source object when the user releases the mouse at the close of a drag operation.\n     * @param ev The event.\n     */\n    ondragend: (this: Document, ev: DragEvent) => any;\n    /**\n     * Fires on the target element when the user drags the object to a valid drop target.\n     * @param ev The drag event.\n     */\n    ondragenter: (this: Document, ev: DragEvent) => any;\n    /**\n     * Fires on the target object when the user moves the mouse out of a valid drop target during a drag operation.\n     * @param ev The drag event.\n     */\n    ondragleave: (this: Document, ev: DragEvent) => any;\n    /**\n     * Fires on the target element continuously while the user drags the object over a valid drop target.\n     * @param ev The event.\n     */\n    ondragover: (this: Document, ev: DragEvent) => any;\n    /**\n     * Fires on the source object when the user starts to drag a text selection or selected object.\n     * @param ev The event.\n     */\n    ondragstart: (this: Document, ev: DragEvent) => any;\n    ondrop: (this: Document, ev: DragEvent) => any;\n    /**\n     * Occurs when the duration attribute is updated.\n     * @param ev The event.\n     */\n    ondurationchange: (this: Document, ev: Event) => any;\n    /**\n     * Occurs when the media element is reset to its initial state.\n     * @param ev The event.\n     */\n    onemptied: (this: Document, ev: Event) => any;\n    /**\n     * Occurs when the end of playback is reached.\n     * @param ev The event\n     */\n    onended: (this: Document, ev: MediaStreamErrorEvent) => any;\n    /**\n     * Fires when an error occurs during object loading.\n     * @param ev The event.\n     */\n    onerror: (this: Document, ev: ErrorEvent) => any;\n    /**\n     * Fires when the object receives focus.\n     * @param ev The event.\n     */\n    onfocus: (this: Document, ev: FocusEvent) => any;\n    onfullscreenchange: (this: Document, ev: Event) => any;\n    onfullscreenerror: (this: Document, ev: Event) => any;\n    oninput: (this: Document, ev: Event) => any;\n    oninvalid: (this: Document, ev: Event) => any;\n    /**\n     * Fires when the user presses a key.\n     * @param ev The keyboard event\n     */\n    onkeydown: (this: Document, ev: KeyboardEvent) => any;\n    /**\n     * Fires when the user presses an alphanumeric key.\n     * @param ev The event.\n     */\n    onkeypress: (this: Document, ev: KeyboardEvent) => any;\n    /**\n     * Fires when the user releases a key.\n     * @param ev The keyboard event\n     */\n    onkeyup: (this: Document, ev: KeyboardEvent) => any;\n    /**\n     * Fires immediately after the browser loads the object.\n     * @param ev The event.\n     */\n    onload: (this: Document, ev: Event) => any;\n    /**\n     * Occurs when media data is loaded at the current playback position.\n     * @param ev The event.\n     */\n    onloadeddata: (this: Document, ev: Event) => any;\n    /**\n     * Occurs when the duration and dimensions of the media have been determined.\n     * @param ev The event.\n     */\n    onloadedmetadata: (this: Document, ev: Event) => any;\n    /**\n     * Occurs when Internet Explorer begins looking for media data.\n     * @param ev The event.\n     */\n    onloadstart: (this: Document, ev: Event) => any;\n    /**\n     * Fires when the user clicks the object with either mouse button.\n     * @param ev The mouse event.\n     */\n    onmousedown: (this: Document, ev: MouseEvent) => any;\n    /**\n     * Fires when the user moves the mouse over the object.\n     * @param ev The mouse event.\n     */\n    onmousemove: (this: Document, ev: MouseEvent) => any;\n    /**\n     * Fires when the user moves the mouse pointer outside the boundaries of the object.\n     * @param ev The mouse event.\n     */\n    onmouseout: (this: Document, ev: MouseEvent) => any;\n    /**\n     * Fires when the user moves the mouse pointer into the object.\n     * @param ev The mouse event.\n     */\n    onmouseover: (this: Document, ev: MouseEvent) => any;\n    /**\n     * Fires when the user releases a mouse button while the mouse is over the object.\n     * @param ev The mouse event.\n     */\n    onmouseup: (this: Document, ev: MouseEvent) => any;\n    /**\n     * Fires when the wheel button is rotated.\n     * @param ev The mouse event\n     */\n    onmousewheel: (this: Document, ev: WheelEvent) => any;\n    onmscontentzoom: (this: Document, ev: UIEvent) => any;\n    onmsgesturechange: (this: Document, ev: MSGestureEvent) => any;\n    onmsgesturedoubletap: (this: Document, ev: MSGestureEvent) => any;\n    onmsgestureend: (this: Document, ev: MSGestureEvent) => any;\n    onmsgesturehold: (this: Document, ev: MSGestureEvent) => any;\n    onmsgesturestart: (this: Document, ev: MSGestureEvent) => any;\n    onmsgesturetap: (this: Document, ev: MSGestureEvent) => any;\n    onmsinertiastart: (this: Document, ev: MSGestureEvent) => any;\n    onmsmanipulationstatechanged: (this: Document, ev: MSManipulationEvent) => any;\n    onmspointercancel: (this: Document, ev: MSPointerEvent) => any;\n    onmspointerdown: (this: Document, ev: MSPointerEvent) => any;\n    onmspointerenter: (this: Document, ev: MSPointerEvent) => any;\n    onmspointerleave: (this: Document, ev: MSPointerEvent) => any;\n    onmspointermove: (this: Document, ev: MSPointerEvent) => any;\n    onmspointerout: (this: Document, ev: MSPointerEvent) => any;\n    onmspointerover: (this: Document, ev: MSPointerEvent) => any;\n    onmspointerup: (this: Document, ev: MSPointerEvent) => any;\n    /**\n     * Occurs when an item is removed from a Jump List of a webpage running in Site Mode.\n     * @param ev The event.\n     */\n    onmssitemodejumplistitemremoved: (this: Document, ev: MSSiteModeEvent) => any;\n    /**\n     * Occurs when a user clicks a button in a Thumbnail Toolbar of a webpage running in Site Mode.\n     * @param ev The event.\n     */\n    onmsthumbnailclick: (this: Document, ev: MSSiteModeEvent) => any;\n    /**\n     * Occurs when playback is paused.\n     * @param ev The event.\n     */\n    onpause: (this: Document, ev: Event) => any;\n    /**\n     * Occurs when the play method is requested.\n     * @param ev The event.\n     */\n    onplay: (this: Document, ev: Event) => any;\n    /**\n     * Occurs when the audio or video has started playing.\n     * @param ev The event.\n     */\n    onplaying: (this: Document, ev: Event) => any;\n    onpointerlockchange: (this: Document, ev: Event) => any;\n    onpointerlockerror: (this: Document, ev: Event) => any;\n    /**\n     * Occurs to indicate progress while downloading media data.\n     * @param ev The event.\n     */\n    onprogress: (this: Document, ev: ProgressEvent) => any;\n    /**\n     * Occurs when the playback rate is increased or decreased.\n     * @param ev The event.\n     */\n    onratechange: (this: Document, ev: Event) => any;\n    /**\n     * Fires when the state of the object has changed.\n     * @param ev The event\n     */\n    onreadystatechange: (this: Document, ev: Event) => any;\n    /**\n     * Fires when the user resets a form.\n     * @param ev The event.\n     */\n    onreset: (this: Document, ev: Event) => any;\n    /**\n     * Fires when the user repositions the scroll box in the scroll bar on the object.\n     * @param ev The event.\n     */\n    onscroll: (this: Document, ev: UIEvent) => any;\n    /**\n     * Occurs when the seek operation ends.\n     * @param ev The event.\n     */\n    onseeked: (this: Document, ev: Event) => any;\n    /**\n     * Occurs when the current playback position is moved.\n     * @param ev The event.\n     */\n    onseeking: (this: Document, ev: Event) => any;\n    /**\n     * Fires when the current selection changes.\n     * @param ev The event.\n     */\n    onselect: (this: Document, ev: UIEvent) => any;\n    /**\n     * Fires when the selection state of a document changes.\n     * @param ev The event.\n     */\n    onselectionchange: (this: Document, ev: Event) => any;\n    onselectstart: (this: Document, ev: Event) => any;\n    /**\n     * Occurs when the download has stopped.\n     * @param ev The event.\n     */\n    onstalled: (this: Document, ev: Event) => any;\n    /**\n     * Fires when the user clicks the Stop button or leaves the Web page.\n     * @param ev The event.\n     */\n    onstop: (this: Document, ev: Event) => any;\n    onsubmit: (this: Document, ev: Event) => any;\n    /**\n     * Occurs if the load operation has been intentionally halted.\n     * @param ev The event.\n     */\n    onsuspend: (this: Document, ev: Event) => any;\n    /**\n     * Occurs to indicate the current playback position.\n     * @param ev The event.\n     */\n    ontimeupdate: (this: Document, ev: Event) => any;\n    ontouchcancel: (ev: TouchEvent) => any;\n    ontouchend: (ev: TouchEvent) => any;\n    ontouchmove: (ev: TouchEvent) => any;\n    ontouchstart: (ev: TouchEvent) => any;\n    /**\n     * Occurs when the volume is changed, or playback is muted or unmuted.\n     * @param ev The event.\n     */\n    onvolumechange: (this: Document, ev: Event) => any;\n    /**\n     * Occurs when playback stops because the next frame of a video resource is not available.\n     * @param ev The event.\n     */\n    onwaiting: (this: Document, ev: Event) => any;\n    onwebkitfullscreenchange: (this: Document, ev: Event) => any;\n    onwebkitfullscreenerror: (this: Document, ev: Event) => any;\n    plugins: HTMLCollectionOf<HTMLEmbedElement>;\n    readonly pointerLockElement: Element;\n    /**\n     * Retrieves a value that indicates the current state of the object.\n     */\n    readonly readyState: string;\n    /**\n     * Gets the URL of the location that referred the user to the current page.\n     */\n    readonly referrer: string;\n    /**\n     * Gets the root svg element in the document hierarchy.\n     */\n    readonly rootElement: SVGSVGElement;\n    /**\n     * Retrieves a collection of all script objects in the document.\n     */\n    scripts: HTMLCollectionOf<HTMLScriptElement>;\n    readonly scrollingElement: Element | null;\n    /**\n     * Retrieves a collection of styleSheet objects representing the style sheets that correspond to each instance of a link or style object in the document.\n     */\n    readonly styleSheets: StyleSheetList;\n    /**\n     * Contains the title of the document.\n     */\n    title: string;\n    /**\n     * Sets or gets the URL for the current document.\n     */\n    readonly URL: string;\n    /**\n     * Gets the URL for the document, stripped of any character encoding.\n     */\n    readonly URLUnencoded: string;\n    readonly visibilityState: VisibilityState;\n    /**\n     * Sets or gets the color of the links that the user has visited.\n     */\n    vlinkColor: string;\n    readonly webkitCurrentFullScreenElement: Element | null;\n    readonly webkitFullscreenElement: Element | null;\n    readonly webkitFullscreenEnabled: boolean;\n    readonly webkitIsFullScreen: boolean;\n    readonly xmlEncoding: string | null;\n    xmlStandalone: boolean;\n    /**\n     * Gets or sets the version attribute specified in the declaration of an XML document.\n     */\n    xmlVersion: string | null;\n    adoptNode<T extends Node>(source: T): T;\n    captureEvents(): void;\n    caretRangeFromPoint(x: number, y: number): Range;\n    clear(): void;\n    /**\n     * Closes an output stream and forces the sent data to display.\n     */\n    close(): void;\n    /**\n     * Creates an attribute object with a specified name.\n     * @param name String that sets the attribute object's name.\n     */\n    createAttribute(name: string): Attr;\n    createAttributeNS(namespaceURI: string | null, qualifiedName: string): Attr;\n    createCDATASection(data: string): CDATASection;\n    /**\n     * Creates a comment object with the specified data.\n     * @param data Sets the comment object's data.\n     */\n    createComment(data: string): Comment;\n    /**\n     * Creates a new document.\n     */\n    createDocumentFragment(): DocumentFragment;\n    /**\n     * Creates an instance of the element for the specified tag.\n     * @param tagName The name of an element.\n     */\n    createElement<K extends keyof HTMLElementTagNameMap>(tagName: K): HTMLElementTagNameMap[K];\n    createElement(tagName: string): HTMLElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/1999/xhtml\", qualifiedName: string): HTMLElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"a\"): SVGAElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"circle\"): SVGCircleElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"clipPath\"): SVGClipPathElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"componentTransferFunction\"): SVGComponentTransferFunctionElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"defs\"): SVGDefsElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"desc\"): SVGDescElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"ellipse\"): SVGEllipseElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feBlend\"): SVGFEBlendElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feColorMatrix\"): SVGFEColorMatrixElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feComponentTransfer\"): SVGFEComponentTransferElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feComposite\"): SVGFECompositeElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feConvolveMatrix\"): SVGFEConvolveMatrixElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feDiffuseLighting\"): SVGFEDiffuseLightingElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feDisplacementMap\"): SVGFEDisplacementMapElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feDistantLight\"): SVGFEDistantLightElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feFlood\"): SVGFEFloodElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feFuncA\"): SVGFEFuncAElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feFuncB\"): SVGFEFuncBElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feFuncG\"): SVGFEFuncGElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feFuncR\"): SVGFEFuncRElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feGaussianBlur\"): SVGFEGaussianBlurElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feImage\"): SVGFEImageElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feMerge\"): SVGFEMergeElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feMergeNode\"): SVGFEMergeNodeElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feMorphology\"): SVGFEMorphologyElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feOffset\"): SVGFEOffsetElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"fePointLight\"): SVGFEPointLightElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feSpecularLighting\"): SVGFESpecularLightingElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feSpotLight\"): SVGFESpotLightElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feTile\"): SVGFETileElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"feTurbulence\"): SVGFETurbulenceElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"filter\"): SVGFilterElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"foreignObject\"): SVGForeignObjectElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"g\"): SVGGElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"image\"): SVGImageElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"gradient\"): SVGGradientElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"line\"): SVGLineElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"linearGradient\"): SVGLinearGradientElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"marker\"): SVGMarkerElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"mask\"): SVGMaskElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"path\"): SVGPathElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"metadata\"): SVGMetadataElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"pattern\"): SVGPatternElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"polygon\"): SVGPolygonElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"polyline\"): SVGPolylineElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"radialGradient\"): SVGRadialGradientElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"rect\"): SVGRectElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"svg\"): SVGSVGElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"script\"): SVGScriptElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"stop\"): SVGStopElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"style\"): SVGStyleElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"switch\"): SVGSwitchElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"symbol\"): SVGSymbolElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"tspan\"): SVGTSpanElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"textContent\"): SVGTextContentElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"text\"): SVGTextElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"textPath\"): SVGTextPathElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"textPositioning\"): SVGTextPositioningElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"title\"): SVGTitleElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"use\"): SVGUseElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: \"view\"): SVGViewElement;\n    createElementNS(namespaceURI: \"http://www.w3.org/2000/svg\", qualifiedName: string): SVGElement;\n    createElementNS(namespaceURI: string | null, qualifiedName: string): Element;\n    createExpression(expression: string, resolver: XPathNSResolver): XPathExpression;\n    /**\n     * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n     * @param root The root element or node to start traversing on.\n     * @param whatToShow The type of nodes or elements to appear in the node list\n     * @param filter A custom NodeFilter function to use. For more information, see filter. Use null for no filter.\n     * @param entityReferenceExpansion A flag that specifies whether entity reference nodes are expanded.\n     */\n    createNodeIterator(root: Node, whatToShow?: number, filter?: NodeFilter, entityReferenceExpansion?: boolean): NodeIterator;\n    createNSResolver(nodeResolver: Node): XPathNSResolver;\n    createProcessingInstruction(target: string, data: string): ProcessingInstruction;\n    /**\n     *  Returns an empty range object that has both of its boundary points positioned at the beginning of the document.\n     */\n    createRange(): Range;\n    /**\n     * Creates a text string from the specified value.\n     * @param data String that specifies the nodeValue property of the text node.\n     */\n    createTextNode(data: string): Text;\n    createTouch(view: Window, target: EventTarget, identifier: number, pageX: number, pageY: number, screenX: number, screenY: number): Touch;\n    createTouchList(...touches: Touch[]): TouchList;\n    /**\n     * Creates a TreeWalker object that you can use to traverse filtered lists of nodes or elements in a document.\n     * @param root The root element or node to start traversing on.\n     * @param whatToShow The type of nodes or elements to appear in the node list. For more information, see whatToShow.\n     * @param filter A custom NodeFilter function to use.\n     * @param entityReferenceExpansion A flag that specifies whether entity reference nodes are expanded.\n     */\n    createTreeWalker(root: Node, whatToShow?: number, filter?: NodeFilter, entityReferenceExpansion?: boolean): TreeWalker;\n    /**\n     * Returns the element for the specified x coordinate and the specified y coordinate.\n     * @param x The x-offset\n     * @param y The y-offset\n     */\n    elementFromPoint(x: number, y: number): Element;\n    evaluate(expression: string, contextNode: Node, resolver: XPathNSResolver | null, type: number, result: XPathResult | null): XPathResult;\n    /**\n     * Executes a command on the current document, current selection, or the given range.\n     * @param commandId String that specifies the command to execute. This command can be any of the command identifiers that can be executed in script.\n     * @param showUI Display the user interface, defaults to false.\n     * @param value Value to assign.\n     */\n    execCommand(commandId: string, showUI?: boolean, value?: any): boolean;\n    /**\n     * Displays help information for the given command identifier.\n     * @param commandId Displays help information for the given command identifier.\n     */\n    execCommandShowHelp(commandId: string): boolean;\n    exitFullscreen(): void;\n    exitPointerLock(): void;\n    /**\n     * Causes the element to receive the focus and executes the code specified by the onfocus event.\n     */\n    focus(): void;\n    /**\n     * Returns a reference to the first object with the specified value of the ID or NAME attribute.\n     * @param elementId String that specifies the ID value. Case-insensitive.\n     */\n    getElementById(elementId: string): HTMLElement | null;\n    getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;\n    /**\n     * Gets a collection of objects based on the value of the NAME or ID attribute.\n     * @param elementName Gets a collection of objects based on the value of the NAME or ID attribute.\n     */\n    getElementsByName(elementName: string): NodeListOf<HTMLElement>;\n    /**\n     * Retrieves a collection of objects based on the specified element name.\n     * @param name Specifies the name of an element.\n     */\n    getElementsByTagName<K extends keyof ElementListTagNameMap>(tagname: K): ElementListTagNameMap[K];\n    getElementsByTagName(tagname: string): NodeListOf<Element>;\n    getElementsByTagNameNS(namespaceURI: \"http://www.w3.org/1999/xhtml\", localName: string): HTMLCollectionOf<HTMLElement>;\n    getElementsByTagNameNS(namespaceURI: \"http://www.w3.org/2000/svg\", localName: string): HTMLCollectionOf<SVGElement>;\n    getElementsByTagNameNS(namespaceURI: string, localName: string): HTMLCollectionOf<Element>;\n    /**\n     * Returns an object representing the current selection of the document that is loaded into the object displaying a webpage.\n     */\n    getSelection(): Selection;\n    /**\n     * Gets a value indicating whether the object currently has focus.\n     */\n    hasFocus(): boolean;\n    importNode<T extends Node>(importedNode: T, deep: boolean): T;\n    msElementsFromPoint(x: number, y: number): NodeListOf<Element>;\n    msElementsFromRect(left: number, top: number, width: number, height: number): NodeListOf<Element>;\n    /**\n     * Opens a new window and loads a document specified by a given URL. Also, opens a new window that uses the url parameter and the name parameter to collect the output of the write method and the writeln method.\n     * @param url Specifies a MIME type for the document.\n     * @param name Specifies the name of the window. This name is used as the value for the TARGET attribute on a form or an anchor element.\n     * @param features Contains a list of items separated by commas. Each item consists of an option and a value, separated by an equals sign (for example, \"fullscreen=yes, toolbar=yes\"). The following values are supported.\n     * @param replace Specifies whether the existing entry for the document is replaced in the history list.\n     */\n    open(url?: string, name?: string, features?: string, replace?: boolean): Document;\n    /**\n     * Returns a Boolean value that indicates whether a specified command can be successfully executed using execCommand, given the current state of the document.\n     * @param commandId Specifies a command identifier.\n     */\n    queryCommandEnabled(commandId: string): boolean;\n    /**\n     * Returns a Boolean value that indicates whether the specified command is in the indeterminate state.\n     * @param commandId String that specifies a command identifier.\n     */\n    queryCommandIndeterm(commandId: string): boolean;\n    /**\n     * Returns a Boolean value that indicates the current state of the command.\n     * @param commandId String that specifies a command identifier.\n     */\n    queryCommandState(commandId: string): boolean;\n    /**\n     * Returns a Boolean value that indicates whether the current command is supported on the current range.\n     * @param commandId Specifies a command identifier.\n     */\n    queryCommandSupported(commandId: string): boolean;\n    /**\n     * Retrieves the string associated with a command.\n     * @param commandId String that contains the identifier of a command. This can be any command identifier given in the list of Command Identifiers.\n     */\n    queryCommandText(commandId: string): string;\n    /**\n     * Returns the current value of the document, range, or current selection for the given command.\n     * @param commandId String that specifies a command identifier.\n     */\n    queryCommandValue(commandId: string): string;\n    releaseEvents(): void;\n    /**\n     * Allows updating the print settings for the page.\n     */\n    updateSettings(): void;\n    webkitCancelFullScreen(): void;\n    webkitExitFullscreen(): void;\n    /**\n     * Writes one or more HTML expressions to a document in the specified window.\n     * @param content Specifies the text and HTML tags to write.\n     */\n    write(...content: string[]): void;\n    /**\n     * Writes one or more HTML expressions, followed by a carriage return, to a document in the specified window.\n     * @param content The text and HTML tags to write.\n     */\n    writeln(...content: string[]): void;\n    addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var Document: {\n    prototype: Document;\n    new(): Document;\n};\n\ninterface DocumentFragment extends Node, NodeSelector, ParentNode {\n    getElementById(elementId: string): HTMLElement | null;\n}\n\ndeclare var DocumentFragment: {\n    prototype: DocumentFragment;\n    new(): DocumentFragment;\n};\n\ninterface DocumentType extends Node, ChildNode {\n    readonly entities: NamedNodeMap;\n    readonly internalSubset: string | null;\n    readonly name: string;\n    readonly notations: NamedNodeMap;\n    readonly publicId: string;\n    readonly systemId: string;\n}\n\ndeclare var DocumentType: {\n    prototype: DocumentType;\n    new(): DocumentType;\n};\n\ninterface DOMError {\n    readonly name: string;\n    toString(): string;\n}\n\ndeclare var DOMError: {\n    prototype: DOMError;\n    new(): DOMError;\n};\n\ninterface DOMException {\n    readonly code: number;\n    readonly message: string;\n    readonly name: string;\n    toString(): string;\n    readonly ABORT_ERR: number;\n    readonly DATA_CLONE_ERR: number;\n    readonly DOMSTRING_SIZE_ERR: number;\n    readonly HIERARCHY_REQUEST_ERR: number;\n    readonly INDEX_SIZE_ERR: number;\n    readonly INUSE_ATTRIBUTE_ERR: number;\n    readonly INVALID_ACCESS_ERR: number;\n    readonly INVALID_CHARACTER_ERR: number;\n    readonly INVALID_MODIFICATION_ERR: number;\n    readonly INVALID_NODE_TYPE_ERR: number;\n    readonly INVALID_STATE_ERR: number;\n    readonly NAMESPACE_ERR: number;\n    readonly NETWORK_ERR: number;\n    readonly NO_DATA_ALLOWED_ERR: number;\n    readonly NO_MODIFICATION_ALLOWED_ERR: number;\n    readonly NOT_FOUND_ERR: number;\n    readonly NOT_SUPPORTED_ERR: number;\n    readonly PARSE_ERR: number;\n    readonly QUOTA_EXCEEDED_ERR: number;\n    readonly SECURITY_ERR: number;\n    readonly SERIALIZE_ERR: number;\n    readonly SYNTAX_ERR: number;\n    readonly TIMEOUT_ERR: number;\n    readonly TYPE_MISMATCH_ERR: number;\n    readonly URL_MISMATCH_ERR: number;\n    readonly VALIDATION_ERR: number;\n    readonly WRONG_DOCUMENT_ERR: number;\n}\n\ndeclare var DOMException: {\n    prototype: DOMException;\n    new(): DOMException;\n    readonly ABORT_ERR: number;\n    readonly DATA_CLONE_ERR: number;\n    readonly DOMSTRING_SIZE_ERR: number;\n    readonly HIERARCHY_REQUEST_ERR: number;\n    readonly INDEX_SIZE_ERR: number;\n    readonly INUSE_ATTRIBUTE_ERR: number;\n    readonly INVALID_ACCESS_ERR: number;\n    readonly INVALID_CHARACTER_ERR: number;\n    readonly INVALID_MODIFICATION_ERR: number;\n    readonly INVALID_NODE_TYPE_ERR: number;\n    readonly INVALID_STATE_ERR: number;\n    readonly NAMESPACE_ERR: number;\n    readonly NETWORK_ERR: number;\n    readonly NO_DATA_ALLOWED_ERR: number;\n    readonly NO_MODIFICATION_ALLOWED_ERR: number;\n    readonly NOT_FOUND_ERR: number;\n    readonly NOT_SUPPORTED_ERR: number;\n    readonly PARSE_ERR: number;\n    readonly QUOTA_EXCEEDED_ERR: number;\n    readonly SECURITY_ERR: number;\n    readonly SERIALIZE_ERR: number;\n    readonly SYNTAX_ERR: number;\n    readonly TIMEOUT_ERR: number;\n    readonly TYPE_MISMATCH_ERR: number;\n    readonly URL_MISMATCH_ERR: number;\n    readonly VALIDATION_ERR: number;\n    readonly WRONG_DOCUMENT_ERR: number;\n};\n\ninterface DOMImplementation {\n    createDocument(namespaceURI: string | null, qualifiedName: string | null, doctype: DocumentType | null): Document;\n    createDocumentType(qualifiedName: string, publicId: string, systemId: string): DocumentType;\n    createHTMLDocument(title: string): Document;\n    hasFeature(feature: string | null, version: string | null): boolean;\n}\n\ndeclare var DOMImplementation: {\n    prototype: DOMImplementation;\n    new(): DOMImplementation;\n};\n\ninterface DOMParser {\n    parseFromString(source: string, mimeType: string): Document;\n}\n\ndeclare var DOMParser: {\n    prototype: DOMParser;\n    new(): DOMParser;\n};\n\ninterface DOMSettableTokenList extends DOMTokenList {\n    value: string;\n}\n\ndeclare var DOMSettableTokenList: {\n    prototype: DOMSettableTokenList;\n    new(): DOMSettableTokenList;\n};\n\ninterface DOMStringList {\n    readonly length: number;\n    contains(str: string): boolean;\n    item(index: number): string | null;\n    [index: number]: string;\n}\n\ndeclare var DOMStringList: {\n    prototype: DOMStringList;\n    new(): DOMStringList;\n};\n\ninterface DOMStringMap {\n    [name: string]: string | undefined;\n}\n\ndeclare var DOMStringMap: {\n    prototype: DOMStringMap;\n    new(): DOMStringMap;\n};\n\ninterface DOMTokenList {\n    readonly length: number;\n    add(...token: string[]): void;\n    contains(token: string): boolean;\n    item(index: number): string;\n    remove(...token: string[]): void;\n    toggle(token: string, force?: boolean): boolean;\n    toString(): string;\n    [index: number]: string;\n}\n\ndeclare var DOMTokenList: {\n    prototype: DOMTokenList;\n    new(): DOMTokenList;\n};\n\ninterface DragEvent extends MouseEvent {\n    readonly dataTransfer: DataTransfer;\n    initDragEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, ctrlKeyArg: boolean, altKeyArg: boolean, shiftKeyArg: boolean, metaKeyArg: boolean, buttonArg: number, relatedTargetArg: EventTarget, dataTransferArg: DataTransfer): void;\n    msConvertURL(file: File, targetType: string, targetURL?: string): void;\n}\n\ndeclare var DragEvent: {\n    prototype: DragEvent;\n    new(type: \"drag\" | \"dragend\" | \"dragenter\" | \"dragexit\" | \"dragleave\" | \"dragover\" | \"dragstart\" | \"drop\", dragEventInit?: { dataTransfer?: DataTransfer }): DragEvent;\n};\n\ninterface DynamicsCompressorNode extends AudioNode {\n    readonly attack: AudioParam;\n    readonly knee: AudioParam;\n    readonly ratio: AudioParam;\n    readonly reduction: number;\n    readonly release: AudioParam;\n    readonly threshold: AudioParam;\n}\n\ndeclare var DynamicsCompressorNode: {\n    prototype: DynamicsCompressorNode;\n    new(): DynamicsCompressorNode;\n};\n\ninterface ElementEventMap extends GlobalEventHandlersEventMap {\n    \"ariarequest\": Event;\n    \"command\": Event;\n    \"gotpointercapture\": PointerEvent;\n    \"lostpointercapture\": PointerEvent;\n    \"MSGestureChange\": MSGestureEvent;\n    \"MSGestureDoubleTap\": MSGestureEvent;\n    \"MSGestureEnd\": MSGestureEvent;\n    \"MSGestureHold\": MSGestureEvent;\n    \"MSGestureStart\": MSGestureEvent;\n    \"MSGestureTap\": MSGestureEvent;\n    \"MSGotPointerCapture\": MSPointerEvent;\n    \"MSInertiaStart\": MSGestureEvent;\n    \"MSLostPointerCapture\": MSPointerEvent;\n    \"MSPointerCancel\": MSPointerEvent;\n    \"MSPointerDown\": MSPointerEvent;\n    \"MSPointerEnter\": MSPointerEvent;\n    \"MSPointerLeave\": MSPointerEvent;\n    \"MSPointerMove\": MSPointerEvent;\n    \"MSPointerOut\": MSPointerEvent;\n    \"MSPointerOver\": MSPointerEvent;\n    \"MSPointerUp\": MSPointerEvent;\n    \"touchcancel\": TouchEvent;\n    \"touchend\": TouchEvent;\n    \"touchmove\": TouchEvent;\n    \"touchstart\": TouchEvent;\n    \"webkitfullscreenchange\": Event;\n    \"webkitfullscreenerror\": Event;\n}\n\ninterface Element extends Node, GlobalEventHandlers, ElementTraversal, NodeSelector, ChildNode, ParentNode {\n    readonly classList: DOMTokenList;\n    className: string;\n    readonly clientHeight: number;\n    readonly clientLeft: number;\n    readonly clientTop: number;\n    readonly clientWidth: number;\n    id: string;\n    innerHTML: string;\n    msContentZoomFactor: number;\n    readonly msRegionOverflow: string;\n    onariarequest: (this: Element, ev: Event) => any;\n    oncommand: (this: Element, ev: Event) => any;\n    ongotpointercapture: (this: Element, ev: PointerEvent) => any;\n    onlostpointercapture: (this: Element, ev: PointerEvent) => any;\n    onmsgesturechange: (this: Element, ev: MSGestureEvent) => any;\n    onmsgesturedoubletap: (this: Element, ev: MSGestureEvent) => any;\n    onmsgestureend: (this: Element, ev: MSGestureEvent) => any;\n    onmsgesturehold: (this: Element, ev: MSGestureEvent) => any;\n    onmsgesturestart: (this: Element, ev: MSGestureEvent) => any;\n    onmsgesturetap: (this: Element, ev: MSGestureEvent) => any;\n    onmsgotpointercapture: (this: Element, ev: MSPointerEvent) => any;\n    onmsinertiastart: (this: Element, ev: MSGestureEvent) => any;\n    onmslostpointercapture: (this: Element, ev: MSPointerEvent) => any;\n    onmspointercancel: (this: Element, ev: MSPointerEvent) => any;\n    onmspointerdown: (this: Element, ev: MSPointerEvent) => any;\n    onmspointerenter: (this: Element, ev: MSPointerEvent) => any;\n    onmspointerleave: (this: Element, ev: MSPointerEvent) => any;\n    onmspointermove: (this: Element, ev: MSPointerEvent) => any;\n    onmspointerout: (this: Element, ev: MSPointerEvent) => any;\n    onmspointerover: (this: Element, ev: MSPointerEvent) => any;\n    onmspointerup: (this: Element, ev: MSPointerEvent) => any;\n    ontouchcancel: (ev: TouchEvent) => any;\n    ontouchend: (ev: TouchEvent) => any;\n    ontouchmove: (ev: TouchEvent) => any;\n    ontouchstart: (ev: TouchEvent) => any;\n    onwebkitfullscreenchange: (this: Element, ev: Event) => any;\n    onwebkitfullscreenerror: (this: Element, ev: Event) => any;\n    outerHTML: string;\n    readonly prefix: string | null;\n    readonly scrollHeight: number;\n    scrollLeft: number;\n    scrollTop: number;\n    readonly scrollWidth: number;\n    readonly tagName: string;\n    readonly assignedSlot: HTMLSlotElement | null;\n    slot: string;\n    readonly shadowRoot: ShadowRoot | null;\n    getAttribute(name: string): string | null;\n    getAttributeNode(name: string): Attr;\n    getAttributeNodeNS(namespaceURI: string, localName: string): Attr;\n    getAttributeNS(namespaceURI: string, localName: string): string;\n    getBoundingClientRect(): ClientRect;\n    getClientRects(): ClientRectList;\n    getElementsByTagName<K extends keyof ElementListTagNameMap>(name: K): ElementListTagNameMap[K];\n    getElementsByTagName(name: string): NodeListOf<Element>;\n    getElementsByTagNameNS(namespaceURI: \"http://www.w3.org/1999/xhtml\", localName: string): HTMLCollectionOf<HTMLElement>;\n    getElementsByTagNameNS(namespaceURI: \"http://www.w3.org/2000/svg\", localName: string): HTMLCollectionOf<SVGElement>;\n    getElementsByTagNameNS(namespaceURI: string, localName: string): HTMLCollectionOf<Element>;\n    hasAttribute(name: string): boolean;\n    hasAttributeNS(namespaceURI: string, localName: string): boolean;\n    msGetRegionContent(): MSRangeCollection;\n    msGetUntransformedBounds(): ClientRect;\n    msMatchesSelector(selectors: string): boolean;\n    msReleasePointerCapture(pointerId: number): void;\n    msSetPointerCapture(pointerId: number): void;\n    msZoomTo(args: MsZoomToOptions): void;\n    releasePointerCapture(pointerId: number): void;\n    removeAttribute(qualifiedName: string): void;\n    removeAttributeNode(oldAttr: Attr): Attr;\n    removeAttributeNS(namespaceURI: string, localName: string): void;\n    requestFullscreen(): void;\n    requestPointerLock(): void;\n    setAttribute(name: string, value: string): void;\n    setAttributeNode(newAttr: Attr): Attr;\n    setAttributeNodeNS(newAttr: Attr): Attr;\n    setAttributeNS(namespaceURI: string, qualifiedName: string, value: string): void;\n    setPointerCapture(pointerId: number): void;\n    webkitMatchesSelector(selectors: string): boolean;\n    webkitRequestFullscreen(): void;\n    webkitRequestFullScreen(): void;\n    getElementsByClassName(classNames: string): NodeListOf<Element>;\n    matches(selector: string): boolean;\n    closest(selector: string): Element | null;\n    scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;\n    scroll(options?: ScrollToOptions): void;\n    scroll(x: number, y: number): void;\n    scrollTo(options?: ScrollToOptions): void;\n    scrollTo(x: number, y: number): void;\n    scrollBy(options?: ScrollToOptions): void;\n    scrollBy(x: number, y: number): void;\n    insertAdjacentElement(position: InsertPosition, insertedElement: Element): Element | null;\n    insertAdjacentHTML(where: InsertPosition, html: string): void;\n    insertAdjacentText(where: InsertPosition, text: string): void;\n    attachShadow(shadowRootInitDict: ShadowRootInit): ShadowRoot;\n    addEventListener<K extends keyof ElementEventMap>(type: K, listener: (this: Element, ev: ElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var Element: {\n    prototype: Element;\n    new(): Element;\n};\n\ninterface ErrorEvent extends Event {\n    readonly colno: number;\n    readonly error: any;\n    readonly filename: string;\n    readonly lineno: number;\n    readonly message: string;\n    initErrorEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, messageArg: string, filenameArg: string, linenoArg: number): void;\n}\n\ndeclare var ErrorEvent: {\n    prototype: ErrorEvent;\n    new(type: string, errorEventInitDict?: ErrorEventInit): ErrorEvent;\n};\n\ninterface Event {\n    readonly bubbles: boolean;\n    readonly cancelable: boolean;\n    cancelBubble: boolean;\n    readonly currentTarget: EventTarget;\n    readonly defaultPrevented: boolean;\n    readonly eventPhase: number;\n    readonly isTrusted: boolean;\n    returnValue: boolean;\n    readonly srcElement: Element | null;\n    readonly target: EventTarget;\n    readonly timeStamp: number;\n    readonly type: string;\n    readonly scoped: boolean;\n    initEvent(eventTypeArg: string, canBubbleArg: boolean, cancelableArg: boolean): void;\n    preventDefault(): void;\n    stopImmediatePropagation(): void;\n    stopPropagation(): void;\n    deepPath(): EventTarget[];\n    readonly AT_TARGET: number;\n    readonly BUBBLING_PHASE: number;\n    readonly CAPTURING_PHASE: number;\n}\n\ndeclare var Event: {\n    prototype: Event;\n    new(typeArg: string, eventInitDict?: EventInit): Event;\n    readonly AT_TARGET: number;\n    readonly BUBBLING_PHASE: number;\n    readonly CAPTURING_PHASE: number;\n};\n\ninterface EventTarget {\n    addEventListener(type: string, listener?: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    dispatchEvent(evt: Event): boolean;\n    removeEventListener(type: string, listener?: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var EventTarget: {\n    prototype: EventTarget;\n    new(): EventTarget;\n};\n\ninterface EXT_frag_depth {\n}\n\ndeclare var EXT_frag_depth: {\n    prototype: EXT_frag_depth;\n    new(): EXT_frag_depth;\n};\n\ninterface EXT_texture_filter_anisotropic {\n    readonly MAX_TEXTURE_MAX_ANISOTROPY_EXT: number;\n    readonly TEXTURE_MAX_ANISOTROPY_EXT: number;\n}\n\ndeclare var EXT_texture_filter_anisotropic: {\n    prototype: EXT_texture_filter_anisotropic;\n    new(): EXT_texture_filter_anisotropic;\n    readonly MAX_TEXTURE_MAX_ANISOTROPY_EXT: number;\n    readonly TEXTURE_MAX_ANISOTROPY_EXT: number;\n};\n\ninterface ExtensionScriptApis {\n    extensionIdToShortId(extensionId: string): number;\n    fireExtensionApiTelemetry(functionName: string, isSucceeded: boolean, isSupported: boolean): void;\n    genericFunction(routerAddress: any, parameters?: string, callbackId?: number): void;\n    genericSynchronousFunction(functionId: number, parameters?: string): string;\n    getExtensionId(): string;\n    registerGenericFunctionCallbackHandler(callbackHandler: any): void;\n    registerGenericPersistentCallbackHandler(callbackHandler: any): void;\n}\n\ndeclare var ExtensionScriptApis: {\n    prototype: ExtensionScriptApis;\n    new(): ExtensionScriptApis;\n};\n\ninterface External {\n}\n\ndeclare var External: {\n    prototype: External;\n    new(): External;\n};\n\ninterface File extends Blob {\n    readonly lastModifiedDate: any;\n    readonly name: string;\n    readonly webkitRelativePath: string;\n}\n\ndeclare var File: {\n    prototype: File;\n    new (parts: (ArrayBuffer | ArrayBufferView | Blob | string)[], filename: string, properties?: FilePropertyBag): File;\n};\n\ninterface FileList {\n    readonly length: number;\n    item(index: number): File;\n    [index: number]: File;\n}\n\ndeclare var FileList: {\n    prototype: FileList;\n    new(): FileList;\n};\n\ninterface FileReader extends EventTarget, MSBaseReader {\n    readonly error: DOMError;\n    readAsArrayBuffer(blob: Blob): void;\n    readAsBinaryString(blob: Blob): void;\n    readAsDataURL(blob: Blob): void;\n    readAsText(blob: Blob, encoding?: string): void;\n    addEventListener<K extends keyof MSBaseReaderEventMap>(type: K, listener: (this: FileReader, ev: MSBaseReaderEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var FileReader: {\n    prototype: FileReader;\n    new(): FileReader;\n};\n\ninterface FocusEvent extends UIEvent {\n    readonly relatedTarget: EventTarget;\n    initFocusEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, relatedTargetArg: EventTarget): void;\n}\n\ndeclare var FocusEvent: {\n    prototype: FocusEvent;\n    new(typeArg: string, eventInitDict?: FocusEventInit): FocusEvent;\n};\n\ninterface FocusNavigationEvent extends Event {\n    readonly navigationReason: NavigationReason;\n    readonly originHeight: number;\n    readonly originLeft: number;\n    readonly originTop: number;\n    readonly originWidth: number;\n    requestFocus(): void;\n}\n\ndeclare var FocusNavigationEvent: {\n    prototype: FocusNavigationEvent;\n    new(type: string, eventInitDict?: FocusNavigationEventInit): FocusNavigationEvent;\n};\n\ninterface FormData {\n    append(name: string, value: string | Blob, fileName?: string): void;\n    delete(name: string): void;\n    get(name: string): FormDataEntryValue | null;\n    getAll(name: string): FormDataEntryValue[];\n    has(name: string): boolean;\n    set(name: string, value: string | Blob, fileName?: string): void;\n}\n\ndeclare var FormData: {\n    prototype: FormData;\n    new (form?: HTMLFormElement): FormData;\n};\n\ninterface GainNode extends AudioNode {\n    readonly gain: AudioParam;\n}\n\ndeclare var GainNode: {\n    prototype: GainNode;\n    new(): GainNode;\n};\n\ninterface Gamepad {\n    readonly axes: number[];\n    readonly buttons: GamepadButton[];\n    readonly connected: boolean;\n    readonly id: string;\n    readonly index: number;\n    readonly mapping: string;\n    readonly timestamp: number;\n}\n\ndeclare var Gamepad: {\n    prototype: Gamepad;\n    new(): Gamepad;\n};\n\ninterface GamepadButton {\n    readonly pressed: boolean;\n    readonly value: number;\n}\n\ndeclare var GamepadButton: {\n    prototype: GamepadButton;\n    new(): GamepadButton;\n};\n\ninterface GamepadEvent extends Event {\n    readonly gamepad: Gamepad;\n}\n\ndeclare var GamepadEvent: {\n    prototype: GamepadEvent;\n    new(typeArg: string, eventInitDict?: GamepadEventInit): GamepadEvent;\n};\n\ninterface Geolocation {\n    clearWatch(watchId: number): void;\n    getCurrentPosition(successCallback: PositionCallback, errorCallback?: PositionErrorCallback, options?: PositionOptions): void;\n    watchPosition(successCallback: PositionCallback, errorCallback?: PositionErrorCallback, options?: PositionOptions): number;\n}\n\ndeclare var Geolocation: {\n    prototype: Geolocation;\n    new(): Geolocation;\n};\n\ninterface HashChangeEvent extends Event {\n    readonly newURL: string | null;\n    readonly oldURL: string | null;\n}\n\ndeclare var HashChangeEvent: {\n    prototype: HashChangeEvent;\n    new(typeArg: string, eventInitDict?: HashChangeEventInit): HashChangeEvent;\n};\n\ninterface Headers {\n    append(name: string, value: string): void;\n    delete(name: string): void;\n    forEach(callback: ForEachCallback): void;\n    get(name: string): string | null;\n    has(name: string): boolean;\n    set(name: string, value: string): void;\n}\n\ndeclare var Headers: {\n    prototype: Headers;\n    new(init?: any): Headers;\n};\n\ninterface History {\n    readonly length: number;\n    readonly state: any;\n    scrollRestoration: ScrollRestoration;\n    back(): void;\n    forward(): void;\n    go(delta?: number): void;\n    pushState(data: any, title: string, url?: string | null): void;\n    replaceState(data: any, title: string, url?: string | null): void;\n}\n\ndeclare var History: {\n    prototype: History;\n    new(): History;\n};\n\ninterface HTMLAllCollection {\n    readonly length: number;\n    item(nameOrIndex?: string): HTMLCollection | Element | null;\n    namedItem(name: string): HTMLCollection | Element | null;\n    [index: number]: Element;\n}\n\ndeclare var HTMLAllCollection: {\n    prototype: HTMLAllCollection;\n    new(): HTMLAllCollection;\n};\n\ninterface HTMLAnchorElement extends HTMLElement {\n    /**\n     * Sets or retrieves the character set used to encode the object.\n     */\n    charset: string;\n    /**\n     * Sets or retrieves the coordinates of the object.\n     */\n    coords: string;\n    download: string;\n    /**\n     * Contains the anchor portion of the URL including the hash sign (#).\n     */\n    hash: string;\n    /**\n     * Contains the hostname and port values of the URL.\n     */\n    host: string;\n    /**\n     * Contains the hostname of a URL.\n     */\n    hostname: string;\n    /**\n     * Sets or retrieves a destination URL or an anchor point.\n     */\n    href: string;\n    /**\n     * Sets or retrieves the language code of the object.\n     */\n    hreflang: string;\n    Methods: string;\n    readonly mimeType: string;\n    /**\n     * Sets or retrieves the shape of the object.\n     */\n    name: string;\n    readonly nameProp: string;\n    /**\n     * Contains the pathname of the URL.\n     */\n    pathname: string;\n    /**\n     * Sets or retrieves the port number associated with a URL.\n     */\n    port: string;\n    /**\n     * Contains the protocol of the URL.\n     */\n    protocol: string;\n    readonly protocolLong: string;\n    /**\n     * Sets or retrieves the relationship between the object and the destination of the link.\n     */\n    rel: string;\n    /**\n     * Sets or retrieves the relationship between the object and the destination of the link.\n     */\n    rev: string;\n    /**\n     * Sets or retrieves the substring of the href property that follows the question mark.\n     */\n    search: string;\n    /**\n     * Sets or retrieves the shape of the object.\n     */\n    shape: string;\n    /**\n     * Sets or retrieves the window or frame at which to target content.\n     */\n    target: string;\n    /**\n     * Retrieves or sets the text of the object as a string.\n     */\n    text: string;\n    type: string;\n    urn: string;\n    /**\n     * Returns a string representation of an object.\n     */\n    toString(): string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLAnchorElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLAnchorElement: {\n    prototype: HTMLAnchorElement;\n    new(): HTMLAnchorElement;\n};\n\ninterface HTMLAppletElement extends HTMLElement {\n    align: string;\n    /**\n     * Sets or retrieves a text alternative to the graphic.\n     */\n    alt: string;\n    /**\n     * Gets or sets the optional alternative HTML script to execute if the object fails to load.\n     */\n    altHtml: string;\n    /**\n     * Sets or retrieves a character string that can be used to implement your own archive functionality for the object.\n     */\n    archive: string;\n    /**\n     * Retrieves a string of the URL where the object tag can be found. This is often the href of the document that the object is in, or the value set by a base element.\n     */\n    readonly BaseHref: string;\n    border: string;\n    code: string;\n    /**\n     * Sets or retrieves the URL of the component.\n     */\n    codeBase: string;\n    /**\n     * Sets or retrieves the Internet media type for the code associated with the object.\n     */\n    codeType: string;\n    /**\n     * Address of a pointer to the document this page or frame contains. If there is no document, then null will be returned.\n     */\n    readonly contentDocument: Document;\n    /**\n     * Sets or retrieves the URL that references the data of the object.\n     */\n    data: string;\n    /**\n     * Sets or retrieves a character string that can be used to implement your own declare functionality for the object.\n     */\n    declare: boolean;\n    readonly form: HTMLFormElement;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: string;\n    hspace: number;\n    /**\n     * Sets or retrieves the shape of the object.\n     */\n    name: string;\n    object: string | null;\n    /**\n     * Sets or retrieves a message to be displayed while an object is loading.\n     */\n    standby: string;\n    /**\n     * Returns the content type of the object.\n     */\n    type: string;\n    /**\n     * Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map.\n     */\n    useMap: string;\n    vspace: number;\n    width: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLAppletElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLAppletElement: {\n    prototype: HTMLAppletElement;\n    new(): HTMLAppletElement;\n};\n\ninterface HTMLAreaElement extends HTMLElement {\n    /**\n     * Sets or retrieves a text alternative to the graphic.\n     */\n    alt: string;\n    /**\n     * Sets or retrieves the coordinates of the object.\n     */\n    coords: string;\n    download: string;\n    /**\n     * Sets or retrieves the subsection of the href property that follows the number sign (#).\n     */\n    hash: string;\n    /**\n     * Sets or retrieves the hostname and port number of the location or URL.\n     */\n    host: string;\n    /**\n     * Sets or retrieves the host name part of the location or URL.\n     */\n    hostname: string;\n    /**\n     * Sets or retrieves a destination URL or an anchor point.\n     */\n    href: string;\n    /**\n     * Sets or gets whether clicks in this region cause action.\n     */\n    noHref: boolean;\n    /**\n     * Sets or retrieves the file name or path specified by the object.\n     */\n    pathname: string;\n    /**\n     * Sets or retrieves the port number associated with a URL.\n     */\n    port: string;\n    /**\n     * Sets or retrieves the protocol portion of a URL.\n     */\n    protocol: string;\n    rel: string;\n    /**\n     * Sets or retrieves the substring of the href property that follows the question mark.\n     */\n    search: string;\n    /**\n     * Sets or retrieves the shape of the object.\n     */\n    shape: string;\n    /**\n     * Sets or retrieves the window or frame at which to target content.\n     */\n    target: string;\n    /**\n     * Returns a string representation of an object.\n     */\n    toString(): string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLAreaElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLAreaElement: {\n    prototype: HTMLAreaElement;\n    new(): HTMLAreaElement;\n};\n\ninterface HTMLAreasCollection extends HTMLCollectionBase {\n}\n\ndeclare var HTMLAreasCollection: {\n    prototype: HTMLAreasCollection;\n    new(): HTMLAreasCollection;\n};\n\ninterface HTMLAudioElement extends HTMLMediaElement {\n    addEventListener<K extends keyof HTMLMediaElementEventMap>(type: K, listener: (this: HTMLAudioElement, ev: HTMLMediaElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLAudioElement: {\n    prototype: HTMLAudioElement;\n    new(): HTMLAudioElement;\n};\n\ninterface HTMLBaseElement extends HTMLElement {\n    /**\n     * Gets or sets the baseline URL on which relative links are based.\n     */\n    href: string;\n    /**\n     * Sets or retrieves the window or frame at which to target content.\n     */\n    target: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLBaseElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLBaseElement: {\n    prototype: HTMLBaseElement;\n    new(): HTMLBaseElement;\n};\n\ninterface HTMLBaseFontElement extends HTMLElement, DOML2DeprecatedColorProperty {\n    /**\n     * Sets or retrieves the current typeface family.\n     */\n    face: string;\n    /**\n     * Sets or retrieves the font size of the object.\n     */\n    size: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLBaseFontElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLBaseFontElement: {\n    prototype: HTMLBaseFontElement;\n    new(): HTMLBaseFontElement;\n};\n\ninterface HTMLBodyElementEventMap extends HTMLElementEventMap {\n    \"afterprint\": Event;\n    \"beforeprint\": Event;\n    \"beforeunload\": BeforeUnloadEvent;\n    \"blur\": FocusEvent;\n    \"error\": ErrorEvent;\n    \"focus\": FocusEvent;\n    \"hashchange\": HashChangeEvent;\n    \"load\": Event;\n    \"message\": MessageEvent;\n    \"offline\": Event;\n    \"online\": Event;\n    \"orientationchange\": Event;\n    \"pagehide\": PageTransitionEvent;\n    \"pageshow\": PageTransitionEvent;\n    \"popstate\": PopStateEvent;\n    \"resize\": UIEvent;\n    \"scroll\": UIEvent;\n    \"storage\": StorageEvent;\n    \"unload\": Event;\n}\n\ninterface HTMLBodyElement extends HTMLElement {\n    aLink: any;\n    background: string;\n    bgColor: any;\n    bgProperties: string;\n    link: any;\n    noWrap: boolean;\n    onafterprint: (this: HTMLBodyElement, ev: Event) => any;\n    onbeforeprint: (this: HTMLBodyElement, ev: Event) => any;\n    onbeforeunload: (this: HTMLBodyElement, ev: BeforeUnloadEvent) => any;\n    onblur: (this: HTMLBodyElement, ev: FocusEvent) => any;\n    onerror: (this: HTMLBodyElement, ev: ErrorEvent) => any;\n    onfocus: (this: HTMLBodyElement, ev: FocusEvent) => any;\n    onhashchange: (this: HTMLBodyElement, ev: HashChangeEvent) => any;\n    onload: (this: HTMLBodyElement, ev: Event) => any;\n    onmessage: (this: HTMLBodyElement, ev: MessageEvent) => any;\n    onoffline: (this: HTMLBodyElement, ev: Event) => any;\n    ononline: (this: HTMLBodyElement, ev: Event) => any;\n    onorientationchange: (this: HTMLBodyElement, ev: Event) => any;\n    onpagehide: (this: HTMLBodyElement, ev: PageTransitionEvent) => any;\n    onpageshow: (this: HTMLBodyElement, ev: PageTransitionEvent) => any;\n    onpopstate: (this: HTMLBodyElement, ev: PopStateEvent) => any;\n    onresize: (this: HTMLBodyElement, ev: UIEvent) => any;\n    onscroll: (this: HTMLBodyElement, ev: UIEvent) => any;\n    onstorage: (this: HTMLBodyElement, ev: StorageEvent) => any;\n    onunload: (this: HTMLBodyElement, ev: Event) => any;\n    text: any;\n    vLink: any;\n    addEventListener<K extends keyof HTMLBodyElementEventMap>(type: K, listener: (this: HTMLBodyElement, ev: HTMLBodyElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLBodyElement: {\n    prototype: HTMLBodyElement;\n    new(): HTMLBodyElement;\n};\n\ninterface HTMLBRElement extends HTMLElement {\n    /**\n     * Sets or retrieves the side on which floating objects are not to be positioned when any IHTMLBlockElement is inserted into the document.\n     */\n    clear: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLBRElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLBRElement: {\n    prototype: HTMLBRElement;\n    new(): HTMLBRElement;\n};\n\ninterface HTMLButtonElement extends HTMLElement {\n    /**\n     * Provides a way to direct a user to a specific field when a document loads. This can provide both direction and convenience for a user, reducing the need to click or tab to a field when a page opens. This attribute is true when present on an element, and false when missing.\n     */\n    autofocus: boolean;\n    disabled: boolean;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement;\n    /**\n     * Overrides the action attribute (where the data on a form is sent) on the parent form element.\n     */\n    formAction: string;\n    /**\n     * Used to override the encoding (formEnctype attribute) specified on the form element.\n     */\n    formEnctype: string;\n    /**\n     * Overrides the submit method attribute previously specified on a form element.\n     */\n    formMethod: string;\n    /**\n     * Overrides any validation or required attributes on a form or form elements to allow it to be submitted without validation. This can be used to create a \"save draft\"-type submit option.\n     */\n    formNoValidate: string;\n    /**\n     * Overrides the target attribute on a form element.\n     */\n    formTarget: string;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    status: any;\n    /**\n     * Gets the classification and default behavior of the button.\n     */\n    type: string;\n    /**\n     * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as \"this is a required field\". The result is that the user sees validation messages without actually submitting.\n     */\n    readonly validationMessage: string;\n    /**\n     * Returns a  ValidityState object that represents the validity states of an element.\n     */\n    readonly validity: ValidityState;\n    /**\n     * Sets or retrieves the default or selected value of the control.\n     */\n    value: string;\n    /**\n     * Returns whether an element will successfully validate based on forms validation rules and constraints.\n     */\n    readonly willValidate: boolean;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    /**\n     * Sets a custom error message that is displayed when a form is submitted.\n     * @param error Sets a custom error message that is displayed when a form is submitted.\n     */\n    setCustomValidity(error: string): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLButtonElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLButtonElement: {\n    prototype: HTMLButtonElement;\n    new(): HTMLButtonElement;\n};\n\ninterface HTMLCanvasElement extends HTMLElement {\n    /**\n     * Gets or sets the height of a canvas element on a document.\n     */\n    height: number;\n    /**\n     * Gets or sets the width of a canvas element on a document.\n     */\n    width: number;\n    /**\n     * Returns an object that provides methods and properties for drawing and manipulating images and graphics on a canvas element in a document. A context object includes information about colors, line widths, fonts, and other graphic parameters that can be drawn on a canvas.\n     * @param contextId The identifier (ID) of the type of canvas to create. Internet Explorer 9 and Internet Explorer 10 support only a 2-D context using canvas.getContext(\"2d\"); IE11 Preview also supports 3-D or WebGL context using canvas.getContext(\"experimental-webgl\");\n     */\n    getContext(contextId: \"2d\", contextAttributes?: Canvas2DContextAttributes): CanvasRenderingContext2D | null;\n    getContext(contextId: \"webgl\" | \"experimental-webgl\", contextAttributes?: WebGLContextAttributes): WebGLRenderingContext | null;\n    getContext(contextId: string, contextAttributes?: {}): CanvasRenderingContext2D | WebGLRenderingContext | null;\n    /**\n     * Returns a blob object encoded as a Portable Network Graphics (PNG) format from a canvas image or drawing.\n     */\n    msToBlob(): Blob;\n    /**\n     * Returns the content of the current canvas as an image that you can use as a source for another canvas or an HTML element.\n     * @param type The standard MIME type for the image format to return. If you do not specify this parameter, the default value is a PNG format image.\n     */\n    toDataURL(type?: string, ...args: any[]): string;\n    toBlob(callback: (result: Blob | null) => void, type?: string, ...arguments: any[]): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLCanvasElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLCanvasElement: {\n    prototype: HTMLCanvasElement;\n    new(): HTMLCanvasElement;\n};\n\ninterface HTMLCollectionBase {\n    /**\n     * Sets or retrieves the number of objects in a collection.\n     */\n    readonly length: number;\n    /**\n     * Retrieves an object from various collections.\n     */\n    item(index: number): Element;\n    [index: number]: Element;\n}\n\ninterface HTMLCollection extends HTMLCollectionBase {\n    /**\n     * Retrieves a select object or an object from an options collection.\n     */\n    namedItem(name: string): Element | null;\n}\n\ndeclare var HTMLCollection: {\n    prototype: HTMLCollection;\n    new(): HTMLCollection;\n};\n\ninterface HTMLDataElement extends HTMLElement {\n    value: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDataElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLDataElement: {\n    prototype: HTMLDataElement;\n    new(): HTMLDataElement;\n};\n\ninterface HTMLDataListElement extends HTMLElement {\n    options: HTMLCollectionOf<HTMLOptionElement>;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDataListElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLDataListElement: {\n    prototype: HTMLDataListElement;\n    new(): HTMLDataListElement;\n};\n\ninterface HTMLDirectoryElement extends HTMLElement {\n    compact: boolean;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDirectoryElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLDirectoryElement: {\n    prototype: HTMLDirectoryElement;\n    new(): HTMLDirectoryElement;\n};\n\ninterface HTMLDivElement extends HTMLElement {\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    align: string;\n    /**\n     * Sets or retrieves whether the browser automatically performs wordwrap.\n     */\n    noWrap: boolean;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDivElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLDivElement: {\n    prototype: HTMLDivElement;\n    new(): HTMLDivElement;\n};\n\ninterface HTMLDListElement extends HTMLElement {\n    compact: boolean;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDListElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLDListElement: {\n    prototype: HTMLDListElement;\n    new(): HTMLDListElement;\n};\n\ninterface HTMLDocument extends Document {\n    addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: HTMLDocument, ev: DocumentEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLDocument: {\n    prototype: HTMLDocument;\n    new(): HTMLDocument;\n};\n\ninterface HTMLElementEventMap extends ElementEventMap {\n    \"abort\": UIEvent;\n    \"activate\": UIEvent;\n    \"beforeactivate\": UIEvent;\n    \"beforecopy\": ClipboardEvent;\n    \"beforecut\": ClipboardEvent;\n    \"beforedeactivate\": UIEvent;\n    \"beforepaste\": ClipboardEvent;\n    \"blur\": FocusEvent;\n    \"canplay\": Event;\n    \"canplaythrough\": Event;\n    \"change\": Event;\n    \"click\": MouseEvent;\n    \"contextmenu\": PointerEvent;\n    \"copy\": ClipboardEvent;\n    \"cuechange\": Event;\n    \"cut\": ClipboardEvent;\n    \"dblclick\": MouseEvent;\n    \"deactivate\": UIEvent;\n    \"drag\": DragEvent;\n    \"dragend\": DragEvent;\n    \"dragenter\": DragEvent;\n    \"dragleave\": DragEvent;\n    \"dragover\": DragEvent;\n    \"dragstart\": DragEvent;\n    \"drop\": DragEvent;\n    \"durationchange\": Event;\n    \"emptied\": Event;\n    \"ended\": MediaStreamErrorEvent;\n    \"error\": ErrorEvent;\n    \"focus\": FocusEvent;\n    \"input\": Event;\n    \"invalid\": Event;\n    \"keydown\": KeyboardEvent;\n    \"keypress\": KeyboardEvent;\n    \"keyup\": KeyboardEvent;\n    \"load\": Event;\n    \"loadeddata\": Event;\n    \"loadedmetadata\": Event;\n    \"loadstart\": Event;\n    \"mousedown\": MouseEvent;\n    \"mouseenter\": MouseEvent;\n    \"mouseleave\": MouseEvent;\n    \"mousemove\": MouseEvent;\n    \"mouseout\": MouseEvent;\n    \"mouseover\": MouseEvent;\n    \"mouseup\": MouseEvent;\n    \"mousewheel\": WheelEvent;\n    \"MSContentZoom\": UIEvent;\n    \"MSManipulationStateChanged\": MSManipulationEvent;\n    \"paste\": ClipboardEvent;\n    \"pause\": Event;\n    \"play\": Event;\n    \"playing\": Event;\n    \"progress\": ProgressEvent;\n    \"ratechange\": Event;\n    \"reset\": Event;\n    \"scroll\": UIEvent;\n    \"seeked\": Event;\n    \"seeking\": Event;\n    \"select\": UIEvent;\n    \"selectstart\": Event;\n    \"stalled\": Event;\n    \"submit\": Event;\n    \"suspend\": Event;\n    \"timeupdate\": Event;\n    \"volumechange\": Event;\n    \"waiting\": Event;\n}\n\ninterface HTMLElement extends Element {\n    accessKey: string;\n    readonly children: HTMLCollection;\n    contentEditable: string;\n    readonly dataset: DOMStringMap;\n    dir: string;\n    draggable: boolean;\n    hidden: boolean;\n    hideFocus: boolean;\n    innerText: string;\n    readonly isContentEditable: boolean;\n    lang: string;\n    readonly offsetHeight: number;\n    readonly offsetLeft: number;\n    readonly offsetParent: Element;\n    readonly offsetTop: number;\n    readonly offsetWidth: number;\n    onabort: (this: HTMLElement, ev: UIEvent) => any;\n    onactivate: (this: HTMLElement, ev: UIEvent) => any;\n    onbeforeactivate: (this: HTMLElement, ev: UIEvent) => any;\n    onbeforecopy: (this: HTMLElement, ev: ClipboardEvent) => any;\n    onbeforecut: (this: HTMLElement, ev: ClipboardEvent) => any;\n    onbeforedeactivate: (this: HTMLElement, ev: UIEvent) => any;\n    onbeforepaste: (this: HTMLElement, ev: ClipboardEvent) => any;\n    onblur: (this: HTMLElement, ev: FocusEvent) => any;\n    oncanplay: (this: HTMLElement, ev: Event) => any;\n    oncanplaythrough: (this: HTMLElement, ev: Event) => any;\n    onchange: (this: HTMLElement, ev: Event) => any;\n    onclick: (this: HTMLElement, ev: MouseEvent) => any;\n    oncontextmenu: (this: HTMLElement, ev: PointerEvent) => any;\n    oncopy: (this: HTMLElement, ev: ClipboardEvent) => any;\n    oncuechange: (this: HTMLElement, ev: Event) => any;\n    oncut: (this: HTMLElement, ev: ClipboardEvent) => any;\n    ondblclick: (this: HTMLElement, ev: MouseEvent) => any;\n    ondeactivate: (this: HTMLElement, ev: UIEvent) => any;\n    ondrag: (this: HTMLElement, ev: DragEvent) => any;\n    ondragend: (this: HTMLElement, ev: DragEvent) => any;\n    ondragenter: (this: HTMLElement, ev: DragEvent) => any;\n    ondragleave: (this: HTMLElement, ev: DragEvent) => any;\n    ondragover: (this: HTMLElement, ev: DragEvent) => any;\n    ondragstart: (this: HTMLElement, ev: DragEvent) => any;\n    ondrop: (this: HTMLElement, ev: DragEvent) => any;\n    ondurationchange: (this: HTMLElement, ev: Event) => any;\n    onemptied: (this: HTMLElement, ev: Event) => any;\n    onended: (this: HTMLElement, ev: MediaStreamErrorEvent) => any;\n    onerror: (this: HTMLElement, ev: ErrorEvent) => any;\n    onfocus: (this: HTMLElement, ev: FocusEvent) => any;\n    oninput: (this: HTMLElement, ev: Event) => any;\n    oninvalid: (this: HTMLElement, ev: Event) => any;\n    onkeydown: (this: HTMLElement, ev: KeyboardEvent) => any;\n    onkeypress: (this: HTMLElement, ev: KeyboardEvent) => any;\n    onkeyup: (this: HTMLElement, ev: KeyboardEvent) => any;\n    onload: (this: HTMLElement, ev: Event) => any;\n    onloadeddata: (this: HTMLElement, ev: Event) => any;\n    onloadedmetadata: (this: HTMLElement, ev: Event) => any;\n    onloadstart: (this: HTMLElement, ev: Event) => any;\n    onmousedown: (this: HTMLElement, ev: MouseEvent) => any;\n    onmouseenter: (this: HTMLElement, ev: MouseEvent) => any;\n    onmouseleave: (this: HTMLElement, ev: MouseEvent) => any;\n    onmousemove: (this: HTMLElement, ev: MouseEvent) => any;\n    onmouseout: (this: HTMLElement, ev: MouseEvent) => any;\n    onmouseover: (this: HTMLElement, ev: MouseEvent) => any;\n    onmouseup: (this: HTMLElement, ev: MouseEvent) => any;\n    onmousewheel: (this: HTMLElement, ev: WheelEvent) => any;\n    onmscontentzoom: (this: HTMLElement, ev: UIEvent) => any;\n    onmsmanipulationstatechanged: (this: HTMLElement, ev: MSManipulationEvent) => any;\n    onpaste: (this: HTMLElement, ev: ClipboardEvent) => any;\n    onpause: (this: HTMLElement, ev: Event) => any;\n    onplay: (this: HTMLElement, ev: Event) => any;\n    onplaying: (this: HTMLElement, ev: Event) => any;\n    onprogress: (this: HTMLElement, ev: ProgressEvent) => any;\n    onratechange: (this: HTMLElement, ev: Event) => any;\n    onreset: (this: HTMLElement, ev: Event) => any;\n    onscroll: (this: HTMLElement, ev: UIEvent) => any;\n    onseeked: (this: HTMLElement, ev: Event) => any;\n    onseeking: (this: HTMLElement, ev: Event) => any;\n    onselect: (this: HTMLElement, ev: UIEvent) => any;\n    onselectstart: (this: HTMLElement, ev: Event) => any;\n    onstalled: (this: HTMLElement, ev: Event) => any;\n    onsubmit: (this: HTMLElement, ev: Event) => any;\n    onsuspend: (this: HTMLElement, ev: Event) => any;\n    ontimeupdate: (this: HTMLElement, ev: Event) => any;\n    onvolumechange: (this: HTMLElement, ev: Event) => any;\n    onwaiting: (this: HTMLElement, ev: Event) => any;\n    outerText: string;\n    spellcheck: boolean;\n    readonly style: CSSStyleDeclaration;\n    tabIndex: number;\n    title: string;\n    blur(): void;\n    click(): void;\n    dragDrop(): boolean;\n    focus(): void;\n    msGetInputContext(): MSInputMethodContext;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLElement: {\n    prototype: HTMLElement;\n    new(): HTMLElement;\n};\n\ninterface HTMLEmbedElement extends HTMLElement, GetSVGDocument {\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: string;\n    hidden: any;\n    /**\n     * Gets or sets whether the DLNA PlayTo device is available.\n     */\n    msPlayToDisabled: boolean;\n    /**\n     * Gets or sets the path to the preferred media source. This enables the Play To target device to stream the media content, which can be DRM protected, from a different location, such as a cloud media server.\n     */\n    msPlayToPreferredSourceUri: string;\n    /**\n     * Gets or sets the primary DLNA PlayTo device.\n     */\n    msPlayToPrimary: boolean;\n    /**\n     * Gets the source associated with the media element for use by the PlayToManager.\n     */\n    readonly msPlayToSource: any;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    /**\n     * Retrieves the palette used for the embedded document.\n     */\n    readonly palette: string;\n    /**\n     * Retrieves the URL of the plug-in used to view an embedded document.\n     */\n    readonly pluginspage: string;\n    readonly readyState: string;\n    /**\n     * Sets or retrieves a URL to be loaded by the object.\n     */\n    src: string;\n    /**\n     * Sets or retrieves the height and width units of the embed object.\n     */\n    units: string;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLEmbedElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLEmbedElement: {\n    prototype: HTMLEmbedElement;\n    new(): HTMLEmbedElement;\n};\n\ninterface HTMLFieldSetElement extends HTMLElement {\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    align: string;\n    disabled: boolean;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement;\n    name: string;\n    /**\n     * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as \"this is a required field\". The result is that the user sees validation messages without actually submitting.\n     */\n    readonly validationMessage: string;\n    /**\n     * Returns a  ValidityState object that represents the validity states of an element.\n     */\n    readonly validity: ValidityState;\n    /**\n     * Returns whether an element will successfully validate based on forms validation rules and constraints.\n     */\n    readonly willValidate: boolean;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    /**\n     * Sets a custom error message that is displayed when a form is submitted.\n     * @param error Sets a custom error message that is displayed when a form is submitted.\n     */\n    setCustomValidity(error: string): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFieldSetElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLFieldSetElement: {\n    prototype: HTMLFieldSetElement;\n    new(): HTMLFieldSetElement;\n};\n\ninterface HTMLFontElement extends HTMLElement, DOML2DeprecatedColorProperty, DOML2DeprecatedSizeProperty {\n    /**\n     * Sets or retrieves the current typeface family.\n     */\n    face: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFontElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLFontElement: {\n    prototype: HTMLFontElement;\n    new(): HTMLFontElement;\n};\n\ninterface HTMLFormControlsCollection extends HTMLCollectionBase {\n    namedItem(name: string): HTMLCollection | Element | null;\n}\n\ndeclare var HTMLFormControlsCollection: {\n    prototype: HTMLFormControlsCollection;\n    new(): HTMLFormControlsCollection;\n};\n\ninterface HTMLFormElement extends HTMLElement {\n    /**\n     * Sets or retrieves a list of character encodings for input data that must be accepted by the server processing the form.\n     */\n    acceptCharset: string;\n    /**\n     * Sets or retrieves the URL to which the form content is sent for processing.\n     */\n    action: string;\n    /**\n     * Specifies whether autocomplete is applied to an editable text field.\n     */\n    autocomplete: string;\n    /**\n     * Retrieves a collection, in source order, of all controls in a given form.\n     */\n    readonly elements: HTMLFormControlsCollection;\n    /**\n     * Sets or retrieves the MIME encoding for the form.\n     */\n    encoding: string;\n    /**\n     * Sets or retrieves the encoding type for the form.\n     */\n    enctype: string;\n    /**\n     * Sets or retrieves the number of objects in a collection.\n     */\n    readonly length: number;\n    /**\n     * Sets or retrieves how to send the form data to the server.\n     */\n    method: string;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    /**\n     * Designates a form that is not validated when submitted.\n     */\n    noValidate: boolean;\n    /**\n     * Sets or retrieves the window or frame at which to target content.\n     */\n    target: string;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    /**\n     * Retrieves a form object or an object from an elements collection.\n     * @param name Variant of type Number or String that specifies the object or collection to retrieve. If this parameter is a Number, it is the zero-based index of the object. If this parameter is a string, all objects with matching name or id properties are retrieved, and a collection is returned if more than one match is made.\n     * @param index Variant of type Number that specifies the zero-based index of the object to retrieve when a collection is returned.\n     */\n    item(name?: any, index?: any): any;\n    /**\n     * Retrieves a form object or an object from an elements collection.\n     */\n    namedItem(name: string): any;\n    /**\n     * Fires when the user resets a form.\n     */\n    reset(): void;\n    /**\n     * Fires when a FORM is about to be submitted.\n     */\n    submit(): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFormElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n    [name: string]: any;\n}\n\ndeclare var HTMLFormElement: {\n    prototype: HTMLFormElement;\n    new(): HTMLFormElement;\n};\n\ninterface HTMLFrameElementEventMap extends HTMLElementEventMap {\n    \"load\": Event;\n}\n\ninterface HTMLFrameElement extends HTMLElement, GetSVGDocument {\n    /**\n     * Specifies the properties of a border drawn around an object.\n     */\n    border: string;\n    /**\n     * Sets or retrieves the border color of the object.\n     */\n    borderColor: any;\n    /**\n     * Retrieves the document object of the page or frame.\n     */\n    readonly contentDocument: Document;\n    /**\n     * Retrieves the object of the specified.\n     */\n    readonly contentWindow: Window;\n    /**\n     * Sets or retrieves whether to display a border for the frame.\n     */\n    frameBorder: string;\n    /**\n     * Sets or retrieves the amount of additional space between the frames.\n     */\n    frameSpacing: any;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: string | number;\n    /**\n     * Sets or retrieves a URI to a long description of the object.\n     */\n    longDesc: string;\n    /**\n     * Sets or retrieves the top and bottom margin heights before displaying the text in a frame.\n     */\n    marginHeight: string;\n    /**\n     * Sets or retrieves the left and right margin widths before displaying the text in a frame.\n     */\n    marginWidth: string;\n    /**\n     * Sets or retrieves the frame name.\n     */\n    name: string;\n    /**\n     * Sets or retrieves whether the user can resize the frame.\n     */\n    noResize: boolean;\n    /**\n     * Raised when the object has been completely received from the server.\n     */\n    onload: (this: HTMLFrameElement, ev: Event) => any;\n    /**\n     * Sets or retrieves whether the frame can be scrolled.\n     */\n    scrolling: string;\n    /**\n     * Sets or retrieves a URL to be loaded by the object.\n     */\n    src: string;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: string | number;\n    addEventListener<K extends keyof HTMLFrameElementEventMap>(type: K, listener: (this: HTMLFrameElement, ev: HTMLFrameElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLFrameElement: {\n    prototype: HTMLFrameElement;\n    new(): HTMLFrameElement;\n};\n\ninterface HTMLFrameSetElementEventMap extends HTMLElementEventMap {\n    \"afterprint\": Event;\n    \"beforeprint\": Event;\n    \"beforeunload\": BeforeUnloadEvent;\n    \"blur\": FocusEvent;\n    \"error\": ErrorEvent;\n    \"focus\": FocusEvent;\n    \"hashchange\": HashChangeEvent;\n    \"load\": Event;\n    \"message\": MessageEvent;\n    \"offline\": Event;\n    \"online\": Event;\n    \"orientationchange\": Event;\n    \"pagehide\": PageTransitionEvent;\n    \"pageshow\": PageTransitionEvent;\n    \"popstate\": PopStateEvent;\n    \"resize\": UIEvent;\n    \"scroll\": UIEvent;\n    \"storage\": StorageEvent;\n    \"unload\": Event;\n}\n\ninterface HTMLFrameSetElement extends HTMLElement {\n    border: string;\n    /**\n     * Sets or retrieves the border color of the object.\n     */\n    borderColor: any;\n    /**\n     * Sets or retrieves the frame widths of the object.\n     */\n    cols: string;\n    /**\n     * Sets or retrieves whether to display a border for the frame.\n     */\n    frameBorder: string;\n    /**\n     * Sets or retrieves the amount of additional space between the frames.\n     */\n    frameSpacing: any;\n    name: string;\n    onafterprint: (this: HTMLFrameSetElement, ev: Event) => any;\n    onbeforeprint: (this: HTMLFrameSetElement, ev: Event) => any;\n    onbeforeunload: (this: HTMLFrameSetElement, ev: BeforeUnloadEvent) => any;\n    /**\n     * Fires when the object loses the input focus.\n     */\n    onblur: (this: HTMLFrameSetElement, ev: FocusEvent) => any;\n    onerror: (this: HTMLFrameSetElement, ev: ErrorEvent) => any;\n    /**\n     * Fires when the object receives focus.\n     */\n    onfocus: (this: HTMLFrameSetElement, ev: FocusEvent) => any;\n    onhashchange: (this: HTMLFrameSetElement, ev: HashChangeEvent) => any;\n    onload: (this: HTMLFrameSetElement, ev: Event) => any;\n    onmessage: (this: HTMLFrameSetElement, ev: MessageEvent) => any;\n    onoffline: (this: HTMLFrameSetElement, ev: Event) => any;\n    ononline: (this: HTMLFrameSetElement, ev: Event) => any;\n    onorientationchange: (this: HTMLFrameSetElement, ev: Event) => any;\n    onpagehide: (this: HTMLFrameSetElement, ev: PageTransitionEvent) => any;\n    onpageshow: (this: HTMLFrameSetElement, ev: PageTransitionEvent) => any;\n    onpopstate: (this: HTMLFrameSetElement, ev: PopStateEvent) => any;\n    onresize: (this: HTMLFrameSetElement, ev: UIEvent) => any;\n    onscroll: (this: HTMLFrameSetElement, ev: UIEvent) => any;\n    onstorage: (this: HTMLFrameSetElement, ev: StorageEvent) => any;\n    onunload: (this: HTMLFrameSetElement, ev: Event) => any;\n    /**\n     * Sets or retrieves the frame heights of the object.\n     */\n    rows: string;\n    addEventListener<K extends keyof HTMLFrameSetElementEventMap>(type: K, listener: (this: HTMLFrameSetElement, ev: HTMLFrameSetElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLFrameSetElement: {\n    prototype: HTMLFrameSetElement;\n    new(): HTMLFrameSetElement;\n};\n\ninterface HTMLHeadElement extends HTMLElement {\n    profile: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHeadElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLHeadElement: {\n    prototype: HTMLHeadElement;\n    new(): HTMLHeadElement;\n};\n\ninterface HTMLHeadingElement extends HTMLElement {\n    /**\n     * Sets or retrieves a value that indicates the table alignment.\n     */\n    align: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHeadingElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLHeadingElement: {\n    prototype: HTMLHeadingElement;\n    new(): HTMLHeadingElement;\n};\n\ninterface HTMLHRElement extends HTMLElement, DOML2DeprecatedColorProperty, DOML2DeprecatedSizeProperty {\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    align: string;\n    /**\n     * Sets or retrieves whether the horizontal rule is drawn with 3-D shading.\n     */\n    noShade: boolean;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHRElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLHRElement: {\n    prototype: HTMLHRElement;\n    new(): HTMLHRElement;\n};\n\ninterface HTMLHtmlElement extends HTMLElement {\n    /**\n     * Sets or retrieves the DTD version that governs the current document.\n     */\n    version: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHtmlElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLHtmlElement: {\n    prototype: HTMLHtmlElement;\n    new(): HTMLHtmlElement;\n};\n\ninterface HTMLIFrameElementEventMap extends HTMLElementEventMap {\n    \"load\": Event;\n}\n\ninterface HTMLIFrameElement extends HTMLElement, GetSVGDocument {\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    align: string;\n    allowFullscreen: boolean;\n    allowPaymentRequest: boolean;\n    /**\n     * Specifies the properties of a border drawn around an object.\n     */\n    border: string;\n    /**\n     * Retrieves the document object of the page or frame.\n     */\n    readonly contentDocument: Document;\n    /**\n     * Retrieves the object of the specified.\n     */\n    readonly contentWindow: Window;\n    /**\n     * Sets or retrieves whether to display a border for the frame.\n     */\n    frameBorder: string;\n    /**\n     * Sets or retrieves the amount of additional space between the frames.\n     */\n    frameSpacing: any;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: string;\n    /**\n     * Sets or retrieves the horizontal margin for the object.\n     */\n    hspace: number;\n    /**\n     * Sets or retrieves a URI to a long description of the object.\n     */\n    longDesc: string;\n    /**\n     * Sets or retrieves the top and bottom margin heights before displaying the text in a frame.\n     */\n    marginHeight: string;\n    /**\n     * Sets or retrieves the left and right margin widths before displaying the text in a frame.\n     */\n    marginWidth: string;\n    /**\n     * Sets or retrieves the frame name.\n     */\n    name: string;\n    /**\n     * Sets or retrieves whether the user can resize the frame.\n     */\n    noResize: boolean;\n    /**\n     * Raised when the object has been completely received from the server.\n     */\n    onload: (this: HTMLIFrameElement, ev: Event) => any;\n    readonly sandbox: DOMSettableTokenList;\n    /**\n     * Sets or retrieves whether the frame can be scrolled.\n     */\n    scrolling: string;\n    /**\n     * Sets or retrieves a URL to be loaded by the object.\n     */\n    src: string;\n    /**\n     * Sets or retrieves the vertical margin for the object.\n     */\n    vspace: number;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: string;\n    addEventListener<K extends keyof HTMLIFrameElementEventMap>(type: K, listener: (this: HTMLIFrameElement, ev: HTMLIFrameElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLIFrameElement: {\n    prototype: HTMLIFrameElement;\n    new(): HTMLIFrameElement;\n};\n\ninterface HTMLImageElement extends HTMLElement {\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    align: string;\n    /**\n     * Sets or retrieves a text alternative to the graphic.\n     */\n    alt: string;\n    /**\n     * Specifies the properties of a border drawn around an object.\n     */\n    border: string;\n    /**\n     * Retrieves whether the object is fully loaded.\n     */\n    readonly complete: boolean;\n    crossOrigin: string | null;\n    readonly currentSrc: string;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: number;\n    /**\n     * Sets or retrieves the width of the border to draw around the object.\n     */\n    hspace: number;\n    /**\n     * Sets or retrieves whether the image is a server-side image map.\n     */\n    isMap: boolean;\n    /**\n     * Sets or retrieves a Uniform Resource Identifier (URI) to a long description of the object.\n     */\n    longDesc: string;\n    lowsrc: string;\n    /**\n     * Gets or sets whether the DLNA PlayTo device is available.\n     */\n    msPlayToDisabled: boolean;\n    msPlayToPreferredSourceUri: string;\n    /**\n     * Gets or sets the primary DLNA PlayTo device.\n     */\n    msPlayToPrimary: boolean;\n    /**\n     * Gets the source associated with the media element for use by the PlayToManager.\n     */\n    readonly msPlayToSource: any;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    /**\n     * The original height of the image resource before sizing.\n     */\n    readonly naturalHeight: number;\n    /**\n     * The original width of the image resource before sizing.\n     */\n    readonly naturalWidth: number;\n    sizes: string;\n    /**\n     * The address or URL of the a media resource that is to be considered.\n     */\n    src: string;\n    srcset: string;\n    /**\n     * Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map.\n     */\n    useMap: string;\n    /**\n     * Sets or retrieves the vertical margin for the object.\n     */\n    vspace: number;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: number;\n    readonly x: number;\n    readonly y: number;\n    msGetAsCastingSource(): any;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLImageElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLImageElement: {\n    prototype: HTMLImageElement;\n    new(): HTMLImageElement;\n};\n\ninterface HTMLInputElement extends HTMLElement {\n    /**\n     * Sets or retrieves a comma-separated list of content types.\n     */\n    accept: string;\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    align: string;\n    /**\n     * Sets or retrieves a text alternative to the graphic.\n     */\n    alt: string;\n    /**\n     * Specifies whether autocomplete is applied to an editable text field.\n     */\n    autocomplete: string;\n    /**\n     * Provides a way to direct a user to a specific field when a document loads. This can provide both direction and convenience for a user, reducing the need to click or tab to a field when a page opens. This attribute is true when present on an element, and false when missing.\n     */\n    autofocus: boolean;\n    /**\n     * Sets or retrieves the width of the border to draw around the object.\n     */\n    border: string;\n    /**\n     * Sets or retrieves the state of the check box or radio button.\n     */\n    checked: boolean;\n    /**\n     * Retrieves whether the object is fully loaded.\n     */\n    readonly complete: boolean;\n    /**\n     * Sets or retrieves the state of the check box or radio button.\n     */\n    defaultChecked: boolean;\n    /**\n     * Sets or retrieves the initial contents of the object.\n     */\n    defaultValue: string;\n    disabled: boolean;\n    /**\n     * Returns a FileList object on a file type input object.\n     */\n    readonly files: FileList | null;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement;\n    /**\n     * Overrides the action attribute (where the data on a form is sent) on the parent form element.\n     */\n    formAction: string;\n    /**\n     * Used to override the encoding (formEnctype attribute) specified on the form element.\n     */\n    formEnctype: string;\n    /**\n     * Overrides the submit method attribute previously specified on a form element.\n     */\n    formMethod: string;\n    /**\n     * Overrides any validation or required attributes on a form or form elements to allow it to be submitted without validation. This can be used to create a \"save draft\"-type submit option.\n     */\n    formNoValidate: string;\n    /**\n     * Overrides the target attribute on a form element.\n     */\n    formTarget: string;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: string;\n    /**\n     * Sets or retrieves the width of the border to draw around the object.\n     */\n    hspace: number;\n    indeterminate: boolean;\n    /**\n     * Specifies the ID of a pre-defined datalist of options for an input element.\n     */\n    readonly list: HTMLElement;\n    /**\n     * Defines the maximum acceptable value for an input element with type=\"number\".When used with the min and step attributes, lets you control the range and increment (such as only even numbers) that the user can enter into an input field.\n     */\n    max: string;\n    /**\n     * Sets or retrieves the maximum number of characters that the user can enter in a text control.\n     */\n    maxLength: number;\n    /**\n     * Defines the minimum acceptable value for an input element with type=\"number\". When used with the max and step attributes, lets you control the range and increment (such as even numbers only) that the user can enter into an input field.\n     */\n    min: string;\n    /**\n     * Sets or retrieves the Boolean value indicating whether multiple items can be selected from a list.\n     */\n    multiple: boolean;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    /**\n     * Gets or sets a string containing a regular expression that the user's input must match.\n     */\n    pattern: string;\n    /**\n     * Gets or sets a text string that is displayed in an input field as a hint or prompt to users as the format or type of information they need to enter.The text appears in an input field until the user puts focus on the field.\n     */\n    placeholder: string;\n    readOnly: boolean;\n    /**\n     * When present, marks an element that can't be submitted without a value.\n     */\n    required: boolean;\n    selectionDirection: string;\n    /**\n     * Gets or sets the end position or offset of a text selection.\n     */\n    selectionEnd: number;\n    /**\n     * Gets or sets the starting position or offset of a text selection.\n     */\n    selectionStart: number;\n    size: number;\n    /**\n     * The address or URL of the a media resource that is to be considered.\n     */\n    src: string;\n    status: boolean;\n    /**\n     * Defines an increment or jump between values that you want to allow the user to enter. When used with the max and min attributes, lets you control the range and increment (for example, allow only even numbers) that the user can enter into an input field.\n     */\n    step: string;\n    /**\n     * Returns the content type of the object.\n     */\n    type: string;\n    /**\n     * Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map.\n     */\n    useMap: string;\n    /**\n     * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as \"this is a required field\". The result is that the user sees validation messages without actually submitting.\n     */\n    readonly validationMessage: string;\n    /**\n     * Returns a  ValidityState object that represents the validity states of an element.\n     */\n    readonly validity: ValidityState;\n    /**\n     * Returns the value of the data at the cursor's current position.\n     */\n    value: string;\n    valueAsDate: Date;\n    /**\n     * Returns the input field value as a number.\n     */\n    valueAsNumber: number;\n    /**\n     * Sets or retrieves the vertical margin for the object.\n     */\n    vspace: number;\n    webkitdirectory: boolean;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: string;\n    /**\n     * Returns whether an element will successfully validate based on forms validation rules and constraints.\n     */\n    readonly willValidate: boolean;\n    minLength: number;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    /**\n     * Makes the selection equal to the current object.\n     */\n    select(): void;\n    /**\n     * Sets a custom error message that is displayed when a form is submitted.\n     * @param error Sets a custom error message that is displayed when a form is submitted.\n     */\n    setCustomValidity(error: string): void;\n    /**\n     * Sets the start and end positions of a selection in a text field.\n     * @param start The offset into the text field for the start of the selection.\n     * @param end The offset into the text field for the end of the selection.\n     */\n    setSelectionRange(start?: number, end?: number, direction?: string): void;\n    /**\n     * Decrements a range input control's value by the value given by the Step attribute. If the optional parameter is used, it will decrement the input control's step value multiplied by the parameter's value.\n     * @param n Value to decrement the value by.\n     */\n    stepDown(n?: number): void;\n    /**\n     * Increments a range input control's value by the value given by the Step attribute. If the optional parameter is used, will increment the input control's value by that value.\n     * @param n Value to increment the value by.\n     */\n    stepUp(n?: number): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLInputElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLInputElement: {\n    prototype: HTMLInputElement;\n    new(): HTMLInputElement;\n};\n\ninterface HTMLLabelElement extends HTMLElement {\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement;\n    /**\n     * Sets or retrieves the object to which the given label object is assigned.\n     */\n    htmlFor: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLabelElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLLabelElement: {\n    prototype: HTMLLabelElement;\n    new(): HTMLLabelElement;\n};\n\ninterface HTMLLegendElement extends HTMLElement {\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    align: string;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLegendElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLLegendElement: {\n    prototype: HTMLLegendElement;\n    new(): HTMLLegendElement;\n};\n\ninterface HTMLLIElement extends HTMLElement {\n    type: string;\n    /**\n     * Sets or retrieves the value of a list item.\n     */\n    value: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLIElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLLIElement: {\n    prototype: HTMLLIElement;\n    new(): HTMLLIElement;\n};\n\ninterface HTMLLinkElement extends HTMLElement, LinkStyle {\n    /**\n     * Sets or retrieves the character set used to encode the object.\n     */\n    charset: string;\n    disabled: boolean;\n    /**\n     * Sets or retrieves a destination URL or an anchor point.\n     */\n    href: string;\n    /**\n     * Sets or retrieves the language code of the object.\n     */\n    hreflang: string;\n    /**\n     * Sets or retrieves the media type.\n     */\n    media: string;\n    /**\n     * Sets or retrieves the relationship between the object and the destination of the link.\n     */\n    rel: string;\n    /**\n     * Sets or retrieves the relationship between the object and the destination of the link.\n     */\n    rev: string;\n    /**\n     * Sets or retrieves the window or frame at which to target content.\n     */\n    target: string;\n    /**\n     * Sets or retrieves the MIME type of the object.\n     */\n    type: string;\n    import?: Document;\n    integrity: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLinkElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLLinkElement: {\n    prototype: HTMLLinkElement;\n    new(): HTMLLinkElement;\n};\n\ninterface HTMLMapElement extends HTMLElement {\n    /**\n     * Retrieves a collection of the area objects defined for the given map object.\n     */\n    readonly areas: HTMLAreasCollection;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMapElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLMapElement: {\n    prototype: HTMLMapElement;\n    new(): HTMLMapElement;\n};\n\ninterface HTMLMarqueeElementEventMap extends HTMLElementEventMap {\n    \"bounce\": Event;\n    \"finish\": Event;\n    \"start\": Event;\n}\n\ninterface HTMLMarqueeElement extends HTMLElement {\n    behavior: string;\n    bgColor: any;\n    direction: string;\n    height: string;\n    hspace: number;\n    loop: number;\n    onbounce: (this: HTMLMarqueeElement, ev: Event) => any;\n    onfinish: (this: HTMLMarqueeElement, ev: Event) => any;\n    onstart: (this: HTMLMarqueeElement, ev: Event) => any;\n    scrollAmount: number;\n    scrollDelay: number;\n    trueSpeed: boolean;\n    vspace: number;\n    width: string;\n    start(): void;\n    stop(): void;\n    addEventListener<K extends keyof HTMLMarqueeElementEventMap>(type: K, listener: (this: HTMLMarqueeElement, ev: HTMLMarqueeElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLMarqueeElement: {\n    prototype: HTMLMarqueeElement;\n    new(): HTMLMarqueeElement;\n};\n\ninterface HTMLMediaElementEventMap extends HTMLElementEventMap {\n    \"encrypted\": MediaEncryptedEvent;\n    \"msneedkey\": MSMediaKeyNeededEvent;\n}\n\ninterface HTMLMediaElement extends HTMLElement {\n    /**\n     * Returns an AudioTrackList object with the audio tracks for a given video element.\n     */\n    readonly audioTracks: AudioTrackList;\n    /**\n     * Gets or sets a value that indicates whether to start playing the media automatically.\n     */\n    autoplay: boolean;\n    /**\n     * Gets a collection of buffered time ranges.\n     */\n    readonly buffered: TimeRanges;\n    /**\n     * Gets or sets a flag that indicates whether the client provides a set of controls for the media (in case the developer does not include controls for the player).\n     */\n    controls: boolean;\n    crossOrigin: string | null;\n    /**\n     * Gets the address or URL of the current media resource that is selected by IHTMLMediaElement.\n     */\n    readonly currentSrc: string;\n    /**\n     * Gets or sets the current playback position, in seconds.\n     */\n    currentTime: number;\n    defaultMuted: boolean;\n    /**\n     * Gets or sets the default playback rate when the user is not using fast forward or reverse for a video or audio resource.\n     */\n    defaultPlaybackRate: number;\n    /**\n     * Returns the duration in seconds of the current media resource. A NaN value is returned if duration is not available, or Infinity if the media resource is streaming.\n     */\n    readonly duration: number;\n    /**\n     * Gets information about whether the playback has ended or not.\n     */\n    readonly ended: boolean;\n    /**\n     * Returns an object representing the current error state of the audio or video element.\n     */\n    readonly error: MediaError;\n    /**\n     * Gets or sets a flag to specify whether playback should restart after it completes.\n     */\n    loop: boolean;\n    readonly mediaKeys: MediaKeys | null;\n    /**\n     * Specifies the purpose of the audio or video media, such as background audio or alerts.\n     */\n    msAudioCategory: string;\n    /**\n     * Specifies the output device id that the audio will be sent to.\n     */\n    msAudioDeviceType: string;\n    readonly msGraphicsTrustStatus: MSGraphicsTrust;\n    /**\n     * Gets the MSMediaKeys object, which is used for decrypting media data, that is associated with this media element.\n     */\n    readonly msKeys: MSMediaKeys;\n    /**\n     * Gets or sets whether the DLNA PlayTo device is available.\n     */\n    msPlayToDisabled: boolean;\n    /**\n     * Gets or sets the path to the preferred media source. This enables the Play To target device to stream the media content, which can be DRM protected, from a different location, such as a cloud media server.\n     */\n    msPlayToPreferredSourceUri: string;\n    /**\n     * Gets or sets the primary DLNA PlayTo device.\n     */\n    msPlayToPrimary: boolean;\n    /**\n     * Gets the source associated with the media element for use by the PlayToManager.\n     */\n    readonly msPlayToSource: any;\n    /**\n     * Specifies whether or not to enable low-latency playback on the media element.\n     */\n    msRealTime: boolean;\n    /**\n     * Gets or sets a flag that indicates whether the audio (either audio or the audio track on video media) is muted.\n     */\n    muted: boolean;\n    /**\n     * Gets the current network activity for the element.\n     */\n    readonly networkState: number;\n    onencrypted: (this: HTMLMediaElement, ev: MediaEncryptedEvent) => any;\n    onmsneedkey: (this: HTMLMediaElement, ev: MSMediaKeyNeededEvent) => any;\n    /**\n     * Gets a flag that specifies whether playback is paused.\n     */\n    readonly paused: boolean;\n    /**\n     * Gets or sets the current rate of speed for the media resource to play. This speed is expressed as a multiple of the normal speed of the media resource.\n     */\n    playbackRate: number;\n    /**\n     * Gets TimeRanges for the current media resource that has been played.\n     */\n    readonly played: TimeRanges;\n    /**\n     * Gets or sets the current playback position, in seconds.\n     */\n    preload: string;\n    readyState: number;\n    /**\n     * Returns a TimeRanges object that represents the ranges of the current media resource that can be seeked.\n     */\n    readonly seekable: TimeRanges;\n    /**\n     * Gets a flag that indicates whether the the client is currently moving to a new playback position in the media resource.\n     */\n    readonly seeking: boolean;\n    /**\n     * The address or URL of the a media resource that is to be considered.\n     */\n    src: string;\n    srcObject: MediaStream | null;\n    readonly textTracks: TextTrackList;\n    readonly videoTracks: VideoTrackList;\n    /**\n     * Gets or sets the volume level for audio portions of the media element.\n     */\n    volume: number;\n    addTextTrack(kind: string, label?: string, language?: string): TextTrack;\n    /**\n     * Returns a string that specifies whether the client can play a given media resource type.\n     */\n    canPlayType(type: string): string;\n    /**\n     * Resets the audio or video object and loads a new media resource.\n     */\n    load(): void;\n    /**\n     * Clears all effects from the media pipeline.\n     */\n    msClearEffects(): void;\n    msGetAsCastingSource(): any;\n    /**\n     * Inserts the specified audio effect into media pipeline.\n     */\n    msInsertAudioEffect(activatableClassId: string, effectRequired: boolean, config?: any): void;\n    msSetMediaKeys(mediaKeys: MSMediaKeys): void;\n    /**\n     * Specifies the media protection manager for a given media pipeline.\n     */\n    msSetMediaProtectionManager(mediaProtectionManager?: any): void;\n    /**\n     * Pauses the current playback and sets paused to TRUE. This can be used to test whether the media is playing or paused. You can also use the pause or play events to tell whether the media is playing or not.\n     */\n    pause(): void;\n    /**\n     * Loads and starts playback of a media resource.\n     */\n    play(): Promise<void>;\n    setMediaKeys(mediaKeys: MediaKeys | null): Promise<void>;\n    readonly HAVE_CURRENT_DATA: number;\n    readonly HAVE_ENOUGH_DATA: number;\n    readonly HAVE_FUTURE_DATA: number;\n    readonly HAVE_METADATA: number;\n    readonly HAVE_NOTHING: number;\n    readonly NETWORK_EMPTY: number;\n    readonly NETWORK_IDLE: number;\n    readonly NETWORK_LOADING: number;\n    readonly NETWORK_NO_SOURCE: number;\n    addEventListener<K extends keyof HTMLMediaElementEventMap>(type: K, listener: (this: HTMLMediaElement, ev: HTMLMediaElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLMediaElement: {\n    prototype: HTMLMediaElement;\n    new(): HTMLMediaElement;\n    readonly HAVE_CURRENT_DATA: number;\n    readonly HAVE_ENOUGH_DATA: number;\n    readonly HAVE_FUTURE_DATA: number;\n    readonly HAVE_METADATA: number;\n    readonly HAVE_NOTHING: number;\n    readonly NETWORK_EMPTY: number;\n    readonly NETWORK_IDLE: number;\n    readonly NETWORK_LOADING: number;\n    readonly NETWORK_NO_SOURCE: number;\n};\n\ninterface HTMLMenuElement extends HTMLElement {\n    compact: boolean;\n    type: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMenuElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLMenuElement: {\n    prototype: HTMLMenuElement;\n    new(): HTMLMenuElement;\n};\n\ninterface HTMLMetaElement extends HTMLElement {\n    /**\n     * Sets or retrieves the character set used to encode the object.\n     */\n    charset: string;\n    /**\n     * Gets or sets meta-information to associate with httpEquiv or name.\n     */\n    content: string;\n    /**\n     * Gets or sets information used to bind the value of a content attribute of a meta element to an HTTP response header.\n     */\n    httpEquiv: string;\n    /**\n     * Sets or retrieves the value specified in the content attribute of the meta object.\n     */\n    name: string;\n    /**\n     * Sets or retrieves a scheme to be used in interpreting the value of a property specified for the object.\n     */\n    scheme: string;\n    /**\n     * Sets or retrieves the URL property that will be loaded after the specified time has elapsed.\n     */\n    url: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMetaElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLMetaElement: {\n    prototype: HTMLMetaElement;\n    new(): HTMLMetaElement;\n};\n\ninterface HTMLMeterElement extends HTMLElement {\n    high: number;\n    low: number;\n    max: number;\n    min: number;\n    optimum: number;\n    value: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMeterElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLMeterElement: {\n    prototype: HTMLMeterElement;\n    new(): HTMLMeterElement;\n};\n\ninterface HTMLModElement extends HTMLElement {\n    /**\n     * Sets or retrieves reference information about the object.\n     */\n    cite: string;\n    /**\n     * Sets or retrieves the date and time of a modification to the object.\n     */\n    dateTime: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLModElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLModElement: {\n    prototype: HTMLModElement;\n    new(): HTMLModElement;\n};\n\ninterface HTMLObjectElement extends HTMLElement, GetSVGDocument {\n    align: string;\n    /**\n     * Sets or retrieves a text alternative to the graphic.\n     */\n    alt: string;\n    /**\n     * Gets or sets the optional alternative HTML script to execute if the object fails to load.\n     */\n    altHtml: string;\n    /**\n     * Sets or retrieves a character string that can be used to implement your own archive functionality for the object.\n     */\n    archive: string;\n    /**\n     * Retrieves a string of the URL where the object tag can be found. This is often the href of the document that the object is in, or the value set by a base element.\n     */\n    readonly BaseHref: string;\n    border: string;\n    /**\n     * Sets or retrieves the URL of the file containing the compiled Java class.\n     */\n    code: string;\n    /**\n     * Sets or retrieves the URL of the component.\n     */\n    codeBase: string;\n    /**\n     * Sets or retrieves the Internet media type for the code associated with the object.\n     */\n    codeType: string;\n    /**\n     * Retrieves the document object of the page or frame.\n     */\n    readonly contentDocument: Document;\n    /**\n     * Sets or retrieves the URL that references the data of the object.\n     */\n    data: string;\n    declare: boolean;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: string;\n    hspace: number;\n    /**\n     * Gets or sets whether the DLNA PlayTo device is available.\n     */\n    msPlayToDisabled: boolean;\n    /**\n     * Gets or sets the path to the preferred media source. This enables the Play To target device to stream the media content, which can be DRM protected, from a different location, such as a cloud media server.\n     */\n    msPlayToPreferredSourceUri: string;\n    /**\n     * Gets or sets the primary DLNA PlayTo device.\n     */\n    msPlayToPrimary: boolean;\n    /**\n     * Gets the source associated with the media element for use by the PlayToManager.\n     */\n    readonly msPlayToSource: any;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    readonly readyState: number;\n    /**\n     * Sets or retrieves a message to be displayed while an object is loading.\n     */\n    standby: string;\n    /**\n     * Sets or retrieves the MIME type of the object.\n     */\n    type: string;\n    /**\n     * Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map.\n     */\n    useMap: string;\n    /**\n     * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as \"this is a required field\". The result is that the user sees validation messages without actually submitting.\n     */\n    readonly validationMessage: string;\n    /**\n     * Returns a  ValidityState object that represents the validity states of an element.\n     */\n    readonly validity: ValidityState;\n    vspace: number;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: string;\n    /**\n     * Returns whether an element will successfully validate based on forms validation rules and constraints.\n     */\n    readonly willValidate: boolean;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    /**\n     * Sets a custom error message that is displayed when a form is submitted.\n     * @param error Sets a custom error message that is displayed when a form is submitted.\n     */\n    setCustomValidity(error: string): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLObjectElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLObjectElement: {\n    prototype: HTMLObjectElement;\n    new(): HTMLObjectElement;\n};\n\ninterface HTMLOListElement extends HTMLElement {\n    compact: boolean;\n    /**\n     * The starting number.\n     */\n    start: number;\n    type: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOListElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLOListElement: {\n    prototype: HTMLOListElement;\n    new(): HTMLOListElement;\n};\n\ninterface HTMLOptGroupElement extends HTMLElement {\n    /**\n     * Sets or retrieves the status of an option.\n     */\n    defaultSelected: boolean;\n    disabled: boolean;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement;\n    /**\n     * Sets or retrieves the ordinal position of an option in a list box.\n     */\n    readonly index: number;\n    /**\n     * Sets or retrieves a value that you can use to implement your own label functionality for the object.\n     */\n    label: string;\n    /**\n     * Sets or retrieves whether the option in the list box is the default item.\n     */\n    selected: boolean;\n    /**\n     * Sets or retrieves the text string specified by the option tag.\n     */\n    readonly text: string;\n    /**\n     * Sets or retrieves the value which is returned to the server when the form control is submitted.\n     */\n    value: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOptGroupElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLOptGroupElement: {\n    prototype: HTMLOptGroupElement;\n    new(): HTMLOptGroupElement;\n};\n\ninterface HTMLOptionElement extends HTMLElement {\n    /**\n     * Sets or retrieves the status of an option.\n     */\n    defaultSelected: boolean;\n    disabled: boolean;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement;\n    /**\n     * Sets or retrieves the ordinal position of an option in a list box.\n     */\n    readonly index: number;\n    /**\n     * Sets or retrieves a value that you can use to implement your own label functionality for the object.\n     */\n    label: string;\n    /**\n     * Sets or retrieves whether the option in the list box is the default item.\n     */\n    selected: boolean;\n    /**\n     * Sets or retrieves the text string specified by the option tag.\n     */\n    text: string;\n    /**\n     * Sets or retrieves the value which is returned to the server when the form control is submitted.\n     */\n    value: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOptionElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLOptionElement: {\n    prototype: HTMLOptionElement;\n    new(): HTMLOptionElement;\n};\n\ninterface HTMLOptionsCollection extends HTMLCollectionOf<HTMLOptionElement> {\n    length: number;\n    selectedIndex: number;\n    add(element: HTMLOptionElement | HTMLOptGroupElement, before?: HTMLElement | number): void;\n    remove(index: number): void;\n}\n\ndeclare var HTMLOptionsCollection: {\n    prototype: HTMLOptionsCollection;\n    new(): HTMLOptionsCollection;\n};\n\ninterface HTMLOutputElement extends HTMLElement {\n    defaultValue: string;\n    readonly form: HTMLFormElement;\n    readonly htmlFor: DOMSettableTokenList;\n    name: string;\n    readonly type: string;\n    readonly validationMessage: string;\n    readonly validity: ValidityState;\n    value: string;\n    readonly willValidate: boolean;\n    checkValidity(): boolean;\n    reportValidity(): boolean;\n    setCustomValidity(error: string): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOutputElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLOutputElement: {\n    prototype: HTMLOutputElement;\n    new(): HTMLOutputElement;\n};\n\ninterface HTMLParagraphElement extends HTMLElement {\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    align: string;\n    clear: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLParagraphElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLParagraphElement: {\n    prototype: HTMLParagraphElement;\n    new(): HTMLParagraphElement;\n};\n\ninterface HTMLParamElement extends HTMLElement {\n    /**\n     * Sets or retrieves the name of an input parameter for an element.\n     */\n    name: string;\n    /**\n     * Sets or retrieves the content type of the resource designated by the value attribute.\n     */\n    type: string;\n    /**\n     * Sets or retrieves the value of an input parameter for an element.\n     */\n    value: string;\n    /**\n     * Sets or retrieves the data type of the value attribute.\n     */\n    valueType: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLParamElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLParamElement: {\n    prototype: HTMLParamElement;\n    new(): HTMLParamElement;\n};\n\ninterface HTMLPictureElement extends HTMLElement {\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLPictureElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLPictureElement: {\n    prototype: HTMLPictureElement;\n    new(): HTMLPictureElement;\n};\n\ninterface HTMLPreElement extends HTMLElement {\n    /**\n     * Sets or gets a value that you can use to implement your own width functionality for the object.\n     */\n    width: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLPreElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLPreElement: {\n    prototype: HTMLPreElement;\n    new(): HTMLPreElement;\n};\n\ninterface HTMLProgressElement extends HTMLElement {\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement;\n    /**\n     * Defines the maximum, or \"done\" value for a progress element.\n     */\n    max: number;\n    /**\n     * Returns the quotient of value/max when the value attribute is set (determinate progress bar), or -1 when the value attribute is missing (indeterminate progress bar).\n     */\n    readonly position: number;\n    /**\n     * Sets or gets the current value of a progress element. The value must be a non-negative number between 0 and the max value.\n     */\n    value: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLProgressElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLProgressElement: {\n    prototype: HTMLProgressElement;\n    new(): HTMLProgressElement;\n};\n\ninterface HTMLQuoteElement extends HTMLElement {\n    /**\n     * Sets or retrieves reference information about the object.\n     */\n    cite: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLQuoteElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLQuoteElement: {\n    prototype: HTMLQuoteElement;\n    new(): HTMLQuoteElement;\n};\n\ninterface HTMLScriptElement extends HTMLElement {\n    async: boolean;\n    /**\n     * Sets or retrieves the character set used to encode the object.\n     */\n    charset: string;\n    crossOrigin: string | null;\n    /**\n     * Sets or retrieves the status of the script.\n     */\n    defer: boolean;\n    /**\n     * Sets or retrieves the event for which the script is written.\n     */\n    event: string;\n    /**\n     * Sets or retrieves the object that is bound to the event script.\n     */\n    htmlFor: string;\n    /**\n     * Retrieves the URL to an external file that contains the source code or data.\n     */\n    src: string;\n    /**\n     * Retrieves or sets the text of the object as a string.\n     */\n    text: string;\n    /**\n     * Sets or retrieves the MIME type for the associated scripting engine.\n     */\n    type: string;\n    integrity: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLScriptElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLScriptElement: {\n    prototype: HTMLScriptElement;\n    new(): HTMLScriptElement;\n};\n\ninterface HTMLSelectElement extends HTMLElement {\n    /**\n     * Provides a way to direct a user to a specific field when a document loads. This can provide both direction and convenience for a user, reducing the need to click or tab to a field when a page opens. This attribute is true when present on an element, and false when missing.\n     */\n    autofocus: boolean;\n    disabled: boolean;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement;\n    /**\n     * Sets or retrieves the number of objects in a collection.\n     */\n    length: number;\n    /**\n     * Sets or retrieves the Boolean value indicating whether multiple items can be selected from a list.\n     */\n    multiple: boolean;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    readonly options: HTMLOptionsCollection;\n    /**\n     * When present, marks an element that can't be submitted without a value.\n     */\n    required: boolean;\n    /**\n     * Sets or retrieves the index of the selected option in a select object.\n     */\n    selectedIndex: number;\n    selectedOptions: HTMLCollectionOf<HTMLOptionElement>;\n    /**\n     * Sets or retrieves the number of rows in the list box.\n     */\n    size: number;\n    /**\n     * Retrieves the type of select control based on the value of the MULTIPLE attribute.\n     */\n    readonly type: string;\n    /**\n     * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as \"this is a required field\". The result is that the user sees validation messages without actually submitting.\n     */\n    readonly validationMessage: string;\n    /**\n     * Returns a  ValidityState object that represents the validity states of an element.\n     */\n    readonly validity: ValidityState;\n    /**\n     * Sets or retrieves the value which is returned to the server when the form control is submitted.\n     */\n    value: string;\n    /**\n     * Returns whether an element will successfully validate based on forms validation rules and constraints.\n     */\n    readonly willValidate: boolean;\n    /**\n     * Adds an element to the areas, controlRange, or options collection.\n     * @param element Variant of type Number that specifies the index position in the collection where the element is placed. If no value is given, the method places the element at the end of the collection.\n     * @param before Variant of type Object that specifies an element to insert before, or null to append the object to the collection.\n     */\n    add(element: HTMLElement, before?: HTMLElement | number): void;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    /**\n     * Retrieves a select object or an object from an options collection.\n     * @param name Variant of type Number or String that specifies the object or collection to retrieve. If this parameter is an integer, it is the zero-based index of the object. If this parameter is a string, all objects with matching name or id properties are retrieved, and a collection is returned if more than one match is made.\n     * @param index Variant of type Number that specifies the zero-based index of the object to retrieve when a collection is returned.\n     */\n    item(name?: any, index?: any): any;\n    /**\n     * Retrieves a select object or an object from an options collection.\n     * @param namedItem A String that specifies the name or id property of the object to retrieve. A collection is returned if more than one match is made.\n     */\n    namedItem(name: string): any;\n    /**\n     * Removes an element from the collection.\n     * @param index Number that specifies the zero-based index of the element to remove from the collection.\n     */\n    remove(index?: number): void;\n    /**\n     * Sets a custom error message that is displayed when a form is submitted.\n     * @param error Sets a custom error message that is displayed when a form is submitted.\n     */\n    setCustomValidity(error: string): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSelectElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n    [name: string]: any;\n}\n\ndeclare var HTMLSelectElement: {\n    prototype: HTMLSelectElement;\n    new(): HTMLSelectElement;\n};\n\ninterface HTMLSourceElement extends HTMLElement {\n    /**\n     * Gets or sets the intended media type of the media source.\n     */\n    media: string;\n    msKeySystem: string;\n    sizes: string;\n    /**\n     * The address or URL of the a media resource that is to be considered.\n     */\n    src: string;\n    srcset: string;\n    /**\n     * Gets or sets the MIME type of a media resource.\n     */\n    type: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSourceElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLSourceElement: {\n    prototype: HTMLSourceElement;\n    new(): HTMLSourceElement;\n};\n\ninterface HTMLSpanElement extends HTMLElement {\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSpanElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLSpanElement: {\n    prototype: HTMLSpanElement;\n    new(): HTMLSpanElement;\n};\n\ninterface HTMLStyleElement extends HTMLElement, LinkStyle {\n    disabled: boolean;\n    /**\n     * Sets or retrieves the media type.\n     */\n    media: string;\n    /**\n     * Retrieves the CSS language in which the style sheet is written.\n     */\n    type: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLStyleElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLStyleElement: {\n    prototype: HTMLStyleElement;\n    new(): HTMLStyleElement;\n};\n\ninterface HTMLTableCaptionElement extends HTMLElement {\n    /**\n     * Sets or retrieves the alignment of the caption or legend.\n     */\n    align: string;\n    /**\n     * Sets or retrieves whether the caption appears at the top or bottom of the table.\n     */\n    vAlign: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableCaptionElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLTableCaptionElement: {\n    prototype: HTMLTableCaptionElement;\n    new(): HTMLTableCaptionElement;\n};\n\ninterface HTMLTableCellElement extends HTMLElement, HTMLTableAlignment {\n    /**\n     * Sets or retrieves abbreviated text for the object.\n     */\n    abbr: string;\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    align: string;\n    /**\n     * Sets or retrieves a comma-delimited list of conceptual categories associated with the object.\n     */\n    axis: string;\n    bgColor: any;\n    /**\n     * Retrieves the position of the object in the cells collection of a row.\n     */\n    readonly cellIndex: number;\n    /**\n     * Sets or retrieves the number columns in the table that the object should span.\n     */\n    colSpan: number;\n    /**\n     * Sets or retrieves a list of header cells that provide information for the object.\n     */\n    headers: string;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: any;\n    /**\n     * Sets or retrieves whether the browser automatically performs wordwrap.\n     */\n    noWrap: boolean;\n    /**\n     * Sets or retrieves how many rows in a table the cell should span.\n     */\n    rowSpan: number;\n    /**\n     * Sets or retrieves the group of cells in a table to which the object's information applies.\n     */\n    scope: string;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableCellElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLTableCellElement: {\n    prototype: HTMLTableCellElement;\n    new(): HTMLTableCellElement;\n};\n\ninterface HTMLTableColElement extends HTMLElement, HTMLTableAlignment {\n    /**\n     * Sets or retrieves the alignment of the object relative to the display or table.\n     */\n    align: string;\n    /**\n     * Sets or retrieves the number of columns in the group.\n     */\n    span: number;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: any;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableColElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLTableColElement: {\n    prototype: HTMLTableColElement;\n    new(): HTMLTableColElement;\n};\n\ninterface HTMLTableDataCellElement extends HTMLTableCellElement {\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableDataCellElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLTableDataCellElement: {\n    prototype: HTMLTableDataCellElement;\n    new(): HTMLTableDataCellElement;\n};\n\ninterface HTMLTableElement extends HTMLElement {\n    /**\n     * Sets or retrieves a value that indicates the table alignment.\n     */\n    align: string;\n    bgColor: any;\n    /**\n     * Sets or retrieves the width of the border to draw around the object.\n     */\n    border: string;\n    /**\n     * Sets or retrieves the border color of the object.\n     */\n    borderColor: any;\n    /**\n     * Retrieves the caption object of a table.\n     */\n    caption: HTMLTableCaptionElement;\n    /**\n     * Sets or retrieves the amount of space between the border of the cell and the content of the cell.\n     */\n    cellPadding: string;\n    /**\n     * Sets or retrieves the amount of space between cells in a table.\n     */\n    cellSpacing: string;\n    /**\n     * Sets or retrieves the number of columns in the table.\n     */\n    cols: number;\n    /**\n     * Sets or retrieves the way the border frame around the table is displayed.\n     */\n    frame: string;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: any;\n    /**\n     * Sets or retrieves the number of horizontal rows contained in the object.\n     */\n    rows: HTMLCollectionOf<HTMLTableRowElement>;\n    /**\n     * Sets or retrieves which dividing lines (inner borders) are displayed.\n     */\n    rules: string;\n    /**\n     * Sets or retrieves a description and/or structure of the object.\n     */\n    summary: string;\n    /**\n     * Retrieves a collection of all tBody objects in the table. Objects in this collection are in source order.\n     */\n    tBodies: HTMLCollectionOf<HTMLTableSectionElement>;\n    /**\n     * Retrieves the tFoot object of the table.\n     */\n    tFoot: HTMLTableSectionElement;\n    /**\n     * Retrieves the tHead object of the table.\n     */\n    tHead: HTMLTableSectionElement;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: string;\n    /**\n     * Creates an empty caption element in the table.\n     */\n    createCaption(): HTMLTableCaptionElement;\n    /**\n     * Creates an empty tBody element in the table.\n     */\n    createTBody(): HTMLTableSectionElement;\n    /**\n     * Creates an empty tFoot element in the table.\n     */\n    createTFoot(): HTMLTableSectionElement;\n    /**\n     * Returns the tHead element object if successful, or null otherwise.\n     */\n    createTHead(): HTMLTableSectionElement;\n    /**\n     * Deletes the caption element and its contents from the table.\n     */\n    deleteCaption(): void;\n    /**\n     * Removes the specified row (tr) from the element and from the rows collection.\n     * @param index Number that specifies the zero-based position in the rows collection of the row to remove.\n     */\n    deleteRow(index?: number): void;\n    /**\n     * Deletes the tFoot element and its contents from the table.\n     */\n    deleteTFoot(): void;\n    /**\n     * Deletes the tHead element and its contents from the table.\n     */\n    deleteTHead(): void;\n    /**\n     * Creates a new row (tr) in the table, and adds the row to the rows collection.\n     * @param index Number that specifies where to insert the row in the rows collection. The default value is -1, which appends the new row to the end of the rows collection.\n     */\n    insertRow(index?: number): HTMLTableRowElement;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLTableElement: {\n    prototype: HTMLTableElement;\n    new(): HTMLTableElement;\n};\n\ninterface HTMLTableHeaderCellElement extends HTMLTableCellElement {\n    /**\n     * Sets or retrieves the group of cells in a table to which the object's information applies.\n     */\n    scope: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableHeaderCellElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLTableHeaderCellElement: {\n    prototype: HTMLTableHeaderCellElement;\n    new(): HTMLTableHeaderCellElement;\n};\n\ninterface HTMLTableRowElement extends HTMLElement, HTMLTableAlignment {\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    align: string;\n    bgColor: any;\n    /**\n     * Retrieves a collection of all cells in the table row.\n     */\n    cells: HTMLCollectionOf<HTMLTableDataCellElement | HTMLTableHeaderCellElement>;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: any;\n    /**\n     * Retrieves the position of the object in the rows collection for the table.\n     */\n    readonly rowIndex: number;\n    /**\n     * Retrieves the position of the object in the collection.\n     */\n    readonly sectionRowIndex: number;\n    /**\n     * Removes the specified cell from the table row, as well as from the cells collection.\n     * @param index Number that specifies the zero-based position of the cell to remove from the table row. If no value is provided, the last cell in the cells collection is deleted.\n     */\n    deleteCell(index?: number): void;\n    /**\n     * Creates a new cell in the table row, and adds the cell to the cells collection.\n     * @param index Number that specifies where to insert the cell in the tr. The default value is -1, which appends the new cell to the end of the cells collection.\n     */\n    insertCell(index?: number): HTMLTableDataCellElement;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableRowElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLTableRowElement: {\n    prototype: HTMLTableRowElement;\n    new(): HTMLTableRowElement;\n};\n\ninterface HTMLTableSectionElement extends HTMLElement, HTMLTableAlignment {\n    /**\n     * Sets or retrieves a value that indicates the table alignment.\n     */\n    align: string;\n    /**\n     * Sets or retrieves the number of horizontal rows contained in the object.\n     */\n    rows: HTMLCollectionOf<HTMLTableRowElement>;\n    /**\n     * Removes the specified row (tr) from the element and from the rows collection.\n     * @param index Number that specifies the zero-based position in the rows collection of the row to remove.\n     */\n    deleteRow(index?: number): void;\n    /**\n     * Creates a new row (tr) in the table, and adds the row to the rows collection.\n     * @param index Number that specifies where to insert the row in the rows collection. The default value is -1, which appends the new row to the end of the rows collection.\n     */\n    insertRow(index?: number): HTMLTableRowElement;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableSectionElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLTableSectionElement: {\n    prototype: HTMLTableSectionElement;\n    new(): HTMLTableSectionElement;\n};\n\ninterface HTMLTemplateElement extends HTMLElement {\n    readonly content: DocumentFragment;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTemplateElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLTemplateElement: {\n    prototype: HTMLTemplateElement;\n    new(): HTMLTemplateElement;\n};\n\ninterface HTMLTextAreaElement extends HTMLElement {\n    /**\n     * Provides a way to direct a user to a specific field when a document loads. This can provide both direction and convenience for a user, reducing the need to click or tab to a field when a page opens. This attribute is true when present on an element, and false when missing.\n     */\n    autofocus: boolean;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    cols: number;\n    /**\n     * Sets or retrieves the initial contents of the object.\n     */\n    defaultValue: string;\n    disabled: boolean;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement;\n    /**\n     * Sets or retrieves the maximum number of characters that the user can enter in a text control.\n     */\n    maxLength: number;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    /**\n     * Gets or sets a text string that is displayed in an input field as a hint or prompt to users as the format or type of information they need to enter.The text appears in an input field until the user puts focus on the field.\n     */\n    placeholder: string;\n    /**\n     * Sets or retrieves the value indicated whether the content of the object is read-only.\n     */\n    readOnly: boolean;\n    /**\n     * When present, marks an element that can't be submitted without a value.\n     */\n    required: boolean;\n    /**\n     * Sets or retrieves the number of horizontal rows contained in the object.\n     */\n    rows: number;\n    /**\n     * Gets or sets the end position or offset of a text selection.\n     */\n    selectionEnd: number;\n    /**\n     * Gets or sets the starting position or offset of a text selection.\n     */\n    selectionStart: number;\n    /**\n     * Sets or retrieves the value indicating whether the control is selected.\n     */\n    status: any;\n    /**\n     * Retrieves the type of control.\n     */\n    readonly type: string;\n    /**\n     * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as \"this is a required field\". The result is that the user sees validation messages without actually submitting.\n     */\n    readonly validationMessage: string;\n    /**\n     * Returns a  ValidityState object that represents the validity states of an element.\n     */\n    readonly validity: ValidityState;\n    /**\n     * Retrieves or sets the text in the entry field of the textArea element.\n     */\n    value: string;\n    /**\n     * Returns whether an element will successfully validate based on forms validation rules and constraints.\n     */\n    readonly willValidate: boolean;\n    /**\n     * Sets or retrieves how to handle wordwrapping in the object.\n     */\n    wrap: string;\n    minLength: number;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    /**\n     * Highlights the input area of a form element.\n     */\n    select(): void;\n    /**\n     * Sets a custom error message that is displayed when a form is submitted.\n     * @param error Sets a custom error message that is displayed when a form is submitted.\n     */\n    setCustomValidity(error: string): void;\n    /**\n     * Sets the start and end positions of a selection in a text field.\n     * @param start The offset into the text field for the start of the selection.\n     * @param end The offset into the text field for the end of the selection.\n     */\n    setSelectionRange(start: number, end: number): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTextAreaElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLTextAreaElement: {\n    prototype: HTMLTextAreaElement;\n    new(): HTMLTextAreaElement;\n};\n\ninterface HTMLTimeElement extends HTMLElement {\n    dateTime: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTimeElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLTimeElement: {\n    prototype: HTMLTimeElement;\n    new(): HTMLTimeElement;\n};\n\ninterface HTMLTitleElement extends HTMLElement {\n    /**\n     * Retrieves or sets the text of the object as a string.\n     */\n    text: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTitleElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLTitleElement: {\n    prototype: HTMLTitleElement;\n    new(): HTMLTitleElement;\n};\n\ninterface HTMLTrackElement extends HTMLElement {\n    default: boolean;\n    kind: string;\n    label: string;\n    readonly readyState: number;\n    src: string;\n    srclang: string;\n    readonly track: TextTrack;\n    readonly ERROR: number;\n    readonly LOADED: number;\n    readonly LOADING: number;\n    readonly NONE: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTrackElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLTrackElement: {\n    prototype: HTMLTrackElement;\n    new(): HTMLTrackElement;\n    readonly ERROR: number;\n    readonly LOADED: number;\n    readonly LOADING: number;\n    readonly NONE: number;\n};\n\ninterface HTMLUListElement extends HTMLElement {\n    compact: boolean;\n    type: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLUListElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLUListElement: {\n    prototype: HTMLUListElement;\n    new(): HTMLUListElement;\n};\n\ninterface HTMLUnknownElement extends HTMLElement {\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLUnknownElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLUnknownElement: {\n    prototype: HTMLUnknownElement;\n    new(): HTMLUnknownElement;\n};\n\ninterface HTMLVideoElementEventMap extends HTMLMediaElementEventMap {\n    \"MSVideoFormatChanged\": Event;\n    \"MSVideoFrameStepCompleted\": Event;\n    \"MSVideoOptimalLayoutChanged\": Event;\n}\n\ninterface HTMLVideoElement extends HTMLMediaElement {\n    /**\n     * Gets or sets the height of the video element.\n     */\n    height: number;\n    msHorizontalMirror: boolean;\n    readonly msIsLayoutOptimalForPlayback: boolean;\n    readonly msIsStereo3D: boolean;\n    msStereo3DPackingMode: string;\n    msStereo3DRenderMode: string;\n    msZoom: boolean;\n    onMSVideoFormatChanged: (this: HTMLVideoElement, ev: Event) => any;\n    onMSVideoFrameStepCompleted: (this: HTMLVideoElement, ev: Event) => any;\n    onMSVideoOptimalLayoutChanged: (this: HTMLVideoElement, ev: Event) => any;\n    /**\n     * Gets or sets a URL of an image to display, for example, like a movie poster. This can be a still frame from the video, or another image if no video data is available.\n     */\n    poster: string;\n    /**\n     * Gets the intrinsic height of a video in CSS pixels, or zero if the dimensions are not known.\n     */\n    readonly videoHeight: number;\n    /**\n     * Gets the intrinsic width of a video in CSS pixels, or zero if the dimensions are not known.\n     */\n    readonly videoWidth: number;\n    readonly webkitDisplayingFullscreen: boolean;\n    readonly webkitSupportsFullscreen: boolean;\n    /**\n     * Gets or sets the width of the video element.\n     */\n    width: number;\n    getVideoPlaybackQuality(): VideoPlaybackQuality;\n    msFrameStep(forward: boolean): void;\n    msInsertVideoEffect(activatableClassId: string, effectRequired: boolean, config?: any): void;\n    msSetVideoRectangle(left: number, top: number, right: number, bottom: number): void;\n    webkitEnterFullscreen(): void;\n    webkitEnterFullScreen(): void;\n    webkitExitFullscreen(): void;\n    webkitExitFullScreen(): void;\n    addEventListener<K extends keyof HTMLVideoElementEventMap>(type: K, listener: (this: HTMLVideoElement, ev: HTMLVideoElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var HTMLVideoElement: {\n    prototype: HTMLVideoElement;\n    new(): HTMLVideoElement;\n};\n\ninterface IDBCursor {\n    readonly direction: IDBCursorDirection;\n    key: IDBKeyRange | IDBValidKey;\n    readonly primaryKey: any;\n    source: IDBObjectStore | IDBIndex;\n    advance(count: number): void;\n    continue(key?: IDBKeyRange | IDBValidKey): void;\n    delete(): IDBRequest;\n    update(value: any): IDBRequest;\n    readonly NEXT: string;\n    readonly NEXT_NO_DUPLICATE: string;\n    readonly PREV: string;\n    readonly PREV_NO_DUPLICATE: string;\n}\n\ndeclare var IDBCursor: {\n    prototype: IDBCursor;\n    new(): IDBCursor;\n    readonly NEXT: string;\n    readonly NEXT_NO_DUPLICATE: string;\n    readonly PREV: string;\n    readonly PREV_NO_DUPLICATE: string;\n};\n\ninterface IDBCursorWithValue extends IDBCursor {\n    readonly value: any;\n}\n\ndeclare var IDBCursorWithValue: {\n    prototype: IDBCursorWithValue;\n    new(): IDBCursorWithValue;\n};\n\ninterface IDBDatabaseEventMap {\n    \"abort\": Event;\n    \"error\": Event;\n}\n\ninterface IDBDatabase extends EventTarget {\n    readonly name: string;\n    readonly objectStoreNames: DOMStringList;\n    onabort: (this: IDBDatabase, ev: Event) => any;\n    onerror: (this: IDBDatabase, ev: Event) => any;\n    version: number;\n    onversionchange: (ev: IDBVersionChangeEvent) => any;\n    close(): void;\n    createObjectStore(name: string, optionalParameters?: IDBObjectStoreParameters): IDBObjectStore;\n    deleteObjectStore(name: string): void;\n    transaction(storeNames: string | string[], mode?: IDBTransactionMode): IDBTransaction;\n    addEventListener(type: \"versionchange\", listener: (ev: IDBVersionChangeEvent) => any, useCapture?: boolean): void;\n    addEventListener<K extends keyof IDBDatabaseEventMap>(type: K, listener: (this: IDBDatabase, ev: IDBDatabaseEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var IDBDatabase: {\n    prototype: IDBDatabase;\n    new(): IDBDatabase;\n};\n\ninterface IDBFactory {\n    cmp(first: any, second: any): number;\n    deleteDatabase(name: string): IDBOpenDBRequest;\n    open(name: string, version?: number): IDBOpenDBRequest;\n}\n\ndeclare var IDBFactory: {\n    prototype: IDBFactory;\n    new(): IDBFactory;\n};\n\ninterface IDBIndex {\n    keyPath: string | string[];\n    readonly name: string;\n    readonly objectStore: IDBObjectStore;\n    readonly unique: boolean;\n    multiEntry: boolean;\n    count(key?: IDBKeyRange | IDBValidKey): IDBRequest;\n    get(key: IDBKeyRange | IDBValidKey): IDBRequest;\n    getKey(key: IDBKeyRange | IDBValidKey): IDBRequest;\n    openCursor(range?: IDBKeyRange | IDBValidKey, direction?: IDBCursorDirection): IDBRequest;\n    openKeyCursor(range?: IDBKeyRange | IDBValidKey, direction?: IDBCursorDirection): IDBRequest;\n}\n\ndeclare var IDBIndex: {\n    prototype: IDBIndex;\n    new(): IDBIndex;\n};\n\ninterface IDBKeyRange {\n    readonly lower: any;\n    readonly lowerOpen: boolean;\n    readonly upper: any;\n    readonly upperOpen: boolean;\n}\n\ndeclare var IDBKeyRange: {\n    prototype: IDBKeyRange;\n    new(): IDBKeyRange;\n    bound(lower: any, upper: any, lowerOpen?: boolean, upperOpen?: boolean): IDBKeyRange;\n    lowerBound(lower: any, open?: boolean): IDBKeyRange;\n    only(value: any): IDBKeyRange;\n    upperBound(upper: any, open?: boolean): IDBKeyRange;\n};\n\ninterface IDBObjectStore {\n    readonly indexNames: DOMStringList;\n    keyPath: string | string[];\n    readonly name: string;\n    readonly transaction: IDBTransaction;\n    autoIncrement: boolean;\n    add(value: any, key?: IDBKeyRange | IDBValidKey): IDBRequest;\n    clear(): IDBRequest;\n    count(key?: IDBKeyRange | IDBValidKey): IDBRequest;\n    createIndex(name: string, keyPath: string | string[], optionalParameters?: IDBIndexParameters): IDBIndex;\n    delete(key: IDBKeyRange | IDBValidKey): IDBRequest;\n    deleteIndex(indexName: string): void;\n    get(key: any): IDBRequest;\n    index(name: string): IDBIndex;\n    openCursor(range?: IDBKeyRange | IDBValidKey, direction?: IDBCursorDirection): IDBRequest;\n    put(value: any, key?: IDBKeyRange | IDBValidKey): IDBRequest;\n}\n\ndeclare var IDBObjectStore: {\n    prototype: IDBObjectStore;\n    new(): IDBObjectStore;\n};\n\ninterface IDBOpenDBRequestEventMap extends IDBRequestEventMap {\n    \"blocked\": Event;\n    \"upgradeneeded\": IDBVersionChangeEvent;\n}\n\ninterface IDBOpenDBRequest extends IDBRequest {\n    onblocked: (this: IDBOpenDBRequest, ev: Event) => any;\n    onupgradeneeded: (this: IDBOpenDBRequest, ev: IDBVersionChangeEvent) => any;\n    addEventListener<K extends keyof IDBOpenDBRequestEventMap>(type: K, listener: (this: IDBOpenDBRequest, ev: IDBOpenDBRequestEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var IDBOpenDBRequest: {\n    prototype: IDBOpenDBRequest;\n    new(): IDBOpenDBRequest;\n};\n\ninterface IDBRequestEventMap {\n    \"error\": Event;\n    \"success\": Event;\n}\n\ninterface IDBRequest extends EventTarget {\n    readonly error: DOMException;\n    onerror: (this: IDBRequest, ev: Event) => any;\n    onsuccess: (this: IDBRequest, ev: Event) => any;\n    readonly readyState: IDBRequestReadyState;\n    readonly result: any;\n    source: IDBObjectStore | IDBIndex | IDBCursor;\n    readonly transaction: IDBTransaction;\n    addEventListener<K extends keyof IDBRequestEventMap>(type: K, listener: (this: IDBRequest, ev: IDBRequestEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var IDBRequest: {\n    prototype: IDBRequest;\n    new(): IDBRequest;\n};\n\ninterface IDBTransactionEventMap {\n    \"abort\": Event;\n    \"complete\": Event;\n    \"error\": Event;\n}\n\ninterface IDBTransaction extends EventTarget {\n    readonly db: IDBDatabase;\n    readonly error: DOMException;\n    readonly mode: IDBTransactionMode;\n    onabort: (this: IDBTransaction, ev: Event) => any;\n    oncomplete: (this: IDBTransaction, ev: Event) => any;\n    onerror: (this: IDBTransaction, ev: Event) => any;\n    abort(): void;\n    objectStore(name: string): IDBObjectStore;\n    readonly READ_ONLY: string;\n    readonly READ_WRITE: string;\n    readonly VERSION_CHANGE: string;\n    addEventListener<K extends keyof IDBTransactionEventMap>(type: K, listener: (this: IDBTransaction, ev: IDBTransactionEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var IDBTransaction: {\n    prototype: IDBTransaction;\n    new(): IDBTransaction;\n    readonly READ_ONLY: string;\n    readonly READ_WRITE: string;\n    readonly VERSION_CHANGE: string;\n};\n\ninterface IDBVersionChangeEvent extends Event {\n    readonly newVersion: number | null;\n    readonly oldVersion: number;\n}\n\ndeclare var IDBVersionChangeEvent: {\n    prototype: IDBVersionChangeEvent;\n    new(): IDBVersionChangeEvent;\n};\n\ninterface IIRFilterNode extends AudioNode {\n    getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void;\n}\n\ndeclare var IIRFilterNode: {\n    prototype: IIRFilterNode;\n    new(): IIRFilterNode;\n};\n\ninterface ImageData {\n    data: Uint8ClampedArray;\n    readonly height: number;\n    readonly width: number;\n}\n\ndeclare var ImageData: {\n    prototype: ImageData;\n    new(width: number, height: number): ImageData;\n    new(array: Uint8ClampedArray, width: number, height: number): ImageData;\n};\n\ninterface IntersectionObserver {\n    readonly root: Element | null;\n    readonly rootMargin: string;\n    readonly thresholds: number[];\n    disconnect(): void;\n    observe(target: Element): void;\n    takeRecords(): IntersectionObserverEntry[];\n    unobserve(target: Element): void;\n}\n\ndeclare var IntersectionObserver: {\n    prototype: IntersectionObserver;\n    new(callback: IntersectionObserverCallback, options?: IntersectionObserverInit): IntersectionObserver;\n};\n\ninterface IntersectionObserverEntry {\n    readonly boundingClientRect: ClientRect;\n    readonly intersectionRatio: number;\n    readonly intersectionRect: ClientRect;\n    readonly rootBounds: ClientRect;\n    readonly target: Element;\n    readonly time: number;\n}\n\ndeclare var IntersectionObserverEntry: {\n    prototype: IntersectionObserverEntry;\n    new(intersectionObserverEntryInit: IntersectionObserverEntryInit): IntersectionObserverEntry;\n};\n\ninterface KeyboardEvent extends UIEvent {\n    readonly altKey: boolean;\n    readonly char: string | null;\n    readonly charCode: number;\n    readonly ctrlKey: boolean;\n    readonly key: string;\n    readonly keyCode: number;\n    readonly locale: string;\n    readonly location: number;\n    readonly metaKey: boolean;\n    readonly repeat: boolean;\n    readonly shiftKey: boolean;\n    readonly which: number;\n    readonly code: string;\n    getModifierState(keyArg: string): boolean;\n    initKeyboardEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, keyArg: string, locationArg: number, modifiersListArg: string, repeat: boolean, locale: string): void;\n    readonly DOM_KEY_LOCATION_JOYSTICK: number;\n    readonly DOM_KEY_LOCATION_LEFT: number;\n    readonly DOM_KEY_LOCATION_MOBILE: number;\n    readonly DOM_KEY_LOCATION_NUMPAD: number;\n    readonly DOM_KEY_LOCATION_RIGHT: number;\n    readonly DOM_KEY_LOCATION_STANDARD: number;\n}\n\ndeclare var KeyboardEvent: {\n    prototype: KeyboardEvent;\n    new(typeArg: string, eventInitDict?: KeyboardEventInit): KeyboardEvent;\n    readonly DOM_KEY_LOCATION_JOYSTICK: number;\n    readonly DOM_KEY_LOCATION_LEFT: number;\n    readonly DOM_KEY_LOCATION_MOBILE: number;\n    readonly DOM_KEY_LOCATION_NUMPAD: number;\n    readonly DOM_KEY_LOCATION_RIGHT: number;\n    readonly DOM_KEY_LOCATION_STANDARD: number;\n};\n\ninterface ListeningStateChangedEvent extends Event {\n    readonly label: string;\n    readonly state: ListeningState;\n}\n\ndeclare var ListeningStateChangedEvent: {\n    prototype: ListeningStateChangedEvent;\n    new(): ListeningStateChangedEvent;\n};\n\ninterface Location {\n    hash: string;\n    host: string;\n    hostname: string;\n    href: string;\n    readonly origin: string;\n    pathname: string;\n    port: string;\n    protocol: string;\n    search: string;\n    assign(url: string): void;\n    reload(forcedReload?: boolean): void;\n    replace(url: string): void;\n    toString(): string;\n}\n\ndeclare var Location: {\n    prototype: Location;\n    new(): Location;\n};\n\ninterface LongRunningScriptDetectedEvent extends Event {\n    readonly executionTime: number;\n    stopPageScriptExecution: boolean;\n}\n\ndeclare var LongRunningScriptDetectedEvent: {\n    prototype: LongRunningScriptDetectedEvent;\n    new(): LongRunningScriptDetectedEvent;\n};\n\ninterface MediaDeviceInfo {\n    readonly deviceId: string;\n    readonly groupId: string;\n    readonly kind: MediaDeviceKind;\n    readonly label: string;\n}\n\ndeclare var MediaDeviceInfo: {\n    prototype: MediaDeviceInfo;\n    new(): MediaDeviceInfo;\n};\n\ninterface MediaDevicesEventMap {\n    \"devicechange\": Event;\n}\n\ninterface MediaDevices extends EventTarget {\n    ondevicechange: (this: MediaDevices, ev: Event) => any;\n    enumerateDevices(): any;\n    getSupportedConstraints(): MediaTrackSupportedConstraints;\n    getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream>;\n    addEventListener<K extends keyof MediaDevicesEventMap>(type: K, listener: (this: MediaDevices, ev: MediaDevicesEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var MediaDevices: {\n    prototype: MediaDevices;\n    new(): MediaDevices;\n};\n\ninterface MediaElementAudioSourceNode extends AudioNode {\n}\n\ndeclare var MediaElementAudioSourceNode: {\n    prototype: MediaElementAudioSourceNode;\n    new(): MediaElementAudioSourceNode;\n};\n\ninterface MediaEncryptedEvent extends Event {\n    readonly initData: ArrayBuffer | null;\n    readonly initDataType: string;\n}\n\ndeclare var MediaEncryptedEvent: {\n    prototype: MediaEncryptedEvent;\n    new(type: string, eventInitDict?: MediaEncryptedEventInit): MediaEncryptedEvent;\n};\n\ninterface MediaError {\n    readonly code: number;\n    readonly msExtendedCode: number;\n    readonly MEDIA_ERR_ABORTED: number;\n    readonly MEDIA_ERR_DECODE: number;\n    readonly MEDIA_ERR_NETWORK: number;\n    readonly MEDIA_ERR_SRC_NOT_SUPPORTED: number;\n    readonly MS_MEDIA_ERR_ENCRYPTED: number;\n}\n\ndeclare var MediaError: {\n    prototype: MediaError;\n    new(): MediaError;\n    readonly MEDIA_ERR_ABORTED: number;\n    readonly MEDIA_ERR_DECODE: number;\n    readonly MEDIA_ERR_NETWORK: number;\n    readonly MEDIA_ERR_SRC_NOT_SUPPORTED: number;\n    readonly MS_MEDIA_ERR_ENCRYPTED: number;\n};\n\ninterface MediaKeyMessageEvent extends Event {\n    readonly message: ArrayBuffer;\n    readonly messageType: MediaKeyMessageType;\n}\n\ndeclare var MediaKeyMessageEvent: {\n    prototype: MediaKeyMessageEvent;\n    new(type: string, eventInitDict?: MediaKeyMessageEventInit): MediaKeyMessageEvent;\n};\n\ninterface MediaKeys {\n    createSession(sessionType?: MediaKeySessionType): MediaKeySession;\n    setServerCertificate(serverCertificate: any): Promise<void>;\n}\n\ndeclare var MediaKeys: {\n    prototype: MediaKeys;\n    new(): MediaKeys;\n};\n\ninterface MediaKeySession extends EventTarget {\n    readonly closed: Promise<void>;\n    readonly expiration: number;\n    readonly keyStatuses: MediaKeyStatusMap;\n    readonly sessionId: string;\n    close(): Promise<void>;\n    generateRequest(initDataType: string, initData: any): Promise<void>;\n    load(sessionId: string): Promise<boolean>;\n    remove(): Promise<void>;\n    update(response: any): Promise<void>;\n}\n\ndeclare var MediaKeySession: {\n    prototype: MediaKeySession;\n    new(): MediaKeySession;\n};\n\ninterface MediaKeyStatusMap {\n    readonly size: number;\n    forEach(callback: ForEachCallback): void;\n    get(keyId: any): MediaKeyStatus;\n    has(keyId: any): boolean;\n}\n\ndeclare var MediaKeyStatusMap: {\n    prototype: MediaKeyStatusMap;\n    new(): MediaKeyStatusMap;\n};\n\ninterface MediaKeySystemAccess {\n    readonly keySystem: string;\n    createMediaKeys(): Promise<MediaKeys>;\n    getConfiguration(): MediaKeySystemConfiguration;\n}\n\ndeclare var MediaKeySystemAccess: {\n    prototype: MediaKeySystemAccess;\n    new(): MediaKeySystemAccess;\n};\n\ninterface MediaList {\n    readonly length: number;\n    mediaText: string;\n    appendMedium(newMedium: string): void;\n    deleteMedium(oldMedium: string): void;\n    item(index: number): string;\n    toString(): string;\n    [index: number]: string;\n}\n\ndeclare var MediaList: {\n    prototype: MediaList;\n    new(): MediaList;\n};\n\ninterface MediaQueryList {\n    readonly matches: boolean;\n    readonly media: string;\n    addListener(listener: MediaQueryListListener): void;\n    removeListener(listener: MediaQueryListListener): void;\n}\n\ndeclare var MediaQueryList: {\n    prototype: MediaQueryList;\n    new(): MediaQueryList;\n};\n\ninterface MediaSource extends EventTarget {\n    readonly activeSourceBuffers: SourceBufferList;\n    duration: number;\n    readonly readyState: string;\n    readonly sourceBuffers: SourceBufferList;\n    addSourceBuffer(type: string): SourceBuffer;\n    endOfStream(error?: number): void;\n    removeSourceBuffer(sourceBuffer: SourceBuffer): void;\n}\n\ndeclare var MediaSource: {\n    prototype: MediaSource;\n    new(): MediaSource;\n    isTypeSupported(type: string): boolean;\n};\n\ninterface MediaStreamEventMap {\n    \"active\": Event;\n    \"addtrack\": MediaStreamTrackEvent;\n    \"inactive\": Event;\n    \"removetrack\": MediaStreamTrackEvent;\n}\n\ninterface MediaStream extends EventTarget {\n    readonly active: boolean;\n    readonly id: string;\n    onactive: (this: MediaStream, ev: Event) => any;\n    onaddtrack: (this: MediaStream, ev: MediaStreamTrackEvent) => any;\n    oninactive: (this: MediaStream, ev: Event) => any;\n    onremovetrack: (this: MediaStream, ev: MediaStreamTrackEvent) => any;\n    addTrack(track: MediaStreamTrack): void;\n    clone(): MediaStream;\n    getAudioTracks(): MediaStreamTrack[];\n    getTrackById(trackId: string): MediaStreamTrack | null;\n    getTracks(): MediaStreamTrack[];\n    getVideoTracks(): MediaStreamTrack[];\n    removeTrack(track: MediaStreamTrack): void;\n    stop(): void;\n    addEventListener<K extends keyof MediaStreamEventMap>(type: K, listener: (this: MediaStream, ev: MediaStreamEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var MediaStream: {\n    prototype: MediaStream;\n    new(streamOrTracks?: MediaStream | MediaStreamTrack[]): MediaStream;\n};\n\ninterface MediaStreamAudioSourceNode extends AudioNode {\n}\n\ndeclare var MediaStreamAudioSourceNode: {\n    prototype: MediaStreamAudioSourceNode;\n    new(): MediaStreamAudioSourceNode;\n};\n\ninterface MediaStreamError {\n    readonly constraintName: string | null;\n    readonly message: string | null;\n    readonly name: string;\n}\n\ndeclare var MediaStreamError: {\n    prototype: MediaStreamError;\n    new(): MediaStreamError;\n};\n\ninterface MediaStreamErrorEvent extends Event {\n    readonly error: MediaStreamError | null;\n}\n\ndeclare var MediaStreamErrorEvent: {\n    prototype: MediaStreamErrorEvent;\n    new(typeArg: string, eventInitDict?: MediaStreamErrorEventInit): MediaStreamErrorEvent;\n};\n\ninterface MediaStreamEvent extends Event {\n    readonly stream: MediaStream | null;\n}\n\ndeclare var MediaStreamEvent: {\n    prototype: MediaStreamEvent;\n    new(type: string, eventInitDict: MediaStreamEventInit): MediaStreamEvent;\n};\n\ninterface MediaStreamTrackEventMap {\n    \"ended\": MediaStreamErrorEvent;\n    \"mute\": Event;\n    \"overconstrained\": MediaStreamErrorEvent;\n    \"unmute\": Event;\n}\n\ninterface MediaStreamTrack extends EventTarget {\n    enabled: boolean;\n    readonly id: string;\n    readonly kind: string;\n    readonly label: string;\n    readonly muted: boolean;\n    onended: (this: MediaStreamTrack, ev: MediaStreamErrorEvent) => any;\n    onmute: (this: MediaStreamTrack, ev: Event) => any;\n    onoverconstrained: (this: MediaStreamTrack, ev: MediaStreamErrorEvent) => any;\n    onunmute: (this: MediaStreamTrack, ev: Event) => any;\n    readonly readonly: boolean;\n    readonly readyState: MediaStreamTrackState;\n    readonly remote: boolean;\n    applyConstraints(constraints: MediaTrackConstraints): Promise<void>;\n    clone(): MediaStreamTrack;\n    getCapabilities(): MediaTrackCapabilities;\n    getConstraints(): MediaTrackConstraints;\n    getSettings(): MediaTrackSettings;\n    stop(): void;\n    addEventListener<K extends keyof MediaStreamTrackEventMap>(type: K, listener: (this: MediaStreamTrack, ev: MediaStreamTrackEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var MediaStreamTrack: {\n    prototype: MediaStreamTrack;\n    new(): MediaStreamTrack;\n};\n\ninterface MediaStreamTrackEvent extends Event {\n    readonly track: MediaStreamTrack;\n}\n\ndeclare var MediaStreamTrackEvent: {\n    prototype: MediaStreamTrackEvent;\n    new(typeArg: string, eventInitDict?: MediaStreamTrackEventInit): MediaStreamTrackEvent;\n};\n\ninterface MessageChannel {\n    readonly port1: MessagePort;\n    readonly port2: MessagePort;\n}\n\ndeclare var MessageChannel: {\n    prototype: MessageChannel;\n    new(): MessageChannel;\n};\n\ninterface MessageEvent extends Event {\n    readonly data: any;\n    readonly origin: string;\n    readonly ports: any;\n    readonly source: Window;\n    initMessageEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, dataArg: any, originArg: string, lastEventIdArg: string, sourceArg: Window): void;\n}\n\ndeclare var MessageEvent: {\n    prototype: MessageEvent;\n    new(type: string, eventInitDict?: MessageEventInit): MessageEvent;\n};\n\ninterface MessagePortEventMap {\n    \"message\": MessageEvent;\n}\n\ninterface MessagePort extends EventTarget {\n    onmessage: (this: MessagePort, ev: MessageEvent) => any;\n    close(): void;\n    postMessage(message?: any, transfer?: any[]): void;\n    start(): void;\n    addEventListener<K extends keyof MessagePortEventMap>(type: K, listener: (this: MessagePort, ev: MessagePortEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var MessagePort: {\n    prototype: MessagePort;\n    new(): MessagePort;\n};\n\ninterface MimeType {\n    readonly description: string;\n    readonly enabledPlugin: Plugin;\n    readonly suffixes: string;\n    readonly type: string;\n}\n\ndeclare var MimeType: {\n    prototype: MimeType;\n    new(): MimeType;\n};\n\ninterface MimeTypeArray {\n    readonly length: number;\n    item(index: number): Plugin;\n    namedItem(type: string): Plugin;\n    [index: number]: Plugin;\n}\n\ndeclare var MimeTypeArray: {\n    prototype: MimeTypeArray;\n    new(): MimeTypeArray;\n};\n\ninterface MouseEvent extends UIEvent {\n    readonly altKey: boolean;\n    readonly button: number;\n    readonly buttons: number;\n    readonly clientX: number;\n    readonly clientY: number;\n    readonly ctrlKey: boolean;\n    readonly fromElement: Element;\n    readonly layerX: number;\n    readonly layerY: number;\n    readonly metaKey: boolean;\n    readonly movementX: number;\n    readonly movementY: number;\n    readonly offsetX: number;\n    readonly offsetY: number;\n    readonly pageX: number;\n    readonly pageY: number;\n    readonly relatedTarget: EventTarget;\n    readonly screenX: number;\n    readonly screenY: number;\n    readonly shiftKey: boolean;\n    readonly toElement: Element;\n    readonly which: number;\n    readonly x: number;\n    readonly y: number;\n    getModifierState(keyArg: string): boolean;\n    initMouseEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, ctrlKeyArg: boolean, altKeyArg: boolean, shiftKeyArg: boolean, metaKeyArg: boolean, buttonArg: number, relatedTargetArg: EventTarget | null): void;\n}\n\ndeclare var MouseEvent: {\n    prototype: MouseEvent;\n    new(typeArg: string, eventInitDict?: MouseEventInit): MouseEvent;\n};\n\ninterface MSApp {\n    clearTemporaryWebDataAsync(): MSAppAsyncOperation;\n    createBlobFromRandomAccessStream(type: string, seeker: any): Blob;\n    createDataPackage(object: any): any;\n    createDataPackageFromSelection(): any;\n    createFileFromStorageFile(storageFile: any): File;\n    createStreamFromInputStream(type: string, inputStream: any): MSStream;\n    execAsyncAtPriority(asynchronousCallback: MSExecAtPriorityFunctionCallback, priority: string, ...args: any[]): void;\n    execAtPriority(synchronousCallback: MSExecAtPriorityFunctionCallback, priority: string, ...args: any[]): any;\n    getCurrentPriority(): string;\n    getHtmlPrintDocumentSourceAsync(htmlDoc: any): Promise<any>;\n    getViewId(view: any): any;\n    isTaskScheduledAtPriorityOrHigher(priority: string): boolean;\n    pageHandlesAllApplicationActivations(enabled: boolean): void;\n    suppressSubdownloadCredentialPrompts(suppress: boolean): void;\n    terminateApp(exceptionObject: any): void;\n    readonly CURRENT: string;\n    readonly HIGH: string;\n    readonly IDLE: string;\n    readonly NORMAL: string;\n}\ndeclare var MSApp: MSApp;\n\ninterface MSAppAsyncOperationEventMap {\n    \"complete\": Event;\n    \"error\": Event;\n}\n\ninterface MSAppAsyncOperation extends EventTarget {\n    readonly error: DOMError;\n    oncomplete: (this: MSAppAsyncOperation, ev: Event) => any;\n    onerror: (this: MSAppAsyncOperation, ev: Event) => any;\n    readonly readyState: number;\n    readonly result: any;\n    start(): void;\n    readonly COMPLETED: number;\n    readonly ERROR: number;\n    readonly STARTED: number;\n    addEventListener<K extends keyof MSAppAsyncOperationEventMap>(type: K, listener: (this: MSAppAsyncOperation, ev: MSAppAsyncOperationEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var MSAppAsyncOperation: {\n    prototype: MSAppAsyncOperation;\n    new(): MSAppAsyncOperation;\n    readonly COMPLETED: number;\n    readonly ERROR: number;\n    readonly STARTED: number;\n};\n\ninterface MSAssertion {\n    readonly id: string;\n    readonly type: MSCredentialType;\n}\n\ndeclare var MSAssertion: {\n    prototype: MSAssertion;\n    new(): MSAssertion;\n};\n\ninterface MSBlobBuilder {\n    append(data: any, endings?: string): void;\n    getBlob(contentType?: string): Blob;\n}\n\ndeclare var MSBlobBuilder: {\n    prototype: MSBlobBuilder;\n    new(): MSBlobBuilder;\n};\n\ninterface MSCredentials {\n    getAssertion(challenge: string, filter?: MSCredentialFilter, params?: MSSignatureParameters): Promise<MSAssertion>;\n    makeCredential(accountInfo: MSAccountInfo, params: MSCredentialParameters[], challenge?: string): Promise<MSAssertion>;\n}\n\ndeclare var MSCredentials: {\n    prototype: MSCredentials;\n    new(): MSCredentials;\n};\n\ninterface MSFIDOCredentialAssertion extends MSAssertion {\n    readonly algorithm: string | Algorithm;\n    readonly attestation: any;\n    readonly publicKey: string;\n    readonly transportHints: MSTransportType[];\n}\n\ndeclare var MSFIDOCredentialAssertion: {\n    prototype: MSFIDOCredentialAssertion;\n    new(): MSFIDOCredentialAssertion;\n};\n\ninterface MSFIDOSignature {\n    readonly authnrData: string;\n    readonly clientData: string;\n    readonly signature: string;\n}\n\ndeclare var MSFIDOSignature: {\n    prototype: MSFIDOSignature;\n    new(): MSFIDOSignature;\n};\n\ninterface MSFIDOSignatureAssertion extends MSAssertion {\n    readonly signature: MSFIDOSignature;\n}\n\ndeclare var MSFIDOSignatureAssertion: {\n    prototype: MSFIDOSignatureAssertion;\n    new(): MSFIDOSignatureAssertion;\n};\n\ninterface MSGesture {\n    target: Element;\n    addPointer(pointerId: number): void;\n    stop(): void;\n}\n\ndeclare var MSGesture: {\n    prototype: MSGesture;\n    new(): MSGesture;\n};\n\ninterface MSGestureEvent extends UIEvent {\n    readonly clientX: number;\n    readonly clientY: number;\n    readonly expansion: number;\n    readonly gestureObject: any;\n    readonly hwTimestamp: number;\n    readonly offsetX: number;\n    readonly offsetY: number;\n    readonly rotation: number;\n    readonly scale: number;\n    readonly screenX: number;\n    readonly screenY: number;\n    readonly translationX: number;\n    readonly translationY: number;\n    readonly velocityAngular: number;\n    readonly velocityExpansion: number;\n    readonly velocityX: number;\n    readonly velocityY: number;\n    initGestureEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, offsetXArg: number, offsetYArg: number, translationXArg: number, translationYArg: number, scaleArg: number, expansionArg: number, rotationArg: number, velocityXArg: number, velocityYArg: number, velocityExpansionArg: number, velocityAngularArg: number, hwTimestampArg: number): void;\n    readonly MSGESTURE_FLAG_BEGIN: number;\n    readonly MSGESTURE_FLAG_CANCEL: number;\n    readonly MSGESTURE_FLAG_END: number;\n    readonly MSGESTURE_FLAG_INERTIA: number;\n    readonly MSGESTURE_FLAG_NONE: number;\n}\n\ndeclare var MSGestureEvent: {\n    prototype: MSGestureEvent;\n    new(): MSGestureEvent;\n    readonly MSGESTURE_FLAG_BEGIN: number;\n    readonly MSGESTURE_FLAG_CANCEL: number;\n    readonly MSGESTURE_FLAG_END: number;\n    readonly MSGESTURE_FLAG_INERTIA: number;\n    readonly MSGESTURE_FLAG_NONE: number;\n};\n\ninterface MSGraphicsTrust {\n    readonly constrictionActive: boolean;\n    readonly status: string;\n}\n\ndeclare var MSGraphicsTrust: {\n    prototype: MSGraphicsTrust;\n    new(): MSGraphicsTrust;\n};\n\ninterface MSHTMLWebViewElement extends HTMLElement {\n    readonly canGoBack: boolean;\n    readonly canGoForward: boolean;\n    readonly containsFullScreenElement: boolean;\n    readonly documentTitle: string;\n    height: number;\n    readonly settings: MSWebViewSettings;\n    src: string;\n    width: number;\n    addWebAllowedObject(name: string, applicationObject: any): void;\n    buildLocalStreamUri(contentIdentifier: string, relativePath: string): string;\n    capturePreviewToBlobAsync(): MSWebViewAsyncOperation;\n    captureSelectedContentToDataPackageAsync(): MSWebViewAsyncOperation;\n    getDeferredPermissionRequestById(id: number): DeferredPermissionRequest;\n    getDeferredPermissionRequests(): DeferredPermissionRequest[];\n    goBack(): void;\n    goForward(): void;\n    invokeScriptAsync(scriptName: string, ...args: any[]): MSWebViewAsyncOperation;\n    navigate(uri: string): void;\n    navigateFocus(navigationReason: NavigationReason, origin: FocusNavigationOrigin): void;\n    navigateToLocalStreamUri(source: string, streamResolver: any): void;\n    navigateToString(contents: string): void;\n    navigateWithHttpRequestMessage(requestMessage: any): void;\n    refresh(): void;\n    stop(): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: MSHTMLWebViewElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var MSHTMLWebViewElement: {\n    prototype: MSHTMLWebViewElement;\n    new(): MSHTMLWebViewElement;\n};\n\ninterface MSInputMethodContextEventMap {\n    \"MSCandidateWindowHide\": Event;\n    \"MSCandidateWindowShow\": Event;\n    \"MSCandidateWindowUpdate\": Event;\n}\n\ninterface MSInputMethodContext extends EventTarget {\n    readonly compositionEndOffset: number;\n    readonly compositionStartOffset: number;\n    oncandidatewindowhide: (this: MSInputMethodContext, ev: Event) => any;\n    oncandidatewindowshow: (this: MSInputMethodContext, ev: Event) => any;\n    oncandidatewindowupdate: (this: MSInputMethodContext, ev: Event) => any;\n    readonly target: HTMLElement;\n    getCandidateWindowClientRect(): ClientRect;\n    getCompositionAlternatives(): string[];\n    hasComposition(): boolean;\n    isCandidateWindowVisible(): boolean;\n    addEventListener<K extends keyof MSInputMethodContextEventMap>(type: K, listener: (this: MSInputMethodContext, ev: MSInputMethodContextEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var MSInputMethodContext: {\n    prototype: MSInputMethodContext;\n    new(): MSInputMethodContext;\n};\n\ninterface MSManipulationEvent extends UIEvent {\n    readonly currentState: number;\n    readonly inertiaDestinationX: number;\n    readonly inertiaDestinationY: number;\n    readonly lastState: number;\n    initMSManipulationEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, lastState: number, currentState: number): void;\n    readonly MS_MANIPULATION_STATE_ACTIVE: number;\n    readonly MS_MANIPULATION_STATE_CANCELLED: number;\n    readonly MS_MANIPULATION_STATE_COMMITTED: number;\n    readonly MS_MANIPULATION_STATE_DRAGGING: number;\n    readonly MS_MANIPULATION_STATE_INERTIA: number;\n    readonly MS_MANIPULATION_STATE_PRESELECT: number;\n    readonly MS_MANIPULATION_STATE_SELECTING: number;\n    readonly MS_MANIPULATION_STATE_STOPPED: number;\n}\n\ndeclare var MSManipulationEvent: {\n    prototype: MSManipulationEvent;\n    new(): MSManipulationEvent;\n    readonly MS_MANIPULATION_STATE_ACTIVE: number;\n    readonly MS_MANIPULATION_STATE_CANCELLED: number;\n    readonly MS_MANIPULATION_STATE_COMMITTED: number;\n    readonly MS_MANIPULATION_STATE_DRAGGING: number;\n    readonly MS_MANIPULATION_STATE_INERTIA: number;\n    readonly MS_MANIPULATION_STATE_PRESELECT: number;\n    readonly MS_MANIPULATION_STATE_SELECTING: number;\n    readonly MS_MANIPULATION_STATE_STOPPED: number;\n};\n\ninterface MSMediaKeyError {\n    readonly code: number;\n    readonly systemCode: number;\n    readonly MS_MEDIA_KEYERR_CLIENT: number;\n    readonly MS_MEDIA_KEYERR_DOMAIN: number;\n    readonly MS_MEDIA_KEYERR_HARDWARECHANGE: number;\n    readonly MS_MEDIA_KEYERR_OUTPUT: number;\n    readonly MS_MEDIA_KEYERR_SERVICE: number;\n    readonly MS_MEDIA_KEYERR_UNKNOWN: number;\n}\n\ndeclare var MSMediaKeyError: {\n    prototype: MSMediaKeyError;\n    new(): MSMediaKeyError;\n    readonly MS_MEDIA_KEYERR_CLIENT: number;\n    readonly MS_MEDIA_KEYERR_DOMAIN: number;\n    readonly MS_MEDIA_KEYERR_HARDWARECHANGE: number;\n    readonly MS_MEDIA_KEYERR_OUTPUT: number;\n    readonly MS_MEDIA_KEYERR_SERVICE: number;\n    readonly MS_MEDIA_KEYERR_UNKNOWN: number;\n};\n\ninterface MSMediaKeyMessageEvent extends Event {\n    readonly destinationURL: string | null;\n    readonly message: Uint8Array;\n}\n\ndeclare var MSMediaKeyMessageEvent: {\n    prototype: MSMediaKeyMessageEvent;\n    new(): MSMediaKeyMessageEvent;\n};\n\ninterface MSMediaKeyNeededEvent extends Event {\n    readonly initData: Uint8Array | null;\n}\n\ndeclare var MSMediaKeyNeededEvent: {\n    prototype: MSMediaKeyNeededEvent;\n    new(): MSMediaKeyNeededEvent;\n};\n\ninterface MSMediaKeys {\n    readonly keySystem: string;\n    createSession(type: string, initData: Uint8Array, cdmData?: Uint8Array): MSMediaKeySession;\n}\n\ndeclare var MSMediaKeys: {\n    prototype: MSMediaKeys;\n    new(keySystem: string): MSMediaKeys;\n    isTypeSupported(keySystem: string, type?: string): boolean;\n    isTypeSupportedWithFeatures(keySystem: string, type?: string): string;\n};\n\ninterface MSMediaKeySession extends EventTarget {\n    readonly error: MSMediaKeyError | null;\n    readonly keySystem: string;\n    readonly sessionId: string;\n    close(): void;\n    update(key: Uint8Array): void;\n}\n\ndeclare var MSMediaKeySession: {\n    prototype: MSMediaKeySession;\n    new(): MSMediaKeySession;\n};\n\ninterface MSPointerEvent extends MouseEvent {\n    readonly currentPoint: any;\n    readonly height: number;\n    readonly hwTimestamp: number;\n    readonly intermediatePoints: any;\n    readonly isPrimary: boolean;\n    readonly pointerId: number;\n    readonly pointerType: any;\n    readonly pressure: number;\n    readonly rotation: number;\n    readonly tiltX: number;\n    readonly tiltY: number;\n    readonly width: number;\n    getCurrentPoint(element: Element): void;\n    getIntermediatePoints(element: Element): void;\n    initPointerEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, ctrlKeyArg: boolean, altKeyArg: boolean, shiftKeyArg: boolean, metaKeyArg: boolean, buttonArg: number, relatedTargetArg: EventTarget, offsetXArg: number, offsetYArg: number, widthArg: number, heightArg: number, pressure: number, rotation: number, tiltX: number, tiltY: number, pointerIdArg: number, pointerType: any, hwTimestampArg: number, isPrimary: boolean): void;\n}\n\ndeclare var MSPointerEvent: {\n    prototype: MSPointerEvent;\n    new(typeArg: string, eventInitDict?: PointerEventInit): MSPointerEvent;\n};\n\ninterface MSRangeCollection {\n    readonly length: number;\n    item(index: number): Range;\n    [index: number]: Range;\n}\n\ndeclare var MSRangeCollection: {\n    prototype: MSRangeCollection;\n    new(): MSRangeCollection;\n};\n\ninterface MSSiteModeEvent extends Event {\n    readonly actionURL: string;\n    readonly buttonID: number;\n}\n\ndeclare var MSSiteModeEvent: {\n    prototype: MSSiteModeEvent;\n    new(): MSSiteModeEvent;\n};\n\ninterface MSStream {\n    readonly type: string;\n    msClose(): void;\n    msDetachStream(): any;\n}\n\ndeclare var MSStream: {\n    prototype: MSStream;\n    new(): MSStream;\n};\n\ninterface MSStreamReader extends EventTarget, MSBaseReader {\n    readonly error: DOMError;\n    readAsArrayBuffer(stream: MSStream, size?: number): void;\n    readAsBinaryString(stream: MSStream, size?: number): void;\n    readAsBlob(stream: MSStream, size?: number): void;\n    readAsDataURL(stream: MSStream, size?: number): void;\n    readAsText(stream: MSStream, encoding?: string, size?: number): void;\n    addEventListener<K extends keyof MSBaseReaderEventMap>(type: K, listener: (this: MSStreamReader, ev: MSBaseReaderEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var MSStreamReader: {\n    prototype: MSStreamReader;\n    new(): MSStreamReader;\n};\n\ninterface MSWebViewAsyncOperationEventMap {\n    \"complete\": Event;\n    \"error\": Event;\n}\n\ninterface MSWebViewAsyncOperation extends EventTarget {\n    readonly error: DOMError;\n    oncomplete: (this: MSWebViewAsyncOperation, ev: Event) => any;\n    onerror: (this: MSWebViewAsyncOperation, ev: Event) => any;\n    readonly readyState: number;\n    readonly result: any;\n    readonly target: MSHTMLWebViewElement;\n    readonly type: number;\n    start(): void;\n    readonly COMPLETED: number;\n    readonly ERROR: number;\n    readonly STARTED: number;\n    readonly TYPE_CAPTURE_PREVIEW_TO_RANDOM_ACCESS_STREAM: number;\n    readonly TYPE_CREATE_DATA_PACKAGE_FROM_SELECTION: number;\n    readonly TYPE_INVOKE_SCRIPT: number;\n    addEventListener<K extends keyof MSWebViewAsyncOperationEventMap>(type: K, listener: (this: MSWebViewAsyncOperation, ev: MSWebViewAsyncOperationEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var MSWebViewAsyncOperation: {\n    prototype: MSWebViewAsyncOperation;\n    new(): MSWebViewAsyncOperation;\n    readonly COMPLETED: number;\n    readonly ERROR: number;\n    readonly STARTED: number;\n    readonly TYPE_CAPTURE_PREVIEW_TO_RANDOM_ACCESS_STREAM: number;\n    readonly TYPE_CREATE_DATA_PACKAGE_FROM_SELECTION: number;\n    readonly TYPE_INVOKE_SCRIPT: number;\n};\n\ninterface MSWebViewSettings {\n    isIndexedDBEnabled: boolean;\n    isJavaScriptEnabled: boolean;\n}\n\ndeclare var MSWebViewSettings: {\n    prototype: MSWebViewSettings;\n    new(): MSWebViewSettings;\n};\n\ninterface MutationEvent extends Event {\n    readonly attrChange: number;\n    readonly attrName: string;\n    readonly newValue: string;\n    readonly prevValue: string;\n    readonly relatedNode: Node;\n    initMutationEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, relatedNodeArg: Node, prevValueArg: string, newValueArg: string, attrNameArg: string, attrChangeArg: number): void;\n    readonly ADDITION: number;\n    readonly MODIFICATION: number;\n    readonly REMOVAL: number;\n}\n\ndeclare var MutationEvent: {\n    prototype: MutationEvent;\n    new(): MutationEvent;\n    readonly ADDITION: number;\n    readonly MODIFICATION: number;\n    readonly REMOVAL: number;\n};\n\ninterface MutationObserver {\n    disconnect(): void;\n    observe(target: Node, options: MutationObserverInit): void;\n    takeRecords(): MutationRecord[];\n}\n\ndeclare var MutationObserver: {\n    prototype: MutationObserver;\n    new(callback: MutationCallback): MutationObserver;\n};\n\ninterface MutationRecord {\n    readonly addedNodes: NodeList;\n    readonly attributeName: string | null;\n    readonly attributeNamespace: string | null;\n    readonly nextSibling: Node | null;\n    readonly oldValue: string | null;\n    readonly previousSibling: Node | null;\n    readonly removedNodes: NodeList;\n    readonly target: Node;\n    readonly type: string;\n}\n\ndeclare var MutationRecord: {\n    prototype: MutationRecord;\n    new(): MutationRecord;\n};\n\ninterface NamedNodeMap {\n    readonly length: number;\n    getNamedItem(name: string): Attr;\n    getNamedItemNS(namespaceURI: string | null, localName: string | null): Attr;\n    item(index: number): Attr;\n    removeNamedItem(name: string): Attr;\n    removeNamedItemNS(namespaceURI: string | null, localName: string | null): Attr;\n    setNamedItem(arg: Attr): Attr;\n    setNamedItemNS(arg: Attr): Attr;\n    [index: number]: Attr;\n}\n\ndeclare var NamedNodeMap: {\n    prototype: NamedNodeMap;\n    new(): NamedNodeMap;\n};\n\ninterface NavigationCompletedEvent extends NavigationEvent {\n    readonly isSuccess: boolean;\n    readonly webErrorStatus: number;\n}\n\ndeclare var NavigationCompletedEvent: {\n    prototype: NavigationCompletedEvent;\n    new(): NavigationCompletedEvent;\n};\n\ninterface NavigationEvent extends Event {\n    readonly uri: string;\n}\n\ndeclare var NavigationEvent: {\n    prototype: NavigationEvent;\n    new(): NavigationEvent;\n};\n\ninterface NavigationEventWithReferrer extends NavigationEvent {\n    readonly referer: string;\n}\n\ndeclare var NavigationEventWithReferrer: {\n    prototype: NavigationEventWithReferrer;\n    new(): NavigationEventWithReferrer;\n};\n\ninterface Navigator extends Object, NavigatorID, NavigatorOnLine, NavigatorContentUtils, NavigatorStorageUtils, NavigatorGeolocation, MSNavigatorDoNotTrack, MSFileSaver, NavigatorBeacon, NavigatorConcurrentHardware, NavigatorUserMedia {\n    readonly authentication: WebAuthentication;\n    readonly cookieEnabled: boolean;\n    gamepadInputEmulation: GamepadInputEmulationType;\n    readonly language: string;\n    readonly maxTouchPoints: number;\n    readonly mimeTypes: MimeTypeArray;\n    readonly msManipulationViewsEnabled: boolean;\n    readonly msMaxTouchPoints: number;\n    readonly msPointerEnabled: boolean;\n    readonly plugins: PluginArray;\n    readonly pointerEnabled: boolean;\n    readonly serviceWorker: ServiceWorkerContainer;\n    readonly webdriver: boolean;\n    readonly hardwareConcurrency: number;\n    readonly languages: string[];\n    getGamepads(): Gamepad[];\n    javaEnabled(): boolean;\n    msLaunchUri(uri: string, successCallback?: MSLaunchUriCallback, noHandlerCallback?: MSLaunchUriCallback): void;\n    requestMediaKeySystemAccess(keySystem: string, supportedConfigurations: MediaKeySystemConfiguration[]): Promise<MediaKeySystemAccess>;\n    vibrate(pattern: number | number[]): boolean;\n}\n\ndeclare var Navigator: {\n    prototype: Navigator;\n    new(): Navigator;\n};\n\ninterface Node extends EventTarget {\n    readonly attributes: NamedNodeMap;\n    readonly baseURI: string | null;\n    readonly childNodes: NodeList;\n    readonly firstChild: Node | null;\n    readonly lastChild: Node | null;\n    readonly localName: string | null;\n    readonly namespaceURI: string | null;\n    readonly nextSibling: Node | null;\n    readonly nodeName: string;\n    readonly nodeType: number;\n    nodeValue: string | null;\n    readonly ownerDocument: Document;\n    readonly parentElement: HTMLElement | null;\n    readonly parentNode: Node | null;\n    readonly previousSibling: Node | null;\n    textContent: string | null;\n    appendChild<T extends Node>(newChild: T): T;\n    cloneNode(deep?: boolean): Node;\n    compareDocumentPosition(other: Node): number;\n    contains(child: Node): boolean;\n    hasAttributes(): boolean;\n    hasChildNodes(): boolean;\n    insertBefore<T extends Node>(newChild: T, refChild: Node | null): T;\n    isDefaultNamespace(namespaceURI: string | null): boolean;\n    isEqualNode(arg: Node): boolean;\n    isSameNode(other: Node): boolean;\n    lookupNamespaceURI(prefix: string | null): string | null;\n    lookupPrefix(namespaceURI: string | null): string | null;\n    normalize(): void;\n    removeChild<T extends Node>(oldChild: T): T;\n    replaceChild<T extends Node>(newChild: Node, oldChild: T): T;\n    readonly ATTRIBUTE_NODE: number;\n    readonly CDATA_SECTION_NODE: number;\n    readonly COMMENT_NODE: number;\n    readonly DOCUMENT_FRAGMENT_NODE: number;\n    readonly DOCUMENT_NODE: number;\n    readonly DOCUMENT_POSITION_CONTAINED_BY: number;\n    readonly DOCUMENT_POSITION_CONTAINS: number;\n    readonly DOCUMENT_POSITION_DISCONNECTED: number;\n    readonly DOCUMENT_POSITION_FOLLOWING: number;\n    readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;\n    readonly DOCUMENT_POSITION_PRECEDING: number;\n    readonly DOCUMENT_TYPE_NODE: number;\n    readonly ELEMENT_NODE: number;\n    readonly ENTITY_NODE: number;\n    readonly ENTITY_REFERENCE_NODE: number;\n    readonly NOTATION_NODE: number;\n    readonly PROCESSING_INSTRUCTION_NODE: number;\n    readonly TEXT_NODE: number;\n}\n\ndeclare var Node: {\n    prototype: Node;\n    new(): Node;\n    readonly ATTRIBUTE_NODE: number;\n    readonly CDATA_SECTION_NODE: number;\n    readonly COMMENT_NODE: number;\n    readonly DOCUMENT_FRAGMENT_NODE: number;\n    readonly DOCUMENT_NODE: number;\n    readonly DOCUMENT_POSITION_CONTAINED_BY: number;\n    readonly DOCUMENT_POSITION_CONTAINS: number;\n    readonly DOCUMENT_POSITION_DISCONNECTED: number;\n    readonly DOCUMENT_POSITION_FOLLOWING: number;\n    readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;\n    readonly DOCUMENT_POSITION_PRECEDING: number;\n    readonly DOCUMENT_TYPE_NODE: number;\n    readonly ELEMENT_NODE: number;\n    readonly ENTITY_NODE: number;\n    readonly ENTITY_REFERENCE_NODE: number;\n    readonly NOTATION_NODE: number;\n    readonly PROCESSING_INSTRUCTION_NODE: number;\n    readonly TEXT_NODE: number;\n};\n\ninterface NodeFilter {\n    acceptNode(n: Node): number;\n}\n\ndeclare var NodeFilter: {\n    readonly FILTER_ACCEPT: number;\n    readonly FILTER_REJECT: number;\n    readonly FILTER_SKIP: number;\n    readonly SHOW_ALL: number;\n    readonly SHOW_ATTRIBUTE: number;\n    readonly SHOW_CDATA_SECTION: number;\n    readonly SHOW_COMMENT: number;\n    readonly SHOW_DOCUMENT: number;\n    readonly SHOW_DOCUMENT_FRAGMENT: number;\n    readonly SHOW_DOCUMENT_TYPE: number;\n    readonly SHOW_ELEMENT: number;\n    readonly SHOW_ENTITY: number;\n    readonly SHOW_ENTITY_REFERENCE: number;\n    readonly SHOW_NOTATION: number;\n    readonly SHOW_PROCESSING_INSTRUCTION: number;\n    readonly SHOW_TEXT: number;\n};\n\ninterface NodeIterator {\n    readonly expandEntityReferences: boolean;\n    readonly filter: NodeFilter;\n    readonly root: Node;\n    readonly whatToShow: number;\n    detach(): void;\n    nextNode(): Node;\n    previousNode(): Node;\n}\n\ndeclare var NodeIterator: {\n    prototype: NodeIterator;\n    new(): NodeIterator;\n};\n\ninterface NodeList {\n    readonly length: number;\n    item(index: number): Node;\n    [index: number]: Node;\n}\n\ndeclare var NodeList: {\n    prototype: NodeList;\n    new(): NodeList;\n};\n\ninterface NotificationEventMap {\n    \"click\": Event;\n    \"close\": Event;\n    \"error\": Event;\n    \"show\": Event;\n}\n\ninterface Notification extends EventTarget {\n    readonly body: string;\n    readonly dir: NotificationDirection;\n    readonly icon: string;\n    readonly lang: string;\n    onclick: (this: Notification, ev: Event) => any;\n    onclose: (this: Notification, ev: Event) => any;\n    onerror: (this: Notification, ev: Event) => any;\n    onshow: (this: Notification, ev: Event) => any;\n    readonly permission: NotificationPermission;\n    readonly tag: string;\n    readonly title: string;\n    close(): void;\n    addEventListener<K extends keyof NotificationEventMap>(type: K, listener: (this: Notification, ev: NotificationEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var Notification: {\n    prototype: Notification;\n    new(title: string, options?: NotificationOptions): Notification;\n    requestPermission(callback?: NotificationPermissionCallback): Promise<NotificationPermission>;\n};\n\ninterface OES_element_index_uint {\n}\n\ndeclare var OES_element_index_uint: {\n    prototype: OES_element_index_uint;\n    new(): OES_element_index_uint;\n};\n\ninterface OES_standard_derivatives {\n    readonly FRAGMENT_SHADER_DERIVATIVE_HINT_OES: number;\n}\n\ndeclare var OES_standard_derivatives: {\n    prototype: OES_standard_derivatives;\n    new(): OES_standard_derivatives;\n    readonly FRAGMENT_SHADER_DERIVATIVE_HINT_OES: number;\n};\n\ninterface OES_texture_float {\n}\n\ndeclare var OES_texture_float: {\n    prototype: OES_texture_float;\n    new(): OES_texture_float;\n};\n\ninterface OES_texture_float_linear {\n}\n\ndeclare var OES_texture_float_linear: {\n    prototype: OES_texture_float_linear;\n    new(): OES_texture_float_linear;\n};\n\ninterface OES_texture_half_float {\n    readonly HALF_FLOAT_OES: number;\n}\n\ndeclare var OES_texture_half_float: {\n    prototype: OES_texture_half_float;\n    new(): OES_texture_half_float;\n    readonly HALF_FLOAT_OES: number;\n};\n\ninterface OES_texture_half_float_linear {\n}\n\ndeclare var OES_texture_half_float_linear: {\n    prototype: OES_texture_half_float_linear;\n    new(): OES_texture_half_float_linear;\n};\n\ninterface OfflineAudioCompletionEvent extends Event {\n    readonly renderedBuffer: AudioBuffer;\n}\n\ndeclare var OfflineAudioCompletionEvent: {\n    prototype: OfflineAudioCompletionEvent;\n    new(): OfflineAudioCompletionEvent;\n};\n\ninterface OfflineAudioContextEventMap extends AudioContextEventMap {\n    \"complete\": OfflineAudioCompletionEvent;\n}\n\ninterface OfflineAudioContext extends AudioContextBase {\n    readonly length: number;\n    oncomplete: (this: OfflineAudioContext, ev: OfflineAudioCompletionEvent) => any;\n    startRendering(): Promise<AudioBuffer>;\n    suspend(suspendTime: number): Promise<void>;\n    addEventListener<K extends keyof OfflineAudioContextEventMap>(type: K, listener: (this: OfflineAudioContext, ev: OfflineAudioContextEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var OfflineAudioContext: {\n    prototype: OfflineAudioContext;\n    new(numberOfChannels: number, length: number, sampleRate: number): OfflineAudioContext;\n};\n\ninterface OscillatorNodeEventMap {\n    \"ended\": MediaStreamErrorEvent;\n}\n\ninterface OscillatorNode extends AudioNode {\n    readonly detune: AudioParam;\n    readonly frequency: AudioParam;\n    onended: (this: OscillatorNode, ev: MediaStreamErrorEvent) => any;\n    type: OscillatorType;\n    setPeriodicWave(periodicWave: PeriodicWave): void;\n    start(when?: number): void;\n    stop(when?: number): void;\n    addEventListener<K extends keyof OscillatorNodeEventMap>(type: K, listener: (this: OscillatorNode, ev: OscillatorNodeEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var OscillatorNode: {\n    prototype: OscillatorNode;\n    new(): OscillatorNode;\n};\n\ninterface OverflowEvent extends UIEvent {\n    readonly horizontalOverflow: boolean;\n    readonly orient: number;\n    readonly verticalOverflow: boolean;\n    readonly BOTH: number;\n    readonly HORIZONTAL: number;\n    readonly VERTICAL: number;\n}\n\ndeclare var OverflowEvent: {\n    prototype: OverflowEvent;\n    new(): OverflowEvent;\n    readonly BOTH: number;\n    readonly HORIZONTAL: number;\n    readonly VERTICAL: number;\n};\n\ninterface PageTransitionEvent extends Event {\n    readonly persisted: boolean;\n}\n\ndeclare var PageTransitionEvent: {\n    prototype: PageTransitionEvent;\n    new(): PageTransitionEvent;\n};\n\ninterface PannerNode extends AudioNode {\n    coneInnerAngle: number;\n    coneOuterAngle: number;\n    coneOuterGain: number;\n    distanceModel: DistanceModelType;\n    maxDistance: number;\n    panningModel: PanningModelType;\n    refDistance: number;\n    rolloffFactor: number;\n    setOrientation(x: number, y: number, z: number): void;\n    setPosition(x: number, y: number, z: number): void;\n    setVelocity(x: number, y: number, z: number): void;\n}\n\ndeclare var PannerNode: {\n    prototype: PannerNode;\n    new(): PannerNode;\n};\n\ninterface Path2D extends Object, CanvasPathMethods {\n}\n\ndeclare var Path2D: {\n    prototype: Path2D;\n    new(path?: Path2D): Path2D;\n};\n\ninterface PaymentAddress {\n    readonly addressLine: string[];\n    readonly city: string;\n    readonly country: string;\n    readonly dependentLocality: string;\n    readonly languageCode: string;\n    readonly organization: string;\n    readonly phone: string;\n    readonly postalCode: string;\n    readonly recipient: string;\n    readonly region: string;\n    readonly sortingCode: string;\n    toJSON(): any;\n}\n\ndeclare var PaymentAddress: {\n    prototype: PaymentAddress;\n    new(): PaymentAddress;\n};\n\ninterface PaymentRequestEventMap {\n    \"shippingaddresschange\": Event;\n    \"shippingoptionchange\": Event;\n}\n\ninterface PaymentRequest extends EventTarget {\n    onshippingaddresschange: (this: PaymentRequest, ev: Event) => any;\n    onshippingoptionchange: (this: PaymentRequest, ev: Event) => any;\n    readonly shippingAddress: PaymentAddress | null;\n    readonly shippingOption: string | null;\n    readonly shippingType: PaymentShippingType | null;\n    abort(): Promise<void>;\n    show(): Promise<PaymentResponse>;\n    addEventListener<K extends keyof PaymentRequestEventMap>(type: K, listener: (this: PaymentRequest, ev: PaymentRequestEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var PaymentRequest: {\n    prototype: PaymentRequest;\n    new(methodData: PaymentMethodData[], details: PaymentDetails, options?: PaymentOptions): PaymentRequest;\n};\n\ninterface PaymentRequestUpdateEvent extends Event {\n    updateWith(d: Promise<PaymentDetails>): void;\n}\n\ndeclare var PaymentRequestUpdateEvent: {\n    prototype: PaymentRequestUpdateEvent;\n    new(type: string, eventInitDict?: PaymentRequestUpdateEventInit): PaymentRequestUpdateEvent;\n};\n\ninterface PaymentResponse {\n    readonly details: any;\n    readonly methodName: string;\n    readonly payerEmail: string | null;\n    readonly payerName: string | null;\n    readonly payerPhone: string | null;\n    readonly shippingAddress: PaymentAddress | null;\n    readonly shippingOption: string | null;\n    complete(result?: PaymentComplete): Promise<void>;\n    toJSON(): any;\n}\n\ndeclare var PaymentResponse: {\n    prototype: PaymentResponse;\n    new(): PaymentResponse;\n};\n\ninterface Performance {\n    readonly navigation: PerformanceNavigation;\n    readonly timing: PerformanceTiming;\n    clearMarks(markName?: string): void;\n    clearMeasures(measureName?: string): void;\n    clearResourceTimings(): void;\n    getEntries(): any;\n    getEntriesByName(name: string, entryType?: string): any;\n    getEntriesByType(entryType: string): any;\n    getMarks(markName?: string): any;\n    getMeasures(measureName?: string): any;\n    mark(markName: string): void;\n    measure(measureName: string, startMarkName?: string, endMarkName?: string): void;\n    now(): number;\n    setResourceTimingBufferSize(maxSize: number): void;\n    toJSON(): any;\n}\n\ndeclare var Performance: {\n    prototype: Performance;\n    new(): Performance;\n};\n\ninterface PerformanceEntry {\n    readonly duration: number;\n    readonly entryType: string;\n    readonly name: string;\n    readonly startTime: number;\n}\n\ndeclare var PerformanceEntry: {\n    prototype: PerformanceEntry;\n    new(): PerformanceEntry;\n};\n\ninterface PerformanceMark extends PerformanceEntry {\n}\n\ndeclare var PerformanceMark: {\n    prototype: PerformanceMark;\n    new(): PerformanceMark;\n};\n\ninterface PerformanceMeasure extends PerformanceEntry {\n}\n\ndeclare var PerformanceMeasure: {\n    prototype: PerformanceMeasure;\n    new(): PerformanceMeasure;\n};\n\ninterface PerformanceNavigation {\n    readonly redirectCount: number;\n    readonly type: number;\n    toJSON(): any;\n    readonly TYPE_BACK_FORWARD: number;\n    readonly TYPE_NAVIGATE: number;\n    readonly TYPE_RELOAD: number;\n    readonly TYPE_RESERVED: number;\n}\n\ndeclare var PerformanceNavigation: {\n    prototype: PerformanceNavigation;\n    new(): PerformanceNavigation;\n    readonly TYPE_BACK_FORWARD: number;\n    readonly TYPE_NAVIGATE: number;\n    readonly TYPE_RELOAD: number;\n    readonly TYPE_RESERVED: number;\n};\n\ninterface PerformanceNavigationTiming extends PerformanceEntry {\n    readonly connectEnd: number;\n    readonly connectStart: number;\n    readonly domainLookupEnd: number;\n    readonly domainLookupStart: number;\n    readonly domComplete: number;\n    readonly domContentLoadedEventEnd: number;\n    readonly domContentLoadedEventStart: number;\n    readonly domInteractive: number;\n    readonly domLoading: number;\n    readonly fetchStart: number;\n    readonly loadEventEnd: number;\n    readonly loadEventStart: number;\n    readonly navigationStart: number;\n    readonly redirectCount: number;\n    readonly redirectEnd: number;\n    readonly redirectStart: number;\n    readonly requestStart: number;\n    readonly responseEnd: number;\n    readonly responseStart: number;\n    readonly type: NavigationType;\n    readonly unloadEventEnd: number;\n    readonly unloadEventStart: number;\n}\n\ndeclare var PerformanceNavigationTiming: {\n    prototype: PerformanceNavigationTiming;\n    new(): PerformanceNavigationTiming;\n};\n\ninterface PerformanceResourceTiming extends PerformanceEntry {\n    readonly connectEnd: number;\n    readonly connectStart: number;\n    readonly domainLookupEnd: number;\n    readonly domainLookupStart: number;\n    readonly fetchStart: number;\n    readonly initiatorType: string;\n    readonly redirectEnd: number;\n    readonly redirectStart: number;\n    readonly requestStart: number;\n    readonly responseEnd: number;\n    readonly responseStart: number;\n}\n\ndeclare var PerformanceResourceTiming: {\n    prototype: PerformanceResourceTiming;\n    new(): PerformanceResourceTiming;\n};\n\ninterface PerformanceTiming {\n    readonly connectEnd: number;\n    readonly connectStart: number;\n    readonly domainLookupEnd: number;\n    readonly domainLookupStart: number;\n    readonly domComplete: number;\n    readonly domContentLoadedEventEnd: number;\n    readonly domContentLoadedEventStart: number;\n    readonly domInteractive: number;\n    readonly domLoading: number;\n    readonly fetchStart: number;\n    readonly loadEventEnd: number;\n    readonly loadEventStart: number;\n    readonly msFirstPaint: number;\n    readonly navigationStart: number;\n    readonly redirectEnd: number;\n    readonly redirectStart: number;\n    readonly requestStart: number;\n    readonly responseEnd: number;\n    readonly responseStart: number;\n    readonly unloadEventEnd: number;\n    readonly unloadEventStart: number;\n    readonly secureConnectionStart: number;\n    toJSON(): any;\n}\n\ndeclare var PerformanceTiming: {\n    prototype: PerformanceTiming;\n    new(): PerformanceTiming;\n};\n\ninterface PerfWidgetExternal {\n    readonly activeNetworkRequestCount: number;\n    readonly averageFrameTime: number;\n    readonly averagePaintTime: number;\n    readonly extraInformationEnabled: boolean;\n    readonly independentRenderingEnabled: boolean;\n    readonly irDisablingContentString: string;\n    readonly irStatusAvailable: boolean;\n    readonly maxCpuSpeed: number;\n    readonly paintRequestsPerSecond: number;\n    readonly performanceCounter: number;\n    readonly performanceCounterFrequency: number;\n    addEventListener(eventType: string, callback: Function): void;\n    getMemoryUsage(): number;\n    getProcessCpuUsage(): number;\n    getRecentCpuUsage(last: number | null): any;\n    getRecentFrames(last: number | null): any;\n    getRecentMemoryUsage(last: number | null): any;\n    getRecentPaintRequests(last: number | null): any;\n    removeEventListener(eventType: string, callback: Function): void;\n    repositionWindow(x: number, y: number): void;\n    resizeWindow(width: number, height: number): void;\n}\n\ndeclare var PerfWidgetExternal: {\n    prototype: PerfWidgetExternal;\n    new(): PerfWidgetExternal;\n};\n\ninterface PeriodicWave {\n}\n\ndeclare var PeriodicWave: {\n    prototype: PeriodicWave;\n    new(): PeriodicWave;\n};\n\ninterface PermissionRequest extends DeferredPermissionRequest {\n    readonly state: MSWebViewPermissionState;\n    defer(): void;\n}\n\ndeclare var PermissionRequest: {\n    prototype: PermissionRequest;\n    new(): PermissionRequest;\n};\n\ninterface PermissionRequestedEvent extends Event {\n    readonly permissionRequest: PermissionRequest;\n}\n\ndeclare var PermissionRequestedEvent: {\n    prototype: PermissionRequestedEvent;\n    new(): PermissionRequestedEvent;\n};\n\ninterface Plugin {\n    readonly description: string;\n    readonly filename: string;\n    readonly length: number;\n    readonly name: string;\n    readonly version: string;\n    item(index: number): MimeType;\n    namedItem(type: string): MimeType;\n    [index: number]: MimeType;\n}\n\ndeclare var Plugin: {\n    prototype: Plugin;\n    new(): Plugin;\n};\n\ninterface PluginArray {\n    readonly length: number;\n    item(index: number): Plugin;\n    namedItem(name: string): Plugin;\n    refresh(reload?: boolean): void;\n    [index: number]: Plugin;\n}\n\ndeclare var PluginArray: {\n    prototype: PluginArray;\n    new(): PluginArray;\n};\n\ninterface PointerEvent extends MouseEvent {\n    readonly currentPoint: any;\n    readonly height: number;\n    readonly hwTimestamp: number;\n    readonly intermediatePoints: any;\n    readonly isPrimary: boolean;\n    readonly pointerId: number;\n    readonly pointerType: any;\n    readonly pressure: number;\n    readonly rotation: number;\n    readonly tiltX: number;\n    readonly tiltY: number;\n    readonly width: number;\n    getCurrentPoint(element: Element): void;\n    getIntermediatePoints(element: Element): void;\n    initPointerEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, ctrlKeyArg: boolean, altKeyArg: boolean, shiftKeyArg: boolean, metaKeyArg: boolean, buttonArg: number, relatedTargetArg: EventTarget, offsetXArg: number, offsetYArg: number, widthArg: number, heightArg: number, pressure: number, rotation: number, tiltX: number, tiltY: number, pointerIdArg: number, pointerType: any, hwTimestampArg: number, isPrimary: boolean): void;\n}\n\ndeclare var PointerEvent: {\n    prototype: PointerEvent;\n    new(typeArg: string, eventInitDict?: PointerEventInit): PointerEvent;\n};\n\ninterface PopStateEvent extends Event {\n    readonly state: any;\n    initPopStateEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, stateArg: any): void;\n}\n\ndeclare var PopStateEvent: {\n    prototype: PopStateEvent;\n    new(typeArg: string, eventInitDict?: PopStateEventInit): PopStateEvent;\n};\n\ninterface Position {\n    readonly coords: Coordinates;\n    readonly timestamp: number;\n}\n\ndeclare var Position: {\n    prototype: Position;\n    new(): Position;\n};\n\ninterface PositionError {\n    readonly code: number;\n    readonly message: string;\n    toString(): string;\n    readonly PERMISSION_DENIED: number;\n    readonly POSITION_UNAVAILABLE: number;\n    readonly TIMEOUT: number;\n}\n\ndeclare var PositionError: {\n    prototype: PositionError;\n    new(): PositionError;\n    readonly PERMISSION_DENIED: number;\n    readonly POSITION_UNAVAILABLE: number;\n    readonly TIMEOUT: number;\n};\n\ninterface ProcessingInstruction extends CharacterData {\n    readonly target: string;\n}\n\ndeclare var ProcessingInstruction: {\n    prototype: ProcessingInstruction;\n    new(): ProcessingInstruction;\n};\n\ninterface ProgressEvent extends Event {\n    readonly lengthComputable: boolean;\n    readonly loaded: number;\n    readonly total: number;\n    initProgressEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, lengthComputableArg: boolean, loadedArg: number, totalArg: number): void;\n}\n\ndeclare var ProgressEvent: {\n    prototype: ProgressEvent;\n    new(type: string, eventInitDict?: ProgressEventInit): ProgressEvent;\n};\n\ninterface PushManager {\n    getSubscription(): Promise<PushSubscription>;\n    permissionState(options?: PushSubscriptionOptionsInit): Promise<PushPermissionState>;\n    subscribe(options?: PushSubscriptionOptionsInit): Promise<PushSubscription>;\n}\n\ndeclare var PushManager: {\n    prototype: PushManager;\n    new(): PushManager;\n};\n\ninterface PushSubscription {\n    readonly endpoint: USVString;\n    readonly options: PushSubscriptionOptions;\n    getKey(name: PushEncryptionKeyName): ArrayBuffer | null;\n    toJSON(): any;\n    unsubscribe(): Promise<boolean>;\n}\n\ndeclare var PushSubscription: {\n    prototype: PushSubscription;\n    new(): PushSubscription;\n};\n\ninterface PushSubscriptionOptions {\n    readonly applicationServerKey: ArrayBuffer | null;\n    readonly userVisibleOnly: boolean;\n}\n\ndeclare var PushSubscriptionOptions: {\n    prototype: PushSubscriptionOptions;\n    new(): PushSubscriptionOptions;\n};\n\ninterface Range {\n    readonly collapsed: boolean;\n    readonly commonAncestorContainer: Node;\n    readonly endContainer: Node;\n    readonly endOffset: number;\n    readonly startContainer: Node;\n    readonly startOffset: number;\n    cloneContents(): DocumentFragment;\n    cloneRange(): Range;\n    collapse(toStart: boolean): void;\n    compareBoundaryPoints(how: number, sourceRange: Range): number;\n    createContextualFragment(fragment: string): DocumentFragment;\n    deleteContents(): void;\n    detach(): void;\n    expand(Unit: ExpandGranularity): boolean;\n    extractContents(): DocumentFragment;\n    getBoundingClientRect(): ClientRect;\n    getClientRects(): ClientRectList;\n    insertNode(newNode: Node): void;\n    selectNode(refNode: Node): void;\n    selectNodeContents(refNode: Node): void;\n    setEnd(refNode: Node, offset: number): void;\n    setEndAfter(refNode: Node): void;\n    setEndBefore(refNode: Node): void;\n    setStart(refNode: Node, offset: number): void;\n    setStartAfter(refNode: Node): void;\n    setStartBefore(refNode: Node): void;\n    surroundContents(newParent: Node): void;\n    toString(): string;\n    readonly END_TO_END: number;\n    readonly END_TO_START: number;\n    readonly START_TO_END: number;\n    readonly START_TO_START: number;\n}\n\ndeclare var Range: {\n    prototype: Range;\n    new(): Range;\n    readonly END_TO_END: number;\n    readonly END_TO_START: number;\n    readonly START_TO_END: number;\n    readonly START_TO_START: number;\n};\n\ninterface ReadableStream {\n    readonly locked: boolean;\n    cancel(): Promise<void>;\n    getReader(): ReadableStreamReader;\n}\n\ndeclare var ReadableStream: {\n    prototype: ReadableStream;\n    new(): ReadableStream;\n};\n\ninterface ReadableStreamReader {\n    cancel(): Promise<void>;\n    read(): Promise<any>;\n    releaseLock(): void;\n}\n\ndeclare var ReadableStreamReader: {\n    prototype: ReadableStreamReader;\n    new(): ReadableStreamReader;\n};\n\ninterface Request extends Object, Body {\n    readonly cache: RequestCache;\n    readonly credentials: RequestCredentials;\n    readonly destination: RequestDestination;\n    readonly headers: Headers;\n    readonly integrity: string;\n    readonly keepalive: boolean;\n    readonly method: string;\n    readonly mode: RequestMode;\n    readonly redirect: RequestRedirect;\n    readonly referrer: string;\n    readonly referrerPolicy: ReferrerPolicy;\n    readonly type: RequestType;\n    readonly url: string;\n    clone(): Request;\n}\n\ndeclare var Request: {\n    prototype: Request;\n    new(input: Request | string, init?: RequestInit): Request;\n};\n\ninterface Response extends Object, Body {\n    readonly body: ReadableStream | null;\n    readonly headers: Headers;\n    readonly ok: boolean;\n    readonly status: number;\n    readonly statusText: string;\n    readonly type: ResponseType;\n    readonly url: string;\n    clone(): Response;\n}\n\ndeclare var Response: {\n    prototype: Response;\n    new(body?: any, init?: ResponseInit): Response;\n    error: () => Response;\n    redirect: (url: string, status?: number) => Response;\n};\n\ninterface RTCDtlsTransportEventMap {\n    \"dtlsstatechange\": RTCDtlsTransportStateChangedEvent;\n    \"error\": Event;\n}\n\ninterface RTCDtlsTransport extends RTCStatsProvider {\n    ondtlsstatechange: ((this: RTCDtlsTransport, ev: RTCDtlsTransportStateChangedEvent) => any) | null;\n    onerror: ((this: RTCDtlsTransport, ev: Event) => any) | null;\n    readonly state: RTCDtlsTransportState;\n    readonly transport: RTCIceTransport;\n    getLocalParameters(): RTCDtlsParameters;\n    getRemoteCertificates(): ArrayBuffer[];\n    getRemoteParameters(): RTCDtlsParameters | null;\n    start(remoteParameters: RTCDtlsParameters): void;\n    stop(): void;\n    addEventListener<K extends keyof RTCDtlsTransportEventMap>(type: K, listener: (this: RTCDtlsTransport, ev: RTCDtlsTransportEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var RTCDtlsTransport: {\n    prototype: RTCDtlsTransport;\n    new(transport: RTCIceTransport): RTCDtlsTransport;\n};\n\ninterface RTCDtlsTransportStateChangedEvent extends Event {\n    readonly state: RTCDtlsTransportState;\n}\n\ndeclare var RTCDtlsTransportStateChangedEvent: {\n    prototype: RTCDtlsTransportStateChangedEvent;\n    new(): RTCDtlsTransportStateChangedEvent;\n};\n\ninterface RTCDtmfSenderEventMap {\n    \"tonechange\": RTCDTMFToneChangeEvent;\n}\n\ninterface RTCDtmfSender extends EventTarget {\n    readonly canInsertDTMF: boolean;\n    readonly duration: number;\n    readonly interToneGap: number;\n    ontonechange: (this: RTCDtmfSender, ev: RTCDTMFToneChangeEvent) => any;\n    readonly sender: RTCRtpSender;\n    readonly toneBuffer: string;\n    insertDTMF(tones: string, duration?: number, interToneGap?: number): void;\n    addEventListener<K extends keyof RTCDtmfSenderEventMap>(type: K, listener: (this: RTCDtmfSender, ev: RTCDtmfSenderEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var RTCDtmfSender: {\n    prototype: RTCDtmfSender;\n    new(sender: RTCRtpSender): RTCDtmfSender;\n};\n\ninterface RTCDTMFToneChangeEvent extends Event {\n    readonly tone: string;\n}\n\ndeclare var RTCDTMFToneChangeEvent: {\n    prototype: RTCDTMFToneChangeEvent;\n    new(typeArg: string, eventInitDict: RTCDTMFToneChangeEventInit): RTCDTMFToneChangeEvent;\n};\n\ninterface RTCIceCandidate {\n    candidate: string | null;\n    sdpMid: string | null;\n    sdpMLineIndex: number | null;\n    toJSON(): any;\n}\n\ndeclare var RTCIceCandidate: {\n    prototype: RTCIceCandidate;\n    new(candidateInitDict?: RTCIceCandidateInit): RTCIceCandidate;\n};\n\ninterface RTCIceCandidatePairChangedEvent extends Event {\n    readonly pair: RTCIceCandidatePair;\n}\n\ndeclare var RTCIceCandidatePairChangedEvent: {\n    prototype: RTCIceCandidatePairChangedEvent;\n    new(): RTCIceCandidatePairChangedEvent;\n};\n\ninterface RTCIceGathererEventMap {\n    \"error\": Event;\n    \"localcandidate\": RTCIceGathererEvent;\n}\n\ninterface RTCIceGatherer extends RTCStatsProvider {\n    readonly component: RTCIceComponent;\n    onerror: ((this: RTCIceGatherer, ev: Event) => any) | null;\n    onlocalcandidate: ((this: RTCIceGatherer, ev: RTCIceGathererEvent) => any) | null;\n    createAssociatedGatherer(): RTCIceGatherer;\n    getLocalCandidates(): RTCIceCandidateDictionary[];\n    getLocalParameters(): RTCIceParameters;\n    addEventListener<K extends keyof RTCIceGathererEventMap>(type: K, listener: (this: RTCIceGatherer, ev: RTCIceGathererEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var RTCIceGatherer: {\n    prototype: RTCIceGatherer;\n    new(options: RTCIceGatherOptions): RTCIceGatherer;\n};\n\ninterface RTCIceGathererEvent extends Event {\n    readonly candidate: RTCIceCandidateDictionary | RTCIceCandidateComplete;\n}\n\ndeclare var RTCIceGathererEvent: {\n    prototype: RTCIceGathererEvent;\n    new(): RTCIceGathererEvent;\n};\n\ninterface RTCIceTransportEventMap {\n    \"candidatepairchange\": RTCIceCandidatePairChangedEvent;\n    \"icestatechange\": RTCIceTransportStateChangedEvent;\n}\n\ninterface RTCIceTransport extends RTCStatsProvider {\n    readonly component: RTCIceComponent;\n    readonly iceGatherer: RTCIceGatherer | null;\n    oncandidatepairchange: ((this: RTCIceTransport, ev: RTCIceCandidatePairChangedEvent) => any) | null;\n    onicestatechange: ((this: RTCIceTransport, ev: RTCIceTransportStateChangedEvent) => any) | null;\n    readonly role: RTCIceRole;\n    readonly state: RTCIceTransportState;\n    addRemoteCandidate(remoteCandidate: RTCIceCandidateDictionary | RTCIceCandidateComplete): void;\n    createAssociatedTransport(): RTCIceTransport;\n    getNominatedCandidatePair(): RTCIceCandidatePair | null;\n    getRemoteCandidates(): RTCIceCandidateDictionary[];\n    getRemoteParameters(): RTCIceParameters | null;\n    setRemoteCandidates(remoteCandidates: RTCIceCandidateDictionary[]): void;\n    start(gatherer: RTCIceGatherer, remoteParameters: RTCIceParameters, role?: RTCIceRole): void;\n    stop(): void;\n    addEventListener<K extends keyof RTCIceTransportEventMap>(type: K, listener: (this: RTCIceTransport, ev: RTCIceTransportEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var RTCIceTransport: {\n    prototype: RTCIceTransport;\n    new(): RTCIceTransport;\n};\n\ninterface RTCIceTransportStateChangedEvent extends Event {\n    readonly state: RTCIceTransportState;\n}\n\ndeclare var RTCIceTransportStateChangedEvent: {\n    prototype: RTCIceTransportStateChangedEvent;\n    new(): RTCIceTransportStateChangedEvent;\n};\n\ninterface RTCPeerConnectionEventMap {\n    \"addstream\": MediaStreamEvent;\n    \"icecandidate\": RTCPeerConnectionIceEvent;\n    \"iceconnectionstatechange\": Event;\n    \"icegatheringstatechange\": Event;\n    \"negotiationneeded\": Event;\n    \"removestream\": MediaStreamEvent;\n    \"signalingstatechange\": Event;\n}\n\ninterface RTCPeerConnection extends EventTarget {\n    readonly canTrickleIceCandidates: boolean | null;\n    readonly iceConnectionState: RTCIceConnectionState;\n    readonly iceGatheringState: RTCIceGatheringState;\n    readonly localDescription: RTCSessionDescription | null;\n    onaddstream: (this: RTCPeerConnection, ev: MediaStreamEvent) => any;\n    onicecandidate: (this: RTCPeerConnection, ev: RTCPeerConnectionIceEvent) => any;\n    oniceconnectionstatechange: (this: RTCPeerConnection, ev: Event) => any;\n    onicegatheringstatechange: (this: RTCPeerConnection, ev: Event) => any;\n    onnegotiationneeded: (this: RTCPeerConnection, ev: Event) => any;\n    onremovestream: (this: RTCPeerConnection, ev: MediaStreamEvent) => any;\n    onsignalingstatechange: (this: RTCPeerConnection, ev: Event) => any;\n    readonly remoteDescription: RTCSessionDescription | null;\n    readonly signalingState: RTCSignalingState;\n    addIceCandidate(candidate: RTCIceCandidate, successCallback?: VoidFunction, failureCallback?: RTCPeerConnectionErrorCallback): Promise<void>;\n    addStream(stream: MediaStream): void;\n    close(): void;\n    createAnswer(successCallback?: RTCSessionDescriptionCallback, failureCallback?: RTCPeerConnectionErrorCallback): Promise<RTCSessionDescription>;\n    createOffer(successCallback?: RTCSessionDescriptionCallback, failureCallback?: RTCPeerConnectionErrorCallback, options?: RTCOfferOptions): Promise<RTCSessionDescription>;\n    getConfiguration(): RTCConfiguration;\n    getLocalStreams(): MediaStream[];\n    getRemoteStreams(): MediaStream[];\n    getStats(selector: MediaStreamTrack | null, successCallback?: RTCStatsCallback, failureCallback?: RTCPeerConnectionErrorCallback): Promise<RTCStatsReport>;\n    getStreamById(streamId: string): MediaStream | null;\n    removeStream(stream: MediaStream): void;\n    setLocalDescription(description: RTCSessionDescription, successCallback?: VoidFunction, failureCallback?: RTCPeerConnectionErrorCallback): Promise<void>;\n    setRemoteDescription(description: RTCSessionDescription, successCallback?: VoidFunction, failureCallback?: RTCPeerConnectionErrorCallback): Promise<void>;\n    addEventListener<K extends keyof RTCPeerConnectionEventMap>(type: K, listener: (this: RTCPeerConnection, ev: RTCPeerConnectionEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var RTCPeerConnection: {\n    prototype: RTCPeerConnection;\n    new(configuration: RTCConfiguration): RTCPeerConnection;\n};\n\ninterface RTCPeerConnectionIceEvent extends Event {\n    readonly candidate: RTCIceCandidate;\n}\n\ndeclare var RTCPeerConnectionIceEvent: {\n    prototype: RTCPeerConnectionIceEvent;\n    new(type: string, eventInitDict: RTCPeerConnectionIceEventInit): RTCPeerConnectionIceEvent;\n};\n\ninterface RTCRtpReceiverEventMap {\n    \"error\": Event;\n}\n\ninterface RTCRtpReceiver extends RTCStatsProvider {\n    onerror: ((this: RTCRtpReceiver, ev: Event) => any) | null;\n    readonly rtcpTransport: RTCDtlsTransport;\n    readonly track: MediaStreamTrack | null;\n    readonly transport: RTCDtlsTransport | RTCSrtpSdesTransport;\n    getContributingSources(): RTCRtpContributingSource[];\n    receive(parameters: RTCRtpParameters): void;\n    requestSendCSRC(csrc: number): void;\n    setTransport(transport: RTCDtlsTransport | RTCSrtpSdesTransport, rtcpTransport?: RTCDtlsTransport): void;\n    stop(): void;\n    addEventListener<K extends keyof RTCRtpReceiverEventMap>(type: K, listener: (this: RTCRtpReceiver, ev: RTCRtpReceiverEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var RTCRtpReceiver: {\n    prototype: RTCRtpReceiver;\n    new(transport: RTCDtlsTransport | RTCSrtpSdesTransport, kind: string, rtcpTransport?: RTCDtlsTransport): RTCRtpReceiver;\n    getCapabilities(kind?: string): RTCRtpCapabilities;\n};\n\ninterface RTCRtpSenderEventMap {\n    \"error\": Event;\n    \"ssrcconflict\": RTCSsrcConflictEvent;\n}\n\ninterface RTCRtpSender extends RTCStatsProvider {\n    onerror: ((this: RTCRtpSender, ev: Event) => any) | null;\n    onssrcconflict: ((this: RTCRtpSender, ev: RTCSsrcConflictEvent) => any) | null;\n    readonly rtcpTransport: RTCDtlsTransport;\n    readonly track: MediaStreamTrack;\n    readonly transport: RTCDtlsTransport | RTCSrtpSdesTransport;\n    send(parameters: RTCRtpParameters): void;\n    setTrack(track: MediaStreamTrack): void;\n    setTransport(transport: RTCDtlsTransport | RTCSrtpSdesTransport, rtcpTransport?: RTCDtlsTransport): void;\n    stop(): void;\n    addEventListener<K extends keyof RTCRtpSenderEventMap>(type: K, listener: (this: RTCRtpSender, ev: RTCRtpSenderEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var RTCRtpSender: {\n    prototype: RTCRtpSender;\n    new(track: MediaStreamTrack, transport: RTCDtlsTransport | RTCSrtpSdesTransport, rtcpTransport?: RTCDtlsTransport): RTCRtpSender;\n    getCapabilities(kind?: string): RTCRtpCapabilities;\n};\n\ninterface RTCSessionDescription {\n    sdp: string | null;\n    type: RTCSdpType | null;\n    toJSON(): any;\n}\n\ndeclare var RTCSessionDescription: {\n    prototype: RTCSessionDescription;\n    new(descriptionInitDict?: RTCSessionDescriptionInit): RTCSessionDescription;\n};\n\ninterface RTCSrtpSdesTransportEventMap {\n    \"error\": Event;\n}\n\ninterface RTCSrtpSdesTransport extends EventTarget {\n    onerror: ((this: RTCSrtpSdesTransport, ev: Event) => any) | null;\n    readonly transport: RTCIceTransport;\n    addEventListener<K extends keyof RTCSrtpSdesTransportEventMap>(type: K, listener: (this: RTCSrtpSdesTransport, ev: RTCSrtpSdesTransportEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var RTCSrtpSdesTransport: {\n    prototype: RTCSrtpSdesTransport;\n    new(transport: RTCIceTransport, encryptParameters: RTCSrtpSdesParameters, decryptParameters: RTCSrtpSdesParameters): RTCSrtpSdesTransport;\n    getLocalParameters(): RTCSrtpSdesParameters[];\n};\n\ninterface RTCSsrcConflictEvent extends Event {\n    readonly ssrc: number;\n}\n\ndeclare var RTCSsrcConflictEvent: {\n    prototype: RTCSsrcConflictEvent;\n    new(): RTCSsrcConflictEvent;\n};\n\ninterface RTCStatsProvider extends EventTarget {\n    getStats(): Promise<RTCStatsReport>;\n    msGetStats(): Promise<RTCStatsReport>;\n}\n\ndeclare var RTCStatsProvider: {\n    prototype: RTCStatsProvider;\n    new(): RTCStatsProvider;\n};\n\ninterface ScopedCredential {\n    readonly id: ArrayBuffer;\n    readonly type: ScopedCredentialType;\n}\n\ndeclare var ScopedCredential: {\n    prototype: ScopedCredential;\n    new(): ScopedCredential;\n};\n\ninterface ScopedCredentialInfo {\n    readonly credential: ScopedCredential;\n    readonly publicKey: CryptoKey;\n}\n\ndeclare var ScopedCredentialInfo: {\n    prototype: ScopedCredentialInfo;\n    new(): ScopedCredentialInfo;\n};\n\ninterface ScreenEventMap {\n    \"MSOrientationChange\": Event;\n}\n\ninterface Screen extends EventTarget {\n    readonly availHeight: number;\n    readonly availWidth: number;\n    bufferDepth: number;\n    readonly colorDepth: number;\n    readonly deviceXDPI: number;\n    readonly deviceYDPI: number;\n    readonly fontSmoothingEnabled: boolean;\n    readonly height: number;\n    readonly logicalXDPI: number;\n    readonly logicalYDPI: number;\n    readonly msOrientation: string;\n    onmsorientationchange: (this: Screen, ev: Event) => any;\n    readonly pixelDepth: number;\n    readonly systemXDPI: number;\n    readonly systemYDPI: number;\n    readonly width: number;\n    msLockOrientation(orientations: string | string[]): boolean;\n    msUnlockOrientation(): void;\n    addEventListener<K extends keyof ScreenEventMap>(type: K, listener: (this: Screen, ev: ScreenEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var Screen: {\n    prototype: Screen;\n    new(): Screen;\n};\n\ninterface ScriptNotifyEvent extends Event {\n    readonly callingUri: string;\n    readonly value: string;\n}\n\ndeclare var ScriptNotifyEvent: {\n    prototype: ScriptNotifyEvent;\n    new(): ScriptNotifyEvent;\n};\n\ninterface ScriptProcessorNodeEventMap {\n    \"audioprocess\": AudioProcessingEvent;\n}\n\ninterface ScriptProcessorNode extends AudioNode {\n    readonly bufferSize: number;\n    onaudioprocess: (this: ScriptProcessorNode, ev: AudioProcessingEvent) => any;\n    addEventListener<K extends keyof ScriptProcessorNodeEventMap>(type: K, listener: (this: ScriptProcessorNode, ev: ScriptProcessorNodeEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var ScriptProcessorNode: {\n    prototype: ScriptProcessorNode;\n    new(): ScriptProcessorNode;\n};\n\ninterface Selection {\n    readonly anchorNode: Node;\n    readonly anchorOffset: number;\n    readonly baseNode: Node;\n    readonly baseOffset: number;\n    readonly extentNode: Node;\n    readonly extentOffset: number;\n    readonly focusNode: Node;\n    readonly focusOffset: number;\n    readonly isCollapsed: boolean;\n    readonly rangeCount: number;\n    readonly type: string;\n    addRange(range: Range): void;\n    collapse(parentNode: Node, offset: number): void;\n    collapseToEnd(): void;\n    collapseToStart(): void;\n    containsNode(node: Node, partlyContained: boolean): boolean;\n    deleteFromDocument(): void;\n    empty(): void;\n    extend(newNode: Node, offset: number): void;\n    getRangeAt(index: number): Range;\n    removeAllRanges(): void;\n    removeRange(range: Range): void;\n    selectAllChildren(parentNode: Node): void;\n    setBaseAndExtent(baseNode: Node, baseOffset: number, extentNode: Node, extentOffset: number): void;\n    setPosition(parentNode: Node, offset: number): void;\n    toString(): string;\n}\n\ndeclare var Selection: {\n    prototype: Selection;\n    new(): Selection;\n};\n\ninterface ServiceWorkerEventMap extends AbstractWorkerEventMap {\n    \"statechange\": Event;\n}\n\ninterface ServiceWorker extends EventTarget, AbstractWorker {\n    onstatechange: (this: ServiceWorker, ev: Event) => any;\n    readonly scriptURL: USVString;\n    readonly state: ServiceWorkerState;\n    postMessage(message: any, transfer?: any[]): void;\n    addEventListener<K extends keyof ServiceWorkerEventMap>(type: K, listener: (this: ServiceWorker, ev: ServiceWorkerEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var ServiceWorker: {\n    prototype: ServiceWorker;\n    new(): ServiceWorker;\n};\n\ninterface ServiceWorkerContainerEventMap {\n    \"controllerchange\": Event;\n    \"message\": ServiceWorkerMessageEvent;\n}\n\ninterface ServiceWorkerContainer extends EventTarget {\n    readonly controller: ServiceWorker | null;\n    oncontrollerchange: (this: ServiceWorkerContainer, ev: Event) => any;\n    onmessage: (this: ServiceWorkerContainer, ev: ServiceWorkerMessageEvent) => any;\n    readonly ready: Promise<ServiceWorkerRegistration>;\n    getRegistration(clientURL?: USVString): Promise<any>;\n    getRegistrations(): any;\n    register(scriptURL: USVString, options?: RegistrationOptions): Promise<ServiceWorkerRegistration>;\n    addEventListener<K extends keyof ServiceWorkerContainerEventMap>(type: K, listener: (this: ServiceWorkerContainer, ev: ServiceWorkerContainerEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var ServiceWorkerContainer: {\n    prototype: ServiceWorkerContainer;\n    new(): ServiceWorkerContainer;\n};\n\ninterface ServiceWorkerMessageEvent extends Event {\n    readonly data: any;\n    readonly lastEventId: string;\n    readonly origin: string;\n    readonly ports: MessagePort[] | null;\n    readonly source: ServiceWorker | MessagePort | null;\n}\n\ndeclare var ServiceWorkerMessageEvent: {\n    prototype: ServiceWorkerMessageEvent;\n    new(type: string, eventInitDict?: ServiceWorkerMessageEventInit): ServiceWorkerMessageEvent;\n};\n\ninterface ServiceWorkerRegistrationEventMap {\n    \"updatefound\": Event;\n}\n\ninterface ServiceWorkerRegistration extends EventTarget {\n    readonly active: ServiceWorker | null;\n    readonly installing: ServiceWorker | null;\n    onupdatefound: (this: ServiceWorkerRegistration, ev: Event) => any;\n    readonly pushManager: PushManager;\n    readonly scope: USVString;\n    readonly sync: SyncManager;\n    readonly waiting: ServiceWorker | null;\n    getNotifications(filter?: GetNotificationOptions): any;\n    showNotification(title: string, options?: NotificationOptions): Promise<void>;\n    unregister(): Promise<boolean>;\n    update(): Promise<void>;\n    addEventListener<K extends keyof ServiceWorkerRegistrationEventMap>(type: K, listener: (this: ServiceWorkerRegistration, ev: ServiceWorkerRegistrationEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var ServiceWorkerRegistration: {\n    prototype: ServiceWorkerRegistration;\n    new(): ServiceWorkerRegistration;\n};\n\ninterface SourceBuffer extends EventTarget {\n    appendWindowEnd: number;\n    appendWindowStart: number;\n    readonly audioTracks: AudioTrackList;\n    readonly buffered: TimeRanges;\n    mode: AppendMode;\n    timestampOffset: number;\n    readonly updating: boolean;\n    readonly videoTracks: VideoTrackList;\n    abort(): void;\n    appendBuffer(data: ArrayBuffer | ArrayBufferView): void;\n    appendStream(stream: MSStream, maxSize?: number): void;\n    remove(start: number, end: number): void;\n}\n\ndeclare var SourceBuffer: {\n    prototype: SourceBuffer;\n    new(): SourceBuffer;\n};\n\ninterface SourceBufferList extends EventTarget {\n    readonly length: number;\n    item(index: number): SourceBuffer;\n    [index: number]: SourceBuffer;\n}\n\ndeclare var SourceBufferList: {\n    prototype: SourceBufferList;\n    new(): SourceBufferList;\n};\n\ninterface SpeechSynthesisEventMap {\n    \"voiceschanged\": Event;\n}\n\ninterface SpeechSynthesis extends EventTarget {\n    onvoiceschanged: (this: SpeechSynthesis, ev: Event) => any;\n    readonly paused: boolean;\n    readonly pending: boolean;\n    readonly speaking: boolean;\n    cancel(): void;\n    getVoices(): SpeechSynthesisVoice[];\n    pause(): void;\n    resume(): void;\n    speak(utterance: SpeechSynthesisUtterance): void;\n    addEventListener<K extends keyof SpeechSynthesisEventMap>(type: K, listener: (this: SpeechSynthesis, ev: SpeechSynthesisEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SpeechSynthesis: {\n    prototype: SpeechSynthesis;\n    new(): SpeechSynthesis;\n};\n\ninterface SpeechSynthesisEvent extends Event {\n    readonly charIndex: number;\n    readonly elapsedTime: number;\n    readonly name: string;\n    readonly utterance: SpeechSynthesisUtterance | null;\n}\n\ndeclare var SpeechSynthesisEvent: {\n    prototype: SpeechSynthesisEvent;\n    new(type: string, eventInitDict?: SpeechSynthesisEventInit): SpeechSynthesisEvent;\n};\n\ninterface SpeechSynthesisUtteranceEventMap {\n    \"boundary\": Event;\n    \"end\": Event;\n    \"error\": Event;\n    \"mark\": Event;\n    \"pause\": Event;\n    \"resume\": Event;\n    \"start\": Event;\n}\n\ninterface SpeechSynthesisUtterance extends EventTarget {\n    lang: string;\n    onboundary: (this: SpeechSynthesisUtterance, ev: Event) => any;\n    onend: (this: SpeechSynthesisUtterance, ev: Event) => any;\n    onerror: (this: SpeechSynthesisUtterance, ev: Event) => any;\n    onmark: (this: SpeechSynthesisUtterance, ev: Event) => any;\n    onpause: (this: SpeechSynthesisUtterance, ev: Event) => any;\n    onresume: (this: SpeechSynthesisUtterance, ev: Event) => any;\n    onstart: (this: SpeechSynthesisUtterance, ev: Event) => any;\n    pitch: number;\n    rate: number;\n    text: string;\n    voice: SpeechSynthesisVoice;\n    volume: number;\n    addEventListener<K extends keyof SpeechSynthesisUtteranceEventMap>(type: K, listener: (this: SpeechSynthesisUtterance, ev: SpeechSynthesisUtteranceEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SpeechSynthesisUtterance: {\n    prototype: SpeechSynthesisUtterance;\n    new(text?: string): SpeechSynthesisUtterance;\n};\n\ninterface SpeechSynthesisVoice {\n    readonly default: boolean;\n    readonly lang: string;\n    readonly localService: boolean;\n    readonly name: string;\n    readonly voiceURI: string;\n}\n\ndeclare var SpeechSynthesisVoice: {\n    prototype: SpeechSynthesisVoice;\n    new(): SpeechSynthesisVoice;\n};\n\ninterface StereoPannerNode extends AudioNode {\n    readonly pan: AudioParam;\n}\n\ndeclare var StereoPannerNode: {\n    prototype: StereoPannerNode;\n    new(): StereoPannerNode;\n};\n\ninterface Storage {\n    readonly length: number;\n    clear(): void;\n    getItem(key: string): string | null;\n    key(index: number): string | null;\n    removeItem(key: string): void;\n    setItem(key: string, data: string): void;\n    [key: string]: any;\n    [index: number]: string;\n}\n\ndeclare var Storage: {\n    prototype: Storage;\n    new(): Storage;\n};\n\ninterface StorageEvent extends Event {\n    readonly url: string;\n    key?: string;\n    oldValue?: string;\n    newValue?: string;\n    storageArea?: Storage;\n}\n\ndeclare var StorageEvent: {\n    prototype: StorageEvent;\n    new (type: string, eventInitDict?: StorageEventInit): StorageEvent;\n};\n\ninterface StyleMedia {\n    readonly type: string;\n    matchMedium(mediaquery: string): boolean;\n}\n\ndeclare var StyleMedia: {\n    prototype: StyleMedia;\n    new(): StyleMedia;\n};\n\ninterface StyleSheet {\n    disabled: boolean;\n    readonly href: string;\n    readonly media: MediaList;\n    readonly ownerNode: Node;\n    readonly parentStyleSheet: StyleSheet;\n    readonly title: string;\n    readonly type: string;\n}\n\ndeclare var StyleSheet: {\n    prototype: StyleSheet;\n    new(): StyleSheet;\n};\n\ninterface StyleSheetList {\n    readonly length: number;\n    item(index?: number): StyleSheet;\n    [index: number]: StyleSheet;\n}\n\ndeclare var StyleSheetList: {\n    prototype: StyleSheetList;\n    new(): StyleSheetList;\n};\n\ninterface StyleSheetPageList {\n    readonly length: number;\n    item(index: number): CSSPageRule;\n    [index: number]: CSSPageRule;\n}\n\ndeclare var StyleSheetPageList: {\n    prototype: StyleSheetPageList;\n    new(): StyleSheetPageList;\n};\n\ninterface SubtleCrypto {\n    decrypt(algorithm: string | RsaOaepParams | AesCtrParams | AesCbcParams | AesCmacParams | AesGcmParams | AesCfbParams, key: CryptoKey, data: BufferSource): PromiseLike<ArrayBuffer>;\n    deriveBits(algorithm: string | EcdhKeyDeriveParams | DhKeyDeriveParams | ConcatParams | HkdfCtrParams | Pbkdf2Params, baseKey: CryptoKey, length: number): PromiseLike<ArrayBuffer>;\n    deriveKey(algorithm: string | EcdhKeyDeriveParams | DhKeyDeriveParams | ConcatParams | HkdfCtrParams | Pbkdf2Params, baseKey: CryptoKey, derivedKeyType: string | AesDerivedKeyParams | HmacImportParams | ConcatParams | HkdfCtrParams | Pbkdf2Params, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    digest(algorithm: AlgorithmIdentifier, data: BufferSource): PromiseLike<ArrayBuffer>;\n    encrypt(algorithm: string | RsaOaepParams | AesCtrParams | AesCbcParams | AesCmacParams | AesGcmParams | AesCfbParams, key: CryptoKey, data: BufferSource): PromiseLike<ArrayBuffer>;\n    exportKey(format: \"jwk\", key: CryptoKey): PromiseLike<JsonWebKey>;\n    exportKey(format: \"raw\" | \"pkcs8\" | \"spki\", key: CryptoKey): PromiseLike<ArrayBuffer>;\n    exportKey(format: string, key: CryptoKey): PromiseLike<JsonWebKey | ArrayBuffer>;\n    generateKey(algorithm: string, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKeyPair | CryptoKey>;\n    generateKey(algorithm: RsaHashedKeyGenParams | EcKeyGenParams | DhKeyGenParams, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKeyPair>;\n    generateKey(algorithm: AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    importKey(format: \"jwk\", keyData: JsonWebKey, algorithm: string | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | DhImportKeyParams, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    importKey(format: \"raw\" | \"pkcs8\" | \"spki\", keyData: BufferSource, algorithm: string | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | DhImportKeyParams, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    importKey(format: string, keyData: JsonWebKey | BufferSource, algorithm: string | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | DhImportKeyParams, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    sign(algorithm: string | RsaPssParams | EcdsaParams | AesCmacParams, key: CryptoKey, data: BufferSource): PromiseLike<ArrayBuffer>;\n    unwrapKey(format: string, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier, unwrappedKeyAlgorithm: AlgorithmIdentifier, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    verify(algorithm: string | RsaPssParams | EcdsaParams | AesCmacParams, key: CryptoKey, signature: BufferSource, data: BufferSource): PromiseLike<boolean>;\n    wrapKey(format: string, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: AlgorithmIdentifier): PromiseLike<ArrayBuffer>;\n}\n\ndeclare var SubtleCrypto: {\n    prototype: SubtleCrypto;\n    new(): SubtleCrypto;\n};\n\ninterface SVGAElement extends SVGGraphicsElement, SVGURIReference {\n    readonly target: SVGAnimatedString;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGAElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGAElement: {\n    prototype: SVGAElement;\n    new(): SVGAElement;\n};\n\ninterface SVGAngle {\n    readonly unitType: number;\n    value: number;\n    valueAsString: string;\n    valueInSpecifiedUnits: number;\n    convertToSpecifiedUnits(unitType: number): void;\n    newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;\n    readonly SVG_ANGLETYPE_DEG: number;\n    readonly SVG_ANGLETYPE_GRAD: number;\n    readonly SVG_ANGLETYPE_RAD: number;\n    readonly SVG_ANGLETYPE_UNKNOWN: number;\n    readonly SVG_ANGLETYPE_UNSPECIFIED: number;\n}\n\ndeclare var SVGAngle: {\n    prototype: SVGAngle;\n    new(): SVGAngle;\n    readonly SVG_ANGLETYPE_DEG: number;\n    readonly SVG_ANGLETYPE_GRAD: number;\n    readonly SVG_ANGLETYPE_RAD: number;\n    readonly SVG_ANGLETYPE_UNKNOWN: number;\n    readonly SVG_ANGLETYPE_UNSPECIFIED: number;\n};\n\ninterface SVGAnimatedAngle {\n    readonly animVal: SVGAngle;\n    readonly baseVal: SVGAngle;\n}\n\ndeclare var SVGAnimatedAngle: {\n    prototype: SVGAnimatedAngle;\n    new(): SVGAnimatedAngle;\n};\n\ninterface SVGAnimatedBoolean {\n    readonly animVal: boolean;\n    baseVal: boolean;\n}\n\ndeclare var SVGAnimatedBoolean: {\n    prototype: SVGAnimatedBoolean;\n    new(): SVGAnimatedBoolean;\n};\n\ninterface SVGAnimatedEnumeration {\n    readonly animVal: number;\n    baseVal: number;\n}\n\ndeclare var SVGAnimatedEnumeration: {\n    prototype: SVGAnimatedEnumeration;\n    new(): SVGAnimatedEnumeration;\n};\n\ninterface SVGAnimatedInteger {\n    readonly animVal: number;\n    baseVal: number;\n}\n\ndeclare var SVGAnimatedInteger: {\n    prototype: SVGAnimatedInteger;\n    new(): SVGAnimatedInteger;\n};\n\ninterface SVGAnimatedLength {\n    readonly animVal: SVGLength;\n    readonly baseVal: SVGLength;\n}\n\ndeclare var SVGAnimatedLength: {\n    prototype: SVGAnimatedLength;\n    new(): SVGAnimatedLength;\n};\n\ninterface SVGAnimatedLengthList {\n    readonly animVal: SVGLengthList;\n    readonly baseVal: SVGLengthList;\n}\n\ndeclare var SVGAnimatedLengthList: {\n    prototype: SVGAnimatedLengthList;\n    new(): SVGAnimatedLengthList;\n};\n\ninterface SVGAnimatedNumber {\n    readonly animVal: number;\n    baseVal: number;\n}\n\ndeclare var SVGAnimatedNumber: {\n    prototype: SVGAnimatedNumber;\n    new(): SVGAnimatedNumber;\n};\n\ninterface SVGAnimatedNumberList {\n    readonly animVal: SVGNumberList;\n    readonly baseVal: SVGNumberList;\n}\n\ndeclare var SVGAnimatedNumberList: {\n    prototype: SVGAnimatedNumberList;\n    new(): SVGAnimatedNumberList;\n};\n\ninterface SVGAnimatedPreserveAspectRatio {\n    readonly animVal: SVGPreserveAspectRatio;\n    readonly baseVal: SVGPreserveAspectRatio;\n}\n\ndeclare var SVGAnimatedPreserveAspectRatio: {\n    prototype: SVGAnimatedPreserveAspectRatio;\n    new(): SVGAnimatedPreserveAspectRatio;\n};\n\ninterface SVGAnimatedRect {\n    readonly animVal: SVGRect;\n    readonly baseVal: SVGRect;\n}\n\ndeclare var SVGAnimatedRect: {\n    prototype: SVGAnimatedRect;\n    new(): SVGAnimatedRect;\n};\n\ninterface SVGAnimatedString {\n    readonly animVal: string;\n    baseVal: string;\n}\n\ndeclare var SVGAnimatedString: {\n    prototype: SVGAnimatedString;\n    new(): SVGAnimatedString;\n};\n\ninterface SVGAnimatedTransformList {\n    readonly animVal: SVGTransformList;\n    readonly baseVal: SVGTransformList;\n}\n\ndeclare var SVGAnimatedTransformList: {\n    prototype: SVGAnimatedTransformList;\n    new(): SVGAnimatedTransformList;\n};\n\ninterface SVGCircleElement extends SVGGraphicsElement {\n    readonly cx: SVGAnimatedLength;\n    readonly cy: SVGAnimatedLength;\n    readonly r: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGCircleElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGCircleElement: {\n    prototype: SVGCircleElement;\n    new(): SVGCircleElement;\n};\n\ninterface SVGClipPathElement extends SVGGraphicsElement, SVGUnitTypes {\n    readonly clipPathUnits: SVGAnimatedEnumeration;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGClipPathElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGClipPathElement: {\n    prototype: SVGClipPathElement;\n    new(): SVGClipPathElement;\n};\n\ninterface SVGComponentTransferFunctionElement extends SVGElement {\n    readonly amplitude: SVGAnimatedNumber;\n    readonly exponent: SVGAnimatedNumber;\n    readonly intercept: SVGAnimatedNumber;\n    readonly offset: SVGAnimatedNumber;\n    readonly slope: SVGAnimatedNumber;\n    readonly tableValues: SVGAnimatedNumberList;\n    readonly type: SVGAnimatedEnumeration;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_GAMMA: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_LINEAR: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_TABLE: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGComponentTransferFunctionElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGComponentTransferFunctionElement: {\n    prototype: SVGComponentTransferFunctionElement;\n    new(): SVGComponentTransferFunctionElement;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_GAMMA: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_LINEAR: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_TABLE: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN: number;\n};\n\ninterface SVGDefsElement extends SVGGraphicsElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGDefsElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGDefsElement: {\n    prototype: SVGDefsElement;\n    new(): SVGDefsElement;\n};\n\ninterface SVGDescElement extends SVGElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGDescElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGDescElement: {\n    prototype: SVGDescElement;\n    new(): SVGDescElement;\n};\n\ninterface SVGElementEventMap extends ElementEventMap {\n    \"click\": MouseEvent;\n    \"dblclick\": MouseEvent;\n    \"focusin\": FocusEvent;\n    \"focusout\": FocusEvent;\n    \"load\": Event;\n    \"mousedown\": MouseEvent;\n    \"mousemove\": MouseEvent;\n    \"mouseout\": MouseEvent;\n    \"mouseover\": MouseEvent;\n    \"mouseup\": MouseEvent;\n}\n\ninterface SVGElement extends Element {\n    className: any;\n    onclick: (this: SVGElement, ev: MouseEvent) => any;\n    ondblclick: (this: SVGElement, ev: MouseEvent) => any;\n    onfocusin: (this: SVGElement, ev: FocusEvent) => any;\n    onfocusout: (this: SVGElement, ev: FocusEvent) => any;\n    onload: (this: SVGElement, ev: Event) => any;\n    onmousedown: (this: SVGElement, ev: MouseEvent) => any;\n    onmousemove: (this: SVGElement, ev: MouseEvent) => any;\n    onmouseout: (this: SVGElement, ev: MouseEvent) => any;\n    onmouseover: (this: SVGElement, ev: MouseEvent) => any;\n    onmouseup: (this: SVGElement, ev: MouseEvent) => any;\n    readonly ownerSVGElement: SVGSVGElement;\n    readonly style: CSSStyleDeclaration;\n    readonly viewportElement: SVGElement;\n    xmlbase: string;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGElement: {\n    prototype: SVGElement;\n    new(): SVGElement;\n};\n\ninterface SVGElementInstance extends EventTarget {\n    readonly childNodes: SVGElementInstanceList;\n    readonly correspondingElement: SVGElement;\n    readonly correspondingUseElement: SVGUseElement;\n    readonly firstChild: SVGElementInstance;\n    readonly lastChild: SVGElementInstance;\n    readonly nextSibling: SVGElementInstance;\n    readonly parentNode: SVGElementInstance;\n    readonly previousSibling: SVGElementInstance;\n}\n\ndeclare var SVGElementInstance: {\n    prototype: SVGElementInstance;\n    new(): SVGElementInstance;\n};\n\ninterface SVGElementInstanceList {\n    readonly length: number;\n    item(index: number): SVGElementInstance;\n}\n\ndeclare var SVGElementInstanceList: {\n    prototype: SVGElementInstanceList;\n    new(): SVGElementInstanceList;\n};\n\ninterface SVGEllipseElement extends SVGGraphicsElement {\n    readonly cx: SVGAnimatedLength;\n    readonly cy: SVGAnimatedLength;\n    readonly rx: SVGAnimatedLength;\n    readonly ry: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGEllipseElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGEllipseElement: {\n    prototype: SVGEllipseElement;\n    new(): SVGEllipseElement;\n};\n\ninterface SVGFEBlendElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly in2: SVGAnimatedString;\n    readonly mode: SVGAnimatedEnumeration;\n    readonly SVG_FEBLEND_MODE_COLOR: number;\n    readonly SVG_FEBLEND_MODE_COLOR_BURN: number;\n    readonly SVG_FEBLEND_MODE_COLOR_DODGE: number;\n    readonly SVG_FEBLEND_MODE_DARKEN: number;\n    readonly SVG_FEBLEND_MODE_DIFFERENCE: number;\n    readonly SVG_FEBLEND_MODE_EXCLUSION: number;\n    readonly SVG_FEBLEND_MODE_HARD_LIGHT: number;\n    readonly SVG_FEBLEND_MODE_HUE: number;\n    readonly SVG_FEBLEND_MODE_LIGHTEN: number;\n    readonly SVG_FEBLEND_MODE_LUMINOSITY: number;\n    readonly SVG_FEBLEND_MODE_MULTIPLY: number;\n    readonly SVG_FEBLEND_MODE_NORMAL: number;\n    readonly SVG_FEBLEND_MODE_OVERLAY: number;\n    readonly SVG_FEBLEND_MODE_SATURATION: number;\n    readonly SVG_FEBLEND_MODE_SCREEN: number;\n    readonly SVG_FEBLEND_MODE_SOFT_LIGHT: number;\n    readonly SVG_FEBLEND_MODE_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEBlendElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEBlendElement: {\n    prototype: SVGFEBlendElement;\n    new(): SVGFEBlendElement;\n    readonly SVG_FEBLEND_MODE_COLOR: number;\n    readonly SVG_FEBLEND_MODE_COLOR_BURN: number;\n    readonly SVG_FEBLEND_MODE_COLOR_DODGE: number;\n    readonly SVG_FEBLEND_MODE_DARKEN: number;\n    readonly SVG_FEBLEND_MODE_DIFFERENCE: number;\n    readonly SVG_FEBLEND_MODE_EXCLUSION: number;\n    readonly SVG_FEBLEND_MODE_HARD_LIGHT: number;\n    readonly SVG_FEBLEND_MODE_HUE: number;\n    readonly SVG_FEBLEND_MODE_LIGHTEN: number;\n    readonly SVG_FEBLEND_MODE_LUMINOSITY: number;\n    readonly SVG_FEBLEND_MODE_MULTIPLY: number;\n    readonly SVG_FEBLEND_MODE_NORMAL: number;\n    readonly SVG_FEBLEND_MODE_OVERLAY: number;\n    readonly SVG_FEBLEND_MODE_SATURATION: number;\n    readonly SVG_FEBLEND_MODE_SCREEN: number;\n    readonly SVG_FEBLEND_MODE_SOFT_LIGHT: number;\n    readonly SVG_FEBLEND_MODE_UNKNOWN: number;\n};\n\ninterface SVGFEColorMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly type: SVGAnimatedEnumeration;\n    readonly values: SVGAnimatedNumberList;\n    readonly SVG_FECOLORMATRIX_TYPE_HUEROTATE: number;\n    readonly SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA: number;\n    readonly SVG_FECOLORMATRIX_TYPE_MATRIX: number;\n    readonly SVG_FECOLORMATRIX_TYPE_SATURATE: number;\n    readonly SVG_FECOLORMATRIX_TYPE_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEColorMatrixElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEColorMatrixElement: {\n    prototype: SVGFEColorMatrixElement;\n    new(): SVGFEColorMatrixElement;\n    readonly SVG_FECOLORMATRIX_TYPE_HUEROTATE: number;\n    readonly SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA: number;\n    readonly SVG_FECOLORMATRIX_TYPE_MATRIX: number;\n    readonly SVG_FECOLORMATRIX_TYPE_SATURATE: number;\n    readonly SVG_FECOLORMATRIX_TYPE_UNKNOWN: number;\n};\n\ninterface SVGFEComponentTransferElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEComponentTransferElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEComponentTransferElement: {\n    prototype: SVGFEComponentTransferElement;\n    new(): SVGFEComponentTransferElement;\n};\n\ninterface SVGFECompositeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly in2: SVGAnimatedString;\n    readonly k1: SVGAnimatedNumber;\n    readonly k2: SVGAnimatedNumber;\n    readonly k3: SVGAnimatedNumber;\n    readonly k4: SVGAnimatedNumber;\n    readonly operator: SVGAnimatedEnumeration;\n    readonly SVG_FECOMPOSITE_OPERATOR_ARITHMETIC: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_ATOP: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_IN: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_OUT: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_OVER: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_UNKNOWN: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_XOR: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFECompositeElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFECompositeElement: {\n    prototype: SVGFECompositeElement;\n    new(): SVGFECompositeElement;\n    readonly SVG_FECOMPOSITE_OPERATOR_ARITHMETIC: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_ATOP: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_IN: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_OUT: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_OVER: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_UNKNOWN: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_XOR: number;\n};\n\ninterface SVGFEConvolveMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly bias: SVGAnimatedNumber;\n    readonly divisor: SVGAnimatedNumber;\n    readonly edgeMode: SVGAnimatedEnumeration;\n    readonly in1: SVGAnimatedString;\n    readonly kernelMatrix: SVGAnimatedNumberList;\n    readonly kernelUnitLengthX: SVGAnimatedNumber;\n    readonly kernelUnitLengthY: SVGAnimatedNumber;\n    readonly orderX: SVGAnimatedInteger;\n    readonly orderY: SVGAnimatedInteger;\n    readonly preserveAlpha: SVGAnimatedBoolean;\n    readonly targetX: SVGAnimatedInteger;\n    readonly targetY: SVGAnimatedInteger;\n    readonly SVG_EDGEMODE_DUPLICATE: number;\n    readonly SVG_EDGEMODE_NONE: number;\n    readonly SVG_EDGEMODE_UNKNOWN: number;\n    readonly SVG_EDGEMODE_WRAP: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEConvolveMatrixElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEConvolveMatrixElement: {\n    prototype: SVGFEConvolveMatrixElement;\n    new(): SVGFEConvolveMatrixElement;\n    readonly SVG_EDGEMODE_DUPLICATE: number;\n    readonly SVG_EDGEMODE_NONE: number;\n    readonly SVG_EDGEMODE_UNKNOWN: number;\n    readonly SVG_EDGEMODE_WRAP: number;\n};\n\ninterface SVGFEDiffuseLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly diffuseConstant: SVGAnimatedNumber;\n    readonly in1: SVGAnimatedString;\n    readonly kernelUnitLengthX: SVGAnimatedNumber;\n    readonly kernelUnitLengthY: SVGAnimatedNumber;\n    readonly surfaceScale: SVGAnimatedNumber;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDiffuseLightingElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEDiffuseLightingElement: {\n    prototype: SVGFEDiffuseLightingElement;\n    new(): SVGFEDiffuseLightingElement;\n};\n\ninterface SVGFEDisplacementMapElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly in2: SVGAnimatedString;\n    readonly scale: SVGAnimatedNumber;\n    readonly xChannelSelector: SVGAnimatedEnumeration;\n    readonly yChannelSelector: SVGAnimatedEnumeration;\n    readonly SVG_CHANNEL_A: number;\n    readonly SVG_CHANNEL_B: number;\n    readonly SVG_CHANNEL_G: number;\n    readonly SVG_CHANNEL_R: number;\n    readonly SVG_CHANNEL_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDisplacementMapElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEDisplacementMapElement: {\n    prototype: SVGFEDisplacementMapElement;\n    new(): SVGFEDisplacementMapElement;\n    readonly SVG_CHANNEL_A: number;\n    readonly SVG_CHANNEL_B: number;\n    readonly SVG_CHANNEL_G: number;\n    readonly SVG_CHANNEL_R: number;\n    readonly SVG_CHANNEL_UNKNOWN: number;\n};\n\ninterface SVGFEDistantLightElement extends SVGElement {\n    readonly azimuth: SVGAnimatedNumber;\n    readonly elevation: SVGAnimatedNumber;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDistantLightElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEDistantLightElement: {\n    prototype: SVGFEDistantLightElement;\n    new(): SVGFEDistantLightElement;\n};\n\ninterface SVGFEFloodElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFloodElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEFloodElement: {\n    prototype: SVGFEFloodElement;\n    new(): SVGFEFloodElement;\n};\n\ninterface SVGFEFuncAElement extends SVGComponentTransferFunctionElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncAElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEFuncAElement: {\n    prototype: SVGFEFuncAElement;\n    new(): SVGFEFuncAElement;\n};\n\ninterface SVGFEFuncBElement extends SVGComponentTransferFunctionElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncBElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEFuncBElement: {\n    prototype: SVGFEFuncBElement;\n    new(): SVGFEFuncBElement;\n};\n\ninterface SVGFEFuncGElement extends SVGComponentTransferFunctionElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncGElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEFuncGElement: {\n    prototype: SVGFEFuncGElement;\n    new(): SVGFEFuncGElement;\n};\n\ninterface SVGFEFuncRElement extends SVGComponentTransferFunctionElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncRElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEFuncRElement: {\n    prototype: SVGFEFuncRElement;\n    new(): SVGFEFuncRElement;\n};\n\ninterface SVGFEGaussianBlurElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly stdDeviationX: SVGAnimatedNumber;\n    readonly stdDeviationY: SVGAnimatedNumber;\n    setStdDeviation(stdDeviationX: number, stdDeviationY: number): void;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEGaussianBlurElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEGaussianBlurElement: {\n    prototype: SVGFEGaussianBlurElement;\n    new(): SVGFEGaussianBlurElement;\n};\n\ninterface SVGFEImageElement extends SVGElement, SVGFilterPrimitiveStandardAttributes, SVGURIReference {\n    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEImageElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEImageElement: {\n    prototype: SVGFEImageElement;\n    new(): SVGFEImageElement;\n};\n\ninterface SVGFEMergeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMergeElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEMergeElement: {\n    prototype: SVGFEMergeElement;\n    new(): SVGFEMergeElement;\n};\n\ninterface SVGFEMergeNodeElement extends SVGElement {\n    readonly in1: SVGAnimatedString;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMergeNodeElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEMergeNodeElement: {\n    prototype: SVGFEMergeNodeElement;\n    new(): SVGFEMergeNodeElement;\n};\n\ninterface SVGFEMorphologyElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly operator: SVGAnimatedEnumeration;\n    readonly radiusX: SVGAnimatedNumber;\n    readonly radiusY: SVGAnimatedNumber;\n    readonly SVG_MORPHOLOGY_OPERATOR_DILATE: number;\n    readonly SVG_MORPHOLOGY_OPERATOR_ERODE: number;\n    readonly SVG_MORPHOLOGY_OPERATOR_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMorphologyElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEMorphologyElement: {\n    prototype: SVGFEMorphologyElement;\n    new(): SVGFEMorphologyElement;\n    readonly SVG_MORPHOLOGY_OPERATOR_DILATE: number;\n    readonly SVG_MORPHOLOGY_OPERATOR_ERODE: number;\n    readonly SVG_MORPHOLOGY_OPERATOR_UNKNOWN: number;\n};\n\ninterface SVGFEOffsetElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly dx: SVGAnimatedNumber;\n    readonly dy: SVGAnimatedNumber;\n    readonly in1: SVGAnimatedString;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEOffsetElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEOffsetElement: {\n    prototype: SVGFEOffsetElement;\n    new(): SVGFEOffsetElement;\n};\n\ninterface SVGFEPointLightElement extends SVGElement {\n    readonly x: SVGAnimatedNumber;\n    readonly y: SVGAnimatedNumber;\n    readonly z: SVGAnimatedNumber;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEPointLightElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFEPointLightElement: {\n    prototype: SVGFEPointLightElement;\n    new(): SVGFEPointLightElement;\n};\n\ninterface SVGFESpecularLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly kernelUnitLengthX: SVGAnimatedNumber;\n    readonly kernelUnitLengthY: SVGAnimatedNumber;\n    readonly specularConstant: SVGAnimatedNumber;\n    readonly specularExponent: SVGAnimatedNumber;\n    readonly surfaceScale: SVGAnimatedNumber;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFESpecularLightingElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFESpecularLightingElement: {\n    prototype: SVGFESpecularLightingElement;\n    new(): SVGFESpecularLightingElement;\n};\n\ninterface SVGFESpotLightElement extends SVGElement {\n    readonly limitingConeAngle: SVGAnimatedNumber;\n    readonly pointsAtX: SVGAnimatedNumber;\n    readonly pointsAtY: SVGAnimatedNumber;\n    readonly pointsAtZ: SVGAnimatedNumber;\n    readonly specularExponent: SVGAnimatedNumber;\n    readonly x: SVGAnimatedNumber;\n    readonly y: SVGAnimatedNumber;\n    readonly z: SVGAnimatedNumber;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFESpotLightElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFESpotLightElement: {\n    prototype: SVGFESpotLightElement;\n    new(): SVGFESpotLightElement;\n};\n\ninterface SVGFETileElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFETileElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFETileElement: {\n    prototype: SVGFETileElement;\n    new(): SVGFETileElement;\n};\n\ninterface SVGFETurbulenceElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly baseFrequencyX: SVGAnimatedNumber;\n    readonly baseFrequencyY: SVGAnimatedNumber;\n    readonly numOctaves: SVGAnimatedInteger;\n    readonly seed: SVGAnimatedNumber;\n    readonly stitchTiles: SVGAnimatedEnumeration;\n    readonly type: SVGAnimatedEnumeration;\n    readonly SVG_STITCHTYPE_NOSTITCH: number;\n    readonly SVG_STITCHTYPE_STITCH: number;\n    readonly SVG_STITCHTYPE_UNKNOWN: number;\n    readonly SVG_TURBULENCE_TYPE_FRACTALNOISE: number;\n    readonly SVG_TURBULENCE_TYPE_TURBULENCE: number;\n    readonly SVG_TURBULENCE_TYPE_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFETurbulenceElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFETurbulenceElement: {\n    prototype: SVGFETurbulenceElement;\n    new(): SVGFETurbulenceElement;\n    readonly SVG_STITCHTYPE_NOSTITCH: number;\n    readonly SVG_STITCHTYPE_STITCH: number;\n    readonly SVG_STITCHTYPE_UNKNOWN: number;\n    readonly SVG_TURBULENCE_TYPE_FRACTALNOISE: number;\n    readonly SVG_TURBULENCE_TYPE_TURBULENCE: number;\n    readonly SVG_TURBULENCE_TYPE_UNKNOWN: number;\n};\n\ninterface SVGFilterElement extends SVGElement, SVGUnitTypes, SVGURIReference {\n    readonly filterResX: SVGAnimatedInteger;\n    readonly filterResY: SVGAnimatedInteger;\n    readonly filterUnits: SVGAnimatedEnumeration;\n    readonly height: SVGAnimatedLength;\n    readonly primitiveUnits: SVGAnimatedEnumeration;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    setFilterRes(filterResX: number, filterResY: number): void;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFilterElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGFilterElement: {\n    prototype: SVGFilterElement;\n    new(): SVGFilterElement;\n};\n\ninterface SVGForeignObjectElement extends SVGGraphicsElement {\n    readonly height: SVGAnimatedLength;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGForeignObjectElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGForeignObjectElement: {\n    prototype: SVGForeignObjectElement;\n    new(): SVGForeignObjectElement;\n};\n\ninterface SVGGElement extends SVGGraphicsElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGGElement: {\n    prototype: SVGGElement;\n    new(): SVGGElement;\n};\n\ninterface SVGGradientElement extends SVGElement, SVGUnitTypes, SVGURIReference {\n    readonly gradientTransform: SVGAnimatedTransformList;\n    readonly gradientUnits: SVGAnimatedEnumeration;\n    readonly spreadMethod: SVGAnimatedEnumeration;\n    readonly SVG_SPREADMETHOD_PAD: number;\n    readonly SVG_SPREADMETHOD_REFLECT: number;\n    readonly SVG_SPREADMETHOD_REPEAT: number;\n    readonly SVG_SPREADMETHOD_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGradientElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGGradientElement: {\n    prototype: SVGGradientElement;\n    new(): SVGGradientElement;\n    readonly SVG_SPREADMETHOD_PAD: number;\n    readonly SVG_SPREADMETHOD_REFLECT: number;\n    readonly SVG_SPREADMETHOD_REPEAT: number;\n    readonly SVG_SPREADMETHOD_UNKNOWN: number;\n};\n\ninterface SVGGraphicsElement extends SVGElement, SVGTests {\n    readonly farthestViewportElement: SVGElement;\n    readonly nearestViewportElement: SVGElement;\n    readonly transform: SVGAnimatedTransformList;\n    getBBox(): SVGRect;\n    getCTM(): SVGMatrix;\n    getScreenCTM(): SVGMatrix;\n    getTransformToElement(element: SVGElement): SVGMatrix;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGraphicsElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGGraphicsElement: {\n    prototype: SVGGraphicsElement;\n    new(): SVGGraphicsElement;\n};\n\ninterface SVGImageElement extends SVGGraphicsElement, SVGURIReference {\n    readonly height: SVGAnimatedLength;\n    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGImageElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGImageElement: {\n    prototype: SVGImageElement;\n    new(): SVGImageElement;\n};\n\ninterface SVGLength {\n    readonly unitType: number;\n    value: number;\n    valueAsString: string;\n    valueInSpecifiedUnits: number;\n    convertToSpecifiedUnits(unitType: number): void;\n    newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;\n    readonly SVG_LENGTHTYPE_CM: number;\n    readonly SVG_LENGTHTYPE_EMS: number;\n    readonly SVG_LENGTHTYPE_EXS: number;\n    readonly SVG_LENGTHTYPE_IN: number;\n    readonly SVG_LENGTHTYPE_MM: number;\n    readonly SVG_LENGTHTYPE_NUMBER: number;\n    readonly SVG_LENGTHTYPE_PC: number;\n    readonly SVG_LENGTHTYPE_PERCENTAGE: number;\n    readonly SVG_LENGTHTYPE_PT: number;\n    readonly SVG_LENGTHTYPE_PX: number;\n    readonly SVG_LENGTHTYPE_UNKNOWN: number;\n}\n\ndeclare var SVGLength: {\n    prototype: SVGLength;\n    new(): SVGLength;\n    readonly SVG_LENGTHTYPE_CM: number;\n    readonly SVG_LENGTHTYPE_EMS: number;\n    readonly SVG_LENGTHTYPE_EXS: number;\n    readonly SVG_LENGTHTYPE_IN: number;\n    readonly SVG_LENGTHTYPE_MM: number;\n    readonly SVG_LENGTHTYPE_NUMBER: number;\n    readonly SVG_LENGTHTYPE_PC: number;\n    readonly SVG_LENGTHTYPE_PERCENTAGE: number;\n    readonly SVG_LENGTHTYPE_PT: number;\n    readonly SVG_LENGTHTYPE_PX: number;\n    readonly SVG_LENGTHTYPE_UNKNOWN: number;\n};\n\ninterface SVGLengthList {\n    readonly numberOfItems: number;\n    appendItem(newItem: SVGLength): SVGLength;\n    clear(): void;\n    getItem(index: number): SVGLength;\n    initialize(newItem: SVGLength): SVGLength;\n    insertItemBefore(newItem: SVGLength, index: number): SVGLength;\n    removeItem(index: number): SVGLength;\n    replaceItem(newItem: SVGLength, index: number): SVGLength;\n}\n\ndeclare var SVGLengthList: {\n    prototype: SVGLengthList;\n    new(): SVGLengthList;\n};\n\ninterface SVGLinearGradientElement extends SVGGradientElement {\n    readonly x1: SVGAnimatedLength;\n    readonly x2: SVGAnimatedLength;\n    readonly y1: SVGAnimatedLength;\n    readonly y2: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGLinearGradientElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGLinearGradientElement: {\n    prototype: SVGLinearGradientElement;\n    new(): SVGLinearGradientElement;\n};\n\ninterface SVGLineElement extends SVGGraphicsElement {\n    readonly x1: SVGAnimatedLength;\n    readonly x2: SVGAnimatedLength;\n    readonly y1: SVGAnimatedLength;\n    readonly y2: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGLineElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGLineElement: {\n    prototype: SVGLineElement;\n    new(): SVGLineElement;\n};\n\ninterface SVGMarkerElement extends SVGElement, SVGFitToViewBox {\n    readonly markerHeight: SVGAnimatedLength;\n    readonly markerUnits: SVGAnimatedEnumeration;\n    readonly markerWidth: SVGAnimatedLength;\n    readonly orientAngle: SVGAnimatedAngle;\n    readonly orientType: SVGAnimatedEnumeration;\n    readonly refX: SVGAnimatedLength;\n    readonly refY: SVGAnimatedLength;\n    setOrientToAngle(angle: SVGAngle): void;\n    setOrientToAuto(): void;\n    readonly SVG_MARKER_ORIENT_ANGLE: number;\n    readonly SVG_MARKER_ORIENT_AUTO: number;\n    readonly SVG_MARKER_ORIENT_UNKNOWN: number;\n    readonly SVG_MARKERUNITS_STROKEWIDTH: number;\n    readonly SVG_MARKERUNITS_UNKNOWN: number;\n    readonly SVG_MARKERUNITS_USERSPACEONUSE: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMarkerElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGMarkerElement: {\n    prototype: SVGMarkerElement;\n    new(): SVGMarkerElement;\n    readonly SVG_MARKER_ORIENT_ANGLE: number;\n    readonly SVG_MARKER_ORIENT_AUTO: number;\n    readonly SVG_MARKER_ORIENT_UNKNOWN: number;\n    readonly SVG_MARKERUNITS_STROKEWIDTH: number;\n    readonly SVG_MARKERUNITS_UNKNOWN: number;\n    readonly SVG_MARKERUNITS_USERSPACEONUSE: number;\n};\n\ninterface SVGMaskElement extends SVGElement, SVGTests, SVGUnitTypes {\n    readonly height: SVGAnimatedLength;\n    readonly maskContentUnits: SVGAnimatedEnumeration;\n    readonly maskUnits: SVGAnimatedEnumeration;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMaskElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGMaskElement: {\n    prototype: SVGMaskElement;\n    new(): SVGMaskElement;\n};\n\ninterface SVGMatrix {\n    a: number;\n    b: number;\n    c: number;\n    d: number;\n    e: number;\n    f: number;\n    flipX(): SVGMatrix;\n    flipY(): SVGMatrix;\n    inverse(): SVGMatrix;\n    multiply(secondMatrix: SVGMatrix): SVGMatrix;\n    rotate(angle: number): SVGMatrix;\n    rotateFromVector(x: number, y: number): SVGMatrix;\n    scale(scaleFactor: number): SVGMatrix;\n    scaleNonUniform(scaleFactorX: number, scaleFactorY: number): SVGMatrix;\n    skewX(angle: number): SVGMatrix;\n    skewY(angle: number): SVGMatrix;\n    translate(x: number, y: number): SVGMatrix;\n}\n\ndeclare var SVGMatrix: {\n    prototype: SVGMatrix;\n    new(): SVGMatrix;\n};\n\ninterface SVGMetadataElement extends SVGElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMetadataElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGMetadataElement: {\n    prototype: SVGMetadataElement;\n    new(): SVGMetadataElement;\n};\n\ninterface SVGNumber {\n    value: number;\n}\n\ndeclare var SVGNumber: {\n    prototype: SVGNumber;\n    new(): SVGNumber;\n};\n\ninterface SVGNumberList {\n    readonly numberOfItems: number;\n    appendItem(newItem: SVGNumber): SVGNumber;\n    clear(): void;\n    getItem(index: number): SVGNumber;\n    initialize(newItem: SVGNumber): SVGNumber;\n    insertItemBefore(newItem: SVGNumber, index: number): SVGNumber;\n    removeItem(index: number): SVGNumber;\n    replaceItem(newItem: SVGNumber, index: number): SVGNumber;\n}\n\ndeclare var SVGNumberList: {\n    prototype: SVGNumberList;\n    new(): SVGNumberList;\n};\n\ninterface SVGPathElement extends SVGGraphicsElement {\n    readonly pathSegList: SVGPathSegList;\n    createSVGPathSegArcAbs(x: number, y: number, r1: number, r2: number, angle: number, largeArcFlag: boolean, sweepFlag: boolean): SVGPathSegArcAbs;\n    createSVGPathSegArcRel(x: number, y: number, r1: number, r2: number, angle: number, largeArcFlag: boolean, sweepFlag: boolean): SVGPathSegArcRel;\n    createSVGPathSegClosePath(): SVGPathSegClosePath;\n    createSVGPathSegCurvetoCubicAbs(x: number, y: number, x1: number, y1: number, x2: number, y2: number): SVGPathSegCurvetoCubicAbs;\n    createSVGPathSegCurvetoCubicRel(x: number, y: number, x1: number, y1: number, x2: number, y2: number): SVGPathSegCurvetoCubicRel;\n    createSVGPathSegCurvetoCubicSmoothAbs(x: number, y: number, x2: number, y2: number): SVGPathSegCurvetoCubicSmoothAbs;\n    createSVGPathSegCurvetoCubicSmoothRel(x: number, y: number, x2: number, y2: number): SVGPathSegCurvetoCubicSmoothRel;\n    createSVGPathSegCurvetoQuadraticAbs(x: number, y: number, x1: number, y1: number): SVGPathSegCurvetoQuadraticAbs;\n    createSVGPathSegCurvetoQuadraticRel(x: number, y: number, x1: number, y1: number): SVGPathSegCurvetoQuadraticRel;\n    createSVGPathSegCurvetoQuadraticSmoothAbs(x: number, y: number): SVGPathSegCurvetoQuadraticSmoothAbs;\n    createSVGPathSegCurvetoQuadraticSmoothRel(x: number, y: number): SVGPathSegCurvetoQuadraticSmoothRel;\n    createSVGPathSegLinetoAbs(x: number, y: number): SVGPathSegLinetoAbs;\n    createSVGPathSegLinetoHorizontalAbs(x: number): SVGPathSegLinetoHorizontalAbs;\n    createSVGPathSegLinetoHorizontalRel(x: number): SVGPathSegLinetoHorizontalRel;\n    createSVGPathSegLinetoRel(x: number, y: number): SVGPathSegLinetoRel;\n    createSVGPathSegLinetoVerticalAbs(y: number): SVGPathSegLinetoVerticalAbs;\n    createSVGPathSegLinetoVerticalRel(y: number): SVGPathSegLinetoVerticalRel;\n    createSVGPathSegMovetoAbs(x: number, y: number): SVGPathSegMovetoAbs;\n    createSVGPathSegMovetoRel(x: number, y: number): SVGPathSegMovetoRel;\n    getPathSegAtLength(distance: number): number;\n    getPointAtLength(distance: number): SVGPoint;\n    getTotalLength(): number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPathElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGPathElement: {\n    prototype: SVGPathElement;\n    new(): SVGPathElement;\n};\n\ninterface SVGPathSeg {\n    readonly pathSegType: number;\n    readonly pathSegTypeAsLetter: string;\n    readonly PATHSEG_ARC_ABS: number;\n    readonly PATHSEG_ARC_REL: number;\n    readonly PATHSEG_CLOSEPATH: number;\n    readonly PATHSEG_CURVETO_CUBIC_ABS: number;\n    readonly PATHSEG_CURVETO_CUBIC_REL: number;\n    readonly PATHSEG_CURVETO_CUBIC_SMOOTH_ABS: number;\n    readonly PATHSEG_CURVETO_CUBIC_SMOOTH_REL: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_ABS: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_REL: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: number;\n    readonly PATHSEG_LINETO_ABS: number;\n    readonly PATHSEG_LINETO_HORIZONTAL_ABS: number;\n    readonly PATHSEG_LINETO_HORIZONTAL_REL: number;\n    readonly PATHSEG_LINETO_REL: number;\n    readonly PATHSEG_LINETO_VERTICAL_ABS: number;\n    readonly PATHSEG_LINETO_VERTICAL_REL: number;\n    readonly PATHSEG_MOVETO_ABS: number;\n    readonly PATHSEG_MOVETO_REL: number;\n    readonly PATHSEG_UNKNOWN: number;\n}\n\ndeclare var SVGPathSeg: {\n    prototype: SVGPathSeg;\n    new(): SVGPathSeg;\n    readonly PATHSEG_ARC_ABS: number;\n    readonly PATHSEG_ARC_REL: number;\n    readonly PATHSEG_CLOSEPATH: number;\n    readonly PATHSEG_CURVETO_CUBIC_ABS: number;\n    readonly PATHSEG_CURVETO_CUBIC_REL: number;\n    readonly PATHSEG_CURVETO_CUBIC_SMOOTH_ABS: number;\n    readonly PATHSEG_CURVETO_CUBIC_SMOOTH_REL: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_ABS: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_REL: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: number;\n    readonly PATHSEG_LINETO_ABS: number;\n    readonly PATHSEG_LINETO_HORIZONTAL_ABS: number;\n    readonly PATHSEG_LINETO_HORIZONTAL_REL: number;\n    readonly PATHSEG_LINETO_REL: number;\n    readonly PATHSEG_LINETO_VERTICAL_ABS: number;\n    readonly PATHSEG_LINETO_VERTICAL_REL: number;\n    readonly PATHSEG_MOVETO_ABS: number;\n    readonly PATHSEG_MOVETO_REL: number;\n    readonly PATHSEG_UNKNOWN: number;\n};\n\ninterface SVGPathSegArcAbs extends SVGPathSeg {\n    angle: number;\n    largeArcFlag: boolean;\n    r1: number;\n    r2: number;\n    sweepFlag: boolean;\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegArcAbs: {\n    prototype: SVGPathSegArcAbs;\n    new(): SVGPathSegArcAbs;\n};\n\ninterface SVGPathSegArcRel extends SVGPathSeg {\n    angle: number;\n    largeArcFlag: boolean;\n    r1: number;\n    r2: number;\n    sweepFlag: boolean;\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegArcRel: {\n    prototype: SVGPathSegArcRel;\n    new(): SVGPathSegArcRel;\n};\n\ninterface SVGPathSegClosePath extends SVGPathSeg {\n}\n\ndeclare var SVGPathSegClosePath: {\n    prototype: SVGPathSegClosePath;\n    new(): SVGPathSegClosePath;\n};\n\ninterface SVGPathSegCurvetoCubicAbs extends SVGPathSeg {\n    x: number;\n    x1: number;\n    x2: number;\n    y: number;\n    y1: number;\n    y2: number;\n}\n\ndeclare var SVGPathSegCurvetoCubicAbs: {\n    prototype: SVGPathSegCurvetoCubicAbs;\n    new(): SVGPathSegCurvetoCubicAbs;\n};\n\ninterface SVGPathSegCurvetoCubicRel extends SVGPathSeg {\n    x: number;\n    x1: number;\n    x2: number;\n    y: number;\n    y1: number;\n    y2: number;\n}\n\ndeclare var SVGPathSegCurvetoCubicRel: {\n    prototype: SVGPathSegCurvetoCubicRel;\n    new(): SVGPathSegCurvetoCubicRel;\n};\n\ninterface SVGPathSegCurvetoCubicSmoothAbs extends SVGPathSeg {\n    x: number;\n    x2: number;\n    y: number;\n    y2: number;\n}\n\ndeclare var SVGPathSegCurvetoCubicSmoothAbs: {\n    prototype: SVGPathSegCurvetoCubicSmoothAbs;\n    new(): SVGPathSegCurvetoCubicSmoothAbs;\n};\n\ninterface SVGPathSegCurvetoCubicSmoothRel extends SVGPathSeg {\n    x: number;\n    x2: number;\n    y: number;\n    y2: number;\n}\n\ndeclare var SVGPathSegCurvetoCubicSmoothRel: {\n    prototype: SVGPathSegCurvetoCubicSmoothRel;\n    new(): SVGPathSegCurvetoCubicSmoothRel;\n};\n\ninterface SVGPathSegCurvetoQuadraticAbs extends SVGPathSeg {\n    x: number;\n    x1: number;\n    y: number;\n    y1: number;\n}\n\ndeclare var SVGPathSegCurvetoQuadraticAbs: {\n    prototype: SVGPathSegCurvetoQuadraticAbs;\n    new(): SVGPathSegCurvetoQuadraticAbs;\n};\n\ninterface SVGPathSegCurvetoQuadraticRel extends SVGPathSeg {\n    x: number;\n    x1: number;\n    y: number;\n    y1: number;\n}\n\ndeclare var SVGPathSegCurvetoQuadraticRel: {\n    prototype: SVGPathSegCurvetoQuadraticRel;\n    new(): SVGPathSegCurvetoQuadraticRel;\n};\n\ninterface SVGPathSegCurvetoQuadraticSmoothAbs extends SVGPathSeg {\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegCurvetoQuadraticSmoothAbs: {\n    prototype: SVGPathSegCurvetoQuadraticSmoothAbs;\n    new(): SVGPathSegCurvetoQuadraticSmoothAbs;\n};\n\ninterface SVGPathSegCurvetoQuadraticSmoothRel extends SVGPathSeg {\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegCurvetoQuadraticSmoothRel: {\n    prototype: SVGPathSegCurvetoQuadraticSmoothRel;\n    new(): SVGPathSegCurvetoQuadraticSmoothRel;\n};\n\ninterface SVGPathSegLinetoAbs extends SVGPathSeg {\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegLinetoAbs: {\n    prototype: SVGPathSegLinetoAbs;\n    new(): SVGPathSegLinetoAbs;\n};\n\ninterface SVGPathSegLinetoHorizontalAbs extends SVGPathSeg {\n    x: number;\n}\n\ndeclare var SVGPathSegLinetoHorizontalAbs: {\n    prototype: SVGPathSegLinetoHorizontalAbs;\n    new(): SVGPathSegLinetoHorizontalAbs;\n};\n\ninterface SVGPathSegLinetoHorizontalRel extends SVGPathSeg {\n    x: number;\n}\n\ndeclare var SVGPathSegLinetoHorizontalRel: {\n    prototype: SVGPathSegLinetoHorizontalRel;\n    new(): SVGPathSegLinetoHorizontalRel;\n};\n\ninterface SVGPathSegLinetoRel extends SVGPathSeg {\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegLinetoRel: {\n    prototype: SVGPathSegLinetoRel;\n    new(): SVGPathSegLinetoRel;\n};\n\ninterface SVGPathSegLinetoVerticalAbs extends SVGPathSeg {\n    y: number;\n}\n\ndeclare var SVGPathSegLinetoVerticalAbs: {\n    prototype: SVGPathSegLinetoVerticalAbs;\n    new(): SVGPathSegLinetoVerticalAbs;\n};\n\ninterface SVGPathSegLinetoVerticalRel extends SVGPathSeg {\n    y: number;\n}\n\ndeclare var SVGPathSegLinetoVerticalRel: {\n    prototype: SVGPathSegLinetoVerticalRel;\n    new(): SVGPathSegLinetoVerticalRel;\n};\n\ninterface SVGPathSegList {\n    readonly numberOfItems: number;\n    appendItem(newItem: SVGPathSeg): SVGPathSeg;\n    clear(): void;\n    getItem(index: number): SVGPathSeg;\n    initialize(newItem: SVGPathSeg): SVGPathSeg;\n    insertItemBefore(newItem: SVGPathSeg, index: number): SVGPathSeg;\n    removeItem(index: number): SVGPathSeg;\n    replaceItem(newItem: SVGPathSeg, index: number): SVGPathSeg;\n}\n\ndeclare var SVGPathSegList: {\n    prototype: SVGPathSegList;\n    new(): SVGPathSegList;\n};\n\ninterface SVGPathSegMovetoAbs extends SVGPathSeg {\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegMovetoAbs: {\n    prototype: SVGPathSegMovetoAbs;\n    new(): SVGPathSegMovetoAbs;\n};\n\ninterface SVGPathSegMovetoRel extends SVGPathSeg {\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegMovetoRel: {\n    prototype: SVGPathSegMovetoRel;\n    new(): SVGPathSegMovetoRel;\n};\n\ninterface SVGPatternElement extends SVGElement, SVGTests, SVGUnitTypes, SVGFitToViewBox, SVGURIReference {\n    readonly height: SVGAnimatedLength;\n    readonly patternContentUnits: SVGAnimatedEnumeration;\n    readonly patternTransform: SVGAnimatedTransformList;\n    readonly patternUnits: SVGAnimatedEnumeration;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPatternElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGPatternElement: {\n    prototype: SVGPatternElement;\n    new(): SVGPatternElement;\n};\n\ninterface SVGPoint {\n    x: number;\n    y: number;\n    matrixTransform(matrix: SVGMatrix): SVGPoint;\n}\n\ndeclare var SVGPoint: {\n    prototype: SVGPoint;\n    new(): SVGPoint;\n};\n\ninterface SVGPointList {\n    readonly numberOfItems: number;\n    appendItem(newItem: SVGPoint): SVGPoint;\n    clear(): void;\n    getItem(index: number): SVGPoint;\n    initialize(newItem: SVGPoint): SVGPoint;\n    insertItemBefore(newItem: SVGPoint, index: number): SVGPoint;\n    removeItem(index: number): SVGPoint;\n    replaceItem(newItem: SVGPoint, index: number): SVGPoint;\n}\n\ndeclare var SVGPointList: {\n    prototype: SVGPointList;\n    new(): SVGPointList;\n};\n\ninterface SVGPolygonElement extends SVGGraphicsElement, SVGAnimatedPoints {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPolygonElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGPolygonElement: {\n    prototype: SVGPolygonElement;\n    new(): SVGPolygonElement;\n};\n\ninterface SVGPolylineElement extends SVGGraphicsElement, SVGAnimatedPoints {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPolylineElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGPolylineElement: {\n    prototype: SVGPolylineElement;\n    new(): SVGPolylineElement;\n};\n\ninterface SVGPreserveAspectRatio {\n    align: number;\n    meetOrSlice: number;\n    readonly SVG_MEETORSLICE_MEET: number;\n    readonly SVG_MEETORSLICE_SLICE: number;\n    readonly SVG_MEETORSLICE_UNKNOWN: number;\n    readonly SVG_PRESERVEASPECTRATIO_NONE: number;\n    readonly SVG_PRESERVEASPECTRATIO_UNKNOWN: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMAXYMAX: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMAXYMID: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMAXYMIN: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMIDYMAX: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMIDYMID: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMIDYMIN: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMINYMAX: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMINYMID: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMINYMIN: number;\n}\n\ndeclare var SVGPreserveAspectRatio: {\n    prototype: SVGPreserveAspectRatio;\n    new(): SVGPreserveAspectRatio;\n    readonly SVG_MEETORSLICE_MEET: number;\n    readonly SVG_MEETORSLICE_SLICE: number;\n    readonly SVG_MEETORSLICE_UNKNOWN: number;\n    readonly SVG_PRESERVEASPECTRATIO_NONE: number;\n    readonly SVG_PRESERVEASPECTRATIO_UNKNOWN: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMAXYMAX: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMAXYMID: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMAXYMIN: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMIDYMAX: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMIDYMID: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMIDYMIN: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMINYMAX: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMINYMID: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMINYMIN: number;\n};\n\ninterface SVGRadialGradientElement extends SVGGradientElement {\n    readonly cx: SVGAnimatedLength;\n    readonly cy: SVGAnimatedLength;\n    readonly fx: SVGAnimatedLength;\n    readonly fy: SVGAnimatedLength;\n    readonly r: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGRadialGradientElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGRadialGradientElement: {\n    prototype: SVGRadialGradientElement;\n    new(): SVGRadialGradientElement;\n};\n\ninterface SVGRect {\n    height: number;\n    width: number;\n    x: number;\n    y: number;\n}\n\ndeclare var SVGRect: {\n    prototype: SVGRect;\n    new(): SVGRect;\n};\n\ninterface SVGRectElement extends SVGGraphicsElement {\n    readonly height: SVGAnimatedLength;\n    readonly rx: SVGAnimatedLength;\n    readonly ry: SVGAnimatedLength;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGRectElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGRectElement: {\n    prototype: SVGRectElement;\n    new(): SVGRectElement;\n};\n\ninterface SVGScriptElement extends SVGElement, SVGURIReference {\n    type: string;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGScriptElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGScriptElement: {\n    prototype: SVGScriptElement;\n    new(): SVGScriptElement;\n};\n\ninterface SVGStopElement extends SVGElement {\n    readonly offset: SVGAnimatedNumber;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGStopElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGStopElement: {\n    prototype: SVGStopElement;\n    new(): SVGStopElement;\n};\n\ninterface SVGStringList {\n    readonly numberOfItems: number;\n    appendItem(newItem: string): string;\n    clear(): void;\n    getItem(index: number): string;\n    initialize(newItem: string): string;\n    insertItemBefore(newItem: string, index: number): string;\n    removeItem(index: number): string;\n    replaceItem(newItem: string, index: number): string;\n}\n\ndeclare var SVGStringList: {\n    prototype: SVGStringList;\n    new(): SVGStringList;\n};\n\ninterface SVGStyleElement extends SVGElement {\n    disabled: boolean;\n    media: string;\n    title: string;\n    type: string;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGStyleElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGStyleElement: {\n    prototype: SVGStyleElement;\n    new(): SVGStyleElement;\n};\n\ninterface SVGSVGElementEventMap extends SVGElementEventMap {\n    \"SVGAbort\": Event;\n    \"SVGError\": Event;\n    \"resize\": UIEvent;\n    \"scroll\": UIEvent;\n    \"SVGUnload\": Event;\n    \"SVGZoom\": SVGZoomEvent;\n}\n\ninterface SVGSVGElement extends SVGGraphicsElement, DocumentEvent, SVGFitToViewBox, SVGZoomAndPan {\n    contentScriptType: string;\n    contentStyleType: string;\n    currentScale: number;\n    readonly currentTranslate: SVGPoint;\n    readonly height: SVGAnimatedLength;\n    onabort: (this: SVGSVGElement, ev: Event) => any;\n    onerror: (this: SVGSVGElement, ev: Event) => any;\n    onresize: (this: SVGSVGElement, ev: UIEvent) => any;\n    onscroll: (this: SVGSVGElement, ev: UIEvent) => any;\n    onunload: (this: SVGSVGElement, ev: Event) => any;\n    onzoom: (this: SVGSVGElement, ev: SVGZoomEvent) => any;\n    readonly pixelUnitToMillimeterX: number;\n    readonly pixelUnitToMillimeterY: number;\n    readonly screenPixelToMillimeterX: number;\n    readonly screenPixelToMillimeterY: number;\n    readonly viewport: SVGRect;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    checkEnclosure(element: SVGElement, rect: SVGRect): boolean;\n    checkIntersection(element: SVGElement, rect: SVGRect): boolean;\n    createSVGAngle(): SVGAngle;\n    createSVGLength(): SVGLength;\n    createSVGMatrix(): SVGMatrix;\n    createSVGNumber(): SVGNumber;\n    createSVGPoint(): SVGPoint;\n    createSVGRect(): SVGRect;\n    createSVGTransform(): SVGTransform;\n    createSVGTransformFromMatrix(matrix: SVGMatrix): SVGTransform;\n    deselectAll(): void;\n    forceRedraw(): void;\n    getComputedStyle(elt: Element, pseudoElt?: string): CSSStyleDeclaration;\n    getCurrentTime(): number;\n    getElementById(elementId: string): Element;\n    getEnclosureList(rect: SVGRect, referenceElement: SVGElement): NodeListOf<SVGCircleElement | SVGEllipseElement | SVGImageElement | SVGLineElement | SVGPathElement | SVGPolygonElement | SVGPolylineElement | SVGRectElement | SVGTextElement | SVGUseElement>;\n    getIntersectionList(rect: SVGRect, referenceElement: SVGElement): NodeListOf<SVGCircleElement | SVGEllipseElement | SVGImageElement | SVGLineElement | SVGPathElement | SVGPolygonElement | SVGPolylineElement | SVGRectElement | SVGTextElement | SVGUseElement>;\n    pauseAnimations(): void;\n    setCurrentTime(seconds: number): void;\n    suspendRedraw(maxWaitMilliseconds: number): number;\n    unpauseAnimations(): void;\n    unsuspendRedraw(suspendHandleID: number): void;\n    unsuspendRedrawAll(): void;\n    addEventListener<K extends keyof SVGSVGElementEventMap>(type: K, listener: (this: SVGSVGElement, ev: SVGSVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGSVGElement: {\n    prototype: SVGSVGElement;\n    new(): SVGSVGElement;\n};\n\ninterface SVGSwitchElement extends SVGGraphicsElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGSwitchElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGSwitchElement: {\n    prototype: SVGSwitchElement;\n    new(): SVGSwitchElement;\n};\n\ninterface SVGSymbolElement extends SVGElement, SVGFitToViewBox {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGSymbolElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGSymbolElement: {\n    prototype: SVGSymbolElement;\n    new(): SVGSymbolElement;\n};\n\ninterface SVGTextContentElement extends SVGGraphicsElement {\n    readonly lengthAdjust: SVGAnimatedEnumeration;\n    readonly textLength: SVGAnimatedLength;\n    getCharNumAtPosition(point: SVGPoint): number;\n    getComputedTextLength(): number;\n    getEndPositionOfChar(charnum: number): SVGPoint;\n    getExtentOfChar(charnum: number): SVGRect;\n    getNumberOfChars(): number;\n    getRotationOfChar(charnum: number): number;\n    getStartPositionOfChar(charnum: number): SVGPoint;\n    getSubStringLength(charnum: number, nchars: number): number;\n    selectSubString(charnum: number, nchars: number): void;\n    readonly LENGTHADJUST_SPACING: number;\n    readonly LENGTHADJUST_SPACINGANDGLYPHS: number;\n    readonly LENGTHADJUST_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextContentElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGTextContentElement: {\n    prototype: SVGTextContentElement;\n    new(): SVGTextContentElement;\n    readonly LENGTHADJUST_SPACING: number;\n    readonly LENGTHADJUST_SPACINGANDGLYPHS: number;\n    readonly LENGTHADJUST_UNKNOWN: number;\n};\n\ninterface SVGTextElement extends SVGTextPositioningElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGTextElement: {\n    prototype: SVGTextElement;\n    new(): SVGTextElement;\n};\n\ninterface SVGTextPathElement extends SVGTextContentElement, SVGURIReference {\n    readonly method: SVGAnimatedEnumeration;\n    readonly spacing: SVGAnimatedEnumeration;\n    readonly startOffset: SVGAnimatedLength;\n    readonly TEXTPATH_METHODTYPE_ALIGN: number;\n    readonly TEXTPATH_METHODTYPE_STRETCH: number;\n    readonly TEXTPATH_METHODTYPE_UNKNOWN: number;\n    readonly TEXTPATH_SPACINGTYPE_AUTO: number;\n    readonly TEXTPATH_SPACINGTYPE_EXACT: number;\n    readonly TEXTPATH_SPACINGTYPE_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextPathElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGTextPathElement: {\n    prototype: SVGTextPathElement;\n    new(): SVGTextPathElement;\n    readonly TEXTPATH_METHODTYPE_ALIGN: number;\n    readonly TEXTPATH_METHODTYPE_STRETCH: number;\n    readonly TEXTPATH_METHODTYPE_UNKNOWN: number;\n    readonly TEXTPATH_SPACINGTYPE_AUTO: number;\n    readonly TEXTPATH_SPACINGTYPE_EXACT: number;\n    readonly TEXTPATH_SPACINGTYPE_UNKNOWN: number;\n};\n\ninterface SVGTextPositioningElement extends SVGTextContentElement {\n    readonly dx: SVGAnimatedLengthList;\n    readonly dy: SVGAnimatedLengthList;\n    readonly rotate: SVGAnimatedNumberList;\n    readonly x: SVGAnimatedLengthList;\n    readonly y: SVGAnimatedLengthList;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextPositioningElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGTextPositioningElement: {\n    prototype: SVGTextPositioningElement;\n    new(): SVGTextPositioningElement;\n};\n\ninterface SVGTitleElement extends SVGElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTitleElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGTitleElement: {\n    prototype: SVGTitleElement;\n    new(): SVGTitleElement;\n};\n\ninterface SVGTransform {\n    readonly angle: number;\n    readonly matrix: SVGMatrix;\n    readonly type: number;\n    setMatrix(matrix: SVGMatrix): void;\n    setRotate(angle: number, cx: number, cy: number): void;\n    setScale(sx: number, sy: number): void;\n    setSkewX(angle: number): void;\n    setSkewY(angle: number): void;\n    setTranslate(tx: number, ty: number): void;\n    readonly SVG_TRANSFORM_MATRIX: number;\n    readonly SVG_TRANSFORM_ROTATE: number;\n    readonly SVG_TRANSFORM_SCALE: number;\n    readonly SVG_TRANSFORM_SKEWX: number;\n    readonly SVG_TRANSFORM_SKEWY: number;\n    readonly SVG_TRANSFORM_TRANSLATE: number;\n    readonly SVG_TRANSFORM_UNKNOWN: number;\n}\n\ndeclare var SVGTransform: {\n    prototype: SVGTransform;\n    new(): SVGTransform;\n    readonly SVG_TRANSFORM_MATRIX: number;\n    readonly SVG_TRANSFORM_ROTATE: number;\n    readonly SVG_TRANSFORM_SCALE: number;\n    readonly SVG_TRANSFORM_SKEWX: number;\n    readonly SVG_TRANSFORM_SKEWY: number;\n    readonly SVG_TRANSFORM_TRANSLATE: number;\n    readonly SVG_TRANSFORM_UNKNOWN: number;\n};\n\ninterface SVGTransformList {\n    readonly numberOfItems: number;\n    appendItem(newItem: SVGTransform): SVGTransform;\n    clear(): void;\n    consolidate(): SVGTransform;\n    createSVGTransformFromMatrix(matrix: SVGMatrix): SVGTransform;\n    getItem(index: number): SVGTransform;\n    initialize(newItem: SVGTransform): SVGTransform;\n    insertItemBefore(newItem: SVGTransform, index: number): SVGTransform;\n    removeItem(index: number): SVGTransform;\n    replaceItem(newItem: SVGTransform, index: number): SVGTransform;\n}\n\ndeclare var SVGTransformList: {\n    prototype: SVGTransformList;\n    new(): SVGTransformList;\n};\n\ninterface SVGTSpanElement extends SVGTextPositioningElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTSpanElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGTSpanElement: {\n    prototype: SVGTSpanElement;\n    new(): SVGTSpanElement;\n};\n\ninterface SVGUnitTypes {\n    readonly SVG_UNIT_TYPE_OBJECTBOUNDINGBOX: number;\n    readonly SVG_UNIT_TYPE_UNKNOWN: number;\n    readonly SVG_UNIT_TYPE_USERSPACEONUSE: number;\n}\ndeclare var SVGUnitTypes: SVGUnitTypes;\n\ninterface SVGUseElement extends SVGGraphicsElement, SVGURIReference {\n    readonly animatedInstanceRoot: SVGElementInstance;\n    readonly height: SVGAnimatedLength;\n    readonly instanceRoot: SVGElementInstance;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGUseElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGUseElement: {\n    prototype: SVGUseElement;\n    new(): SVGUseElement;\n};\n\ninterface SVGViewElement extends SVGElement, SVGZoomAndPan, SVGFitToViewBox {\n    readonly viewTarget: SVGStringList;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGViewElement, ev: SVGElementEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var SVGViewElement: {\n    prototype: SVGViewElement;\n    new(): SVGViewElement;\n};\n\ninterface SVGZoomAndPan {\n    readonly zoomAndPan: number;\n}\n\ndeclare var SVGZoomAndPan: {\n    readonly SVG_ZOOMANDPAN_DISABLE: number;\n    readonly SVG_ZOOMANDPAN_MAGNIFY: number;\n    readonly SVG_ZOOMANDPAN_UNKNOWN: number;\n};\n\ninterface SVGZoomEvent extends UIEvent {\n    readonly newScale: number;\n    readonly newTranslate: SVGPoint;\n    readonly previousScale: number;\n    readonly previousTranslate: SVGPoint;\n    readonly zoomRectScreen: SVGRect;\n}\n\ndeclare var SVGZoomEvent: {\n    prototype: SVGZoomEvent;\n    new(): SVGZoomEvent;\n};\n\ninterface SyncManager {\n    getTags(): any;\n    register(tag: string): Promise<void>;\n}\n\ndeclare var SyncManager: {\n    prototype: SyncManager;\n    new(): SyncManager;\n};\n\ninterface Text extends CharacterData {\n    readonly wholeText: string;\n    readonly assignedSlot: HTMLSlotElement | null;\n    splitText(offset: number): Text;\n}\n\ndeclare var Text: {\n    prototype: Text;\n    new(data?: string): Text;\n};\n\ninterface TextEvent extends UIEvent {\n    readonly data: string;\n    readonly inputMethod: number;\n    readonly locale: string;\n    initTextEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, dataArg: string, inputMethod: number, locale: string): void;\n    readonly DOM_INPUT_METHOD_DROP: number;\n    readonly DOM_INPUT_METHOD_HANDWRITING: number;\n    readonly DOM_INPUT_METHOD_IME: number;\n    readonly DOM_INPUT_METHOD_KEYBOARD: number;\n    readonly DOM_INPUT_METHOD_MULTIMODAL: number;\n    readonly DOM_INPUT_METHOD_OPTION: number;\n    readonly DOM_INPUT_METHOD_PASTE: number;\n    readonly DOM_INPUT_METHOD_SCRIPT: number;\n    readonly DOM_INPUT_METHOD_UNKNOWN: number;\n    readonly DOM_INPUT_METHOD_VOICE: number;\n}\n\ndeclare var TextEvent: {\n    prototype: TextEvent;\n    new(): TextEvent;\n    readonly DOM_INPUT_METHOD_DROP: number;\n    readonly DOM_INPUT_METHOD_HANDWRITING: number;\n    readonly DOM_INPUT_METHOD_IME: number;\n    readonly DOM_INPUT_METHOD_KEYBOARD: number;\n    readonly DOM_INPUT_METHOD_MULTIMODAL: number;\n    readonly DOM_INPUT_METHOD_OPTION: number;\n    readonly DOM_INPUT_METHOD_PASTE: number;\n    readonly DOM_INPUT_METHOD_SCRIPT: number;\n    readonly DOM_INPUT_METHOD_UNKNOWN: number;\n    readonly DOM_INPUT_METHOD_VOICE: number;\n};\n\ninterface TextMetrics {\n    readonly width: number;\n}\n\ndeclare var TextMetrics: {\n    prototype: TextMetrics;\n    new(): TextMetrics;\n};\n\ninterface TextTrackEventMap {\n    \"cuechange\": Event;\n    \"error\": Event;\n    \"load\": Event;\n}\n\ninterface TextTrack extends EventTarget {\n    readonly activeCues: TextTrackCueList;\n    readonly cues: TextTrackCueList;\n    readonly inBandMetadataTrackDispatchType: string;\n    readonly kind: string;\n    readonly label: string;\n    readonly language: string;\n    mode: any;\n    oncuechange: (this: TextTrack, ev: Event) => any;\n    onerror: (this: TextTrack, ev: Event) => any;\n    onload: (this: TextTrack, ev: Event) => any;\n    readonly readyState: number;\n    addCue(cue: TextTrackCue): void;\n    removeCue(cue: TextTrackCue): void;\n    readonly DISABLED: number;\n    readonly ERROR: number;\n    readonly HIDDEN: number;\n    readonly LOADED: number;\n    readonly LOADING: number;\n    readonly NONE: number;\n    readonly SHOWING: number;\n    addEventListener<K extends keyof TextTrackEventMap>(type: K, listener: (this: TextTrack, ev: TextTrackEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var TextTrack: {\n    prototype: TextTrack;\n    new(): TextTrack;\n    readonly DISABLED: number;\n    readonly ERROR: number;\n    readonly HIDDEN: number;\n    readonly LOADED: number;\n    readonly LOADING: number;\n    readonly NONE: number;\n    readonly SHOWING: number;\n};\n\ninterface TextTrackCueEventMap {\n    \"enter\": Event;\n    \"exit\": Event;\n}\n\ninterface TextTrackCue extends EventTarget {\n    endTime: number;\n    id: string;\n    onenter: (this: TextTrackCue, ev: Event) => any;\n    onexit: (this: TextTrackCue, ev: Event) => any;\n    pauseOnExit: boolean;\n    startTime: number;\n    text: string;\n    readonly track: TextTrack;\n    getCueAsHTML(): DocumentFragment;\n    addEventListener<K extends keyof TextTrackCueEventMap>(type: K, listener: (this: TextTrackCue, ev: TextTrackCueEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var TextTrackCue: {\n    prototype: TextTrackCue;\n    new(startTime: number, endTime: number, text: string): TextTrackCue;\n};\n\ninterface TextTrackCueList {\n    readonly length: number;\n    getCueById(id: string): TextTrackCue;\n    item(index: number): TextTrackCue;\n    [index: number]: TextTrackCue;\n}\n\ndeclare var TextTrackCueList: {\n    prototype: TextTrackCueList;\n    new(): TextTrackCueList;\n};\n\ninterface TextTrackListEventMap {\n    \"addtrack\": TrackEvent;\n}\n\ninterface TextTrackList extends EventTarget {\n    readonly length: number;\n    onaddtrack: ((this: TextTrackList, ev: TrackEvent) => any) | null;\n    item(index: number): TextTrack;\n    addEventListener<K extends keyof TextTrackListEventMap>(type: K, listener: (this: TextTrackList, ev: TextTrackListEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n    [index: number]: TextTrack;\n}\n\ndeclare var TextTrackList: {\n    prototype: TextTrackList;\n    new(): TextTrackList;\n};\n\ninterface TimeRanges {\n    readonly length: number;\n    end(index: number): number;\n    start(index: number): number;\n}\n\ndeclare var TimeRanges: {\n    prototype: TimeRanges;\n    new(): TimeRanges;\n};\n\ninterface Touch {\n    readonly clientX: number;\n    readonly clientY: number;\n    readonly identifier: number;\n    readonly pageX: number;\n    readonly pageY: number;\n    readonly screenX: number;\n    readonly screenY: number;\n    readonly target: EventTarget;\n}\n\ndeclare var Touch: {\n    prototype: Touch;\n    new(): Touch;\n};\n\ninterface TouchEvent extends UIEvent {\n    readonly altKey: boolean;\n    readonly changedTouches: TouchList;\n    readonly charCode: number;\n    readonly ctrlKey: boolean;\n    readonly keyCode: number;\n    readonly metaKey: boolean;\n    readonly shiftKey: boolean;\n    readonly targetTouches: TouchList;\n    readonly touches: TouchList;\n    readonly which: number;\n}\n\ndeclare var TouchEvent: {\n    prototype: TouchEvent;\n    new(type: string, touchEventInit?: TouchEventInit): TouchEvent;\n};\n\ninterface TouchList {\n    readonly length: number;\n    item(index: number): Touch | null;\n    [index: number]: Touch;\n}\n\ndeclare var TouchList: {\n    prototype: TouchList;\n    new(): TouchList;\n};\n\ninterface TrackEvent extends Event {\n    readonly track: VideoTrack | AudioTrack | TextTrack | null;\n}\n\ndeclare var TrackEvent: {\n    prototype: TrackEvent;\n    new(typeArg: string, eventInitDict?: TrackEventInit): TrackEvent;\n};\n\ninterface TransitionEvent extends Event {\n    readonly elapsedTime: number;\n    readonly propertyName: string;\n    initTransitionEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, propertyNameArg: string, elapsedTimeArg: number): void;\n}\n\ndeclare var TransitionEvent: {\n    prototype: TransitionEvent;\n    new(typeArg: string, eventInitDict?: TransitionEventInit): TransitionEvent;\n};\n\ninterface TreeWalker {\n    currentNode: Node;\n    readonly expandEntityReferences: boolean;\n    readonly filter: NodeFilter;\n    readonly root: Node;\n    readonly whatToShow: number;\n    firstChild(): Node;\n    lastChild(): Node;\n    nextNode(): Node;\n    nextSibling(): Node;\n    parentNode(): Node;\n    previousNode(): Node;\n    previousSibling(): Node;\n}\n\ndeclare var TreeWalker: {\n    prototype: TreeWalker;\n    new(): TreeWalker;\n};\n\ninterface UIEvent extends Event {\n    readonly detail: number;\n    readonly view: Window;\n    initUIEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number): void;\n}\n\ndeclare var UIEvent: {\n    prototype: UIEvent;\n    new(typeArg: string, eventInitDict?: UIEventInit): UIEvent;\n};\n\ninterface UnviewableContentIdentifiedEvent extends NavigationEventWithReferrer {\n    readonly mediaType: string;\n}\n\ndeclare var UnviewableContentIdentifiedEvent: {\n    prototype: UnviewableContentIdentifiedEvent;\n    new(): UnviewableContentIdentifiedEvent;\n};\n\ninterface URL {\n    hash: string;\n    host: string;\n    hostname: string;\n    href: string;\n    readonly origin: string;\n    password: string;\n    pathname: string;\n    port: string;\n    protocol: string;\n    search: string;\n    username: string;\n    readonly searchParams: URLSearchParams;\n    toString(): string;\n}\n\ndeclare var URL: {\n    prototype: URL;\n    new(url: string, base?: string): URL;\n    createObjectURL(object: any, options?: ObjectURLOptions): string;\n    revokeObjectURL(url: string): void;\n};\n\ninterface ValidityState {\n    readonly badInput: boolean;\n    readonly customError: boolean;\n    readonly patternMismatch: boolean;\n    readonly rangeOverflow: boolean;\n    readonly rangeUnderflow: boolean;\n    readonly stepMismatch: boolean;\n    readonly tooLong: boolean;\n    readonly typeMismatch: boolean;\n    readonly valid: boolean;\n    readonly valueMissing: boolean;\n}\n\ndeclare var ValidityState: {\n    prototype: ValidityState;\n    new(): ValidityState;\n};\n\ninterface VideoPlaybackQuality {\n    readonly corruptedVideoFrames: number;\n    readonly creationTime: number;\n    readonly droppedVideoFrames: number;\n    readonly totalFrameDelay: number;\n    readonly totalVideoFrames: number;\n}\n\ndeclare var VideoPlaybackQuality: {\n    prototype: VideoPlaybackQuality;\n    new(): VideoPlaybackQuality;\n};\n\ninterface VideoTrack {\n    readonly id: string;\n    kind: string;\n    readonly label: string;\n    language: string;\n    selected: boolean;\n    readonly sourceBuffer: SourceBuffer;\n}\n\ndeclare var VideoTrack: {\n    prototype: VideoTrack;\n    new(): VideoTrack;\n};\n\ninterface VideoTrackListEventMap {\n    \"addtrack\": TrackEvent;\n    \"change\": Event;\n    \"removetrack\": TrackEvent;\n}\n\ninterface VideoTrackList extends EventTarget {\n    readonly length: number;\n    onaddtrack: (this: VideoTrackList, ev: TrackEvent) => any;\n    onchange: (this: VideoTrackList, ev: Event) => any;\n    onremovetrack: (this: VideoTrackList, ev: TrackEvent) => any;\n    readonly selectedIndex: number;\n    getTrackById(id: string): VideoTrack | null;\n    item(index: number): VideoTrack;\n    addEventListener<K extends keyof VideoTrackListEventMap>(type: K, listener: (this: VideoTrackList, ev: VideoTrackListEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n    [index: number]: VideoTrack;\n}\n\ndeclare var VideoTrackList: {\n    prototype: VideoTrackList;\n    new(): VideoTrackList;\n};\n\ninterface WaveShaperNode extends AudioNode {\n    curve: Float32Array | null;\n    oversample: OverSampleType;\n}\n\ndeclare var WaveShaperNode: {\n    prototype: WaveShaperNode;\n    new(): WaveShaperNode;\n};\n\ninterface WebAuthentication {\n    getAssertion(assertionChallenge: any, options?: AssertionOptions): Promise<WebAuthnAssertion>;\n    makeCredential(accountInformation: Account, cryptoParameters: ScopedCredentialParameters[], attestationChallenge: any, options?: ScopedCredentialOptions): Promise<ScopedCredentialInfo>;\n}\n\ndeclare var WebAuthentication: {\n    prototype: WebAuthentication;\n    new(): WebAuthentication;\n};\n\ninterface WebAuthnAssertion {\n    readonly authenticatorData: ArrayBuffer;\n    readonly clientData: ArrayBuffer;\n    readonly credential: ScopedCredential;\n    readonly signature: ArrayBuffer;\n}\n\ndeclare var WebAuthnAssertion: {\n    prototype: WebAuthnAssertion;\n    new(): WebAuthnAssertion;\n};\n\ninterface WEBGL_compressed_texture_s3tc {\n    readonly COMPRESSED_RGB_S3TC_DXT1_EXT: number;\n    readonly COMPRESSED_RGBA_S3TC_DXT1_EXT: number;\n    readonly COMPRESSED_RGBA_S3TC_DXT3_EXT: number;\n    readonly COMPRESSED_RGBA_S3TC_DXT5_EXT: number;\n}\n\ndeclare var WEBGL_compressed_texture_s3tc: {\n    prototype: WEBGL_compressed_texture_s3tc;\n    new(): WEBGL_compressed_texture_s3tc;\n    readonly COMPRESSED_RGB_S3TC_DXT1_EXT: number;\n    readonly COMPRESSED_RGBA_S3TC_DXT1_EXT: number;\n    readonly COMPRESSED_RGBA_S3TC_DXT3_EXT: number;\n    readonly COMPRESSED_RGBA_S3TC_DXT5_EXT: number;\n};\n\ninterface WEBGL_debug_renderer_info {\n    readonly UNMASKED_RENDERER_WEBGL: number;\n    readonly UNMASKED_VENDOR_WEBGL: number;\n}\n\ndeclare var WEBGL_debug_renderer_info: {\n    prototype: WEBGL_debug_renderer_info;\n    new(): WEBGL_debug_renderer_info;\n    readonly UNMASKED_RENDERER_WEBGL: number;\n    readonly UNMASKED_VENDOR_WEBGL: number;\n};\n\ninterface WEBGL_depth_texture {\n    readonly UNSIGNED_INT_24_8_WEBGL: number;\n}\n\ndeclare var WEBGL_depth_texture: {\n    prototype: WEBGL_depth_texture;\n    new(): WEBGL_depth_texture;\n    readonly UNSIGNED_INT_24_8_WEBGL: number;\n};\n\ninterface WebGLActiveInfo {\n    readonly name: string;\n    readonly size: number;\n    readonly type: number;\n}\n\ndeclare var WebGLActiveInfo: {\n    prototype: WebGLActiveInfo;\n    new(): WebGLActiveInfo;\n};\n\ninterface WebGLBuffer extends WebGLObject {\n}\n\ndeclare var WebGLBuffer: {\n    prototype: WebGLBuffer;\n    new(): WebGLBuffer;\n};\n\ninterface WebGLContextEvent extends Event {\n    readonly statusMessage: string;\n}\n\ndeclare var WebGLContextEvent: {\n    prototype: WebGLContextEvent;\n    new(typeArg: string, eventInitDict?: WebGLContextEventInit): WebGLContextEvent;\n};\n\ninterface WebGLFramebuffer extends WebGLObject {\n}\n\ndeclare var WebGLFramebuffer: {\n    prototype: WebGLFramebuffer;\n    new(): WebGLFramebuffer;\n};\n\ninterface WebGLObject {\n}\n\ndeclare var WebGLObject: {\n    prototype: WebGLObject;\n    new(): WebGLObject;\n};\n\ninterface WebGLProgram extends WebGLObject {\n}\n\ndeclare var WebGLProgram: {\n    prototype: WebGLProgram;\n    new(): WebGLProgram;\n};\n\ninterface WebGLRenderbuffer extends WebGLObject {\n}\n\ndeclare var WebGLRenderbuffer: {\n    prototype: WebGLRenderbuffer;\n    new(): WebGLRenderbuffer;\n};\n\ninterface WebGLRenderingContext {\n    readonly canvas: HTMLCanvasElement;\n    readonly drawingBufferHeight: number;\n    readonly drawingBufferWidth: number;\n    activeTexture(texture: number): void;\n    attachShader(program: WebGLProgram | null, shader: WebGLShader | null): void;\n    bindAttribLocation(program: WebGLProgram | null, index: number, name: string): void;\n    bindBuffer(target: number, buffer: WebGLBuffer | null): void;\n    bindFramebuffer(target: number, framebuffer: WebGLFramebuffer | null): void;\n    bindRenderbuffer(target: number, renderbuffer: WebGLRenderbuffer | null): void;\n    bindTexture(target: number, texture: WebGLTexture | null): void;\n    blendColor(red: number, green: number, blue: number, alpha: number): void;\n    blendEquation(mode: number): void;\n    blendEquationSeparate(modeRGB: number, modeAlpha: number): void;\n    blendFunc(sfactor: number, dfactor: number): void;\n    blendFuncSeparate(srcRGB: number, dstRGB: number, srcAlpha: number, dstAlpha: number): void;\n    bufferData(target: number, size: number | ArrayBufferView | ArrayBuffer, usage: number): void;\n    bufferSubData(target: number, offset: number, data: ArrayBufferView | ArrayBuffer): void;\n    checkFramebufferStatus(target: number): number;\n    clear(mask: number): void;\n    clearColor(red: number, green: number, blue: number, alpha: number): void;\n    clearDepth(depth: number): void;\n    clearStencil(s: number): void;\n    colorMask(red: boolean, green: boolean, blue: boolean, alpha: boolean): void;\n    compileShader(shader: WebGLShader | null): void;\n    compressedTexImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, data: ArrayBufferView): void;\n    compressedTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, data: ArrayBufferView): void;\n    copyTexImage2D(target: number, level: number, internalformat: number, x: number, y: number, width: number, height: number, border: number): void;\n    copyTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;\n    createBuffer(): WebGLBuffer | null;\n    createFramebuffer(): WebGLFramebuffer | null;\n    createProgram(): WebGLProgram | null;\n    createRenderbuffer(): WebGLRenderbuffer | null;\n    createShader(type: number): WebGLShader | null;\n    createTexture(): WebGLTexture | null;\n    cullFace(mode: number): void;\n    deleteBuffer(buffer: WebGLBuffer | null): void;\n    deleteFramebuffer(framebuffer: WebGLFramebuffer | null): void;\n    deleteProgram(program: WebGLProgram | null): void;\n    deleteRenderbuffer(renderbuffer: WebGLRenderbuffer | null): void;\n    deleteShader(shader: WebGLShader | null): void;\n    deleteTexture(texture: WebGLTexture | null): void;\n    depthFunc(func: number): void;\n    depthMask(flag: boolean): void;\n    depthRange(zNear: number, zFar: number): void;\n    detachShader(program: WebGLProgram | null, shader: WebGLShader | null): void;\n    disable(cap: number): void;\n    disableVertexAttribArray(index: number): void;\n    drawArrays(mode: number, first: number, count: number): void;\n    drawElements(mode: number, count: number, type: number, offset: number): void;\n    enable(cap: number): void;\n    enableVertexAttribArray(index: number): void;\n    finish(): void;\n    flush(): void;\n    framebufferRenderbuffer(target: number, attachment: number, renderbuffertarget: number, renderbuffer: WebGLRenderbuffer | null): void;\n    framebufferTexture2D(target: number, attachment: number, textarget: number, texture: WebGLTexture | null, level: number): void;\n    frontFace(mode: number): void;\n    generateMipmap(target: number): void;\n    getActiveAttrib(program: WebGLProgram | null, index: number): WebGLActiveInfo | null;\n    getActiveUniform(program: WebGLProgram | null, index: number): WebGLActiveInfo | null;\n    getAttachedShaders(program: WebGLProgram | null): WebGLShader[] | null;\n    getAttribLocation(program: WebGLProgram | null, name: string): number;\n    getBufferParameter(target: number, pname: number): any;\n    getContextAttributes(): WebGLContextAttributes;\n    getError(): number;\n    getExtension(name: string): any;\n    getFramebufferAttachmentParameter(target: number, attachment: number, pname: number): any;\n    getParameter(pname: number): any;\n    getProgramInfoLog(program: WebGLProgram | null): string | null;\n    getProgramParameter(program: WebGLProgram | null, pname: number): any;\n    getRenderbufferParameter(target: number, pname: number): any;\n    getShaderInfoLog(shader: WebGLShader | null): string | null;\n    getShaderParameter(shader: WebGLShader | null, pname: number): any;\n    getShaderPrecisionFormat(shadertype: number, precisiontype: number): WebGLShaderPrecisionFormat | null;\n    getShaderSource(shader: WebGLShader | null): string | null;\n    getSupportedExtensions(): string[] | null;\n    getTexParameter(target: number, pname: number): any;\n    getUniform(program: WebGLProgram | null, location: WebGLUniformLocation | null): any;\n    getUniformLocation(program: WebGLProgram | null, name: string): WebGLUniformLocation | null;\n    getVertexAttrib(index: number, pname: number): any;\n    getVertexAttribOffset(index: number, pname: number): number;\n    hint(target: number, mode: number): void;\n    isBuffer(buffer: WebGLBuffer | null): boolean;\n    isContextLost(): boolean;\n    isEnabled(cap: number): boolean;\n    isFramebuffer(framebuffer: WebGLFramebuffer | null): boolean;\n    isProgram(program: WebGLProgram | null): boolean;\n    isRenderbuffer(renderbuffer: WebGLRenderbuffer | null): boolean;\n    isShader(shader: WebGLShader | null): boolean;\n    isTexture(texture: WebGLTexture | null): boolean;\n    lineWidth(width: number): void;\n    linkProgram(program: WebGLProgram | null): void;\n    pixelStorei(pname: number, param: number | boolean): void;\n    polygonOffset(factor: number, units: number): void;\n    readPixels(x: number, y: number, width: number, height: number, format: number, type: number, pixels: ArrayBufferView | null): void;\n    renderbufferStorage(target: number, internalformat: number, width: number, height: number): void;\n    sampleCoverage(value: number, invert: boolean): void;\n    scissor(x: number, y: number, width: number, height: number): void;\n    shaderSource(shader: WebGLShader | null, source: string): void;\n    stencilFunc(func: number, ref: number, mask: number): void;\n    stencilFuncSeparate(face: number, func: number, ref: number, mask: number): void;\n    stencilMask(mask: number): void;\n    stencilMaskSeparate(face: number, mask: number): void;\n    stencilOp(fail: number, zfail: number, zpass: number): void;\n    stencilOpSeparate(face: number, fail: number, zfail: number, zpass: number): void;\n    texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, pixels: ArrayBufferView | null): void;\n    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, pixels: ImageBitmap | ImageData | HTMLVideoElement | HTMLImageElement | HTMLCanvasElement): void;\n    texParameterf(target: number, pname: number, param: number): void;\n    texParameteri(target: number, pname: number, param: number): void;\n    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, pixels: ArrayBufferView | null): void;\n    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, pixels: ImageBitmap | ImageData | HTMLVideoElement | HTMLImageElement | HTMLCanvasElement): void;\n    uniform1f(location: WebGLUniformLocation | null, x: number): void;\n    uniform1fv(location: WebGLUniformLocation, v: Float32Array | number[]): void;\n    uniform1i(location: WebGLUniformLocation | null, x: number): void;\n    uniform1iv(location: WebGLUniformLocation, v: Int32Array | number[]): void;\n    uniform2f(location: WebGLUniformLocation | null, x: number, y: number): void;\n    uniform2fv(location: WebGLUniformLocation, v: Float32Array | number[]): void;\n    uniform2i(location: WebGLUniformLocation | null, x: number, y: number): void;\n    uniform2iv(location: WebGLUniformLocation, v: Int32Array | number[]): void;\n    uniform3f(location: WebGLUniformLocation | null, x: number, y: number, z: number): void;\n    uniform3fv(location: WebGLUniformLocation, v: Float32Array | number[]): void;\n    uniform3i(location: WebGLUniformLocation | null, x: number, y: number, z: number): void;\n    uniform3iv(location: WebGLUniformLocation, v: Int32Array | number[]): void;\n    uniform4f(location: WebGLUniformLocation | null, x: number, y: number, z: number, w: number): void;\n    uniform4fv(location: WebGLUniformLocation, v: Float32Array | number[]): void;\n    uniform4i(location: WebGLUniformLocation | null, x: number, y: number, z: number, w: number): void;\n    uniform4iv(location: WebGLUniformLocation, v: Int32Array | number[]): void;\n    uniformMatrix2fv(location: WebGLUniformLocation, transpose: boolean, value: Float32Array | number[]): void;\n    uniformMatrix3fv(location: WebGLUniformLocation, transpose: boolean, value: Float32Array | number[]): void;\n    uniformMatrix4fv(location: WebGLUniformLocation, transpose: boolean, value: Float32Array | number[]): void;\n    useProgram(program: WebGLProgram | null): void;\n    validateProgram(program: WebGLProgram | null): void;\n    vertexAttrib1f(indx: number, x: number): void;\n    vertexAttrib1fv(indx: number, values: Float32Array | number[]): void;\n    vertexAttrib2f(indx: number, x: number, y: number): void;\n    vertexAttrib2fv(indx: number, values: Float32Array | number[]): void;\n    vertexAttrib3f(indx: number, x: number, y: number, z: number): void;\n    vertexAttrib3fv(indx: number, values: Float32Array | number[]): void;\n    vertexAttrib4f(indx: number, x: number, y: number, z: number, w: number): void;\n    vertexAttrib4fv(indx: number, values: Float32Array | number[]): void;\n    vertexAttribPointer(indx: number, size: number, type: number, normalized: boolean, stride: number, offset: number): void;\n    viewport(x: number, y: number, width: number, height: number): void;\n    readonly ACTIVE_ATTRIBUTES: number;\n    readonly ACTIVE_TEXTURE: number;\n    readonly ACTIVE_UNIFORMS: number;\n    readonly ALIASED_LINE_WIDTH_RANGE: number;\n    readonly ALIASED_POINT_SIZE_RANGE: number;\n    readonly ALPHA: number;\n    readonly ALPHA_BITS: number;\n    readonly ALWAYS: number;\n    readonly ARRAY_BUFFER: number;\n    readonly ARRAY_BUFFER_BINDING: number;\n    readonly ATTACHED_SHADERS: number;\n    readonly BACK: number;\n    readonly BLEND: number;\n    readonly BLEND_COLOR: number;\n    readonly BLEND_DST_ALPHA: number;\n    readonly BLEND_DST_RGB: number;\n    readonly BLEND_EQUATION: number;\n    readonly BLEND_EQUATION_ALPHA: number;\n    readonly BLEND_EQUATION_RGB: number;\n    readonly BLEND_SRC_ALPHA: number;\n    readonly BLEND_SRC_RGB: number;\n    readonly BLUE_BITS: number;\n    readonly BOOL: number;\n    readonly BOOL_VEC2: number;\n    readonly BOOL_VEC3: number;\n    readonly BOOL_VEC4: number;\n    readonly BROWSER_DEFAULT_WEBGL: number;\n    readonly BUFFER_SIZE: number;\n    readonly BUFFER_USAGE: number;\n    readonly BYTE: number;\n    readonly CCW: number;\n    readonly CLAMP_TO_EDGE: number;\n    readonly COLOR_ATTACHMENT0: number;\n    readonly COLOR_BUFFER_BIT: number;\n    readonly COLOR_CLEAR_VALUE: number;\n    readonly COLOR_WRITEMASK: number;\n    readonly COMPILE_STATUS: number;\n    readonly COMPRESSED_TEXTURE_FORMATS: number;\n    readonly CONSTANT_ALPHA: number;\n    readonly CONSTANT_COLOR: number;\n    readonly CONTEXT_LOST_WEBGL: number;\n    readonly CULL_FACE: number;\n    readonly CULL_FACE_MODE: number;\n    readonly CURRENT_PROGRAM: number;\n    readonly CURRENT_VERTEX_ATTRIB: number;\n    readonly CW: number;\n    readonly DECR: number;\n    readonly DECR_WRAP: number;\n    readonly DELETE_STATUS: number;\n    readonly DEPTH_ATTACHMENT: number;\n    readonly DEPTH_BITS: number;\n    readonly DEPTH_BUFFER_BIT: number;\n    readonly DEPTH_CLEAR_VALUE: number;\n    readonly DEPTH_COMPONENT: number;\n    readonly DEPTH_COMPONENT16: number;\n    readonly DEPTH_FUNC: number;\n    readonly DEPTH_RANGE: number;\n    readonly DEPTH_STENCIL: number;\n    readonly DEPTH_STENCIL_ATTACHMENT: number;\n    readonly DEPTH_TEST: number;\n    readonly DEPTH_WRITEMASK: number;\n    readonly DITHER: number;\n    readonly DONT_CARE: number;\n    readonly DST_ALPHA: number;\n    readonly DST_COLOR: number;\n    readonly DYNAMIC_DRAW: number;\n    readonly ELEMENT_ARRAY_BUFFER: number;\n    readonly ELEMENT_ARRAY_BUFFER_BINDING: number;\n    readonly EQUAL: number;\n    readonly FASTEST: number;\n    readonly FLOAT: number;\n    readonly FLOAT_MAT2: number;\n    readonly FLOAT_MAT3: number;\n    readonly FLOAT_MAT4: number;\n    readonly FLOAT_VEC2: number;\n    readonly FLOAT_VEC3: number;\n    readonly FLOAT_VEC4: number;\n    readonly FRAGMENT_SHADER: number;\n    readonly FRAMEBUFFER: number;\n    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: number;\n    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: number;\n    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: number;\n    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: number;\n    readonly FRAMEBUFFER_BINDING: number;\n    readonly FRAMEBUFFER_COMPLETE: number;\n    readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT: number;\n    readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS: number;\n    readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: number;\n    readonly FRAMEBUFFER_UNSUPPORTED: number;\n    readonly FRONT: number;\n    readonly FRONT_AND_BACK: number;\n    readonly FRONT_FACE: number;\n    readonly FUNC_ADD: number;\n    readonly FUNC_REVERSE_SUBTRACT: number;\n    readonly FUNC_SUBTRACT: number;\n    readonly GENERATE_MIPMAP_HINT: number;\n    readonly GEQUAL: number;\n    readonly GREATER: number;\n    readonly GREEN_BITS: number;\n    readonly HIGH_FLOAT: number;\n    readonly HIGH_INT: number;\n    readonly IMPLEMENTATION_COLOR_READ_FORMAT: number;\n    readonly IMPLEMENTATION_COLOR_READ_TYPE: number;\n    readonly INCR: number;\n    readonly INCR_WRAP: number;\n    readonly INT: number;\n    readonly INT_VEC2: number;\n    readonly INT_VEC3: number;\n    readonly INT_VEC4: number;\n    readonly INVALID_ENUM: number;\n    readonly INVALID_FRAMEBUFFER_OPERATION: number;\n    readonly INVALID_OPERATION: number;\n    readonly INVALID_VALUE: number;\n    readonly INVERT: number;\n    readonly KEEP: number;\n    readonly LEQUAL: number;\n    readonly LESS: number;\n    readonly LINE_LOOP: number;\n    readonly LINE_STRIP: number;\n    readonly LINE_WIDTH: number;\n    readonly LINEAR: number;\n    readonly LINEAR_MIPMAP_LINEAR: number;\n    readonly LINEAR_MIPMAP_NEAREST: number;\n    readonly LINES: number;\n    readonly LINK_STATUS: number;\n    readonly LOW_FLOAT: number;\n    readonly LOW_INT: number;\n    readonly LUMINANCE: number;\n    readonly LUMINANCE_ALPHA: number;\n    readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS: number;\n    readonly MAX_CUBE_MAP_TEXTURE_SIZE: number;\n    readonly MAX_FRAGMENT_UNIFORM_VECTORS: number;\n    readonly MAX_RENDERBUFFER_SIZE: number;\n    readonly MAX_TEXTURE_IMAGE_UNITS: number;\n    readonly MAX_TEXTURE_SIZE: number;\n    readonly MAX_VARYING_VECTORS: number;\n    readonly MAX_VERTEX_ATTRIBS: number;\n    readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS: number;\n    readonly MAX_VERTEX_UNIFORM_VECTORS: number;\n    readonly MAX_VIEWPORT_DIMS: number;\n    readonly MEDIUM_FLOAT: number;\n    readonly MEDIUM_INT: number;\n    readonly MIRRORED_REPEAT: number;\n    readonly NEAREST: number;\n    readonly NEAREST_MIPMAP_LINEAR: number;\n    readonly NEAREST_MIPMAP_NEAREST: number;\n    readonly NEVER: number;\n    readonly NICEST: number;\n    readonly NO_ERROR: number;\n    readonly NONE: number;\n    readonly NOTEQUAL: number;\n    readonly ONE: number;\n    readonly ONE_MINUS_CONSTANT_ALPHA: number;\n    readonly ONE_MINUS_CONSTANT_COLOR: number;\n    readonly ONE_MINUS_DST_ALPHA: number;\n    readonly ONE_MINUS_DST_COLOR: number;\n    readonly ONE_MINUS_SRC_ALPHA: number;\n    readonly ONE_MINUS_SRC_COLOR: number;\n    readonly OUT_OF_MEMORY: number;\n    readonly PACK_ALIGNMENT: number;\n    readonly POINTS: number;\n    readonly POLYGON_OFFSET_FACTOR: number;\n    readonly POLYGON_OFFSET_FILL: number;\n    readonly POLYGON_OFFSET_UNITS: number;\n    readonly RED_BITS: number;\n    readonly RENDERBUFFER: number;\n    readonly RENDERBUFFER_ALPHA_SIZE: number;\n    readonly RENDERBUFFER_BINDING: number;\n    readonly RENDERBUFFER_BLUE_SIZE: number;\n    readonly RENDERBUFFER_DEPTH_SIZE: number;\n    readonly RENDERBUFFER_GREEN_SIZE: number;\n    readonly RENDERBUFFER_HEIGHT: number;\n    readonly RENDERBUFFER_INTERNAL_FORMAT: number;\n    readonly RENDERBUFFER_RED_SIZE: number;\n    readonly RENDERBUFFER_STENCIL_SIZE: number;\n    readonly RENDERBUFFER_WIDTH: number;\n    readonly RENDERER: number;\n    readonly REPEAT: number;\n    readonly REPLACE: number;\n    readonly RGB: number;\n    readonly RGB5_A1: number;\n    readonly RGB565: number;\n    readonly RGBA: number;\n    readonly RGBA4: number;\n    readonly SAMPLE_ALPHA_TO_COVERAGE: number;\n    readonly SAMPLE_BUFFERS: number;\n    readonly SAMPLE_COVERAGE: number;\n    readonly SAMPLE_COVERAGE_INVERT: number;\n    readonly SAMPLE_COVERAGE_VALUE: number;\n    readonly SAMPLER_2D: number;\n    readonly SAMPLER_CUBE: number;\n    readonly SAMPLES: number;\n    readonly SCISSOR_BOX: number;\n    readonly SCISSOR_TEST: number;\n    readonly SHADER_TYPE: number;\n    readonly SHADING_LANGUAGE_VERSION: number;\n    readonly SHORT: number;\n    readonly SRC_ALPHA: number;\n    readonly SRC_ALPHA_SATURATE: number;\n    readonly SRC_COLOR: number;\n    readonly STATIC_DRAW: number;\n    readonly STENCIL_ATTACHMENT: number;\n    readonly STENCIL_BACK_FAIL: number;\n    readonly STENCIL_BACK_FUNC: number;\n    readonly STENCIL_BACK_PASS_DEPTH_FAIL: number;\n    readonly STENCIL_BACK_PASS_DEPTH_PASS: number;\n    readonly STENCIL_BACK_REF: number;\n    readonly STENCIL_BACK_VALUE_MASK: number;\n    readonly STENCIL_BACK_WRITEMASK: number;\n    readonly STENCIL_BITS: number;\n    readonly STENCIL_BUFFER_BIT: number;\n    readonly STENCIL_CLEAR_VALUE: number;\n    readonly STENCIL_FAIL: number;\n    readonly STENCIL_FUNC: number;\n    readonly STENCIL_INDEX: number;\n    readonly STENCIL_INDEX8: number;\n    readonly STENCIL_PASS_DEPTH_FAIL: number;\n    readonly STENCIL_PASS_DEPTH_PASS: number;\n    readonly STENCIL_REF: number;\n    readonly STENCIL_TEST: number;\n    readonly STENCIL_VALUE_MASK: number;\n    readonly STENCIL_WRITEMASK: number;\n    readonly STREAM_DRAW: number;\n    readonly SUBPIXEL_BITS: number;\n    readonly TEXTURE: number;\n    readonly TEXTURE_2D: number;\n    readonly TEXTURE_BINDING_2D: number;\n    readonly TEXTURE_BINDING_CUBE_MAP: number;\n    readonly TEXTURE_CUBE_MAP: number;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_X: number;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_Y: number;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_Z: number;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_X: number;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_Y: number;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_Z: number;\n    readonly TEXTURE_MAG_FILTER: number;\n    readonly TEXTURE_MIN_FILTER: number;\n    readonly TEXTURE_WRAP_S: number;\n    readonly TEXTURE_WRAP_T: number;\n    readonly TEXTURE0: number;\n    readonly TEXTURE1: number;\n    readonly TEXTURE10: number;\n    readonly TEXTURE11: number;\n    readonly TEXTURE12: number;\n    readonly TEXTURE13: number;\n    readonly TEXTURE14: number;\n    readonly TEXTURE15: number;\n    readonly TEXTURE16: number;\n    readonly TEXTURE17: number;\n    readonly TEXTURE18: number;\n    readonly TEXTURE19: number;\n    readonly TEXTURE2: number;\n    readonly TEXTURE20: number;\n    readonly TEXTURE21: number;\n    readonly TEXTURE22: number;\n    readonly TEXTURE23: number;\n    readonly TEXTURE24: number;\n    readonly TEXTURE25: number;\n    readonly TEXTURE26: number;\n    readonly TEXTURE27: number;\n    readonly TEXTURE28: number;\n    readonly TEXTURE29: number;\n    readonly TEXTURE3: number;\n    readonly TEXTURE30: number;\n    readonly TEXTURE31: number;\n    readonly TEXTURE4: number;\n    readonly TEXTURE5: number;\n    readonly TEXTURE6: number;\n    readonly TEXTURE7: number;\n    readonly TEXTURE8: number;\n    readonly TEXTURE9: number;\n    readonly TRIANGLE_FAN: number;\n    readonly TRIANGLE_STRIP: number;\n    readonly TRIANGLES: number;\n    readonly UNPACK_ALIGNMENT: number;\n    readonly UNPACK_COLORSPACE_CONVERSION_WEBGL: number;\n    readonly UNPACK_FLIP_Y_WEBGL: number;\n    readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL: number;\n    readonly UNSIGNED_BYTE: number;\n    readonly UNSIGNED_INT: number;\n    readonly UNSIGNED_SHORT: number;\n    readonly UNSIGNED_SHORT_4_4_4_4: number;\n    readonly UNSIGNED_SHORT_5_5_5_1: number;\n    readonly UNSIGNED_SHORT_5_6_5: number;\n    readonly VALIDATE_STATUS: number;\n    readonly VENDOR: number;\n    readonly VERSION: number;\n    readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: number;\n    readonly VERTEX_ATTRIB_ARRAY_ENABLED: number;\n    readonly VERTEX_ATTRIB_ARRAY_NORMALIZED: number;\n    readonly VERTEX_ATTRIB_ARRAY_POINTER: number;\n    readonly VERTEX_ATTRIB_ARRAY_SIZE: number;\n    readonly VERTEX_ATTRIB_ARRAY_STRIDE: number;\n    readonly VERTEX_ATTRIB_ARRAY_TYPE: number;\n    readonly VERTEX_SHADER: number;\n    readonly VIEWPORT: number;\n    readonly ZERO: number;\n}\n\ndeclare var WebGLRenderingContext: {\n    prototype: WebGLRenderingContext;\n    new(): WebGLRenderingContext;\n    readonly ACTIVE_ATTRIBUTES: number;\n    readonly ACTIVE_TEXTURE: number;\n    readonly ACTIVE_UNIFORMS: number;\n    readonly ALIASED_LINE_WIDTH_RANGE: number;\n    readonly ALIASED_POINT_SIZE_RANGE: number;\n    readonly ALPHA: number;\n    readonly ALPHA_BITS: number;\n    readonly ALWAYS: number;\n    readonly ARRAY_BUFFER: number;\n    readonly ARRAY_BUFFER_BINDING: number;\n    readonly ATTACHED_SHADERS: number;\n    readonly BACK: number;\n    readonly BLEND: number;\n    readonly BLEND_COLOR: number;\n    readonly BLEND_DST_ALPHA: number;\n    readonly BLEND_DST_RGB: number;\n    readonly BLEND_EQUATION: number;\n    readonly BLEND_EQUATION_ALPHA: number;\n    readonly BLEND_EQUATION_RGB: number;\n    readonly BLEND_SRC_ALPHA: number;\n    readonly BLEND_SRC_RGB: number;\n    readonly BLUE_BITS: number;\n    readonly BOOL: number;\n    readonly BOOL_VEC2: number;\n    readonly BOOL_VEC3: number;\n    readonly BOOL_VEC4: number;\n    readonly BROWSER_DEFAULT_WEBGL: number;\n    readonly BUFFER_SIZE: number;\n    readonly BUFFER_USAGE: number;\n    readonly BYTE: number;\n    readonly CCW: number;\n    readonly CLAMP_TO_EDGE: number;\n    readonly COLOR_ATTACHMENT0: number;\n    readonly COLOR_BUFFER_BIT: number;\n    readonly COLOR_CLEAR_VALUE: number;\n    readonly COLOR_WRITEMASK: number;\n    readonly COMPILE_STATUS: number;\n    readonly COMPRESSED_TEXTURE_FORMATS: number;\n    readonly CONSTANT_ALPHA: number;\n    readonly CONSTANT_COLOR: number;\n    readonly CONTEXT_LOST_WEBGL: number;\n    readonly CULL_FACE: number;\n    readonly CULL_FACE_MODE: number;\n    readonly CURRENT_PROGRAM: number;\n    readonly CURRENT_VERTEX_ATTRIB: number;\n    readonly CW: number;\n    readonly DECR: number;\n    readonly DECR_WRAP: number;\n    readonly DELETE_STATUS: number;\n    readonly DEPTH_ATTACHMENT: number;\n    readonly DEPTH_BITS: number;\n    readonly DEPTH_BUFFER_BIT: number;\n    readonly DEPTH_CLEAR_VALUE: number;\n    readonly DEPTH_COMPONENT: number;\n    readonly DEPTH_COMPONENT16: number;\n    readonly DEPTH_FUNC: number;\n    readonly DEPTH_RANGE: number;\n    readonly DEPTH_STENCIL: number;\n    readonly DEPTH_STENCIL_ATTACHMENT: number;\n    readonly DEPTH_TEST: number;\n    readonly DEPTH_WRITEMASK: number;\n    readonly DITHER: number;\n    readonly DONT_CARE: number;\n    readonly DST_ALPHA: number;\n    readonly DST_COLOR: number;\n    readonly DYNAMIC_DRAW: number;\n    readonly ELEMENT_ARRAY_BUFFER: number;\n    readonly ELEMENT_ARRAY_BUFFER_BINDING: number;\n    readonly EQUAL: number;\n    readonly FASTEST: number;\n    readonly FLOAT: number;\n    readonly FLOAT_MAT2: number;\n    readonly FLOAT_MAT3: number;\n    readonly FLOAT_MAT4: number;\n    readonly FLOAT_VEC2: number;\n    readonly FLOAT_VEC3: number;\n    readonly FLOAT_VEC4: number;\n    readonly FRAGMENT_SHADER: number;\n    readonly FRAMEBUFFER: number;\n    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: number;\n    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: number;\n    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: number;\n    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: number;\n    readonly FRAMEBUFFER_BINDING: number;\n    readonly FRAMEBUFFER_COMPLETE: number;\n    readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT: number;\n    readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS: number;\n    readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: number;\n    readonly FRAMEBUFFER_UNSUPPORTED: number;\n    readonly FRONT: number;\n    readonly FRONT_AND_BACK: number;\n    readonly FRONT_FACE: number;\n    readonly FUNC_ADD: number;\n    readonly FUNC_REVERSE_SUBTRACT: number;\n    readonly FUNC_SUBTRACT: number;\n    readonly GENERATE_MIPMAP_HINT: number;\n    readonly GEQUAL: number;\n    readonly GREATER: number;\n    readonly GREEN_BITS: number;\n    readonly HIGH_FLOAT: number;\n    readonly HIGH_INT: number;\n    readonly IMPLEMENTATION_COLOR_READ_FORMAT: number;\n    readonly IMPLEMENTATION_COLOR_READ_TYPE: number;\n    readonly INCR: number;\n    readonly INCR_WRAP: number;\n    readonly INT: number;\n    readonly INT_VEC2: number;\n    readonly INT_VEC3: number;\n    readonly INT_VEC4: number;\n    readonly INVALID_ENUM: number;\n    readonly INVALID_FRAMEBUFFER_OPERATION: number;\n    readonly INVALID_OPERATION: number;\n    readonly INVALID_VALUE: number;\n    readonly INVERT: number;\n    readonly KEEP: number;\n    readonly LEQUAL: number;\n    readonly LESS: number;\n    readonly LINE_LOOP: number;\n    readonly LINE_STRIP: number;\n    readonly LINE_WIDTH: number;\n    readonly LINEAR: number;\n    readonly LINEAR_MIPMAP_LINEAR: number;\n    readonly LINEAR_MIPMAP_NEAREST: number;\n    readonly LINES: number;\n    readonly LINK_STATUS: number;\n    readonly LOW_FLOAT: number;\n    readonly LOW_INT: number;\n    readonly LUMINANCE: number;\n    readonly LUMINANCE_ALPHA: number;\n    readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS: number;\n    readonly MAX_CUBE_MAP_TEXTURE_SIZE: number;\n    readonly MAX_FRAGMENT_UNIFORM_VECTORS: number;\n    readonly MAX_RENDERBUFFER_SIZE: number;\n    readonly MAX_TEXTURE_IMAGE_UNITS: number;\n    readonly MAX_TEXTURE_SIZE: number;\n    readonly MAX_VARYING_VECTORS: number;\n    readonly MAX_VERTEX_ATTRIBS: number;\n    readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS: number;\n    readonly MAX_VERTEX_UNIFORM_VECTORS: number;\n    readonly MAX_VIEWPORT_DIMS: number;\n    readonly MEDIUM_FLOAT: number;\n    readonly MEDIUM_INT: number;\n    readonly MIRRORED_REPEAT: number;\n    readonly NEAREST: number;\n    readonly NEAREST_MIPMAP_LINEAR: number;\n    readonly NEAREST_MIPMAP_NEAREST: number;\n    readonly NEVER: number;\n    readonly NICEST: number;\n    readonly NO_ERROR: number;\n    readonly NONE: number;\n    readonly NOTEQUAL: number;\n    readonly ONE: number;\n    readonly ONE_MINUS_CONSTANT_ALPHA: number;\n    readonly ONE_MINUS_CONSTANT_COLOR: number;\n    readonly ONE_MINUS_DST_ALPHA: number;\n    readonly ONE_MINUS_DST_COLOR: number;\n    readonly ONE_MINUS_SRC_ALPHA: number;\n    readonly ONE_MINUS_SRC_COLOR: number;\n    readonly OUT_OF_MEMORY: number;\n    readonly PACK_ALIGNMENT: number;\n    readonly POINTS: number;\n    readonly POLYGON_OFFSET_FACTOR: number;\n    readonly POLYGON_OFFSET_FILL: number;\n    readonly POLYGON_OFFSET_UNITS: number;\n    readonly RED_BITS: number;\n    readonly RENDERBUFFER: number;\n    readonly RENDERBUFFER_ALPHA_SIZE: number;\n    readonly RENDERBUFFER_BINDING: number;\n    readonly RENDERBUFFER_BLUE_SIZE: number;\n    readonly RENDERBUFFER_DEPTH_SIZE: number;\n    readonly RENDERBUFFER_GREEN_SIZE: number;\n    readonly RENDERBUFFER_HEIGHT: number;\n    readonly RENDERBUFFER_INTERNAL_FORMAT: number;\n    readonly RENDERBUFFER_RED_SIZE: number;\n    readonly RENDERBUFFER_STENCIL_SIZE: number;\n    readonly RENDERBUFFER_WIDTH: number;\n    readonly RENDERER: number;\n    readonly REPEAT: number;\n    readonly REPLACE: number;\n    readonly RGB: number;\n    readonly RGB5_A1: number;\n    readonly RGB565: number;\n    readonly RGBA: number;\n    readonly RGBA4: number;\n    readonly SAMPLE_ALPHA_TO_COVERAGE: number;\n    readonly SAMPLE_BUFFERS: number;\n    readonly SAMPLE_COVERAGE: number;\n    readonly SAMPLE_COVERAGE_INVERT: number;\n    readonly SAMPLE_COVERAGE_VALUE: number;\n    readonly SAMPLER_2D: number;\n    readonly SAMPLER_CUBE: number;\n    readonly SAMPLES: number;\n    readonly SCISSOR_BOX: number;\n    readonly SCISSOR_TEST: number;\n    readonly SHADER_TYPE: number;\n    readonly SHADING_LANGUAGE_VERSION: number;\n    readonly SHORT: number;\n    readonly SRC_ALPHA: number;\n    readonly SRC_ALPHA_SATURATE: number;\n    readonly SRC_COLOR: number;\n    readonly STATIC_DRAW: number;\n    readonly STENCIL_ATTACHMENT: number;\n    readonly STENCIL_BACK_FAIL: number;\n    readonly STENCIL_BACK_FUNC: number;\n    readonly STENCIL_BACK_PASS_DEPTH_FAIL: number;\n    readonly STENCIL_BACK_PASS_DEPTH_PASS: number;\n    readonly STENCIL_BACK_REF: number;\n    readonly STENCIL_BACK_VALUE_MASK: number;\n    readonly STENCIL_BACK_WRITEMASK: number;\n    readonly STENCIL_BITS: number;\n    readonly STENCIL_BUFFER_BIT: number;\n    readonly STENCIL_CLEAR_VALUE: number;\n    readonly STENCIL_FAIL: number;\n    readonly STENCIL_FUNC: number;\n    readonly STENCIL_INDEX: number;\n    readonly STENCIL_INDEX8: number;\n    readonly STENCIL_PASS_DEPTH_FAIL: number;\n    readonly STENCIL_PASS_DEPTH_PASS: number;\n    readonly STENCIL_REF: number;\n    readonly STENCIL_TEST: number;\n    readonly STENCIL_VALUE_MASK: number;\n    readonly STENCIL_WRITEMASK: number;\n    readonly STREAM_DRAW: number;\n    readonly SUBPIXEL_BITS: number;\n    readonly TEXTURE: number;\n    readonly TEXTURE_2D: number;\n    readonly TEXTURE_BINDING_2D: number;\n    readonly TEXTURE_BINDING_CUBE_MAP: number;\n    readonly TEXTURE_CUBE_MAP: number;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_X: number;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_Y: number;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_Z: number;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_X: number;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_Y: number;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_Z: number;\n    readonly TEXTURE_MAG_FILTER: number;\n    readonly TEXTURE_MIN_FILTER: number;\n    readonly TEXTURE_WRAP_S: number;\n    readonly TEXTURE_WRAP_T: number;\n    readonly TEXTURE0: number;\n    readonly TEXTURE1: number;\n    readonly TEXTURE10: number;\n    readonly TEXTURE11: number;\n    readonly TEXTURE12: number;\n    readonly TEXTURE13: number;\n    readonly TEXTURE14: number;\n    readonly TEXTURE15: number;\n    readonly TEXTURE16: number;\n    readonly TEXTURE17: number;\n    readonly TEXTURE18: number;\n    readonly TEXTURE19: number;\n    readonly TEXTURE2: number;\n    readonly TEXTURE20: number;\n    readonly TEXTURE21: number;\n    readonly TEXTURE22: number;\n    readonly TEXTURE23: number;\n    readonly TEXTURE24: number;\n    readonly TEXTURE25: number;\n    readonly TEXTURE26: number;\n    readonly TEXTURE27: number;\n    readonly TEXTURE28: number;\n    readonly TEXTURE29: number;\n    readonly TEXTURE3: number;\n    readonly TEXTURE30: number;\n    readonly TEXTURE31: number;\n    readonly TEXTURE4: number;\n    readonly TEXTURE5: number;\n    readonly TEXTURE6: number;\n    readonly TEXTURE7: number;\n    readonly TEXTURE8: number;\n    readonly TEXTURE9: number;\n    readonly TRIANGLE_FAN: number;\n    readonly TRIANGLE_STRIP: number;\n    readonly TRIANGLES: number;\n    readonly UNPACK_ALIGNMENT: number;\n    readonly UNPACK_COLORSPACE_CONVERSION_WEBGL: number;\n    readonly UNPACK_FLIP_Y_WEBGL: number;\n    readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL: number;\n    readonly UNSIGNED_BYTE: number;\n    readonly UNSIGNED_INT: number;\n    readonly UNSIGNED_SHORT: number;\n    readonly UNSIGNED_SHORT_4_4_4_4: number;\n    readonly UNSIGNED_SHORT_5_5_5_1: number;\n    readonly UNSIGNED_SHORT_5_6_5: number;\n    readonly VALIDATE_STATUS: number;\n    readonly VENDOR: number;\n    readonly VERSION: number;\n    readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: number;\n    readonly VERTEX_ATTRIB_ARRAY_ENABLED: number;\n    readonly VERTEX_ATTRIB_ARRAY_NORMALIZED: number;\n    readonly VERTEX_ATTRIB_ARRAY_POINTER: number;\n    readonly VERTEX_ATTRIB_ARRAY_SIZE: number;\n    readonly VERTEX_ATTRIB_ARRAY_STRIDE: number;\n    readonly VERTEX_ATTRIB_ARRAY_TYPE: number;\n    readonly VERTEX_SHADER: number;\n    readonly VIEWPORT: number;\n    readonly ZERO: number;\n};\n\ninterface WebGLShader extends WebGLObject {\n}\n\ndeclare var WebGLShader: {\n    prototype: WebGLShader;\n    new(): WebGLShader;\n};\n\ninterface WebGLShaderPrecisionFormat {\n    readonly precision: number;\n    readonly rangeMax: number;\n    readonly rangeMin: number;\n}\n\ndeclare var WebGLShaderPrecisionFormat: {\n    prototype: WebGLShaderPrecisionFormat;\n    new(): WebGLShaderPrecisionFormat;\n};\n\ninterface WebGLTexture extends WebGLObject {\n}\n\ndeclare var WebGLTexture: {\n    prototype: WebGLTexture;\n    new(): WebGLTexture;\n};\n\ninterface WebGLUniformLocation {\n}\n\ndeclare var WebGLUniformLocation: {\n    prototype: WebGLUniformLocation;\n    new(): WebGLUniformLocation;\n};\n\ninterface WebKitCSSMatrix {\n    a: number;\n    b: number;\n    c: number;\n    d: number;\n    e: number;\n    f: number;\n    m11: number;\n    m12: number;\n    m13: number;\n    m14: number;\n    m21: number;\n    m22: number;\n    m23: number;\n    m24: number;\n    m31: number;\n    m32: number;\n    m33: number;\n    m34: number;\n    m41: number;\n    m42: number;\n    m43: number;\n    m44: number;\n    inverse(): WebKitCSSMatrix;\n    multiply(secondMatrix: WebKitCSSMatrix): WebKitCSSMatrix;\n    rotate(angleX: number, angleY?: number, angleZ?: number): WebKitCSSMatrix;\n    rotateAxisAngle(x: number, y: number, z: number, angle: number): WebKitCSSMatrix;\n    scale(scaleX: number, scaleY?: number, scaleZ?: number): WebKitCSSMatrix;\n    setMatrixValue(value: string): void;\n    skewX(angle: number): WebKitCSSMatrix;\n    skewY(angle: number): WebKitCSSMatrix;\n    toString(): string;\n    translate(x: number, y: number, z?: number): WebKitCSSMatrix;\n}\n\ndeclare var WebKitCSSMatrix: {\n    prototype: WebKitCSSMatrix;\n    new(text?: string): WebKitCSSMatrix;\n};\n\ninterface WebKitDirectoryEntry extends WebKitEntry {\n    createReader(): WebKitDirectoryReader;\n}\n\ndeclare var WebKitDirectoryEntry: {\n    prototype: WebKitDirectoryEntry;\n    new(): WebKitDirectoryEntry;\n};\n\ninterface WebKitDirectoryReader {\n    readEntries(successCallback: WebKitEntriesCallback, errorCallback?: WebKitErrorCallback): void;\n}\n\ndeclare var WebKitDirectoryReader: {\n    prototype: WebKitDirectoryReader;\n    new(): WebKitDirectoryReader;\n};\n\ninterface WebKitEntry {\n    readonly filesystem: WebKitFileSystem;\n    readonly fullPath: string;\n    readonly isDirectory: boolean;\n    readonly isFile: boolean;\n    readonly name: string;\n}\n\ndeclare var WebKitEntry: {\n    prototype: WebKitEntry;\n    new(): WebKitEntry;\n};\n\ninterface WebKitFileEntry extends WebKitEntry {\n    file(successCallback: WebKitFileCallback, errorCallback?: WebKitErrorCallback): void;\n}\n\ndeclare var WebKitFileEntry: {\n    prototype: WebKitFileEntry;\n    new(): WebKitFileEntry;\n};\n\ninterface WebKitFileSystem {\n    readonly name: string;\n    readonly root: WebKitDirectoryEntry;\n}\n\ndeclare var WebKitFileSystem: {\n    prototype: WebKitFileSystem;\n    new(): WebKitFileSystem;\n};\n\ninterface WebKitPoint {\n    x: number;\n    y: number;\n}\n\ndeclare var WebKitPoint: {\n    prototype: WebKitPoint;\n    new(x?: number, y?: number): WebKitPoint;\n};\n\ninterface webkitRTCPeerConnection extends RTCPeerConnection {\n    addEventListener<K extends keyof RTCPeerConnectionEventMap>(type: K, listener: (this: webkitRTCPeerConnection, ev: RTCPeerConnectionEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var webkitRTCPeerConnection: {\n    prototype: webkitRTCPeerConnection;\n    new(configuration: RTCConfiguration): webkitRTCPeerConnection;\n};\n\ninterface WebSocketEventMap {\n    \"close\": CloseEvent;\n    \"error\": Event;\n    \"message\": MessageEvent;\n    \"open\": Event;\n}\n\ninterface WebSocket extends EventTarget {\n    binaryType: string;\n    readonly bufferedAmount: number;\n    readonly extensions: string;\n    onclose: (this: WebSocket, ev: CloseEvent) => any;\n    onerror: (this: WebSocket, ev: Event) => any;\n    onmessage: (this: WebSocket, ev: MessageEvent) => any;\n    onopen: (this: WebSocket, ev: Event) => any;\n    readonly protocol: string;\n    readonly readyState: number;\n    readonly url: string;\n    close(code?: number, reason?: string): void;\n    send(data: any): void;\n    readonly CLOSED: number;\n    readonly CLOSING: number;\n    readonly CONNECTING: number;\n    readonly OPEN: number;\n    addEventListener<K extends keyof WebSocketEventMap>(type: K, listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var WebSocket: {\n    prototype: WebSocket;\n    new(url: string, protocols?: string | string[]): WebSocket;\n    readonly CLOSED: number;\n    readonly CLOSING: number;\n    readonly CONNECTING: number;\n    readonly OPEN: number;\n};\n\ninterface WheelEvent extends MouseEvent {\n    readonly deltaMode: number;\n    readonly deltaX: number;\n    readonly deltaY: number;\n    readonly deltaZ: number;\n    readonly wheelDelta: number;\n    readonly wheelDeltaX: number;\n    readonly wheelDeltaY: number;\n    getCurrentPoint(element: Element): void;\n    initWheelEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, buttonArg: number, relatedTargetArg: EventTarget, modifiersListArg: string, deltaXArg: number, deltaYArg: number, deltaZArg: number, deltaMode: number): void;\n    readonly DOM_DELTA_LINE: number;\n    readonly DOM_DELTA_PAGE: number;\n    readonly DOM_DELTA_PIXEL: number;\n}\n\ndeclare var WheelEvent: {\n    prototype: WheelEvent;\n    new(typeArg: string, eventInitDict?: WheelEventInit): WheelEvent;\n    readonly DOM_DELTA_LINE: number;\n    readonly DOM_DELTA_PAGE: number;\n    readonly DOM_DELTA_PIXEL: number;\n};\n\ninterface WindowEventMap extends GlobalEventHandlersEventMap {\n    \"abort\": UIEvent;\n    \"afterprint\": Event;\n    \"beforeprint\": Event;\n    \"beforeunload\": BeforeUnloadEvent;\n    \"blur\": FocusEvent;\n    \"canplay\": Event;\n    \"canplaythrough\": Event;\n    \"change\": Event;\n    \"click\": MouseEvent;\n    \"compassneedscalibration\": Event;\n    \"contextmenu\": PointerEvent;\n    \"dblclick\": MouseEvent;\n    \"devicelight\": DeviceLightEvent;\n    \"devicemotion\": DeviceMotionEvent;\n    \"deviceorientation\": DeviceOrientationEvent;\n    \"drag\": DragEvent;\n    \"dragend\": DragEvent;\n    \"dragenter\": DragEvent;\n    \"dragleave\": DragEvent;\n    \"dragover\": DragEvent;\n    \"dragstart\": DragEvent;\n    \"drop\": DragEvent;\n    \"durationchange\": Event;\n    \"emptied\": Event;\n    \"ended\": MediaStreamErrorEvent;\n    \"error\": ErrorEvent;\n    \"focus\": FocusEvent;\n    \"hashchange\": HashChangeEvent;\n    \"input\": Event;\n    \"invalid\": Event;\n    \"keydown\": KeyboardEvent;\n    \"keypress\": KeyboardEvent;\n    \"keyup\": KeyboardEvent;\n    \"load\": Event;\n    \"loadeddata\": Event;\n    \"loadedmetadata\": Event;\n    \"loadstart\": Event;\n    \"message\": MessageEvent;\n    \"mousedown\": MouseEvent;\n    \"mouseenter\": MouseEvent;\n    \"mouseleave\": MouseEvent;\n    \"mousemove\": MouseEvent;\n    \"mouseout\": MouseEvent;\n    \"mouseover\": MouseEvent;\n    \"mouseup\": MouseEvent;\n    \"mousewheel\": WheelEvent;\n    \"MSGestureChange\": MSGestureEvent;\n    \"MSGestureDoubleTap\": MSGestureEvent;\n    \"MSGestureEnd\": MSGestureEvent;\n    \"MSGestureHold\": MSGestureEvent;\n    \"MSGestureStart\": MSGestureEvent;\n    \"MSGestureTap\": MSGestureEvent;\n    \"MSInertiaStart\": MSGestureEvent;\n    \"MSPointerCancel\": MSPointerEvent;\n    \"MSPointerDown\": MSPointerEvent;\n    \"MSPointerEnter\": MSPointerEvent;\n    \"MSPointerLeave\": MSPointerEvent;\n    \"MSPointerMove\": MSPointerEvent;\n    \"MSPointerOut\": MSPointerEvent;\n    \"MSPointerOver\": MSPointerEvent;\n    \"MSPointerUp\": MSPointerEvent;\n    \"offline\": Event;\n    \"online\": Event;\n    \"orientationchange\": Event;\n    \"pagehide\": PageTransitionEvent;\n    \"pageshow\": PageTransitionEvent;\n    \"pause\": Event;\n    \"play\": Event;\n    \"playing\": Event;\n    \"popstate\": PopStateEvent;\n    \"progress\": ProgressEvent;\n    \"ratechange\": Event;\n    \"readystatechange\": ProgressEvent;\n    \"reset\": Event;\n    \"resize\": UIEvent;\n    \"scroll\": UIEvent;\n    \"seeked\": Event;\n    \"seeking\": Event;\n    \"select\": UIEvent;\n    \"stalled\": Event;\n    \"storage\": StorageEvent;\n    \"submit\": Event;\n    \"suspend\": Event;\n    \"timeupdate\": Event;\n    \"touchcancel\": TouchEvent;\n    \"touchend\": TouchEvent;\n    \"touchmove\": TouchEvent;\n    \"touchstart\": TouchEvent;\n    \"unload\": Event;\n    \"volumechange\": Event;\n    \"waiting\": Event;\n}\n\ninterface Window extends EventTarget, WindowTimers, WindowSessionStorage, WindowLocalStorage, WindowConsole, GlobalEventHandlers, IDBEnvironment, WindowBase64, GlobalFetch {\n    readonly applicationCache: ApplicationCache;\n    readonly caches: CacheStorage;\n    readonly clientInformation: Navigator;\n    readonly closed: boolean;\n    readonly crypto: Crypto;\n    defaultStatus: string;\n    readonly devicePixelRatio: number;\n    readonly document: Document;\n    readonly doNotTrack: string;\n    event: Event | undefined;\n    readonly external: External;\n    readonly frameElement: Element;\n    readonly frames: Window;\n    readonly history: History;\n    readonly innerHeight: number;\n    readonly innerWidth: number;\n    readonly isSecureContext: boolean;\n    readonly length: number;\n    readonly location: Location;\n    readonly locationbar: BarProp;\n    readonly menubar: BarProp;\n    readonly msContentScript: ExtensionScriptApis;\n    readonly msCredentials: MSCredentials;\n    name: string;\n    readonly navigator: Navigator;\n    offscreenBuffering: string | boolean;\n    onabort: (this: Window, ev: UIEvent) => any;\n    onafterprint: (this: Window, ev: Event) => any;\n    onbeforeprint: (this: Window, ev: Event) => any;\n    onbeforeunload: (this: Window, ev: BeforeUnloadEvent) => any;\n    onblur: (this: Window, ev: FocusEvent) => any;\n    oncanplay: (this: Window, ev: Event) => any;\n    oncanplaythrough: (this: Window, ev: Event) => any;\n    onchange: (this: Window, ev: Event) => any;\n    onclick: (this: Window, ev: MouseEvent) => any;\n    oncompassneedscalibration: (this: Window, ev: Event) => any;\n    oncontextmenu: (this: Window, ev: PointerEvent) => any;\n    ondblclick: (this: Window, ev: MouseEvent) => any;\n    ondevicelight: (this: Window, ev: DeviceLightEvent) => any;\n    ondevicemotion: (this: Window, ev: DeviceMotionEvent) => any;\n    ondeviceorientation: (this: Window, ev: DeviceOrientationEvent) => any;\n    ondrag: (this: Window, ev: DragEvent) => any;\n    ondragend: (this: Window, ev: DragEvent) => any;\n    ondragenter: (this: Window, ev: DragEvent) => any;\n    ondragleave: (this: Window, ev: DragEvent) => any;\n    ondragover: (this: Window, ev: DragEvent) => any;\n    ondragstart: (this: Window, ev: DragEvent) => any;\n    ondrop: (this: Window, ev: DragEvent) => any;\n    ondurationchange: (this: Window, ev: Event) => any;\n    onemptied: (this: Window, ev: Event) => any;\n    onended: (this: Window, ev: MediaStreamErrorEvent) => any;\n    onerror: ErrorEventHandler;\n    onfocus: (this: Window, ev: FocusEvent) => any;\n    onhashchange: (this: Window, ev: HashChangeEvent) => any;\n    oninput: (this: Window, ev: Event) => any;\n    oninvalid: (this: Window, ev: Event) => any;\n    onkeydown: (this: Window, ev: KeyboardEvent) => any;\n    onkeypress: (this: Window, ev: KeyboardEvent) => any;\n    onkeyup: (this: Window, ev: KeyboardEvent) => any;\n    onload: (this: Window, ev: Event) => any;\n    onloadeddata: (this: Window, ev: Event) => any;\n    onloadedmetadata: (this: Window, ev: Event) => any;\n    onloadstart: (this: Window, ev: Event) => any;\n    onmessage: (this: Window, ev: MessageEvent) => any;\n    onmousedown: (this: Window, ev: MouseEvent) => any;\n    onmouseenter: (this: Window, ev: MouseEvent) => any;\n    onmouseleave: (this: Window, ev: MouseEvent) => any;\n    onmousemove: (this: Window, ev: MouseEvent) => any;\n    onmouseout: (this: Window, ev: MouseEvent) => any;\n    onmouseover: (this: Window, ev: MouseEvent) => any;\n    onmouseup: (this: Window, ev: MouseEvent) => any;\n    onmousewheel: (this: Window, ev: WheelEvent) => any;\n    onmsgesturechange: (this: Window, ev: MSGestureEvent) => any;\n    onmsgesturedoubletap: (this: Window, ev: MSGestureEvent) => any;\n    onmsgestureend: (this: Window, ev: MSGestureEvent) => any;\n    onmsgesturehold: (this: Window, ev: MSGestureEvent) => any;\n    onmsgesturestart: (this: Window, ev: MSGestureEvent) => any;\n    onmsgesturetap: (this: Window, ev: MSGestureEvent) => any;\n    onmsinertiastart: (this: Window, ev: MSGestureEvent) => any;\n    onmspointercancel: (this: Window, ev: MSPointerEvent) => any;\n    onmspointerdown: (this: Window, ev: MSPointerEvent) => any;\n    onmspointerenter: (this: Window, ev: MSPointerEvent) => any;\n    onmspointerleave: (this: Window, ev: MSPointerEvent) => any;\n    onmspointermove: (this: Window, ev: MSPointerEvent) => any;\n    onmspointerout: (this: Window, ev: MSPointerEvent) => any;\n    onmspointerover: (this: Window, ev: MSPointerEvent) => any;\n    onmspointerup: (this: Window, ev: MSPointerEvent) => any;\n    onoffline: (this: Window, ev: Event) => any;\n    ononline: (this: Window, ev: Event) => any;\n    onorientationchange: (this: Window, ev: Event) => any;\n    onpagehide: (this: Window, ev: PageTransitionEvent) => any;\n    onpageshow: (this: Window, ev: PageTransitionEvent) => any;\n    onpause: (this: Window, ev: Event) => any;\n    onplay: (this: Window, ev: Event) => any;\n    onplaying: (this: Window, ev: Event) => any;\n    onpopstate: (this: Window, ev: PopStateEvent) => any;\n    onprogress: (this: Window, ev: ProgressEvent) => any;\n    onratechange: (this: Window, ev: Event) => any;\n    onreadystatechange: (this: Window, ev: ProgressEvent) => any;\n    onreset: (this: Window, ev: Event) => any;\n    onresize: (this: Window, ev: UIEvent) => any;\n    onscroll: (this: Window, ev: UIEvent) => any;\n    onseeked: (this: Window, ev: Event) => any;\n    onseeking: (this: Window, ev: Event) => any;\n    onselect: (this: Window, ev: UIEvent) => any;\n    onstalled: (this: Window, ev: Event) => any;\n    onstorage: (this: Window, ev: StorageEvent) => any;\n    onsubmit: (this: Window, ev: Event) => any;\n    onsuspend: (this: Window, ev: Event) => any;\n    ontimeupdate: (this: Window, ev: Event) => any;\n    ontouchcancel: (ev: TouchEvent) => any;\n    ontouchend: (ev: TouchEvent) => any;\n    ontouchmove: (ev: TouchEvent) => any;\n    ontouchstart: (ev: TouchEvent) => any;\n    onunload: (this: Window, ev: Event) => any;\n    onvolumechange: (this: Window, ev: Event) => any;\n    onwaiting: (this: Window, ev: Event) => any;\n    opener: any;\n    orientation: string | number;\n    readonly outerHeight: number;\n    readonly outerWidth: number;\n    readonly pageXOffset: number;\n    readonly pageYOffset: number;\n    readonly parent: Window;\n    readonly performance: Performance;\n    readonly personalbar: BarProp;\n    readonly screen: Screen;\n    readonly screenLeft: number;\n    readonly screenTop: number;\n    readonly screenX: number;\n    readonly screenY: number;\n    readonly scrollbars: BarProp;\n    readonly scrollX: number;\n    readonly scrollY: number;\n    readonly self: Window;\n    readonly speechSynthesis: SpeechSynthesis;\n    status: string;\n    readonly statusbar: BarProp;\n    readonly styleMedia: StyleMedia;\n    readonly toolbar: BarProp;\n    readonly top: Window;\n    readonly window: Window;\n    URL: typeof URL;\n    URLSearchParams: typeof URLSearchParams;\n    Blob: typeof Blob;\n    customElements: CustomElementRegistry;\n    alert(message?: any): void;\n    blur(): void;\n    cancelAnimationFrame(handle: number): void;\n    captureEvents(): void;\n    close(): void;\n    confirm(message?: string): boolean;\n    departFocus(navigationReason: NavigationReason, origin: FocusNavigationOrigin): void;\n    focus(): void;\n    getComputedStyle(elt: Element, pseudoElt?: string): CSSStyleDeclaration;\n    getMatchedCSSRules(elt: Element, pseudoElt?: string): CSSRuleList;\n    getSelection(): Selection;\n    matchMedia(mediaQuery: string): MediaQueryList;\n    moveBy(x?: number, y?: number): void;\n    moveTo(x?: number, y?: number): void;\n    msWriteProfilerMark(profilerMarkName: string): void;\n    open(url?: string, target?: string, features?: string, replace?: boolean): Window;\n    postMessage(message: any, targetOrigin: string, transfer?: any[]): void;\n    print(): void;\n    prompt(message?: string, _default?: string): string | null;\n    releaseEvents(): void;\n    requestAnimationFrame(callback: FrameRequestCallback): number;\n    resizeBy(x?: number, y?: number): void;\n    resizeTo(x?: number, y?: number): void;\n    scroll(x?: number, y?: number): void;\n    scrollBy(x?: number, y?: number): void;\n    scrollTo(x?: number, y?: number): void;\n    stop(): void;\n    webkitCancelAnimationFrame(handle: number): void;\n    webkitConvertPointFromNodeToPage(node: Node, pt: WebKitPoint): WebKitPoint;\n    webkitConvertPointFromPageToNode(node: Node, pt: WebKitPoint): WebKitPoint;\n    webkitRequestAnimationFrame(callback: FrameRequestCallback): number;\n    createImageBitmap(image: HTMLImageElement | SVGImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap | ImageData | Blob, options?: ImageBitmapOptions): Promise<ImageBitmap>;\n    createImageBitmap(image: HTMLImageElement | SVGImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap | ImageData | Blob, sx: number, sy: number, sw: number, sh: number, options?: ImageBitmapOptions): Promise<ImageBitmap>;\n    scroll(options?: ScrollToOptions): void;\n    scrollTo(options?: ScrollToOptions): void;\n    scrollBy(options?: ScrollToOptions): void;\n    addEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var Window: {\n    prototype: Window;\n    new(): Window;\n};\n\ninterface WorkerEventMap extends AbstractWorkerEventMap {\n    \"message\": MessageEvent;\n}\n\ninterface Worker extends EventTarget, AbstractWorker {\n    onmessage: (this: Worker, ev: MessageEvent) => any;\n    postMessage(message: any, transfer?: any[]): void;\n    terminate(): void;\n    addEventListener<K extends keyof WorkerEventMap>(type: K, listener: (this: Worker, ev: WorkerEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var Worker: {\n    prototype: Worker;\n    new(stringUrl: string): Worker;\n};\n\ninterface XMLDocument extends Document {\n    addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: XMLDocument, ev: DocumentEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var XMLDocument: {\n    prototype: XMLDocument;\n    new(): XMLDocument;\n};\n\ninterface XMLHttpRequestEventMap extends XMLHttpRequestEventTargetEventMap {\n    \"readystatechange\": Event;\n}\n\ninterface XMLHttpRequest extends EventTarget, XMLHttpRequestEventTarget {\n    onreadystatechange: (this: XMLHttpRequest, ev: Event) => any;\n    readonly readyState: number;\n    readonly response: any;\n    readonly responseText: string;\n    responseType: XMLHttpRequestResponseType;\n    readonly responseURL: string;\n    readonly responseXML: Document | null;\n    readonly status: number;\n    readonly statusText: string;\n    timeout: number;\n    readonly upload: XMLHttpRequestUpload;\n    withCredentials: boolean;\n    msCaching?: string;\n    abort(): void;\n    getAllResponseHeaders(): string;\n    getResponseHeader(header: string): string | null;\n    msCachingEnabled(): boolean;\n    open(method: string, url: string, async?: boolean, user?: string, password?: string): void;\n    overrideMimeType(mime: string): void;\n    send(data?: Document): void;\n    send(data?: string): void;\n    send(data?: any): void;\n    setRequestHeader(header: string, value: string): void;\n    readonly DONE: number;\n    readonly HEADERS_RECEIVED: number;\n    readonly LOADING: number;\n    readonly OPENED: number;\n    readonly UNSENT: number;\n    addEventListener<K extends keyof XMLHttpRequestEventMap>(type: K, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var XMLHttpRequest: {\n    prototype: XMLHttpRequest;\n    new(): XMLHttpRequest;\n    readonly DONE: number;\n    readonly HEADERS_RECEIVED: number;\n    readonly LOADING: number;\n    readonly OPENED: number;\n    readonly UNSENT: number;\n};\n\ninterface XMLHttpRequestUpload extends EventTarget, XMLHttpRequestEventTarget {\n    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ndeclare var XMLHttpRequestUpload: {\n    prototype: XMLHttpRequestUpload;\n    new(): XMLHttpRequestUpload;\n};\n\ninterface XMLSerializer {\n    serializeToString(target: Node): string;\n}\n\ndeclare var XMLSerializer: {\n    prototype: XMLSerializer;\n    new(): XMLSerializer;\n};\n\ninterface XPathEvaluator {\n    createExpression(expression: string, resolver: XPathNSResolver): XPathExpression;\n    createNSResolver(nodeResolver?: Node): XPathNSResolver;\n    evaluate(expression: string, contextNode: Node, resolver: XPathNSResolver | null, type: number, result: XPathResult | null): XPathResult;\n}\n\ndeclare var XPathEvaluator: {\n    prototype: XPathEvaluator;\n    new(): XPathEvaluator;\n};\n\ninterface XPathExpression {\n    evaluate(contextNode: Node, type: number, result: XPathResult | null): XPathResult;\n}\n\ndeclare var XPathExpression: {\n    prototype: XPathExpression;\n    new(): XPathExpression;\n};\n\ninterface XPathNSResolver {\n    lookupNamespaceURI(prefix: string): string;\n}\n\ndeclare var XPathNSResolver: {\n    prototype: XPathNSResolver;\n    new(): XPathNSResolver;\n};\n\ninterface XPathResult {\n    readonly booleanValue: boolean;\n    readonly invalidIteratorState: boolean;\n    readonly numberValue: number;\n    readonly resultType: number;\n    readonly singleNodeValue: Node;\n    readonly snapshotLength: number;\n    readonly stringValue: string;\n    iterateNext(): Node;\n    snapshotItem(index: number): Node;\n    readonly ANY_TYPE: number;\n    readonly ANY_UNORDERED_NODE_TYPE: number;\n    readonly BOOLEAN_TYPE: number;\n    readonly FIRST_ORDERED_NODE_TYPE: number;\n    readonly NUMBER_TYPE: number;\n    readonly ORDERED_NODE_ITERATOR_TYPE: number;\n    readonly ORDERED_NODE_SNAPSHOT_TYPE: number;\n    readonly STRING_TYPE: number;\n    readonly UNORDERED_NODE_ITERATOR_TYPE: number;\n    readonly UNORDERED_NODE_SNAPSHOT_TYPE: number;\n}\n\ndeclare var XPathResult: {\n    prototype: XPathResult;\n    new(): XPathResult;\n    readonly ANY_TYPE: number;\n    readonly ANY_UNORDERED_NODE_TYPE: number;\n    readonly BOOLEAN_TYPE: number;\n    readonly FIRST_ORDERED_NODE_TYPE: number;\n    readonly NUMBER_TYPE: number;\n    readonly ORDERED_NODE_ITERATOR_TYPE: number;\n    readonly ORDERED_NODE_SNAPSHOT_TYPE: number;\n    readonly STRING_TYPE: number;\n    readonly UNORDERED_NODE_ITERATOR_TYPE: number;\n    readonly UNORDERED_NODE_SNAPSHOT_TYPE: number;\n};\n\ninterface XSLTProcessor {\n    clearParameters(): void;\n    getParameter(namespaceURI: string, localName: string): any;\n    importStylesheet(style: Node): void;\n    removeParameter(namespaceURI: string, localName: string): void;\n    reset(): void;\n    setParameter(namespaceURI: string, localName: string, value: any): void;\n    transformToDocument(source: Node): Document;\n    transformToFragment(source: Node, document: Document): DocumentFragment;\n}\n\ndeclare var XSLTProcessor: {\n    prototype: XSLTProcessor;\n    new(): XSLTProcessor;\n};\n\ninterface AbstractWorkerEventMap {\n    \"error\": ErrorEvent;\n}\n\ninterface AbstractWorker {\n    onerror: (this: AbstractWorker, ev: ErrorEvent) => any;\n    addEventListener<K extends keyof AbstractWorkerEventMap>(type: K, listener: (this: AbstractWorker, ev: AbstractWorkerEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ninterface Body {\n    readonly bodyUsed: boolean;\n    arrayBuffer(): Promise<ArrayBuffer>;\n    blob(): Promise<Blob>;\n    json(): Promise<any>;\n    text(): Promise<string>;\n    formData(): Promise<FormData>;\n}\n\ninterface CanvasPathMethods {\n    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;\n    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;\n    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;\n    closePath(): void;\n    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;\n    lineTo(x: number, y: number): void;\n    moveTo(x: number, y: number): void;\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;\n    rect(x: number, y: number, w: number, h: number): void;\n}\n\ninterface ChildNode {\n    remove(): void;\n}\n\ninterface DocumentEvent {\n    createEvent(eventInterface: \"AnimationEvent\"): AnimationEvent;\n    createEvent(eventInterface: \"AudioProcessingEvent\"): AudioProcessingEvent;\n    createEvent(eventInterface: \"BeforeUnloadEvent\"): BeforeUnloadEvent;\n    createEvent(eventInterface: \"ClipboardEvent\"): ClipboardEvent;\n    createEvent(eventInterface: \"CloseEvent\"): CloseEvent;\n    createEvent(eventInterface: \"CompositionEvent\"): CompositionEvent;\n    createEvent(eventInterface: \"CustomEvent\"): CustomEvent;\n    createEvent(eventInterface: \"DeviceLightEvent\"): DeviceLightEvent;\n    createEvent(eventInterface: \"DeviceMotionEvent\"): DeviceMotionEvent;\n    createEvent(eventInterface: \"DeviceOrientationEvent\"): DeviceOrientationEvent;\n    createEvent(eventInterface: \"DragEvent\"): DragEvent;\n    createEvent(eventInterface: \"ErrorEvent\"): ErrorEvent;\n    createEvent(eventInterface: \"Event\"): Event;\n    createEvent(eventInterface: \"Events\"): Event;\n    createEvent(eventInterface: \"FocusEvent\"): FocusEvent;\n    createEvent(eventInterface: \"FocusNavigationEvent\"): FocusNavigationEvent;\n    createEvent(eventInterface: \"GamepadEvent\"): GamepadEvent;\n    createEvent(eventInterface: \"HashChangeEvent\"): HashChangeEvent;\n    createEvent(eventInterface: \"IDBVersionChangeEvent\"): IDBVersionChangeEvent;\n    createEvent(eventInterface: \"KeyboardEvent\"): KeyboardEvent;\n    createEvent(eventInterface: \"ListeningStateChangedEvent\"): ListeningStateChangedEvent;\n    createEvent(eventInterface: \"LongRunningScriptDetectedEvent\"): LongRunningScriptDetectedEvent;\n    createEvent(eventInterface: \"MSGestureEvent\"): MSGestureEvent;\n    createEvent(eventInterface: \"MSManipulationEvent\"): MSManipulationEvent;\n    createEvent(eventInterface: \"MSMediaKeyMessageEvent\"): MSMediaKeyMessageEvent;\n    createEvent(eventInterface: \"MSMediaKeyNeededEvent\"): MSMediaKeyNeededEvent;\n    createEvent(eventInterface: \"MSPointerEvent\"): MSPointerEvent;\n    createEvent(eventInterface: \"MSSiteModeEvent\"): MSSiteModeEvent;\n    createEvent(eventInterface: \"MediaEncryptedEvent\"): MediaEncryptedEvent;\n    createEvent(eventInterface: \"MediaKeyMessageEvent\"): MediaKeyMessageEvent;\n    createEvent(eventInterface: \"MediaStreamErrorEvent\"): MediaStreamErrorEvent;\n    createEvent(eventInterface: \"MediaStreamEvent\"): MediaStreamEvent;\n    createEvent(eventInterface: \"MediaStreamTrackEvent\"): MediaStreamTrackEvent;\n    createEvent(eventInterface: \"MessageEvent\"): MessageEvent;\n    createEvent(eventInterface: \"MouseEvent\"): MouseEvent;\n    createEvent(eventInterface: \"MouseEvents\"): MouseEvent;\n    createEvent(eventInterface: \"MutationEvent\"): MutationEvent;\n    createEvent(eventInterface: \"MutationEvents\"): MutationEvent;\n    createEvent(eventInterface: \"NavigationCompletedEvent\"): NavigationCompletedEvent;\n    createEvent(eventInterface: \"NavigationEvent\"): NavigationEvent;\n    createEvent(eventInterface: \"NavigationEventWithReferrer\"): NavigationEventWithReferrer;\n    createEvent(eventInterface: \"OfflineAudioCompletionEvent\"): OfflineAudioCompletionEvent;\n    createEvent(eventInterface: \"OverflowEvent\"): OverflowEvent;\n    createEvent(eventInterface: \"PageTransitionEvent\"): PageTransitionEvent;\n    createEvent(eventInterface: \"PaymentRequestUpdateEvent\"): PaymentRequestUpdateEvent;\n    createEvent(eventInterface: \"PermissionRequestedEvent\"): PermissionRequestedEvent;\n    createEvent(eventInterface: \"PointerEvent\"): PointerEvent;\n    createEvent(eventInterface: \"PopStateEvent\"): PopStateEvent;\n    createEvent(eventInterface: \"ProgressEvent\"): ProgressEvent;\n    createEvent(eventInterface: \"RTCDTMFToneChangeEvent\"): RTCDTMFToneChangeEvent;\n    createEvent(eventInterface: \"RTCDtlsTransportStateChangedEvent\"): RTCDtlsTransportStateChangedEvent;\n    createEvent(eventInterface: \"RTCIceCandidatePairChangedEvent\"): RTCIceCandidatePairChangedEvent;\n    createEvent(eventInterface: \"RTCIceGathererEvent\"): RTCIceGathererEvent;\n    createEvent(eventInterface: \"RTCIceTransportStateChangedEvent\"): RTCIceTransportStateChangedEvent;\n    createEvent(eventInterface: \"RTCPeerConnectionIceEvent\"): RTCPeerConnectionIceEvent;\n    createEvent(eventInterface: \"RTCSsrcConflictEvent\"): RTCSsrcConflictEvent;\n    createEvent(eventInterface: \"SVGZoomEvent\"): SVGZoomEvent;\n    createEvent(eventInterface: \"SVGZoomEvents\"): SVGZoomEvent;\n    createEvent(eventInterface: \"ScriptNotifyEvent\"): ScriptNotifyEvent;\n    createEvent(eventInterface: \"ServiceWorkerMessageEvent\"): ServiceWorkerMessageEvent;\n    createEvent(eventInterface: \"SpeechSynthesisEvent\"): SpeechSynthesisEvent;\n    createEvent(eventInterface: \"StorageEvent\"): StorageEvent;\n    createEvent(eventInterface: \"TextEvent\"): TextEvent;\n    createEvent(eventInterface: \"TouchEvent\"): TouchEvent;\n    createEvent(eventInterface: \"TrackEvent\"): TrackEvent;\n    createEvent(eventInterface: \"TransitionEvent\"): TransitionEvent;\n    createEvent(eventInterface: \"UIEvent\"): UIEvent;\n    createEvent(eventInterface: \"UIEvents\"): UIEvent;\n    createEvent(eventInterface: \"UnviewableContentIdentifiedEvent\"): UnviewableContentIdentifiedEvent;\n    createEvent(eventInterface: \"WebGLContextEvent\"): WebGLContextEvent;\n    createEvent(eventInterface: \"WheelEvent\"): WheelEvent;\n    createEvent(eventInterface: string): Event;\n}\n\ninterface DOML2DeprecatedColorProperty {\n    color: string;\n}\n\ninterface DOML2DeprecatedSizeProperty {\n    size: number;\n}\n\ninterface ElementTraversal {\n    readonly childElementCount: number;\n    readonly firstElementChild: Element | null;\n    readonly lastElementChild: Element | null;\n    readonly nextElementSibling: Element | null;\n    readonly previousElementSibling: Element | null;\n}\n\ninterface GetSVGDocument {\n    getSVGDocument(): Document;\n}\n\ninterface GlobalEventHandlersEventMap {\n    \"pointercancel\": PointerEvent;\n    \"pointerdown\": PointerEvent;\n    \"pointerenter\": PointerEvent;\n    \"pointerleave\": PointerEvent;\n    \"pointermove\": PointerEvent;\n    \"pointerout\": PointerEvent;\n    \"pointerover\": PointerEvent;\n    \"pointerup\": PointerEvent;\n    \"wheel\": WheelEvent;\n}\n\ninterface GlobalEventHandlers {\n    onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;\n    onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;\n    onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;\n    onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;\n    onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;\n    onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;\n    onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;\n    onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;\n    onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;\n    addEventListener<K extends keyof GlobalEventHandlersEventMap>(type: K, listener: (this: GlobalEventHandlers, ev: GlobalEventHandlersEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ninterface GlobalFetch {\n    fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;\n}\n\ninterface HTMLTableAlignment {\n    /**\n     * Sets or retrieves a value that you can use to implement your own ch functionality for the object.\n     */\n    ch: string;\n    /**\n     * Sets or retrieves a value that you can use to implement your own chOff functionality for the object.\n     */\n    chOff: string;\n    /**\n     * Sets or retrieves how text and other content are vertically aligned within the object that contains them.\n     */\n    vAlign: string;\n}\n\ninterface IDBEnvironment {\n    readonly indexedDB: IDBFactory;\n}\n\ninterface LinkStyle {\n    readonly sheet: StyleSheet;\n}\n\ninterface MSBaseReaderEventMap {\n    \"abort\": Event;\n    \"error\": ErrorEvent;\n    \"load\": Event;\n    \"loadend\": ProgressEvent;\n    \"loadstart\": Event;\n    \"progress\": ProgressEvent;\n}\n\ninterface MSBaseReader {\n    onabort: (this: MSBaseReader, ev: Event) => any;\n    onerror: (this: MSBaseReader, ev: ErrorEvent) => any;\n    onload: (this: MSBaseReader, ev: Event) => any;\n    onloadend: (this: MSBaseReader, ev: ProgressEvent) => any;\n    onloadstart: (this: MSBaseReader, ev: Event) => any;\n    onprogress: (this: MSBaseReader, ev: ProgressEvent) => any;\n    readonly readyState: number;\n    readonly result: any;\n    abort(): void;\n    readonly DONE: number;\n    readonly EMPTY: number;\n    readonly LOADING: number;\n    addEventListener<K extends keyof MSBaseReaderEventMap>(type: K, listener: (this: MSBaseReader, ev: MSBaseReaderEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ninterface MSFileSaver {\n    msSaveBlob(blob: any, defaultName?: string): boolean;\n    msSaveOrOpenBlob(blob: any, defaultName?: string): boolean;\n}\n\ninterface MSNavigatorDoNotTrack {\n    confirmSiteSpecificTrackingException(args: ConfirmSiteSpecificExceptionsInformation): boolean;\n    confirmWebWideTrackingException(args: ExceptionInformation): boolean;\n    removeSiteSpecificTrackingException(args: ExceptionInformation): void;\n    removeWebWideTrackingException(args: ExceptionInformation): void;\n    storeSiteSpecificTrackingException(args: StoreSiteSpecificExceptionsInformation): void;\n    storeWebWideTrackingException(args: StoreExceptionsInformation): void;\n}\n\ninterface NavigatorBeacon {\n    sendBeacon(url: USVString, data?: BodyInit): boolean;\n}\n\ninterface NavigatorConcurrentHardware {\n    readonly hardwareConcurrency: number;\n}\n\ninterface NavigatorContentUtils {\n}\n\ninterface NavigatorGeolocation {\n    readonly geolocation: Geolocation;\n}\n\ninterface NavigatorID {\n    readonly appCodeName: string;\n    readonly appName: string;\n    readonly appVersion: string;\n    readonly platform: string;\n    readonly product: string;\n    readonly productSub: string;\n    readonly userAgent: string;\n    readonly vendor: string;\n    readonly vendorSub: string;\n}\n\ninterface NavigatorOnLine {\n    readonly onLine: boolean;\n}\n\ninterface NavigatorStorageUtils {\n}\n\ninterface NavigatorUserMedia {\n    readonly mediaDevices: MediaDevices;\n    getUserMedia(constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void;\n}\n\ninterface NodeSelector {\n    querySelector<K extends keyof ElementTagNameMap>(selectors: K): ElementTagNameMap[K] | null;\n    querySelector(selectors: string): Element | null;\n    querySelectorAll<K extends keyof ElementListTagNameMap>(selectors: K): ElementListTagNameMap[K];\n    querySelectorAll(selectors: string): NodeListOf<Element>;\n}\n\ninterface RandomSource {\n    getRandomValues(array: ArrayBufferView): ArrayBufferView;\n}\n\ninterface SVGAnimatedPoints {\n    readonly animatedPoints: SVGPointList;\n    readonly points: SVGPointList;\n}\n\ninterface SVGFilterPrimitiveStandardAttributes {\n    readonly height: SVGAnimatedLength;\n    readonly result: SVGAnimatedString;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n}\n\ninterface SVGFitToViewBox {\n    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;\n    readonly viewBox: SVGAnimatedRect;\n}\n\ninterface SVGTests {\n    readonly requiredExtensions: SVGStringList;\n    readonly requiredFeatures: SVGStringList;\n    readonly systemLanguage: SVGStringList;\n    hasExtension(extension: string): boolean;\n}\n\ninterface SVGURIReference {\n    readonly href: SVGAnimatedString;\n}\n\ninterface WindowBase64 {\n    atob(encodedString: string): string;\n    btoa(rawString: string): string;\n}\n\ninterface WindowConsole {\n    readonly console: Console;\n}\n\ninterface WindowLocalStorage {\n    readonly localStorage: Storage;\n}\n\ninterface WindowSessionStorage {\n    readonly sessionStorage: Storage;\n}\n\ninterface WindowTimers extends Object, WindowTimersExtension {\n    clearInterval(handle: number): void;\n    clearTimeout(handle: number): void;\n    setInterval(handler: (...args: any[]) => void, timeout: number): number;\n    setInterval(handler: any, timeout?: any, ...args: any[]): number;\n    setTimeout(handler: (...args: any[]) => void, timeout: number): number;\n    setTimeout(handler: any, timeout?: any, ...args: any[]): number;\n}\n\ninterface WindowTimersExtension {\n    clearImmediate(handle: number): void;\n    setImmediate(handler: (...args: any[]) => void): number;\n    setImmediate(handler: any, ...args: any[]): number;\n}\n\ninterface XMLHttpRequestEventTargetEventMap {\n    \"abort\": Event;\n    \"error\": ErrorEvent;\n    \"load\": Event;\n    \"loadend\": ProgressEvent;\n    \"loadstart\": Event;\n    \"progress\": ProgressEvent;\n    \"timeout\": ProgressEvent;\n}\n\ninterface XMLHttpRequestEventTarget {\n    onabort: (this: XMLHttpRequestEventTarget, ev: Event) => any;\n    onerror: (this: XMLHttpRequestEventTarget, ev: ErrorEvent) => any;\n    onload: (this: XMLHttpRequestEventTarget, ev: Event) => any;\n    onloadend: (this: XMLHttpRequestEventTarget, ev: ProgressEvent) => any;\n    onloadstart: (this: XMLHttpRequestEventTarget, ev: Event) => any;\n    onprogress: (this: XMLHttpRequestEventTarget, ev: ProgressEvent) => any;\n    ontimeout: (this: XMLHttpRequestEventTarget, ev: ProgressEvent) => any;\n    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, useCapture?: boolean): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\n}\n\ninterface ErrorEventInit {\n    message?: string;\n    filename?: string;\n    lineno?: number;\n    conlno?: number;\n    error?: any;\n}\n\ninterface StorageEventInit extends EventInit {\n    key?: string;\n    oldValue?: string;\n    newValue?: string;\n    url: string;\n    storageArea?: Storage;\n}\n\ninterface Canvas2DContextAttributes {\n    alpha?: boolean;\n    willReadFrequently?: boolean;\n    storage?: boolean;\n    [attribute: string]: boolean | string | undefined;\n}\n\ninterface ImageBitmapOptions {\n    imageOrientation?: \"none\" | \"flipY\";\n    premultiplyAlpha?: \"none\" | \"premultiply\" | \"default\";\n    colorSpaceConversion?: \"none\" | \"default\";\n    resizeWidth?: number;\n    resizeHeight?: number;\n    resizeQuality?: \"pixelated\" | \"low\" | \"medium\" | \"high\";\n}\n\ninterface ImageBitmap {\n    readonly width: number;\n    readonly height: number;\n    close(): void;\n}\n\ninterface URLSearchParams {\n    /**\n     * Appends a specified key/value pair as a new search parameter.\n     */\n    append(name: string, value: string): void;\n    /**\n     * Deletes the given search parameter, and its associated value, from the list of all search parameters.\n     */\n    delete(name: string): void;\n    /**\n     * Returns the first value associated to the given search parameter.\n     */\n    get(name: string): string | null;\n    /**\n     * Returns all the values association with a given search parameter.\n     */\n    getAll(name: string): string[];\n    /**\n     * Returns a Boolean indicating if such a search parameter exists.\n     */\n    has(name: string): boolean;\n    /**\n     * Sets the value associated to a given search parameter to the given value. If there were several values, delete the others.\n     */\n    set(name: string, value: string): void;\n}\n\ndeclare var URLSearchParams: {\n    prototype: URLSearchParams;\n    /**\n     * Constructor returning a URLSearchParams object.\n     */\n    new (init?: string | URLSearchParams): URLSearchParams;\n};\n\ninterface NodeListOf<TNode extends Node> extends NodeList {\n    length: number;\n    item(index: number): TNode;\n    [index: number]: TNode;\n}\n\ninterface HTMLCollectionOf<T extends Element> extends HTMLCollection {\n    item(index: number): T;\n    namedItem(name: string): T;\n    [index: number]: T;\n}\n\ninterface BlobPropertyBag {\n    type?: string;\n    endings?: string;\n}\n\ninterface FilePropertyBag {\n    type?: string;\n    lastModified?: number;\n}\n\ninterface EventListenerObject {\n    handleEvent(evt: Event): void;\n}\n\ninterface ProgressEventInit extends EventInit {\n    lengthComputable?: boolean;\n    loaded?: number;\n    total?: number;\n}\n\ninterface ScrollOptions {\n    behavior?: ScrollBehavior;\n}\n\ninterface ScrollToOptions extends ScrollOptions {\n    left?: number;\n    top?: number;\n}\n\ninterface ScrollIntoViewOptions extends ScrollOptions {\n    block?: ScrollLogicalPosition;\n    inline?: ScrollLogicalPosition;\n}\n\ninterface ClipboardEventInit extends EventInit {\n    data?: string;\n    dataType?: string;\n}\n\ninterface IDBArrayKey extends Array<IDBValidKey> {\n}\n\ninterface RsaKeyGenParams extends Algorithm {\n    modulusLength: number;\n    publicExponent: Uint8Array;\n}\n\ninterface RsaHashedKeyGenParams extends RsaKeyGenParams {\n    hash: AlgorithmIdentifier;\n}\n\ninterface RsaKeyAlgorithm extends KeyAlgorithm {\n    modulusLength: number;\n    publicExponent: Uint8Array;\n}\n\ninterface RsaHashedKeyAlgorithm extends RsaKeyAlgorithm {\n    hash: AlgorithmIdentifier;\n}\n\ninterface RsaHashedImportParams {\n    hash: AlgorithmIdentifier;\n}\n\ninterface RsaPssParams {\n    saltLength: number;\n}\n\ninterface RsaOaepParams extends Algorithm {\n    label?: BufferSource;\n}\n\ninterface EcdsaParams extends Algorithm {\n    hash: AlgorithmIdentifier;\n}\n\ninterface EcKeyGenParams extends Algorithm {\n    namedCurve: string;\n}\n\ninterface EcKeyAlgorithm extends KeyAlgorithm {\n    typedCurve: string;\n}\n\ninterface EcKeyImportParams {\n    namedCurve: string;\n}\n\ninterface EcdhKeyDeriveParams extends Algorithm {\n    public: CryptoKey;\n}\n\ninterface AesCtrParams extends Algorithm {\n    counter: BufferSource;\n    length: number;\n}\n\ninterface AesKeyAlgorithm extends KeyAlgorithm {\n    length: number;\n}\n\ninterface AesKeyGenParams extends Algorithm {\n    length: number;\n}\n\ninterface AesDerivedKeyParams extends Algorithm {\n    length: number;\n}\n\ninterface AesCbcParams extends Algorithm {\n    iv: BufferSource;\n}\n\ninterface AesCmacParams extends Algorithm {\n    length: number;\n}\n\ninterface AesGcmParams extends Algorithm {\n    iv: BufferSource;\n    additionalData?: BufferSource;\n    tagLength?: number;\n}\n\ninterface AesCfbParams extends Algorithm {\n    iv: BufferSource;\n}\n\ninterface HmacImportParams extends Algorithm {\n    hash?: AlgorithmIdentifier;\n    length?: number;\n}\n\ninterface HmacKeyAlgorithm extends KeyAlgorithm {\n    hash: AlgorithmIdentifier;\n    length: number;\n}\n\ninterface HmacKeyGenParams extends Algorithm {\n    hash: AlgorithmIdentifier;\n    length?: number;\n}\n\ninterface DhKeyGenParams extends Algorithm {\n    prime: Uint8Array;\n    generator: Uint8Array;\n}\n\ninterface DhKeyAlgorithm extends KeyAlgorithm {\n    prime: Uint8Array;\n    generator: Uint8Array;\n}\n\ninterface DhKeyDeriveParams extends Algorithm {\n    public: CryptoKey;\n}\n\ninterface DhImportKeyParams extends Algorithm {\n    prime: Uint8Array;\n    generator: Uint8Array;\n}\n\ninterface ConcatParams extends Algorithm {\n    hash?: AlgorithmIdentifier;\n    algorithmId: Uint8Array;\n    partyUInfo: Uint8Array;\n    partyVInfo: Uint8Array;\n    publicInfo?: Uint8Array;\n    privateInfo?: Uint8Array;\n}\n\ninterface HkdfCtrParams extends Algorithm {\n    hash: AlgorithmIdentifier;\n    label: BufferSource;\n    context: BufferSource;\n}\n\ninterface Pbkdf2Params extends Algorithm {\n    salt: BufferSource;\n    iterations: number;\n    hash: AlgorithmIdentifier;\n}\n\ninterface RsaOtherPrimesInfo {\n    r: string;\n    d: string;\n    t: string;\n}\n\ninterface JsonWebKey {\n    kty: string;\n    use?: string;\n    key_ops?: string[];\n    alg?: string;\n    kid?: string;\n    x5u?: string;\n    x5c?: string;\n    x5t?: string;\n    ext?: boolean;\n    crv?: string;\n    x?: string;\n    y?: string;\n    d?: string;\n    n?: string;\n    e?: string;\n    p?: string;\n    q?: string;\n    dp?: string;\n    dq?: string;\n    qi?: string;\n    oth?: RsaOtherPrimesInfo[];\n    k?: string;\n}\n\ninterface ParentNode {\n    readonly children: HTMLCollection;\n    readonly firstElementChild: Element | null;\n    readonly lastElementChild: Element | null;\n    readonly childElementCount: number;\n}\n\ninterface DocumentOrShadowRoot {\n    readonly activeElement: Element | null;\n    readonly stylesheets: StyleSheetList;\n    getSelection(): Selection | null;\n    elementFromPoint(x: number, y: number): Element | null;\n    elementsFromPoint(x: number, y: number): Element[];\n}\n\ninterface ShadowRoot extends DocumentOrShadowRoot, DocumentFragment {\n    readonly host: Element;\n    innerHTML: string;\n}\n\ninterface ShadowRootInit {\n    mode: \"open\" | \"closed\";\n    delegatesFocus?: boolean;\n}\n\ninterface HTMLSlotElement extends HTMLElement {\n    name: string;\n    assignedNodes(options?: AssignedNodesOptions): Node[];\n}\n\ninterface AssignedNodesOptions {\n    flatten?: boolean;\n}\n\ninterface ElementDefinitionOptions {\n    extends: string;\n}\n\ninterface CustomElementRegistry {\n    define(name: string, constructor: Function, options?: ElementDefinitionOptions): void;\n    get(name: string): any;\n    whenDefined(name: string): PromiseLike<void>;\n}\n\ninterface PromiseRejectionEvent extends Event {\n    readonly promise: PromiseLike<any>;\n    readonly reason: any;\n}\n\ninterface PromiseRejectionEventInit extends EventInit {\n    promise: PromiseLike<any>;\n    reason?: any;\n}\n\ninterface EventListenerOptions {\n    capture?: boolean;\n}\n\ninterface AddEventListenerOptions extends EventListenerOptions {\n    passive?: boolean;\n    once?: boolean;\n}\n\ninterface TouchEventInit extends EventModifierInit {\n    touches?: Touch[];\n    targetTouches?: Touch[];\n    changedTouches?: Touch[];\n}\n\ndeclare type EventListenerOrEventListenerObject = EventListener | EventListenerObject;\n\ninterface DecodeErrorCallback {\n    (error: DOMException): void;\n}\ninterface DecodeSuccessCallback {\n    (decodedData: AudioBuffer): void;\n}\ninterface ErrorEventHandler {\n    (message: string, filename?: string, lineno?: number, colno?: number, error?: Error): void;\n}\ninterface ForEachCallback {\n    (keyId: any, status: MediaKeyStatus): void;\n}\ninterface FrameRequestCallback {\n    (time: number): void;\n}\ninterface FunctionStringCallback {\n    (data: string): void;\n}\ninterface IntersectionObserverCallback {\n    (entries: IntersectionObserverEntry[], observer: IntersectionObserver): void;\n}\ninterface MediaQueryListListener {\n    (mql: MediaQueryList): void;\n}\ninterface MSExecAtPriorityFunctionCallback {\n    (...args: any[]): any;\n}\ninterface MSLaunchUriCallback {\n    (): void;\n}\ninterface MSUnsafeFunctionCallback {\n    (): any;\n}\ninterface MutationCallback {\n    (mutations: MutationRecord[], observer: MutationObserver): void;\n}\ninterface NavigatorUserMediaErrorCallback {\n    (error: MediaStreamError): void;\n}\ninterface NavigatorUserMediaSuccessCallback {\n    (stream: MediaStream): void;\n}\ninterface NotificationPermissionCallback {\n    (permission: NotificationPermission): void;\n}\ninterface PositionCallback {\n    (position: Position): void;\n}\ninterface PositionErrorCallback {\n    (error: PositionError): void;\n}\ninterface RTCPeerConnectionErrorCallback {\n    (error: DOMError): void;\n}\ninterface RTCSessionDescriptionCallback {\n    (sdp: RTCSessionDescription): void;\n}\ninterface RTCStatsCallback {\n    (report: RTCStatsReport): void;\n}\ninterface VoidFunction {\n    (): void;\n}\ninterface HTMLElementTagNameMap {\n    \"a\": HTMLAnchorElement;\n    \"applet\": HTMLAppletElement;\n    \"area\": HTMLAreaElement;\n    \"audio\": HTMLAudioElement;\n    \"base\": HTMLBaseElement;\n    \"basefont\": HTMLBaseFontElement;\n    \"blockquote\": HTMLQuoteElement;\n    \"body\": HTMLBodyElement;\n    \"br\": HTMLBRElement;\n    \"button\": HTMLButtonElement;\n    \"canvas\": HTMLCanvasElement;\n    \"caption\": HTMLTableCaptionElement;\n    \"col\": HTMLTableColElement;\n    \"colgroup\": HTMLTableColElement;\n    \"data\": HTMLDataElement;\n    \"datalist\": HTMLDataListElement;\n    \"del\": HTMLModElement;\n    \"dir\": HTMLDirectoryElement;\n    \"div\": HTMLDivElement;\n    \"dl\": HTMLDListElement;\n    \"embed\": HTMLEmbedElement;\n    \"fieldset\": HTMLFieldSetElement;\n    \"font\": HTMLFontElement;\n    \"form\": HTMLFormElement;\n    \"frame\": HTMLFrameElement;\n    \"frameset\": HTMLFrameSetElement;\n    \"h1\": HTMLHeadingElement;\n    \"h2\": HTMLHeadingElement;\n    \"h3\": HTMLHeadingElement;\n    \"h4\": HTMLHeadingElement;\n    \"h5\": HTMLHeadingElement;\n    \"h6\": HTMLHeadingElement;\n    \"head\": HTMLHeadElement;\n    \"hr\": HTMLHRElement;\n    \"html\": HTMLHtmlElement;\n    \"iframe\": HTMLIFrameElement;\n    \"img\": HTMLImageElement;\n    \"input\": HTMLInputElement;\n    \"ins\": HTMLModElement;\n    \"isindex\": HTMLUnknownElement;\n    \"label\": HTMLLabelElement;\n    \"legend\": HTMLLegendElement;\n    \"li\": HTMLLIElement;\n    \"link\": HTMLLinkElement;\n    \"listing\": HTMLPreElement;\n    \"map\": HTMLMapElement;\n    \"marquee\": HTMLMarqueeElement;\n    \"menu\": HTMLMenuElement;\n    \"meta\": HTMLMetaElement;\n    \"meter\": HTMLMeterElement;\n    \"nextid\": HTMLUnknownElement;\n    \"object\": HTMLObjectElement;\n    \"ol\": HTMLOListElement;\n    \"optgroup\": HTMLOptGroupElement;\n    \"option\": HTMLOptionElement;\n    \"output\": HTMLOutputElement;\n    \"p\": HTMLParagraphElement;\n    \"param\": HTMLParamElement;\n    \"picture\": HTMLPictureElement;\n    \"pre\": HTMLPreElement;\n    \"progress\": HTMLProgressElement;\n    \"q\": HTMLQuoteElement;\n    \"script\": HTMLScriptElement;\n    \"select\": HTMLSelectElement;\n    \"source\": HTMLSourceElement;\n    \"span\": HTMLSpanElement;\n    \"style\": HTMLStyleElement;\n    \"table\": HTMLTableElement;\n    \"tbody\": HTMLTableSectionElement;\n    \"td\": HTMLTableDataCellElement;\n    \"template\": HTMLTemplateElement;\n    \"textarea\": HTMLTextAreaElement;\n    \"tfoot\": HTMLTableSectionElement;\n    \"th\": HTMLTableHeaderCellElement;\n    \"thead\": HTMLTableSectionElement;\n    \"time\": HTMLTimeElement;\n    \"title\": HTMLTitleElement;\n    \"tr\": HTMLTableRowElement;\n    \"track\": HTMLTrackElement;\n    \"ul\": HTMLUListElement;\n    \"video\": HTMLVideoElement;\n    \"x-ms-webview\": MSHTMLWebViewElement;\n    \"xmp\": HTMLPreElement;\n}\n\ninterface ElementTagNameMap extends HTMLElementTagNameMap {\n    \"abbr\": HTMLElement;\n    \"acronym\": HTMLElement;\n    \"address\": HTMLElement;\n    \"article\": HTMLElement;\n    \"aside\": HTMLElement;\n    \"b\": HTMLElement;\n    \"bdo\": HTMLElement;\n    \"big\": HTMLElement;\n    \"center\": HTMLElement;\n    \"circle\": SVGCircleElement;\n    \"cite\": HTMLElement;\n    \"clippath\": SVGClipPathElement;\n    \"code\": HTMLElement;\n    \"dd\": HTMLElement;\n    \"defs\": SVGDefsElement;\n    \"desc\": SVGDescElement;\n    \"dfn\": HTMLElement;\n    \"dt\": HTMLElement;\n    \"ellipse\": SVGEllipseElement;\n    \"em\": HTMLElement;\n    \"feblend\": SVGFEBlendElement;\n    \"fecolormatrix\": SVGFEColorMatrixElement;\n    \"fecomponenttransfer\": SVGFEComponentTransferElement;\n    \"fecomposite\": SVGFECompositeElement;\n    \"feconvolvematrix\": SVGFEConvolveMatrixElement;\n    \"fediffuselighting\": SVGFEDiffuseLightingElement;\n    \"fedisplacementmap\": SVGFEDisplacementMapElement;\n    \"fedistantlight\": SVGFEDistantLightElement;\n    \"feflood\": SVGFEFloodElement;\n    \"fefunca\": SVGFEFuncAElement;\n    \"fefuncb\": SVGFEFuncBElement;\n    \"fefuncg\": SVGFEFuncGElement;\n    \"fefuncr\": SVGFEFuncRElement;\n    \"fegaussianblur\": SVGFEGaussianBlurElement;\n    \"feimage\": SVGFEImageElement;\n    \"femerge\": SVGFEMergeElement;\n    \"femergenode\": SVGFEMergeNodeElement;\n    \"femorphology\": SVGFEMorphologyElement;\n    \"feoffset\": SVGFEOffsetElement;\n    \"fepointlight\": SVGFEPointLightElement;\n    \"fespecularlighting\": SVGFESpecularLightingElement;\n    \"fespotlight\": SVGFESpotLightElement;\n    \"fetile\": SVGFETileElement;\n    \"feturbulence\": SVGFETurbulenceElement;\n    \"figcaption\": HTMLElement;\n    \"figure\": HTMLElement;\n    \"filter\": SVGFilterElement;\n    \"footer\": HTMLElement;\n    \"foreignobject\": SVGForeignObjectElement;\n    \"g\": SVGGElement;\n    \"header\": HTMLElement;\n    \"hgroup\": HTMLElement;\n    \"i\": HTMLElement;\n    \"image\": SVGImageElement;\n    \"kbd\": HTMLElement;\n    \"keygen\": HTMLElement;\n    \"line\": SVGLineElement;\n    \"lineargradient\": SVGLinearGradientElement;\n    \"mark\": HTMLElement;\n    \"marker\": SVGMarkerElement;\n    \"mask\": SVGMaskElement;\n    \"metadata\": SVGMetadataElement;\n    \"nav\": HTMLElement;\n    \"nobr\": HTMLElement;\n    \"noframes\": HTMLElement;\n    \"noscript\": HTMLElement;\n    \"path\": SVGPathElement;\n    \"pattern\": SVGPatternElement;\n    \"plaintext\": HTMLElement;\n    \"polygon\": SVGPolygonElement;\n    \"polyline\": SVGPolylineElement;\n    \"radialgradient\": SVGRadialGradientElement;\n    \"rect\": SVGRectElement;\n    \"rt\": HTMLElement;\n    \"ruby\": HTMLElement;\n    \"s\": HTMLElement;\n    \"samp\": HTMLElement;\n    \"section\": HTMLElement;\n    \"small\": HTMLElement;\n    \"stop\": SVGStopElement;\n    \"strike\": HTMLElement;\n    \"strong\": HTMLElement;\n    \"sub\": HTMLElement;\n    \"sup\": HTMLElement;\n    \"svg\": SVGSVGElement;\n    \"switch\": SVGSwitchElement;\n    \"symbol\": SVGSymbolElement;\n    \"text\": SVGTextElement;\n    \"textpath\": SVGTextPathElement;\n    \"tspan\": SVGTSpanElement;\n    \"tt\": HTMLElement;\n    \"u\": HTMLElement;\n    \"use\": SVGUseElement;\n    \"var\": HTMLElement;\n    \"view\": SVGViewElement;\n    \"wbr\": HTMLElement;\n}\n\ntype ElementListTagNameMap = {\n    [key in keyof ElementTagNameMap]: NodeListOf<ElementTagNameMap[key]>\n};\n\ndeclare var Audio: { new(src?: string): HTMLAudioElement; };\ndeclare var Image: { new(width?: number, height?: number): HTMLImageElement; };\ndeclare var Option: { new(text?: string, value?: string, defaultSelected?: boolean, selected?: boolean): HTMLOptionElement; };\ndeclare var applicationCache: ApplicationCache;\ndeclare var caches: CacheStorage;\ndeclare var clientInformation: Navigator;\ndeclare var closed: boolean;\ndeclare var crypto: Crypto;\ndeclare var defaultStatus: string;\ndeclare var devicePixelRatio: number;\ndeclare var document: Document;\ndeclare var doNotTrack: string;\ndeclare var event: Event | undefined;\ndeclare var external: External;\ndeclare var frameElement: Element;\ndeclare var frames: Window;\ndeclare var history: History;\ndeclare var innerHeight: number;\ndeclare var innerWidth: number;\ndeclare var isSecureContext: boolean;\ndeclare var length: number;\ndeclare var location: Location;\ndeclare var locationbar: BarProp;\ndeclare var menubar: BarProp;\ndeclare var msContentScript: ExtensionScriptApis;\ndeclare var msCredentials: MSCredentials;\ndeclare const name: never;\ndeclare var navigator: Navigator;\ndeclare var offscreenBuffering: string | boolean;\ndeclare var onabort: (this: Window, ev: UIEvent) => any;\ndeclare var onafterprint: (this: Window, ev: Event) => any;\ndeclare var onbeforeprint: (this: Window, ev: Event) => any;\ndeclare var onbeforeunload: (this: Window, ev: BeforeUnloadEvent) => any;\ndeclare var onblur: (this: Window, ev: FocusEvent) => any;\ndeclare var oncanplay: (this: Window, ev: Event) => any;\ndeclare var oncanplaythrough: (this: Window, ev: Event) => any;\ndeclare var onchange: (this: Window, ev: Event) => any;\ndeclare var onclick: (this: Window, ev: MouseEvent) => any;\ndeclare var oncompassneedscalibration: (this: Window, ev: Event) => any;\ndeclare var oncontextmenu: (this: Window, ev: PointerEvent) => any;\ndeclare var ondblclick: (this: Window, ev: MouseEvent) => any;\ndeclare var ondevicelight: (this: Window, ev: DeviceLightEvent) => any;\ndeclare var ondevicemotion: (this: Window, ev: DeviceMotionEvent) => any;\ndeclare var ondeviceorientation: (this: Window, ev: DeviceOrientationEvent) => any;\ndeclare var ondrag: (this: Window, ev: DragEvent) => any;\ndeclare var ondragend: (this: Window, ev: DragEvent) => any;\ndeclare var ondragenter: (this: Window, ev: DragEvent) => any;\ndeclare var ondragleave: (this: Window, ev: DragEvent) => any;\ndeclare var ondragover: (this: Window, ev: DragEvent) => any;\ndeclare var ondragstart: (this: Window, ev: DragEvent) => any;\ndeclare var ondrop: (this: Window, ev: DragEvent) => any;\ndeclare var ondurationchange: (this: Window, ev: Event) => any;\ndeclare var onemptied: (this: Window, ev: Event) => any;\ndeclare var onended: (this: Window, ev: MediaStreamErrorEvent) => any;\ndeclare var onerror: ErrorEventHandler;\ndeclare var onfocus: (this: Window, ev: FocusEvent) => any;\ndeclare var onhashchange: (this: Window, ev: HashChangeEvent) => any;\ndeclare var oninput: (this: Window, ev: Event) => any;\ndeclare var oninvalid: (this: Window, ev: Event) => any;\ndeclare var onkeydown: (this: Window, ev: KeyboardEvent) => any;\ndeclare var onkeypress: (this: Window, ev: KeyboardEvent) => any;\ndeclare var onkeyup: (this: Window, ev: KeyboardEvent) => any;\ndeclare var onload: (this: Window, ev: Event) => any;\ndeclare var onloadeddata: (this: Window, ev: Event) => any;\ndeclare var onloadedmetadata: (this: Window, ev: Event) => any;\ndeclare var onloadstart: (this: Window, ev: Event) => any;\ndeclare var onmessage: (this: Window, ev: MessageEvent) => any;\ndeclare var onmousedown: (this: Window, ev: MouseEvent) => any;\ndeclare var onmouseenter: (this: Window, ev: MouseEvent) => any;\ndeclare var onmouseleave: (this: Window, ev: MouseEvent) => any;\ndeclare var onmousemove: (this: Window, ev: MouseEvent) => any;\ndeclare var onmouseout: (this: Window, ev: MouseEvent) => any;\ndeclare var onmouseover: (this: Window, ev: MouseEvent) => any;\ndeclare var onmouseup: (this: Window, ev: MouseEvent) => any;\ndeclare var onmousewheel: (this: Window, ev: WheelEvent) => any;\ndeclare var onmsgesturechange: (this: Window, ev: MSGestureEvent) => any;\ndeclare var onmsgesturedoubletap: (this: Window, ev: MSGestureEvent) => any;\ndeclare var onmsgestureend: (this: Window, ev: MSGestureEvent) => any;\ndeclare var onmsgesturehold: (this: Window, ev: MSGestureEvent) => any;\ndeclare var onmsgesturestart: (this: Window, ev: MSGestureEvent) => any;\ndeclare var onmsgesturetap: (this: Window, ev: MSGestureEvent) => any;\ndeclare var onmsinertiastart: (this: Window, ev: MSGestureEvent) => any;\ndeclare var onmspointercancel: (this: Window, ev: MSPointerEvent) => any;\ndeclare var onmspointerdown: (this: Window, ev: MSPointerEvent) => any;\ndeclare var onmspointerenter: (this: Window, ev: MSPointerEvent) => any;\ndeclare var onmspointerleave: (this: Window, ev: MSPointerEvent) => any;\ndeclare var onmspointermove: (this: Window, ev: MSPointerEvent) => any;\ndeclare var onmspointerout: (this: Window, ev: MSPointerEvent) => any;\ndeclare var onmspointerover: (this: Window, ev: MSPointerEvent) => any;\ndeclare var onmspointerup: (this: Window, ev: MSPointerEvent) => any;\ndeclare var onoffline: (this: Window, ev: Event) => any;\ndeclare var ononline: (this: Window, ev: Event) => any;\ndeclare var onorientationchange: (this: Window, ev: Event) => any;\ndeclare var onpagehide: (this: Window, ev: PageTransitionEvent) => any;\ndeclare var onpageshow: (this: Window, ev: PageTransitionEvent) => any;\ndeclare var onpause: (this: Window, ev: Event) => any;\ndeclare var onplay: (this: Window, ev: Event) => any;\ndeclare var onplaying: (this: Window, ev: Event) => any;\ndeclare var onpopstate: (this: Window, ev: PopStateEvent) => any;\ndeclare var onprogress: (this: Window, ev: ProgressEvent) => any;\ndeclare var onratechange: (this: Window, ev: Event) => any;\ndeclare var onreadystatechange: (this: Window, ev: ProgressEvent) => any;\ndeclare var onreset: (this: Window, ev: Event) => any;\ndeclare var onresize: (this: Window, ev: UIEvent) => any;\ndeclare var onscroll: (this: Window, ev: UIEvent) => any;\ndeclare var onseeked: (this: Window, ev: Event) => any;\ndeclare var onseeking: (this: Window, ev: Event) => any;\ndeclare var onselect: (this: Window, ev: UIEvent) => any;\ndeclare var onstalled: (this: Window, ev: Event) => any;\ndeclare var onstorage: (this: Window, ev: StorageEvent) => any;\ndeclare var onsubmit: (this: Window, ev: Event) => any;\ndeclare var onsuspend: (this: Window, ev: Event) => any;\ndeclare var ontimeupdate: (this: Window, ev: Event) => any;\ndeclare var ontouchcancel: (ev: TouchEvent) => any;\ndeclare var ontouchend: (ev: TouchEvent) => any;\ndeclare var ontouchmove: (ev: TouchEvent) => any;\ndeclare var ontouchstart: (ev: TouchEvent) => any;\ndeclare var onunload: (this: Window, ev: Event) => any;\ndeclare var onvolumechange: (this: Window, ev: Event) => any;\ndeclare var onwaiting: (this: Window, ev: Event) => any;\ndeclare var opener: any;\ndeclare var orientation: string | number;\ndeclare var outerHeight: number;\ndeclare var outerWidth: number;\ndeclare var pageXOffset: number;\ndeclare var pageYOffset: number;\ndeclare var parent: Window;\ndeclare var performance: Performance;\ndeclare var personalbar: BarProp;\ndeclare var screen: Screen;\ndeclare var screenLeft: number;\ndeclare var screenTop: number;\ndeclare var screenX: number;\ndeclare var screenY: number;\ndeclare var scrollbars: BarProp;\ndeclare var scrollX: number;\ndeclare var scrollY: number;\ndeclare var self: Window;\ndeclare var speechSynthesis: SpeechSynthesis;\ndeclare var status: string;\ndeclare var statusbar: BarProp;\ndeclare var styleMedia: StyleMedia;\ndeclare var toolbar: BarProp;\ndeclare var top: Window;\ndeclare var window: Window;\ndeclare var customElements: CustomElementRegistry;\ndeclare function alert(message?: any): void;\ndeclare function blur(): void;\ndeclare function cancelAnimationFrame(handle: number): void;\ndeclare function captureEvents(): void;\ndeclare function close(): void;\ndeclare function confirm(message?: string): boolean;\ndeclare function departFocus(navigationReason: NavigationReason, origin: FocusNavigationOrigin): void;\ndeclare function focus(): void;\ndeclare function getComputedStyle(elt: Element, pseudoElt?: string): CSSStyleDeclaration;\ndeclare function getMatchedCSSRules(elt: Element, pseudoElt?: string): CSSRuleList;\ndeclare function getSelection(): Selection;\ndeclare function matchMedia(mediaQuery: string): MediaQueryList;\ndeclare function moveBy(x?: number, y?: number): void;\ndeclare function moveTo(x?: number, y?: number): void;\ndeclare function msWriteProfilerMark(profilerMarkName: string): void;\ndeclare function open(url?: string, target?: string, features?: string, replace?: boolean): Window;\ndeclare function postMessage(message: any, targetOrigin: string, transfer?: any[]): void;\ndeclare function print(): void;\ndeclare function prompt(message?: string, _default?: string): string | null;\ndeclare function releaseEvents(): void;\ndeclare function requestAnimationFrame(callback: FrameRequestCallback): number;\ndeclare function resizeBy(x?: number, y?: number): void;\ndeclare function resizeTo(x?: number, y?: number): void;\ndeclare function scroll(x?: number, y?: number): void;\ndeclare function scrollBy(x?: number, y?: number): void;\ndeclare function scrollTo(x?: number, y?: number): void;\ndeclare function stop(): void;\ndeclare function webkitCancelAnimationFrame(handle: number): void;\ndeclare function webkitConvertPointFromNodeToPage(node: Node, pt: WebKitPoint): WebKitPoint;\ndeclare function webkitConvertPointFromPageToNode(node: Node, pt: WebKitPoint): WebKitPoint;\ndeclare function webkitRequestAnimationFrame(callback: FrameRequestCallback): number;\ndeclare function createImageBitmap(image: HTMLImageElement | SVGImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap | ImageData | Blob, options?: ImageBitmapOptions): Promise<ImageBitmap>;\ndeclare function createImageBitmap(image: HTMLImageElement | SVGImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap | ImageData | Blob, sx: number, sy: number, sw: number, sh: number, options?: ImageBitmapOptions): Promise<ImageBitmap>;\ndeclare function scroll(options?: ScrollToOptions): void;\ndeclare function scrollTo(options?: ScrollToOptions): void;\ndeclare function scrollBy(options?: ScrollToOptions): void;\ndeclare function toString(): string;\ndeclare function dispatchEvent(evt: Event): boolean;\ndeclare function removeEventListener(type: string, listener?: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\ndeclare function clearInterval(handle: number): void;\ndeclare function clearTimeout(handle: number): void;\ndeclare function setInterval(handler: (...args: any[]) => void, timeout: number): number;\ndeclare function setInterval(handler: any, timeout?: any, ...args: any[]): number;\ndeclare function setTimeout(handler: (...args: any[]) => void, timeout: number): number;\ndeclare function setTimeout(handler: any, timeout?: any, ...args: any[]): number;\ndeclare function clearImmediate(handle: number): void;\ndeclare function setImmediate(handler: (...args: any[]) => void): number;\ndeclare function setImmediate(handler: any, ...args: any[]): number;\ndeclare var sessionStorage: Storage;\ndeclare var localStorage: Storage;\ndeclare var console: Console;\ndeclare var onpointercancel: (this: Window, ev: PointerEvent) => any;\ndeclare var onpointerdown: (this: Window, ev: PointerEvent) => any;\ndeclare var onpointerenter: (this: Window, ev: PointerEvent) => any;\ndeclare var onpointerleave: (this: Window, ev: PointerEvent) => any;\ndeclare var onpointermove: (this: Window, ev: PointerEvent) => any;\ndeclare var onpointerout: (this: Window, ev: PointerEvent) => any;\ndeclare var onpointerover: (this: Window, ev: PointerEvent) => any;\ndeclare var onpointerup: (this: Window, ev: PointerEvent) => any;\ndeclare var onwheel: (this: Window, ev: WheelEvent) => any;\ndeclare var indexedDB: IDBFactory;\ndeclare function atob(encodedString: string): string;\ndeclare function btoa(rawString: string): string;\ndeclare function fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;\ndeclare function addEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, useCapture?: boolean): void;\ndeclare function addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\ntype AAGUID = string;\ntype AlgorithmIdentifier = string | Algorithm;\ntype BodyInit = any;\ntype ByteString = string;\ntype ConstrainBoolean = boolean | ConstrainBooleanParameters;\ntype ConstrainDOMString = string | string[] | ConstrainDOMStringParameters;\ntype ConstrainDouble = number | ConstrainDoubleRange;\ntype ConstrainLong = number | ConstrainLongRange;\ntype CryptoOperationData = ArrayBufferView;\ntype GLbitfield = number;\ntype GLboolean = boolean;\ntype GLbyte = number;\ntype GLclampf = number;\ntype GLenum = number;\ntype GLfloat = number;\ntype GLint = number;\ntype GLintptr = number;\ntype GLshort = number;\ntype GLsizei = number;\ntype GLsizeiptr = number;\ntype GLubyte = number;\ntype GLuint = number;\ntype GLushort = number;\ntype HeadersInit = any;\ntype IDBKeyPath = string;\ntype KeyFormat = string;\ntype KeyType = string;\ntype KeyUsage = string;\ntype MSInboundPayload = MSVideoRecvPayload | MSAudioRecvPayload;\ntype MSLocalClientEvent = MSLocalClientEventBase | MSAudioLocalClientEvent;\ntype MSOutboundPayload = MSVideoSendPayload | MSAudioSendPayload;\ntype RTCIceGatherCandidate = RTCIceCandidateDictionary | RTCIceCandidateComplete;\ntype RTCTransport = RTCDtlsTransport | RTCSrtpSdesTransport;\ntype RequestInfo = Request | string;\ntype USVString = string;\ntype payloadtype = number;\ntype ScrollBehavior = \"auto\" | \"instant\" | \"smooth\";\ntype ScrollLogicalPosition = \"start\" | \"center\" | \"end\" | \"nearest\";\ntype IDBValidKey = number | string | Date | IDBArrayKey;\ntype BufferSource = ArrayBuffer | ArrayBufferView;\ntype MouseWheelEvent = WheelEvent;\ntype ScrollRestoration = \"auto\" | \"manual\";\ntype FormDataEntryValue = string | File;\ntype InsertPosition = \"beforebegin\" | \"afterbegin\" | \"beforeend\" | \"afterend\";\ntype AppendMode = \"segments\" | \"sequence\";\ntype AudioContextState = \"suspended\" | \"running\" | \"closed\";\ntype BiquadFilterType = \"lowpass\" | \"highpass\" | \"bandpass\" | \"lowshelf\" | \"highshelf\" | \"peaking\" | \"notch\" | \"allpass\";\ntype CanvasFillRule = \"nonzero\" | \"evenodd\";\ntype ChannelCountMode = \"max\" | \"clamped-max\" | \"explicit\";\ntype ChannelInterpretation = \"speakers\" | \"discrete\";\ntype DistanceModelType = \"linear\" | \"inverse\" | \"exponential\";\ntype ExpandGranularity = \"character\" | \"word\" | \"sentence\" | \"textedit\";\ntype GamepadInputEmulationType = \"mouse\" | \"keyboard\" | \"gamepad\";\ntype IDBCursorDirection = \"next\" | \"nextunique\" | \"prev\" | \"prevunique\";\ntype IDBRequestReadyState = \"pending\" | \"done\";\ntype IDBTransactionMode = \"readonly\" | \"readwrite\" | \"versionchange\";\ntype ListeningState = \"inactive\" | \"active\" | \"disambiguation\";\ntype MediaDeviceKind = \"audioinput\" | \"audiooutput\" | \"videoinput\";\ntype MediaKeyMessageType = \"license-request\" | \"license-renewal\" | \"license-release\" | \"individualization-request\";\ntype MediaKeySessionType = \"temporary\" | \"persistent-license\" | \"persistent-release-message\";\ntype MediaKeysRequirement = \"required\" | \"optional\" | \"not-allowed\";\ntype MediaKeyStatus = \"usable\" | \"expired\" | \"output-downscaled\" | \"output-not-allowed\" | \"status-pending\" | \"internal-error\";\ntype MediaStreamTrackState = \"live\" | \"ended\";\ntype MSCredentialType = \"FIDO_2_0\";\ntype MSIceAddrType = \"os\" | \"stun\" | \"turn\" | \"peer-derived\";\ntype MSIceType = \"failed\" | \"direct\" | \"relay\";\ntype MSStatsType = \"description\" | \"localclientevent\" | \"inbound-network\" | \"outbound-network\" | \"inbound-payload\" | \"outbound-payload\" | \"transportdiagnostics\";\ntype MSTransportType = \"Embedded\" | \"USB\" | \"NFC\" | \"BT\";\ntype MSWebViewPermissionState = \"unknown\" | \"defer\" | \"allow\" | \"deny\";\ntype MSWebViewPermissionType = \"geolocation\" | \"unlimitedIndexedDBQuota\" | \"media\" | \"pointerlock\" | \"webnotifications\";\ntype NavigationReason = \"up\" | \"down\" | \"left\" | \"right\";\ntype NavigationType = \"navigate\" | \"reload\" | \"back_forward\" | \"prerender\";\ntype NotificationDirection = \"auto\" | \"ltr\" | \"rtl\";\ntype NotificationPermission = \"default\" | \"denied\" | \"granted\";\ntype OscillatorType = \"sine\" | \"square\" | \"sawtooth\" | \"triangle\" | \"custom\";\ntype OverSampleType = \"none\" | \"2x\" | \"4x\";\ntype PanningModelType = \"equalpower\";\ntype PaymentComplete = \"success\" | \"fail\" | \"\";\ntype PaymentShippingType = \"shipping\" | \"delivery\" | \"pickup\";\ntype PushEncryptionKeyName = \"p256dh\" | \"auth\";\ntype PushPermissionState = \"granted\" | \"denied\" | \"prompt\";\ntype ReferrerPolicy = \"\" | \"no-referrer\" | \"no-referrer-when-downgrade\" | \"origin-only\" | \"origin-when-cross-origin\" | \"unsafe-url\";\ntype RequestCache = \"default\" | \"no-store\" | \"reload\" | \"no-cache\" | \"force-cache\";\ntype RequestCredentials = \"omit\" | \"same-origin\" | \"include\";\ntype RequestDestination = \"\" | \"document\" | \"sharedworker\" | \"subresource\" | \"unknown\" | \"worker\";\ntype RequestMode = \"navigate\" | \"same-origin\" | \"no-cors\" | \"cors\";\ntype RequestRedirect = \"follow\" | \"error\" | \"manual\";\ntype RequestType = \"\" | \"audio\" | \"font\" | \"image\" | \"script\" | \"style\" | \"track\" | \"video\";\ntype ResponseType = \"basic\" | \"cors\" | \"default\" | \"error\" | \"opaque\" | \"opaqueredirect\";\ntype RTCBundlePolicy = \"balanced\" | \"max-compat\" | \"max-bundle\";\ntype RTCDegradationPreference = \"maintain-framerate\" | \"maintain-resolution\" | \"balanced\";\ntype RTCDtlsRole = \"auto\" | \"client\" | \"server\";\ntype RTCDtlsTransportState = \"new\" | \"connecting\" | \"connected\" | \"closed\";\ntype RTCIceCandidateType = \"host\" | \"srflx\" | \"prflx\" | \"relay\";\ntype RTCIceComponent = \"RTP\" | \"RTCP\";\ntype RTCIceConnectionState = \"new\" | \"checking\" | \"connected\" | \"completed\" | \"failed\" | \"disconnected\" | \"closed\";\ntype RTCIceGathererState = \"new\" | \"gathering\" | \"complete\";\ntype RTCIceGatheringState = \"new\" | \"gathering\" | \"complete\";\ntype RTCIceGatherPolicy = \"all\" | \"nohost\" | \"relay\";\ntype RTCIceProtocol = \"udp\" | \"tcp\";\ntype RTCIceRole = \"controlling\" | \"controlled\";\ntype RTCIceTcpCandidateType = \"active\" | \"passive\" | \"so\";\ntype RTCIceTransportPolicy = \"none\" | \"relay\" | \"all\";\ntype RTCIceTransportState = \"new\" | \"checking\" | \"connected\" | \"completed\" | \"disconnected\" | \"closed\";\ntype RTCSdpType = \"offer\" | \"pranswer\" | \"answer\";\ntype RTCSignalingState = \"stable\" | \"have-local-offer\" | \"have-remote-offer\" | \"have-local-pranswer\" | \"have-remote-pranswer\" | \"closed\";\ntype RTCStatsIceCandidatePairState = \"frozen\" | \"waiting\" | \"inprogress\" | \"failed\" | \"succeeded\" | \"cancelled\";\ntype RTCStatsIceCandidateType = \"host\" | \"serverreflexive\" | \"peerreflexive\" | \"relayed\";\ntype RTCStatsType = \"inboundrtp\" | \"outboundrtp\" | \"session\" | \"datachannel\" | \"track\" | \"transport\" | \"candidatepair\" | \"localcandidate\" | \"remotecandidate\";\ntype ScopedCredentialType = \"ScopedCred\";\ntype ServiceWorkerState = \"installing\" | \"installed\" | \"activating\" | \"activated\" | \"redundant\";\ntype Transport = \"usb\" | \"nfc\" | \"ble\";\ntype VideoFacingModeEnum = \"user\" | \"environment\" | \"left\" | \"right\";\ntype VisibilityState = \"hidden\" | \"visible\" | \"prerender\" | \"unloaded\";\ntype XMLHttpRequestResponseType = \"\" | \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\";","type":3},{"name":"node_modules/intern/index.d.ts","text":"import NodeExecutor from './lib/executors/Node';\ndeclare const intern: NodeExecutor;\nexport default intern;\ndeclare global  {\n    const intern: NodeExecutor;\n}\n","type":2},{"name":"node_modules/@dojo/cli-build-webpack/loaders/istanbul-loader/index.d.ts","text":"","type":2},{"name":"node_modules/@dojo/cli-build-webpack/loaders/istanbul-loader/loader.d.ts","text":"import webpack = require('webpack');\n/**\n * Take a source file and run it through istanbul for instrumentation\n *\n * @param {string} content the source code\n * @param {object} sourceMap The source map object\n */\nexport default function (this: webpack.LoaderContext, content: string, sourceMap?: any): void;\n","type":2},{"name":"node_modules/@dojo/cli-build-webpack/main.d.ts","text":"import { Command } from '@dojo/interfaces/cli';\nimport { ExternalDep } from '@dojo/webpack-contrib/external-loader-plugin/ExternalLoaderPlugin';\nexport interface Bundles {\n    [key: string]: string[];\n}\nexport interface BuildArgs {\n    [index: string]: any;\n    messageBundles: string | string[];\n    supportedLocales: string | string[];\n    watch: boolean;\n    port: string;\n    element: string;\n    elementPrefix: string;\n    withTests: boolean;\n    debug: boolean;\n    disableLazyWidgetDetection: boolean;\n    bundles: Bundles;\n    externals: {\n        outputPath?: string;\n        dependencies: ExternalDep[];\n    };\n    features: string | string[];\n    force: boolean;\n}\ndeclare const command: Command<BuildArgs>;\nexport default command;\n","type":2},{"name":"node_modules/@dojo/cli-build-webpack/plugins/CoreLoadPlugin.d.ts","text":"import Compiler = require('webpack/lib/Compiler');\n/**\n * An object of chunk names and regular expressions. If the requested resource matches the RegExp, the chunk name\n * will be used.\n */\nexport interface DojoLoadChunkNames {\n    [key: string]: RegExp;\n}\n/**\n * Options for the DojoLoadPlugin\n */\nexport interface DojoLoadPluginOptions {\n    basePath?: string;\n    chunkNames?: DojoLoadChunkNames;\n    detectLazyLoads?: boolean;\n    ignoredModules?: string[];\n    mapAppModules?: boolean;\n}\n/**\n * A webpack plugin that forces webpack to ignore `require` passed as a value, and replaces `@dojo/core/load` with a\n * custom function that maps string module IDs to webpack's numerical module IDs.\n */\nexport default class DojoLoadPlugin {\n    private _basePath;\n    private _detectLazyLoads;\n    private _ignoredModules;\n    private _lazyChunkNames;\n    private _mapAppModules;\n    constructor(options?: DojoLoadPluginOptions);\n    /**\n     * Set up event listeners on the compiler and compilation. Register any module that uses a contextual require,\n     * replace use of `@dojo/core/load` with a custom load module, passing it a map of all dynamically-required\n     * module IDs.\n     *\n     * @param compiler\n     * The compiler instance.\n     */\n    apply(compiler: Compiler): void;\n}\n","type":2},{"name":"node_modules/@dojo/cli-build-webpack/plugins/I18nPlugin.d.ts","text":"import Compiler = require('webpack/lib/Compiler');\nexport interface DojoI18nPluginOptions {\n    /**\n     * Indicates whether parsed CLDR URLs should be cached for application to subsequent builds. Since the parser relies on the\n     * modules passed to it, and since the webpack dev server only rebuilds from changed modules, setting this to `true` prevents\n     * CLDR data from being removed on subsequent builds. Defaults to false. This should only be set when building with the\n     * `watch` flag.\n     */\n    cacheCldrUrls?: boolean;\n    /**\n     * The default locale to use as a fallback when the system locale is unsupported. Assumed to correspond to the\n     * default messages in any message bundles.\n     */\n    defaultLocale: string;\n    /**\n     * A list of message bundle paths. Messages for all supported locales will be included in the build.\n     * Unless the message bundle paths have an extension, a `ts` extension is assumed.\n     */\n    messageBundles?: string[];\n    /**\n     * The locales whose CLDR data and messages will be included in the main build.\n     */\n    supportedLocales?: string[];\n}\n/**\n * A webpack plugin that ensures CLDR data and locale-specific messages are available to webpack.\n */\nexport default class DojoI18nPlugin {\n    private _cldrUrls;\n    defaultLocale: string;\n    messageBundles?: string[];\n    supportedLocales?: string[];\n    constructor(options: DojoI18nPluginOptions);\n    /**\n     * Add messages and CLDR data to the build, and replace `@dojo/i18n/cldr/load` with a webpack-specific\n     * load module.\n     *\n     * @param compiler\n     * The current compiler.\n     */\n    apply(compiler: Compiler): void;\n    /**\n     * @protected\n     * Returns a merged array of supported locales.\n     */\n    protected _getLocales(this: DojoI18nPlugin): string[];\n}\n","type":2},{"name":"node_modules/@dojo/cli-build-webpack/plugins/IgnoreUnmodifiedPlugin.d.ts","text":"import Compiler = require('webpack/lib/Compiler');\nexport declare class IgnoreUnmodifiedPlugin {\n    apply(compiler: Compiler): void;\n}\nexport default IgnoreUnmodifiedPlugin;\n","type":2},{"name":"node_modules/@dojo/cli-build-webpack/plugins/InjectModulesPlugin.d.ts","text":"import NormalModule = require('webpack/lib/NormalModule');\nimport NormalModuleFactory = require('webpack/lib/NormalModuleFactory');\nimport Chunk = require('webpack/lib/Chunk');\nimport Compiler = require('webpack/lib/Compiler');\nimport Compilation = require('webpack/lib/Compilation');\nimport Map from '@dojo/shim/Map';\nimport '@dojo/shim/Promise';\nexport interface InjectModulesPluginOptions {\n    /**\n     * An optional base path for the injected modules. If not provided, defaults to the `resolve.root` option.\n     * If `resolve.root` is an array, then the first path is used. If there is no `resolve.root`, then\n     * `${process.cwd()}/node_modules/` is used.\n     */\n    context?: string;\n    /**\n     * The IDs for modules that should be injected into the build. If an array is provided, then the plugin's\n     * `context` is used as the context. An object of contexts to module IDs can also be provided. IDs can be\n     * either relative or absolute. If an ID is relative, then it will be resolved relative to the issuer; if\n     * absolute, it will be resolved relative to the context.\n     */\n    moduleIds: ModuleIds;\n    /**\n     * The regular expression that matches module paths to determine whether the specified module IDs should\n     * be injected into the relevant chunk(s).\n     */\n    resourcePattern: RegExp;\n}\nexport declare type ModuleIds = string[] | {\n    [basePath: string]: string[];\n};\n/**\n * A webpack plugin that injects arbitrary modules into the relevant build chunks if a module matching a specified\n * pattern is included somewhere in the current module hierarchy.\n */\nexport default class InjectModulesPlugin {\n    protected _added: string[];\n    protected _modules: Map<string, NormalModule>;\n    context?: string;\n    moduleIds: ModuleIds;\n    resourcePattern: RegExp;\n    constructor(options: InjectModulesPluginOptions);\n    /**\n     * Set up the compiler and compilation event listeners.\n     *\n     * @param compiler\n     * The compiler instance.\n     */\n    apply(compiler: Compiler): void;\n    /**\n     * Generate and build the module instances, and then inject them into the current compilation.\n     *\n     * @param data\n     * An array of resolved request data used to generate the module object.\n     *\n     * @param compilation\n     * The current compilation.\n     *\n     * @return\n     * A promise that resolves once all modules have been built.\n     */\n    createModules(data: NormalModuleFactory.AfterData[], compilation: Compilation): Promise<void[]>;\n    injectModuleDependencies(module: NormalModule, chunk: Chunk): void;\n    /**\n     * Resolve the request data for all modules injected for the specified resource.\n     *\n     * @param resource\n     * The context for the injected modules.\n     *\n     * @param resolver\n     * The resolver function.\n     *\n     * @return\n     * A promise that resolves to the request data for the injected modules.\n     */\n    resolve(resource: string, resolver: NormalModuleFactory.Resolver): Promise<NormalModuleFactory.AfterData[]>;\n}\n","type":2},{"name":"node_modules/@dojo/cli-build-webpack/plugins/util/i18n.d.ts","text":"import { Program } from 'estree';\n/**\n * Return an array of URLs that are passed as arguments to `@dojo/i18n/cldr/load.default` in the specified AST program\n * and with the specified import variable names.\n *\n * @param ast\n * An AST program to parse\n *\n * @param importNames\n * The variables name(s) in the AST program that represent the `@dojo/i18n/cldr/load.default` function.\n * In the overwhelming majority of use cases, there will only be one.\n *\n * @return\n * An array of containing all the string URLs that were passed to the cldr/load function.\n */\nexport declare const getLoadCallUrls: (program: Program, importNames: string[]) => string[];\n/**\n * Return an array of variable names for `@dojo/i18n/cldr/load` imports.\n *\n * @param ast\n * An AST program to parse.\n *\n * @return\n * A list of variable names.\n */\nexport declare function getLoadImports(ast: Program): string[];\n/**\n * Parse an AST program for all URLs passed to `@dojo/i18n/cldr/load`.\n *\n * Note that `@dojo/i18n/cldr/load` must be loaded with `require` for it to be recognized.\n * URLs can be injected as an array either directly to cldr/load function, or via a variable that is defined within\n * the same program. If a variable is used, then its definition MUST be a straightforward array expression:\n * `const cldrUrls = [ ... ]`. More complex operatiions will not be registered (for example:\n * `const supplemental = [ 'likelySubtags' ].map(name => `cldr-data/supplemental/${name}.json`).\n *\n * @param ast\n * An AST program\n *\n * @return\n * An array of any URLs parsed from calls to `@dojo/i18n/cldr/load.default`.\n */\nexport default function getCldrUrls(context: string, ast: Program): string[];\n","type":2},{"name":"node_modules/@dojo/cli-build-webpack/plugins/util/main.d.ts","text":"/**\n * Creates a regular expression from a string that can match a file path regardless of the path separator.\n *\n * @param pattern A regular expression string that matches a file path pattern.\n *\n * @return A regular expression that matches a file path pattern.\n */\nexport declare function createFilePathRegExp(pattern: string): RegExp;\n/**\n * Strips the module name from the provided path.\n *\n * @param context\n * The context module path.\n *\n * @return\n * The base path.\n */\nexport declare function getBasePath(context: string): string;\n/**\n * Tests a file path for the presence of an extension. Note that the test only accounts for alphanumeric extensions.\n *\n * @param path\n * The file path to test.\n *\n * @return\n * `true` if the file path has an extension; `false` otherwise.\n */\nexport declare function hasExtension(path: string): boolean;\n/**\n * Add any unique strings from the second array into the first array.\n *\n * @param left\n * An array to merge values into.\n *\n * @param right\n * An array with values to merge into the first array.\n *\n * @return\n * A new array containing all unique values from both input arrays.\n */\nexport declare function mergeUnique(left: string[], right: string[]): string[];\n/**\n * Test whether a module ID is relative or absolute.\n *\n * @param id\n * The module ID.\n *\n * @return\n * `true` if the path is relative; `false` otherwise.\n */\nexport declare function isRelative(id: string): boolean;\n/**\n * Resolve a module ID to its absolute file path.\n *\n * @param mid\n * The module ID to resolve.\n *\n * @return\n * The resolved module file path.\n */\nexport declare function resolveMid(mid: string): string;\n","type":2},{"name":"node_modules/@dojo/cli-build-webpack/plugins/util/parser.d.ts","text":"import { ArrayExpression, BaseFunction, Node } from 'estree';\n/**\n * If the provided node is an array expression, then return an array containing its values.\n * @private\n *\n * @param item An AST node\n * @return An array of values if the node is an array expression; otherwise, `undefined`.\n */\nexport declare function extractArrayValues(item: any): any[] | undefined;\n/**\n * Return a parent node's child node, if it exists.\n *\n * @param item The parent node.\n * @return The child node, if it exists.\n */\nexport declare const getNextItem: (item: Node) => Node | null;\n/**\n * Determine whether the provided node is an array expression.\n * @private\n *\n * @param item The node to test.\n * @return `true` if the item is an array expression; false otherwise.\n */\nexport declare function isArrayExpression(item: any): item is ArrayExpression;\n/**\n * Determine whether the provided node is a function declaration.\n * @private\n *\n * @param item The item to test.\n * @return `true` if the node represents either function declaration or a function expression.\n */\nexport declare function isFunctionDefinition(item: any): item is BaseFunction;\n/**\n * Determine whether the specified node is shadowing any of the specified variable names.\n * @private\n *\n * @param item The node to test\n * @param importNames A list of variable names.\n * @return `true` if the node is a shadowing node\n */\nexport declare function isShadowing(item: Node, importNames: string[]): boolean;\n","type":2},{"name":"node_modules/@dojo/cli-build-webpack/postcss.config.d.ts","text":"","type":2},{"name":"node_modules/@dojo/cli-build-webpack/templates/custom-element.d.ts","text":"declare const registerCustomElement: any;\ndeclare const widgetFactory: any;\n","type":2},{"name":"node_modules/@dojo/cli-build-webpack/webpack.config.d.ts","text":"","type":2},{"name":"node_modules/@dojo/cli-build-webpack/webpack.d.ts","text":"declare module 'tapable' {\n\tclass Tapable {\n\t\tprotected _plugins: { [key: string]: Function[] };\n\n\t\tapply(...args: any[]): void;\n\t\tplugin(name: string | string[], fn: Function): void;\n\n\t\tprotected applyPlugins(name: string, ...args: any[]): void;\n\t\tprotected applyPluginsWaterfall(name: string, initial: any, ...args: any[]): any;\n\t\tprotected applyPluginsAsync(name: string, ...args: any[]): void;\n\t\tprotected applyPluginsBailResult(name: string, ...args: any[]): any;\n\t\tprotected applyPluginsAsyncWaterfall(name: string, initial: any, callback: (error: Error | null, value: any) => void): void;\n\t\tprotected applyPluginsAsyncSeries(name: string, ...args: any[]): void;\n\t\tprotected applyPluginsAsyncSeriesBailResult(name: string, ...args: any[]): void;\n\t\tprotected applyPluginsParallel(name: string, ...args: any[]): void;\n\t\tprotected applyPluginsParallelBailResult(name: string, ...args: any[]): void;\n\t}\n\texport = Tapable;\n}\n\ndeclare module 'webpack-sources/lib/ConcatSource' {\n\timport Source = require('webpack-sources/lib/Source');\n\timport sourceMap = require('source-map');\n\n\tclass ConcatSource extends Source {\n\t\tconstructor(...children: (string | Source)[]);\n\n\t\tadd(child: string | Source): void;\n\t\tnode(options: Source.Options): sourceMap.SourceNode;\n\t}\n\n\texport = ConcatSource;\n}\n\ndeclare module 'webpack-sources/lib/Source' {\n\timport * as crypto from 'crypto';\n\n\tabstract class Source {\n\t\tmap(options: Source.Options): string;\n\t\tsize(): number;\n\t\tsource(): string;\n\t\tsourceAndMap(options: Source.Options): { code: string; map: any; };\n\t\tupdateHash(hash: crypto.Hash): void;\n\t}\n\n\tnamespace Source {\n\t\tinterface Options {\n\t\t\tcolumns?: boolean;\n\t\t\tmodule?: boolean;\n\t\t}\n\t}\n\n\texport = Source;\n}\n\ndeclare module 'webpack' {\n\timport webpack = require('webpack/lib/webpack');\n\n\texport = webpack;\n}\n\ndeclare module 'webpack/lib/webpack' {\n\timport WebpackBannerPlugin = require('webpack/lib/BannerPlugin');\n\timport WebpackCompiler = require('webpack/lib/Compiler');\n\timport WebpackContextReplacementPlugin = require('webpack/lib/ContextReplacementPlugin');\n\timport WebpackNormalModuleReplacementPlugin = require('webpack/lib/NormalModuleReplacementPlugin');\n\timport WebpackCommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');\n\timport WebpackUglifyJsPlugin = require('webpack/lib/optimize/UglifyJsPlugin');\n\n\tfunction webpack(options: webpack.Config, callback?: Function): WebpackCompiler;\n\n\tnamespace webpack {\n\t\texport type BannerPlugin = WebpackBannerPlugin;\n\t\texport type Compiler = WebpackCompiler;\n\t\texport type ContextReplacementPlugin = WebpackContextReplacementPlugin;\n\t\texport type NormalModuleReplacementPlugin = WebpackNormalModuleReplacementPlugin;\n\t\texport const BannerPlugin: typeof WebpackBannerPlugin;\n\t\texport const Compiler: typeof WebpackCompiler;\n\t\texport const ContextReplacementPlugin: typeof WebpackContextReplacementPlugin;\n\t\texport const NormalModuleReplacementPlugin: typeof WebpackNormalModuleReplacementPlugin;\n\n\t\tnamespace optimize {\n\t\t\ttype CommonsChunkPlugin = WebpackCommonsChunkPlugin;\n\t\t\ttype UglifyJsPlugin = WebpackUglifyJsPlugin;\n\t\t\texport const CommonsChunkPlugin: typeof WebpackCommonsChunkPlugin;\n\t\t\texport const UglifyJsPlugin: typeof WebpackUglifyJsPlugin;\n\t\t}\n\n\t\ttype Condition = _Condition | _Condition[];\n\t\ttype _Condition = string | RegExp | ConditionFunction | ConditionObject;\n\t\ttype ConditionFunction = (input: string) => boolean;\n\t\tinterface ConditionObject {\n\t\t\tand?: _Condition[];\n\t\t\texclude?: Condition;\n\t\t\tinclude?: Condition;\n\t\t\tnot?: _Condition;\n\t\t\tor?: _Condition[];\n\t\t\ttest?: Condition;\n\t\t}\n\n\t\tinterface Node {\n\t\t\tconsole?: boolean | 'mock';\n\t\t\tglobal?: boolean;\n\t\t\tprocess?: boolean;\n\t\t\t__filename?: boolean | 'mock';\n\t\t\t__dirname?: boolean | 'mock';\n\t\t\tBuffer?: boolean | 'mock';\n\t\t\tsetImmediate?: boolean | 'mock' | 'empty';\n\t\t\t[moduleName: string]: boolean | 'empty' | 'mock' | undefined;\n\t\t}\n\n\t\tinterface Config {\n\t\t\tentry: string | string[] | { [key: string]: string | string[] };\n\t\t\toutput: Output;\n\t\t\tmodule: Module;\n\t\t\tnode?: Node | false;\n\t\t\tresolve?: Resolve;\n\t\t\tresolveLoader?: {\n\t\t\t\tmodules?: string[];\n\t\t\t\textensions?: string[];\n\t\t\t\tpackageMains?: string[];\n\t\t\t\tmoduleExtensions?: string[];\n\t\t\t};\n\t\t\tdevtool?: false | 'eval' | 'cheap-eval-source-map' | 'cheap-source-map' | 'cheap-module-eval-source-map' | 'cheap-module-source-map' | 'eval-source-map' | 'source-map' | 'nosources-source-map' | 'inline-source-map' | 'hidden-source-map';\n\t\t\tcontext?: string;\n\t\t\ttarget?: 'async-node' | 'electron-main' | 'electron-renderer' | 'node' | 'node-webkit' | 'web' | 'webworker';\n\t\t\texternals?: { [key: string]: string | string[] | Object } | ((context: string, request: string, callback: Function) => void)[];\n\t\t\tstats?: Stats;\n\t\t\tplugins?: Plugin[];\n\t\t\tprofile?: boolean;\n\t\t}\n\t\ttype DevtoolFilenameTemplateFunction = (info: DevtoolFilenameTemplateInfo) => string;\n\t\tinterface DevtoolFilenameTemplateInfo {\n\t\t\tabsoluteResourcePath: string;\n\t\t\tallLoaders: string;\n\t\t\thash: string;\n\t\t\tid: string;\n\t\t\tloaders: string;\n\t\t\tresource: string;\n\t\t\tresourcePath: string;\n\t\t}\n\t\tinterface LoaderContext {\n\t\t\tversion: number;\n\t\t\tcontext: string;\n\t\t\trequest: string;\n\t\t\tquery: string;\n\t\t\tdata: any;\n\t\t\tloaders: any[];\n\t\t\tloaderIndex: number;\n\t\t\tresource: string;\n\t\t\tresourcePath: string;\n\t\t\tvalue: any;\n\t\t\tinputValue: any;\n\t\t\toptions: any;\n\t\t\tdebug: boolean;\n\t\t\tminimize: boolean;\n\t\t\tsourceMap: boolean;\n\t\t\ttarget: string;\n\t\t\twebpack: boolean;\n\n\t\t\tasync(): (error?: Error | null, content?: string | Buffer, sourceMap?: any) => void;\n\t\t\tcacheable(flag?: boolean): void;\n\t\t\temitWarning(warning: string): void;\n\t\t\temitError(error: string): void;\n\t\t\texec(code: string, filename: string): void;\n\t\t\tresolve(context: string, request: string, callback: (error?: Error | null, result?: string) => void): void;\n\t\t\taddDependency(file: string): void;\n\t\t\tdependency(file: string): void;\n\t\t\taddContextDependency(directory: string): void;\n\t\t\tclearDependencies(): void;\n\t\t\temitFile(name: string, content: String | Buffer, sourceMap: any): void;\n\t\t}\n\t\tinterface Module {\n\t\t\trules: Rule[];\n\t\t}\n\t\tinterface Output {\n\t\t\tpath: string;\n\t\t\tfilename: string;\n\t\t\tpublicPath?: string;\n\t\t\tlibrary?: string;\n\t\t\tlibraryTarget?: 'var' |\t'this' | 'window' | 'global' | 'commonjs' | 'commonjs2' | 'commonjs-module' | 'amd' | 'umd' | 'assign' | 'jsonp';\n\t\t\tpathinfo?: boolean;\n\t\t\tchunkFilename?: string;\n\t\t\tjsonpFunction?: string;\n\t\t\tsourceMapFilename?: string;\n\t\t\tdevtoolModuleFilenameTemplate?: string | DevtoolFilenameTemplateFunction;\n\t\t\tdevtoolFallbackModuleFilenameTemplate?: string | DevtoolFilenameTemplateFunction;\n\t\t\tumdNamedDefine?: boolean;\n\t\t\tcrossOriginLoading?: boolean | 'anonymous' | 'use-credentials';\n\t\t}\n\t\tinterface Plugin {\n\t\t\tapply(compiler?: WebpackCompiler): void;\n\t\t}\n\t\tinterface Resolve {\n\t\t\talias?: { [key: string]: string; };\n\t\t\taliasFields?: string[];\n\t\t\tcachePredicate?: (info: { path: string; request: string; }) => boolean;\n\t\t\tdescriptionFiles?: string[];\n\t\t\tenforceExtension?: boolean;\n\t\t\tenforceModuleExtension?: boolean;\n\t\t\textensions?: string[];\n\t\t\tmainFields?: string[];\n\t\t\tmainFiles?: string[];\n\t\t\tmodules?: string[];\n\t\t\tplugins?: any[];\n\t\t\tsymlinks?: boolean;\n\t\t\tunsafeCache?: boolean | RegExp | RegExp[];\n\t\t}\n\t\tinterface Rule {\n\t\t\tenforce?: 'pre' | 'post';\n\t\t\texclude?: Condition;\n\t\t\tinclude?: Condition;\n\t\t\tissuer?: _Condition;\n\t\t\tloader?: string;\n\t\t\tloaders?: (string | UseEntry)[];\n\t\t\toneOf?: Rule[];\n\t\t\toptions?: string | Object;\n\t\t\tresource?: _Condition;\n\t\t\trules?: Rule[];\n\t\t\ttest?: Condition;\n\t\t\tuse?: (string | UseEntry)[];\n\t\t}\n\t\ttype Stats = boolean | 'errors-only' | 'minimal' | 'none' | 'normal' | 'verbose' | StatsOptions;\n\t\tinterface StatsOptions {\n\t\t\tassets?: boolean;\n\t\t\tassetsSort?: string;\n\t\t\tcached?: boolean;\n\t\t\tchildren?: boolean;\n\t\t\tchunks?: boolean;\n\t\t\tchunkModules?: boolean;\n\t\t\tchunkOrigins?: boolean;\n\t\t\tchunksSort?: string;\n\t\t\tcontext?: string;\n\t\t\tcolors?: boolean;\n\t\t\terrors?: boolean;\n\t\t\terrorDetails?: boolean;\n\t\t\thash?: boolean;\n\t\t\tmodules?: boolean;\n\t\t\tmodulesSort?: string;\n\t\t\tpublicPath?: boolean;\n\t\t\treasons?: boolean;\n\t\t\tsource?: boolean;\n\t\t\ttimings?: boolean;\n\t\t\tversion?: boolean;\n\t\t\twarnings?: boolean;\n\t\t}\n\t\tinterface UseEntry {\n\t\t\tloader: string;\n\t\t\toptions?: string | Object;\n\t\t}\n\t}\n\n\texport = webpack;\n}\n\ndeclare module 'webpack/lib/dependencies/ConstDependency' {\n\timport NullDependency = require('webpack/lib/dependencies/NullDependency');\n\n\tclass ConstDependencyTemplate {\n\t\tapply(dep: any, source: any): void;\n\t}\n\n\tclass ConstDependency extends NullDependency {\n\t\tconstructor(expression?: any, range?: [number, number]);\n\n\t\tpublic expression?: any;\n\t\tpublic loc?: any;\n\t\tpublic range?: [number, number];\n\n\t\tupdateHash(hash: any): void;\n\n\t\tstatic Template: typeof ConstDependencyTemplate;\n\t}\n\n\texport = ConstDependency;\n}\n\ndeclare module 'webpack/lib/dependencies/NullDependency' {\n\timport Dependency = require('webpack/lib/Dependency');\n\n\tclass NullDependencyTemplate {\n\t\tapply(dep: any, source: any): void;\n\t}\n\n\tclass NullDependency extends Dependency {\n\t\treadonly type: string;\n\t\tisEqualResource(): boolean;\n\t\tupdateHash(hash: any): void;\n\t\tstatic Template: typeof NullDependencyTemplate;\n\t}\n\n\texport = NullDependency;\n}\n\ndeclare module 'webpack/lib/BannerPlugin' {\n\timport webpack = require('webpack');\n\n\tinterface BannerOptions {\n\t\tbanner: string;\n\t\tentryOnly: boolean;\n\t\texclude: string | RegExp | (string | RegExp)[];\n\t\tinclude: string | RegExp | (string | RegExp)[];\n\t\traw: boolean;\n\t\ttest: string | RegExp | (string | RegExp)[];\n\t}\n\n\tclass BannerPlugin implements webpack.Plugin {\n\t\tconstructor(options: string | BannerOptions);\n\t\tapply(compiler: webpack.Compiler): void;\n\t}\n\texport = BannerPlugin;\n}\n\ndeclare module 'webpack/lib/Chunk' {\n\timport Module = require('webpack/lib/Module');\n\timport DependenciesBlock = require('webpack/lib/DependenciesBlock');\n\n\tclass Chunk {\n\t\tid: number;\n\t\tids: number[];\n\t\tdebugId: number;\n\t\tname: string;\n\t\tmodules: Module[];\n\t\tchunks: Chunk[];\n\t\tparents: Chunk[];\n\t\tblocks: DependenciesBlock[];\n\t\torigins: Chunk.Origin[];\n\t\tfiles: any[];\n\t\trendered: boolean;\n\n\t\tconstructor(name: string, module: Module, loc: any);\n\n\t\taddChunk(chunk: Chunk): boolean;\n\t\taddParent(chunk: Chunk): boolean;\n\t\thasRuntime(): boolean;\n\t\tisInitial(): boolean;\n\t\thasEntryModule(): boolean;\n\t\taddModule(module: Module): boolean;\n\t\tremoveModule(module: Module): void;\n\t\tremoveChunk(chunk: Chunk): void;\n\t\tremoveParent(chunk: Chunk): void;\n\n\t\taddBlock(block: DependenciesBlock): boolean;\n\t\taddOrigin(origin: Chunk.Origin): void;\n\n\t\tremove(reason: string): void;\n\n\t\tmoveModule(module: Module, other: Chunk): void;\n\t}\n\n\tnamespace Chunk {\n\t\tinterface Origin {\n\t\t\tmodule: Module;\n\t\t\tloc: any;\n\t\t\tname: string;\n\t\t}\n\t}\n\n\texport = Chunk;\n}\n\ndeclare module 'webpack/lib/Compilation' {\n\timport Tapable = require('tapable');\n\timport MainTemplate = require('webpack/lib/MainTemplate');\n\timport Module = require('webpack/lib/Module');\n\timport Chunk = require('webpack/lib/Chunk');\n\timport Source = require('webpack-sources/lib/Source');\n\timport ModuleTemplate = require('webpack/lib/ModuleTemplate');\n\timport Compiler = require('webpack/lib/Compiler');\n\timport Dependency = require('webpack/lib/Dependency');\n\n\tclass Compilation extends Tapable {\n\t\tdependencyFactories: Map<typeof Dependency, any>;\n\t\tdependencyTemplates: Map<typeof Dependency, any>;\n\t\tmainTemplate: MainTemplate;\n\t\tmoduleTemplate: ModuleTemplate;\n\t\terrors?: Error[];\n\n\t\tconstructor(compiler: Compiler);\n\n\t\taddModule(module: Module, cacheGroup?: string): Module | boolean;\n\t\tbuildModule(module: Module, optional: boolean, origin: Module | null, dependencies: any[] | null, callback: (error?: Error) => void): void;\n\t\tprocessModuleDependencies(module: Module, callback: (error?: Error) => void): void;\n\n\t\tplugin(name: 'normal-module-loader', fn: (this: Compilation, loaderContext: any, module: Module) => void): void;\n\t\tplugin(name: 'seal', fn: (this: Compilation) => void): void;\n\t\tplugin(name: 'optimize', fn: (this: Compilation) => void): void;\n\t\tplugin(name: 'optimize-tree', fn: (this: Compilation, chunks: Chunk[], modules: Module[], callback: (error?: Error) => void) => void): void;\n\t\tplugin(name: 'optimize-modules', fn: (this: Compilation, modules: Module[]) => any): void;\n\t\tplugin(name: 'after-optimize-modules', fn: (this: Compilation, modules: Module[]) => void): void;\n\t\tplugin(name: 'optimize-chunks', fn: (this: Compilation, chunks: Chunk[]) => any): void;\n\t\tplugin(name: 'after-optimize-chunks', fn: (this: Compilation, chunks: Chunk[]) => void): void;\n\t\tplugin(name: 'revive-modules', fn: (this: Compilation, modules: Module[], records: any) => void): void;\n\t\tplugin(name: 'optimize-module-order', fn: (this: Compilation, modules: Module[]) => void): void;\n\t\tplugin(name: 'optimize-module-ids', fn: (this: Compilation, modules: Module[]) => void): void;\n\t\tplugin(name: 'after-optimize-module-ids', fn: (this: Compilation, modules: Module[]) => void): void;\n\t\tplugin(name: 'revive-chunks', fn: (this: Compilation, chunks: Chunk[], records: any) => void): void;\n\t\tplugin(name: 'optimize-chunk-order', fn: (this: Compilation, chunks: Chunk[]) => void): void;\n\t\tplugin(name: 'optimize-chunk-ids', fn: (this: Compilation, chunks: Chunk[]) => void): void;\n\t\tplugin(name: 'after-optimize-chunk-ids', fn: (this: Compilation, chunks: Chunk[]) => void): void;\n\t\tplugin(name: 'record-modules', fn: (this: Compilation, modules: Module[], records: any) => void): void;\n\t\tplugin(name: 'record-chunks', fn: (this: Compilation, chunks: Chunk[], records: any) => void): void;\n\t\tplugin(name: 'before-hash', fn: (this: Compilation) => void): void;\n\t\tplugin(name: 'after-hash', fn: (this: Compilation) => void): void;\n\t\tplugin(name: 'before-chunk-assets', fn: (this: Compilation) => void): void;\n\t\tplugin(name: 'additional-chunk-assets', fn: (this: Compilation, chunks: Chunk[]) => void): void;\n\t\tplugin(name: 'record', fn: (this: Compilation, compilation: Compilation, records: any) => void): void;\n\t\tplugin(name: 'optimize-chunk-assets', fn: (this: Compilation, chunks: Chunk[], callback: (error?: Error) => void) => void): void;\n\t\tplugin(name: 'after-optimize-chunk-assets', fn: (this: Compilation, chunks: Chunk[]) => void): void;\n\t\tplugin(name: 'optimize-assets', fn: (this: Compilation, assets: { [key: string]: Source }, callback: (error?: Error) => void) => void): void;\n\t\tplugin(name: 'after-optimize-assets', fn: (this: Compilation, assets: { [key: string]: Source }) => void): void;\n\t\tplugin(name: 'build-module', fn: (this: Compilation, module: Module) => void): void;\n\t\tplugin(name: 'succeed-module', fn: (this: Compilation, module: Module) => void): void;\n\t\tplugin(name: 'failed-module', fn: (this: Compilation, module: Module, error: Error) => void): void;\n\t\tplugin(name: 'module-asset', fn: (this: Compilation, module: Module, file: string) => void): void;\n\t\tplugin(name: 'chunk-asset', fn: (this: Compilation, chunk: Chunk, file: string) => void): void;\n\t\tplugin(name: 'need-additional-pass', fn: (this: Compilation) => boolean): void;\n\t}\n\n\texport = Compilation;\n}\n\ndeclare module 'webpack/lib/Compiler' {\n\timport Tapable = require('tapable');\n\timport webpack = require('webpack');\n\timport Compilation = require('webpack/lib/Compilation');\n\timport NormalModuleFactory = require('webpack/lib/NormalModuleFactory');\n\timport ContextModuleFactory = require('webpack/lib/ContextModuleFactory');\n\timport Dependency = require('webpack/lib/Dependency');\n\n\tclass Compiler extends Tapable {\n\t\toptions: any;\n\t\twatchFileSystem: any;\n\n\t\trun(callback: Compiler.Callback): void;\n\t\trunAsChild(callback: Compiler.Callback): void;\n\t\twatch(options: any, callback: Compiler.Callback): Compiler.Watching;\n\n\t\tplugin(name: 'watch-run', fn: (this: Compiler, compiler: Compiler) => void): void;\n\t\tplugin(name: 'done', fn: (this: Compiler, stats: any) => void): void;\n\t\tplugin(name: 'emit', fn: (this: Compiler, compilation: Compilation, callback: () => void) => void): void;\n\t\tplugin(name: 'falied', fn: (this: Compiler, error: Error) => void): void;\n\t\tplugin(name: 'invalid', fn: (this: Compiler) => void): void;\n\t\tplugin(name: 'run', fn: (this: Compiler, compiler: Compiler) => void): void;\n\t\tplugin(name: 'emit', fn: (this: Compiler, compilation: Compilation) => void): void;\n\t\tplugin(name: 'after-emit', fn: (this: Compiler, compilation: Compilation) => void): void;\n\t\tplugin(name: 'compilation', fn: (this: Compiler, compilation: Compilation, params: Compiler.CompilationParams) => void): void;\n\t\tplugin(name: 'normal-module-factory', fn: (this: Compiler, factory: NormalModuleFactory) => void): void;\n\t\tplugin(name: 'context-module-factory', fn: (this: Compiler, factory: ContextModuleFactory) => void): void;\n\t\tplugin(name: 'compile', fn: (this: Compiler, params: any) => void): void;\n\t\tplugin(name: 'make', fn: (this: Compiler, compilation: Compilation) => void): void;\n\t\tplugin(name: 'after-compile', fn: (this: Compiler, compilation: Compilation) => void): void;\n\t\tplugin(name: 'after-environment', fn: (this: Compiler) => void): void;\n\t}\n\n\tnamespace Compiler {\n\t\ttype Callback = (error?: Error | null, stats?: StatsObject) => void;\n\t\tinterface CompilationParams {\n\t\t\tnormalModuleFactory: NormalModuleFactory;\n\t\t\tcontextModuleFactory: ContextModuleFactory;\n\t\t\tcompilationDependencies: Dependency[];\n\t\t}\n\t\tinterface StatsObject {\n\t\t\thasErrors(): boolean;\n\t\t\thasWarnings(): boolean;\n\t\t\ttoJson(options?: webpack.Stats): {};\n\t\t\ttoString(options?: webpack.Stats): string;\n\t\t\tcompilation: Compilation;\n\t\t}\n\t\tclass Watching {\n\t\t\tclose(callback: () => void): void;\n\t\t\tinvalidate(): void;\n\t\t\twatch(files: any, dirs: any, missing: any): void;\n\t\t}\n\t}\n\n\texport = Compiler;\n}\n\ndeclare module 'webpack/lib/ContextModuleFactory' {\n\timport Tapable = require('tapable');\n\timport Parser = require('webpack/lib/Parser');\n\n\tclass ContextModuleFactory extends Tapable {\n\t\tplugin(name: 'parser', fn: (this: ContextModuleFactory, parser: Parser, options: any) => void): void;\n\t}\n\n\texport = ContextModuleFactory;\n}\n\ndeclare module 'webpack/lib/ContextReplacementPlugin' {\n\timport webpack = require('webpack');\n\n\tclass ContextReplacementPlugin implements webpack.Plugin {\n\t\tconstructor(resourceRegExp: RegExp, newContentResource?: any, newContentRecursive?: any, newContentRegExp?: any);\n\t\tapply(compiler: webpack.Compiler): void;\n\t}\n\texport = ContextReplacementPlugin;\n}\n\ndeclare module 'webpack/lib/DependenciesBlock' {\n\timport Dependency = require('webpack/lib/Dependency');\n\timport DependenciesBlockVariable = require('webpack/lib/DependenciesBlockVariable');\n\timport * as crypto from 'crypto';\n\n\tclass DependenciesBlock {\n\t\tdependencies: Dependency[];\n\t\tblocks: DependenciesBlock[];\n\t\tvariables: DependenciesBlockVariable[];\n\n\t\taddBlock(block: DependenciesBlock): void;\n\t\taddDependency(dependency: Dependency): void;\n\t\taddVariable(name: string, expression: string, dependencies?: Dependency[]): void;\n\t\tupdateHash(hash: crypto.Hash): void;\n\t\tdisconnect(): void;\n\t\tunseal(): void;\n\t\thasDependencies(filter: (dependency: Dependency) => boolean): boolean;\n\t\tsortItems(): void;\n\t}\n\texport = DependenciesBlock;\n}\n\ndeclare module 'webpack/lib/DependenciesBlockVariable' {\n\timport Dependency = require('webpack/lib/Dependency');\n\timport * as crypto from 'crypto';\n\n\tclass DependenciesBlockVariable {\n\t\tname: string;\n\t\texpression: string;\n\t\tdependencies: Dependency[];\n\n\t\tconstructor(name: string, expression: string, dependencies?: Dependency[]);\n\n\t\tupdateHash(hash: crypto.Hash): void;\n\t}\n\n\texport = DependenciesBlockVariable;\n}\n\ndeclare module 'webpack/lib/Dependency' {\n\timport Module = require('webpack/lib/Module');\n\timport * as crypto from 'crypto';\n\n\tclass Dependency {\n\t\tstatic compare(a: any, b: any): boolean;\n\n\t\tmodule: Module;\n\n\t\tisEqualResource(): boolean;\n\t\tgetReference(): { module: Module; importedNames: boolean; } | null;\n\t\tgetExports(): string[] | null;\n\t\tgetWarnings(): string[] | null;\n\t\tgetErrors(): string[] | null;\n\t\tupdateHash(hash: crypto.Hash): void;\n\t\tdisconnect(): void;\n\t\tcompare(a: any, b: any): boolean;\n\t}\n\texport = Dependency;\n}\n\ndeclare module 'webpack/lib/MainTemplate' {\n\tclass MainTemplate {\n\t\tplugin(name: string, fn: Function): void;\n\t}\n\texport = MainTemplate;\n}\n\ndeclare module 'webpack/lib/Module' {\n\timport DependenciesBlock = require('webpack/lib/DependenciesBlock');\n\timport Chunk = require('webpack/lib/Chunk');\n\n\tclass Module extends DependenciesBlock {\n\t\tcontext: any;\n\t\treasons: any[];\n\t\tdebugId: number;\n\t\tlastId: number;\n\t\tid: number;\n\t\tportableId: number;\n\t\tchunks: Chunk[];\n\t\tstrict: boolean;\n\t\tmeta: any;\n\n\t\taddChunk(chunk: Chunk): void;\n\t\tremoveChunk(chunk: Chunk): void;\n\t}\n\n\texport = Module;\n}\n\ndeclare module 'webpack/lib/ModuleTemplate' {\n\timport Template = require('webpack/lib/Template');\n\timport Module = require('webpack/lib/Module');\n\timport Chunk = require('webpack/lib/Chunk');\n\timport Source = require('webpack-sources/lib/Source');\n\timport * as crypto from 'crypto';\n\n\tclass ModuleTemplate extends Template {\n\t\tplugin(name: 'module', fn: (this: ModuleTemplate, moduleSource: Source, module: Module, chunk: Chunk, dependencyTemplates: Template[]) => Source): void;\n\t\tplugin(name: 'render', fn: (this: ModuleTemplate, moduleSource: Source, module: Module, chunk: Chunk, dependencyTemplates: Template[]) => Source): void;\n\t\tplugin(name: 'package', fn: (this: ModuleTemplate, moduleSource: Source, module: Module, chunk: Chunk, dependencyTemplates: Template[]) => Source): void;\n\t\tplugin(name: 'hash', fn: (this: ModuleTemplate, hash: crypto.Hash) => void): void;\n\t}\n\n\texport = ModuleTemplate;\n}\n\ndeclare module 'webpack/lib/NormalModule' {\n\timport Module = require('webpack/lib/Module');\n\timport Parser = require('webpack/lib/Parser');\n\n\tclass NormalModule extends Module {\n\t\trequest: string;\n\t\tuserRequest: string;\n\t\trawRequest: string;\n\t\tparser: Parser;\n\t\tresource: string;\n\t\tcontext: any;\n\t\tloaders: string[];\n\n\t\tconstructor(request: string, userRequest: string, rawRequest: string, loaders: string[], resource: string, parser: Parser);\n\t}\n\n\texport = NormalModule;\n}\n\ndeclare module 'webpack/lib/NormalModuleReplacementPlugin' {\n\timport webpack = require('webpack');\n\timport NormalModuleFactory = require('webpack/lib/NormalModuleFactory');\n\n\tclass NormalModuleReplacementPlugin implements webpack.Plugin {\n\t\tconstructor(resourceRegExp: RegExp, newResource: string | NormalModuleReplacementPlugin.ResourceCallback);\n\n\t\tapply(compiler: webpack.Compiler): void;\n\t}\n\n\tnamespace NormalModuleReplacementPlugin {\n\t\ttype ResourceCallback = (resource: NormalModuleFactory.BeforeData) => void;\n\t}\n\n\texport = NormalModuleReplacementPlugin;\n}\n\ndeclare module 'webpack/lib/NormalModuleFactory' {\n\timport Tapable = require('tapable');\n\timport Parser = require('webpack/lib/Parser');\n\timport Dependency = require('webpack/lib/Dependency');\n\n\tclass NormalModuleFactory extends Tapable {\n\t\tplugin(name: 'after-resolve', fn: NormalModuleFactory.AfterHandler): void;\n\t\tplugin(name: 'before-resolve', fn: NormalModuleFactory.BeforeHandler): void;\n\t\tplugin(name: 'parser', fn: (this: NormalModuleFactory, parser: Parser, options: any) => void): void;\n\t\tplugin(name: 'resolver', fn: (this: NormalModuleFactory, resolver: NormalModuleFactory.Resolver) => NormalModuleFactory.Resolver): void;\n\t}\n\tnamespace NormalModuleFactory {\n\t\tinterface BeforeData {\n\t\t\tcontextInfo?: any;\n\t\t\tcontext: string;\n\t\t\tdependencies?: Dependency[];\n\t\t\trequest: string;\n\t\t}\n\n\t\ttype BeforeHandler = (this: NormalModuleFactory, current: BeforeData, callback: Callback<BeforeData>) => void;\n\n\t\ttype Callback<T> = (error?: Error | null, nextValue?: T) => void;\n\n\t\tinterface AfterData {\n\t\t\tcontext: string;\n\t\t\trequest: string;\n\t\t\tuserRequest: string;\n\t\t\trawRequest: string;\n\t\t\tloaders: string[];\n\t\t\tresource: string;\n\t\t\tparser: Parser;\n\t\t}\n\n\t\ttype AfterHandler = (this: NormalModuleFactory, current: AfterData, callback: Callback<AfterData>) => void;\n\n\t\ttype Resolver = (data: BeforeData, callback: ResolverCallback) => void;\n\t\ttype ResolverCallback = (error?: Error | null, value?: AfterData) => void;\n\t}\n\n\texport = NormalModuleFactory;\n}\n\ndeclare module 'webpack/lib/NullFactory' {\n\tclass NullFactory {\n\t\tcreate(data: any, callback: () => void): void;\n\t}\n\n\texport = NullFactory;\n}\n\ndeclare module 'webpack/lib/Parser' {\n\timport Tapable = require('tapable');\n\timport NormalModule = require('webpack/lib/NormalModule');\n\timport Module = require('webpack/lib/Module');\n\timport Compilation = require('webpack/lib/Compilation');\n\timport Dependency = require('webpack/lib/Dependency');\n\n\tclass Parser extends Tapable {\n\t\tstate: Parser.NormalModuleState | Parser.ParsedVariableState;\n\t\tplugin(name: string, fn: (this: Parser, ...args: any[]) => any): void;\n\t}\n\n\tnamespace Parser {\n\t\tinterface NormalModuleState {\n\t\t\tcurrent: NormalModule;\n\t\t\tmodule: NormalModule;\n\t\t\tcompilation: Compilation;\n\t\t\toptions: any;\n\t\t}\n\t\tinterface ParsedVariableState {\n\t\t\tcurrent: {\n\t\t\t\taddDependency(dependency: Dependency): void;\n\t\t\t};\n\t\t\tmodule: Module;\n\t\t}\n\t}\n\n\texport = Parser;\n}\n\ndeclare module 'webpack/lib/Template' {\n\timport Tapable = require('tapable');\n\n\tclass Template extends Tapable {\n\t\tconstructor(options: any);\n\t}\n\n\texport = Template;\n}\n\ndeclare module 'webpack/lib/optimize/CommonsChunkPlugin' {\n\timport webpack = require('webpack');\n\n\tclass CommonsChunkPlugin implements webpack.Plugin {\n\t\tconstructor(options: CommonsChunkPlugin.Options);\n\t\tapply(compiler: webpack.Compiler): void;\n\t}\n\tmodule CommonsChunkPlugin {\n\t\tinterface Options {\n\t\t\tname?: string;\n\t\t\tnames?: string[];\n\t\t\tfilename?: string;\n\t\t\tminChunks?: number | Function;\n\t\t\tchunks?: string[];\n\t\t\tchildren?: boolean;\n\t\t\tasync?: boolean | string;\n\t\t\tminSize?: number;\n\t\t}\n\t}\n\texport = CommonsChunkPlugin;\n}\n\ndeclare module 'webpack/lib/optimize/UglifyJsPlugin' {\n\timport webpack = require('webpack');\n\n\tclass UglifyJsPlugin implements webpack.Plugin {\n\t\tconstructor(options?: UglifyJsPlugin.Options);\n\t\tapply(compiler: webpack.Compiler): void;\n\t}\n\tmodule UglifyJsPlugin {\n\t\ttype CommentCallback = (astNode: any, comment: any) => boolean;\n\t\tinterface Compress {\n\t\t\tsequences?: boolean;\n\t\t\tproperties?: boolean;\n\t\t\tdead_code?: boolean;\n\t\t\tdrop_debugger?: boolean;\n\t\t\tunsafe?: boolean;\n\t\t\tconditionals?: boolean;\n\t\t\tcomparisons?: boolean;\n\t\t\tevaluate?: boolean;\n\t\t\tbooleans?: boolean;\n\t\t\tloops?: boolean;\n\t\t\tunused?: boolean;\n\t\t\thoist_funs?: boolean;\n\t\t\thoist_vars?: boolean;\n\t\t\tif_return?: boolean;\n\t\t\tjoin_vars?: boolean;\n\t\t\tcascade?: boolean;\n\t\t\tside_effects?: boolean;\n\t\t\twarnings?: boolean;\n\t\t\tglobal_defs?: { [key: string]: boolean; };\n\t\t}\n\t\tinterface ExtractComments {\n\t\t\tcondition?: RegExp | string | CommentCallback;\n\t\t\tfilename?: string | ((original: string) => string);\n\t\t\tbanner?: false | string | ((original: string) => string);\n\t\t}\n\t\tinterface Mangle {\n\t\t\texcept?: string[];\n\t\t\ttoplevel?: boolean;\n\t\t\teval?: boolean;\n\t\t\tkeep_fnames?: boolean;\n\t\t}\n\t\tinterface Options {\n\t\t\tcompress?: boolean | Compress;\n\t\t\tmangle?: boolean | Mangle;\n\t\t\tbeautify?: boolean;\n\t\t\toutput?: Output;\n\t\t\tcomments?: boolean | RegExp | CommentCallback;\n\t\t\textractComments?: boolean | RegExp | string | CommentCallback | ExtractComments;\n\t\t\tsourceMap?: boolean;\n\t\t\ttest?: RegExp | RegExp[];\n\t\t\tinclude?: RegExp | RegExp[];\n\t\t\texclude?: RegExp | RegExp[];\n\t\t}\n\t\tinterface Output {\n\t\t\tindent_start?: number;\n\t\t\tindent_level?: number;\n\t\t\tquote_keys?: boolean;\n\t\t\tspace_colon?: boolean;\n\t\t\tascii_only?: boolean;\n\t\t\tunescape_regexps?: boolean;\n\t\t\tinline_script?: boolean;\n\t\t\twidth?: number;\n\t\t\tmax_line_length?: number;\n\t\t\tbeautify?: boolean;\n\t\t\tsource_map?: any | null;\n\t\t\tbracketize?: boolean;\n\t\t\tsemicolons?: boolean;\n\t\t\tcomments?: boolean;\n\t\t\tshebang?: boolean;\n\t\t\tpreserve_line?: boolean;\n\t\t\tscrew_ie8?: boolean;\n\t\t\tpreamble?: boolean;\n\t\t\tquote_style?: number;\n\t\t\tkeep_quoted_props?: boolean;\n\t\t\twrap_iife?: boolean;\n\t\t}\n\t}\n\texport = UglifyJsPlugin;\n}\n","type":2},{"name":"node_modules/@dojo/cli-export-project/exportProject.d.ts","text":"import * as resolveCwd from 'resolve-cwd';\nimport { ExportArgs } from './main';\nexport declare let requireResolve: typeof resolveCwd;\nexport declare type StringMap = {\n    [pkg: string]: string;\n};\n/**\n * An async function which resolves when a project bundle has been output for the specified path\n */\nexport default function exportProject({content, index, out, project: root, verbose: verboseFlag}: ExportArgs): Promise<void>;\n","type":2},{"name":"node_modules/@dojo/cli-export-project/interfaces/dojorc.d.ts","text":"export interface BuildWebpackJson {\n\t'locale'?: string;\n\t'messageBundles'?: string | string[];\n\t'supportedLocales'?: string | string[];\n\t'watch'?: boolean;\n\t'port'?: number;\n\t'element'?: string;\n\t'elementPrefix'?: string;\n\t'withTests'?: boolean;\n\t'debug'?: boolean;\n\t'disableLazyWidgetDetection'?: boolean;\n\t'bundles'?: { [bundle: string]: string[] };\n}\n\nexport interface DojoRcJson {\n\t'build-webpack'?: BuildWebpackJson;\n\t[k: string]: any;\n}\n","type":2},{"name":"node_modules/@dojo/cli-export-project/interfaces/interfaces.d.ts","text":"declare module 'resolve-cwd' {\n\tmodule resolve { }\n\tfunction resolve(path: string): string;\n\texport = resolve;\n}\n","type":2},{"name":"node_modules/@dojo/cli-export-project/interfaces/package.json.d.ts","text":"/**\n * A person who has been involved in creating or maintaining this package\n */\nexport interface Person {\n\t'name': string;\n\t'url'?: string;\n\t'email'?: string;\n\t[k: string]: any;\n}\nexport type ScriptsPublishAfter = string;\nexport type ScriptsInstallAfter = string;\nexport type ScriptsUninstallBefore = string;\nexport type ScriptsVersionBefore = string;\nexport type ScriptsTest = string;\nexport type ScriptsStop = string;\nexport type ScriptsStart = string;\nexport type ScriptsRestart = string;\n/**\n * Dependencies are specified with a simple hash of package name to version range. The version range is a string which has one or more space-separated descriptors. Dependencies can also be identified with a tarball or git URL.\n */\nexport interface Dependency {\n\t[k: string]: string;\n}\nexport interface CoreProperties {\n\t/**\n\t * The name of the package.\n\t */\n\t'name'?: string;\n\t/**\n\t * Version must be parseable by node-semver, which is bundled with npm as a dependency.\n\t */\n\t'version'?: string;\n\t/**\n\t * This helps people discover your package, as it's listed in 'npm search'.\n\t */\n\t'description'?: string;\n\t/**\n\t * This helps people discover your package as it's listed in 'npm search'.\n\t */\n\t'keywords'?: string[];\n\t/**\n\t * The url to the project homepage.\n\t */\n\t'homepage'?: string;\n\t/**\n\t * The url to your project's issue tracker and / or the email address to which issues should be reported. These are helpful for people who encounter issues with your package.\n\t */\n\t'bugs'?: {\n\t\t/**\n\t\t * The url to your project's issue tracker.\n\t\t */\n\t\t'url'?: string;\n\t\t/**\n\t\t * The email address to which issues should be reported.\n\t\t */\n\t\t'email'?: string;\n\t\t[k: string]: any;\n\t};\n\t/**\n\t * You should specify a license for your package so that people know how they are permitted to use it, and any restrictions you're placing on it.\n\t */\n\t'license'?: string;\n\t/**\n\t * You should specify a license for your package so that people know how they are permitted to use it, and any restrictions you're placing on it.\n\t */\n\t'licenses'?: {\n\t\t'type'?: string;\n\t\t'url'?: string;\n\t\t[k: string]: any;\n\t}[];\n\t/**\n\t * A person who has been involved in creating or maintaining this package\n\t */\n\t'author'?: Person;\n\t/**\n\t * A list of people who contributed to this package.\n\t */\n\t'contributors'?: Person[];\n\t/**\n\t * A list of people who maintains this package.\n\t */\n\t'maintainers'?: Person[];\n\t/**\n\t * The 'files' field is an array of files to include in your project. If you name a folder in the array, then it will also include the files inside that folder.\n\t */\n\t'files'?: string[];\n\t/**\n\t * The main field is a module ID that is the primary entry point to your program.\n\t */\n\t'main'?: string;\n\t'bin'?: {\n\t\t[k: string]: string;\n\t};\n\t/**\n\t * Specify either a single file or an array of filenames to put in place for the man program to find.\n\t */\n\t'man'?: any[] | string;\n\t'directories'?: {\n\t\t/**\n\t\t * If you specify a 'bin' directory, then all the files in that folder will be used as the 'bin' hash.\n\t\t */\n\t\t'bin'?: string;\n\t\t/**\n\t\t * Put markdown files in here. Eventually, these will be displayed nicely, maybe, someday.\n\t\t */\n\t\t'doc'?: string;\n\t\t/**\n\t\t * Put example scripts in here. Someday, it might be exposed in some clever way.\n\t\t */\n\t\t'example'?: string;\n\t\t/**\n\t\t * Tell people where the bulk of your library is. Nothing special is done with the lib folder in any way, but it's useful meta info.\n\t\t */\n\t\t'lib'?: string;\n\t\t/**\n\t\t * A folder that is full of man pages. Sugar to generate a 'man' array by walking the folder.\n\t\t */\n\t\t'man'?: string;\n\t\t'test'?: string;\n\t\t[k: string]: any;\n\t};\n\t/**\n\t * Specify the place where your code lives. This is helpful for people who want to contribute.\n\t */\n\t'repository'?: {\n\t\t'type'?: string;\n\t\t'url'?: string;\n\t\t[k: string]: any;\n\t};\n\t/**\n\t * The 'scripts' member is an object hash of script commands that are run at various times in the lifecycle of your package. The key is the lifecycle event, and the value is the command to run at that point.\n\t */\n\t'scripts'?: {\n\t\t/**\n\t\t * Run BEFORE the package is published (Also run on local npm install without any arguments)\n\t\t */\n\t\t'prepublish'?: string;\n\t\t/**\n\t\t * Run AFTER the package is published\n\t\t */\n\t\t'publish'?: ScriptsPublishAfter;\n\t\t/**\n\t\t * Run AFTER the package is published\n\t\t */\n\t\t'postpublish'?: ScriptsPublishAfter;\n\t\t/**\n\t\t * Run BEFORE the package is installed\n\t\t */\n\t\t'preinstall'?: string;\n\t\t/**\n\t\t * Run AFTER the package is installed\n\t\t */\n\t\t'install'?: ScriptsInstallAfter;\n\t\t/**\n\t\t * Run AFTER the package is installed\n\t\t */\n\t\t'postinstall'?: ScriptsInstallAfter;\n\t\t/**\n\t\t * Run BEFORE the package is uninstalled\n\t\t */\n\t\t'preuninstall'?: ScriptsUninstallBefore;\n\t\t/**\n\t\t * Run BEFORE the package is uninstalled\n\t\t */\n\t\t'uninstall'?: ScriptsUninstallBefore;\n\t\t/**\n\t\t * Run AFTER the package is uninstalled\n\t\t */\n\t\t'postuninstall'?: string;\n\t\t/**\n\t\t * Run BEFORE bump the package version\n\t\t */\n\t\t'preversion'?: ScriptsVersionBefore;\n\t\t/**\n\t\t * Run BEFORE bump the package version\n\t\t */\n\t\t'version'?: ScriptsVersionBefore;\n\t\t/**\n\t\t * Run AFTER bump the package version\n\t\t */\n\t\t'postversion'?: string;\n\t\t/**\n\t\t * Run by the 'npm test' command\n\t\t */\n\t\t'pretest'?: ScriptsTest;\n\t\t/**\n\t\t * Run by the 'npm test' command\n\t\t */\n\t\t'test'?: ScriptsTest;\n\t\t/**\n\t\t * Run by the 'npm test' command\n\t\t */\n\t\t'posttest'?: ScriptsTest;\n\t\t/**\n\t\t * Run by the 'npm stop' command\n\t\t */\n\t\t'prestop'?: ScriptsStop;\n\t\t/**\n\t\t * Run by the 'npm stop' command\n\t\t */\n\t\t'stop'?: ScriptsStop;\n\t\t/**\n\t\t * Run by the 'npm stop' command\n\t\t */\n\t\t'poststop'?: ScriptsStop;\n\t\t/**\n\t\t * Run by the 'npm start' command\n\t\t */\n\t\t'prestart'?: ScriptsStart;\n\t\t/**\n\t\t * Run by the 'npm start' command\n\t\t */\n\t\t'start'?: ScriptsStart;\n\t\t/**\n\t\t * Run by the 'npm start' command\n\t\t */\n\t\t'poststart'?: ScriptsStart;\n\t\t/**\n\t\t * Run by the 'npm restart' command. Note: 'npm restart' will run the stop and start scripts if no restart script is provided.\n\t\t */\n\t\t'prerestart'?: ScriptsRestart;\n\t\t/**\n\t\t * Run by the 'npm restart' command. Note: 'npm restart' will run the stop and start scripts if no restart script is provided.\n\t\t */\n\t\t'restart'?: ScriptsRestart;\n\t\t/**\n\t\t * Run by the 'npm restart' command. Note: 'npm restart' will run the stop and start scripts if no restart script is provided.\n\t\t */\n\t\t'postrestart'?: ScriptsRestart;\n\t\t[k: string]: string | undefined;\n\t};\n\t/**\n\t * A 'config' hash can be used to set configuration parameters used in package scripts that persist across upgrades.\n\t */\n\t'config'?: any;\n\t/**\n\t * Dependencies are specified with a simple hash of package name to version range. The version range is a string which has one or more space-separated descriptors. Dependencies can also be identified with a tarball or git URL.\n\t */\n\t'dependencies'?: Dependency;\n\t/**\n\t * Dependencies are specified with a simple hash of package name to version range. The version range is a string which has one or more space-separated descriptors. Dependencies can also be identified with a tarball or git URL.\n\t */\n\t'devDependencies'?: Dependency;\n\t/**\n\t * Dependencies are specified with a simple hash of package name to version range. The version range is a string which has one or more space-separated descriptors. Dependencies can also be identified with a tarball or git URL.\n\t */\n\t'optionalDependencies'?: Dependency;\n\t/**\n\t * Dependencies are specified with a simple hash of package name to version range. The version range is a string which has one or more space-separated descriptors. Dependencies can also be identified with a tarball or git URL.\n\t */\n\t'peerDependencies'?: Dependency;\n\t'engines'?: {\n\t\t[k: string]: string;\n\t};\n\t'engineStrict'?: boolean;\n\t/**\n\t * You can specify which operating systems your module will run on\n\t */\n\t'os'?: string[];\n\t/**\n\t * If your code only runs on certain cpu architectures, you can specify which ones.\n\t */\n\t'cpu'?: string[];\n\t/**\n\t * If your package is primarily a command-line application that should be installed globally, then set this value to true to provide a warning if it is installed locally.\n\t */\n\t'preferGlobal'?: boolean;\n\t/**\n\t * If set to true, then npm will refuse to publish it.\n\t */\n\t'private'?: boolean;\n\t'publishConfig'?: any;\n\t'dist'?: {\n\t\t'shasum'?: string;\n\t\t'tarball'?: string;\n\t\t[k: string]: any;\n\t};\n\t'readme'?: string;\n\t[k: string]: any;\n}\nexport interface JspmDefinition {\n\t'jspm'?: CoreProperties;\n\t[k: string]: any;\n}\nexport interface TypingsDefinition {\n\t'typings'?: string;\n\t'types'?: string;\n\t[k: string]: any;\n}\nexport type BundledDependency = string[];\nexport type JsonSchemaForNpmPackageJsonFiles = CoreProperties & JspmDefinition & TypingsDefinition & {\n\t/**\n\t * Array of package names that will be bundled when publishing the package.\n\t */\n\t'bundleDependencies'?: BundledDependency;\n\t[k: string]: any;\n};\n","type":2},{"name":"node_modules/@dojo/cli-export-project/interfaces/project.json.d.ts","text":"import { JsonSchemaForNpmPackageJsonFiles as PackageJson } from './package.json';\nimport { JsonSchemaForTheTypeScriptCompilersConfigurationFile as TsconfigJson } from './tsconfig.json';\nimport { JsonSchemaForTheTsLintConfigurationFiles as TslintJson } from './tslint.json';\nimport { DojoRcJson } from './dojorc';\n\nexport interface ProjectJson {\n\n\t/**\n\t * The package dependencies for the project, either `production` or `development`\n\t */\n\tdependencies: {\n\t\t/**\n\t\t * A map of production dependencies, where the package name is the key and the value is the semver of the package\n\t\t */\n\t\tproduction: {\n\t\t\t[pkg: string]: string;\n\t\t},\n\n\t\t/**\n\t\t * A map of development dependencies, where the package name is the key and the value is the semver of the package\n\t\t */\n\t\tdevelopment: {\n\t\t\t[pkg: string]: string;\n\t\t}\n\t};\n\n\t/**\n\t * The .dojorc for the project\n\t */\n\tdojorc?: DojoRcJson;\n\n\t/**\n\t * Files that are part of the environment but are not exposed for editing\n\t *\n\t * Typically these are TypeScript definition files and libraries that are needed\n\t * to provide context to edit and compile the project files\n\t */\n\tenvironmentFiles: ProjectFile[];\n\n\t/**\n\t * These are the editable project files\n\t */\n\tfiles: ProjectFile[];\n\n\t/**\n\t * The filename of the HTML document for the project to load when running it\n\t */\n\tindex: string;\n\n\t/**\n\t * The package.json for the project\n\t */\n\tpackage: PackageJson;\n\n\t/**\n\t * The tsconfig.json for the project\n\t */\n\ttsconfig: TsconfigJson;\n\n\t/**\n\t * The tslint.json for the project\n\t */\n\ttslint?: TslintJson;\n}\n\nexport interface ProjectFile {\n\ttype: ProjectFileType;\n\tname: string;\n\ttext: string;\n}\n\nexport const enum ProjectFileType {\n\tTypeScript = 1,\n\tDefinition,\n\tLib,\n\tJavaScript,\n\tCSS,\n\tHTML,\n\tMarkdown,\n\tJSON,\n\tXML,\n\tSourceMap,\n\tPlainText\n}\n","type":2},{"name":"node_modules/@dojo/cli-export-project/interfaces/tsconfig.json.d.ts","text":"export interface CompilerOptionsDefinition {\n\t/**\n\t * Instructs the TypeScript compiler how to compile .ts files.\n\t */\n\t'compilerOptions'?: {\n\t\t/**\n\t\t * The character set of the input files.\n\t\t */\n\t\t'charset'?: string;\n\t\t/**\n\t\t * Generates corresponding d.ts files.\n\t\t */\n\t\t'declaration'?: boolean;\n\t\t/**\n\t\t * Specify output directory for generated declaration files. Requires TypeScript version 2.0 or later.\n\t\t */\n\t\t'declarationDir'?: string;\n\t\t/**\n\t\t * Show diagnostic information.\n\t\t */\n\t\t'diagnostics'?: boolean;\n\t\t/**\n\t\t * Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.\n\t\t */\n\t\t'emitBOM'?: boolean;\n\t\t/**\n\t\t * Emit a single file with source maps instead of having a separate file.\n\t\t */\n\t\t'inlineSourceMap'?: boolean;\n\t\t/**\n\t\t * Emit the source alongside the sourcemaps within a single file; requires --inlineSourceMap to be set.\n\t\t */\n\t\t'inlineSources'?: boolean;\n\t\t/**\n\t\t * Specify JSX code generation: 'preserve', 'react', or 'react-native'.\n\t\t */\n\t\t'jsx'?: 'preserve' | 'react' | 'react-native';\n\t\t/**\n\t\t * Specifies the object invoked for createElement and __spread when targeting 'react' JSX emit.\n\t\t */\n\t\t'reactNamespace'?: string;\n\t\t/**\n\t\t * Print names of files part of the compilation.\n\t\t */\n\t\t'listFiles'?: boolean;\n\t\t/**\n\t\t * The locale to use to show error messages, e.g. en-us.\n\t\t */\n\t\t'locale'?: string;\n\t\t/**\n\t\t * Specifies the location where debugger should locate map files instead of generated locations\n\t\t */\n\t\t'mapRoot'?: string;\n\t\t/**\n\t\t * Specify module code generation: 'none', 'CommonJS', 'Amd', 'System', 'UMD', or 'es2015'.\n\t\t */\n\t\t'module'?: 'commonjs' | 'amd' | 'umd' | 'system' | 'es6' | 'es2015' | 'none';\n\t\t/**\n\t\t * Specifies the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix).\n\t\t */\n\t\t'newLine'?: 'CRLF' | 'LF';\n\t\t/**\n\t\t * Do not emit output.\n\t\t */\n\t\t'noEmit'?: boolean;\n\t\t/**\n\t\t * Do not generate custom helper functions like __extends in compiled output.\n\t\t */\n\t\t'noEmitHelpers'?: boolean;\n\t\t/**\n\t\t * Do not emit outputs if any type checking errors were reported.\n\t\t */\n\t\t'noEmitOnError'?: boolean;\n\t\t/**\n\t\t * Warn on expressions and declarations with an implied 'any' type.\n\t\t */\n\t\t'noImplicitAny'?: boolean;\n\t\t/**\n\t\t * Raise error on 'this' expressions with an implied any type.\n\t\t */\n\t\t'noImplicitThis'?: boolean;\n\t\t/**\n\t\t * Report errors on unused locals. Requires TypeScript version 2.0 or later.\n\t\t */\n\t\t'noUnusedLocals'?: boolean;\n\t\t/**\n\t\t * Report errors on unused parameters. Requires TypeScript version 2.0 or later.\n\t\t */\n\t\t'noUnusedParameters'?: boolean;\n\t\t/**\n\t\t * Do not include the default library file (lib.d.ts).\n\t\t */\n\t\t'noLib'?: boolean;\n\t\t/**\n\t\t * Do not add triple-slash references or module import targets to the list of compiled files.\n\t\t */\n\t\t'noResolve'?: boolean;\n\t\t'skipDefaultLibCheck'?: boolean;\n\t\t/**\n\t\t * Skip type checking of declaration files. Requires TypeScript version 2.0 or later.\n\t\t */\n\t\t'skipLibCheck'?: boolean;\n\t\t/**\n\t\t * Concatenate and emit output to single file.\n\t\t */\n\t\t'outFile'?: string;\n\t\t/**\n\t\t * Redirect output structure to the directory.\n\t\t */\n\t\t'outDir'?: string;\n\t\t/**\n\t\t * Do not erase const enum declarations in generated code.\n\t\t */\n\t\t'preserveConstEnums'?: boolean;\n\t\t/**\n\t\t * Stylize errors and messages using color and context (experimental).\n\t\t */\n\t\t'pretty'?: boolean;\n\t\t/**\n\t\t * Do not emit comments to output.\n\t\t */\n\t\t'removeComments'?: boolean;\n\t\t/**\n\t\t * Specifies the root directory of input files. Use to control the output directory structure with --outDir.\n\t\t */\n\t\t'rootDir'?: string;\n\t\t/**\n\t\t * Unconditionally emit imports for unresolved files.\n\t\t */\n\t\t'isolatedModules'?: boolean;\n\t\t/**\n\t\t * Generates corresponding '.map' file.\n\t\t */\n\t\t'sourceMap'?: boolean;\n\t\t/**\n\t\t * Specifies the location where debugger should locate TypeScript files instead of source locations.\n\t\t */\n\t\t'sourceRoot'?: string;\n\t\t/**\n\t\t * Suppress excess property checks for object literals.\n\t\t */\n\t\t'suppressExcessPropertyErrors'?: boolean;\n\t\t/**\n\t\t * Suppress noImplicitAny errors for indexing objects lacking index signatures.\n\t\t */\n\t\t'suppressImplicitAnyIndexErrors'?: boolean;\n\t\t/**\n\t\t * Do not emit declarations for code that has an '@internal' annotation.\n\t\t */\n\t\t'stripInternal'?: boolean;\n\t\t/**\n\t\t * Specify ECMAScript target version. Permitted values are 'es3', 'es5', 'es2015', 'es2016', 'es2017' or 'esnext'.\n\t\t */\n\t\t'target'?: 'es3' | 'es5' | 'es2015' | 'es2016' | 'es2017' | 'esnext' | any;\n\t\t/**\n\t\t * Watch input files.\n\t\t */\n\t\t'watch'?: boolean;\n\t\t/**\n\t\t * Enables experimental support for ES7 decorators.\n\t\t */\n\t\t'experimentalDecorators'?: boolean;\n\t\t/**\n\t\t * Emit design-type metadata for decorated declarations in source.\n\t\t */\n\t\t'emitDecoratorMetadata'?: boolean;\n\t\t/**\n\t\t * Specifies module resolution strategy: 'node' (Node) or 'classic' (TypeScript pre 1.6) .\n\t\t */\n\t\t'moduleResolution'?: string;\n\t\t/**\n\t\t * Do not report errors on unused labels.\n\t\t */\n\t\t'allowUnusedLabels'?: boolean;\n\t\t/**\n\t\t * Report error when not all code paths in function return a value.\n\t\t */\n\t\t'noImplicitReturns'?: boolean;\n\t\t/**\n\t\t * Report errors for fallthrough cases in switch statement.\n\t\t */\n\t\t'noFallthroughCasesInSwitch'?: boolean;\n\t\t/**\n\t\t * Do not report errors on unreachable code.\n\t\t */\n\t\t'allowUnreachableCode'?: boolean;\n\t\t/**\n\t\t * Disallow inconsistently-cased references to the same file.\n\t\t */\n\t\t'forceConsistentCasingInFileNames'?: boolean;\n\t\t/**\n\t\t * Base directory to resolve non-relative module names.\n\t\t */\n\t\t'baseUrl'?: string;\n\t\t/**\n\t\t * Specify path mapping to be computed relative to baseUrl option.\n\t\t */\n\t\t'paths'?: Object;\n\t\t/**\n\t\t * Specify list of root directories to be used when resolving modules.\n\t\t */\n\t\t'rootDirs'?: string[];\n\t\t/**\n\t\t * Specify list of directories for type definition files to be included. Requires TypeScript version 2.0 or later.\n\t\t */\n\t\t'typeRoots'?: string[];\n\t\t/**\n\t\t * Type declaration files to be included in compilation. Requires TypeScript version 2.0 or later.\n\t\t */\n\t\t'types'?: string[];\n\t\t/**\n\t\t * Enable tracing of the name resolution process.\n\t\t */\n\t\t'traceResolution'?: boolean;\n\t\t/**\n\t\t * Allow javascript files to be compiled.\n\t\t */\n\t\t'allowJs'?: boolean;\n\t\t/**\n\t\t * Allow default imports from modules with no default export. This does not affect code emit, just typechecking.\n\t\t */\n\t\t'allowSyntheticDefaultImports'?: boolean;\n\t\t/**\n\t\t * Do not emit 'use strict' directives in module output.\n\t\t */\n\t\t'noImplicitUseStrict'?: boolean;\n\t\t/**\n\t\t * Enable to list all emitted files. Requires TypeScript version 2.0 or later.\n\t\t */\n\t\t'listEmittedFiles'?: boolean;\n\t\t/**\n\t\t * Specify library file to be included in the compilation. Requires TypeScript version 2.0 or later.\n\t\t */\n\t\t'lib'?: ('es5' | 'es6' | 'es2015' | 'es7' | 'es2016' | 'es2017' | 'esnext' | 'dom' | 'dom.iterable' | 'webworker' | 'scripthost' | 'es2015.core' | 'es2015.collection' | 'es2015.generator' | 'es2015.iterable' | 'es2015.promise' | 'es2015.proxy' | 'es2015.reflect' | 'es2015.symbol' | 'es2015.symbol.wellknown' | 'es2016.array.include' | 'es2017.object' | 'es2017.sharedmemory' | 'esnext.asynciterable')[];\n\t\t/**\n\t\t * Enable strict null checks. Requires TypeScript version 2.0 or later.\n\t\t */\n\t\t'strictNullChecks'?: boolean;\n\t\t/**\n\t\t * The maximum dependency depth to search under node_modules and load JavaScript files. Only applicable with --allowJs.\n\t\t */\n\t\t'maxNodeModuleJsDepth'?: number;\n\t\t/**\n\t\t * Import emit helpers (e.g. '__extends', '__rest', etc..) from tslib. Requires TypeScript version 2.1 or later.\n\t\t */\n\t\t'importHelpers'?: boolean;\n\t\t/**\n\t\t * Specify the JSX factory function to use when targeting react JSX emit, e.g. 'React.createElement' or 'h'. Requires TypeScript version 2.1 or later.\n\t\t */\n\t\t'jsxFactory'?: string;\n\t\t/**\n\t\t * Parse in strict mode and emit 'use strict' for each source file. Requires TypeScript version 2.1 or later.\n\t\t */\n\t\t'alwaysStrict'?: boolean;\n\t\t/**\n\t\t * Enable all strict type checking options. Requires TypeScript version 2.3 or later.\n\t\t */\n\t\t'strict'?: boolean;\n\t\t/**\n\t\t * Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. Requires TypeScript version 2.3 or later.\n\t\t */\n\t\t'downlevelIteration'?: boolean;\n\t\t/**\n\t\t * Report errors in .js files. Requires TypeScript version 2.3 or later.\n\t\t */\n\t\t'checkJs'?: boolean;\n\t\t[k: string]: any;\n\t};\n\t[k: string]: any;\n}\nexport interface CompileOnSaveDefinition {\n\t/**\n\t * Enable Compile-on-Save for this project.\n\t */\n\t'compileOnSave'?: boolean;\n\t[k: string]: any;\n}\nexport interface TypeAcquisitionDefinition {\n\t/**\n\t * Auto type (.d.ts) acquisition options for this project. Requires TypeScript version 2.1 or later.\n\t */\n\t'typeAcquisition'?: {\n\t\t/**\n\t\t * Enable auto type acquisition\n\t\t */\n\t\t'enable'?: boolean;\n\t\t/**\n\t\t * Specifies a list of type declarations to be included in auto type acquisition. Ex. ['jquery', 'lodash']\n\t\t */\n\t\t'include'?: string[];\n\t\t/**\n\t\t * Specifies a list of type declarations to be excluded from auto type acquisition. Ex. ['jquery', 'lodash']\n\t\t */\n\t\t'exclude'?: string[];\n\t\t[k: string]: any;\n\t};\n\t[k: string]: any;\n}\nexport interface ExtendsDefinition {\n\t/**\n\t * Path to base configuration file to inherit from. Requires TypeScript version 2.1 or later.\n\t */\n\t'extends'?: string;\n\t[k: string]: any;\n}\nexport interface FilesDefinition {\n\t/**\n\t * If no 'files' or 'include' property is present in a tsconfig.json, the compiler defaults to including all files in the containing directory and subdirectories except those specified by 'exclude'. When a 'files' property is specified, only those files and those specified by 'include' are included.\n\t */\n\t'files'?: string[];\n\t[k: string]: any;\n}\nexport interface ExcludeDefinition {\n\t/**\n\t * Specifies a list of files to be excluded from compilation. The 'exclude' property only affects the files included via the 'include' property and not the 'files' property. Glob patterns require TypeScript version 2.0 or later.\n\t */\n\t'exclude'?: string[];\n\t[k: string]: any;\n}\nexport interface IncludeDefinition {\n\t/**\n\t * Specifies a list of glob patterns that match files to be included in compilation. If no 'files' or 'include' property is present in a tsconfig.json, the compiler defaults to including all files in the containing directory and subdirectories except those specified by 'exclude'. Requires TypeScript version 2.0 or later.\n\t */\n\t'include'?: string[];\n\t[k: string]: any;\n}\nexport type JsonSchemaForTheTypeScriptCompilersConfigurationFile = CompilerOptionsDefinition & CompileOnSaveDefinition & TypeAcquisitionDefinition & ExtendsDefinition & FilesDefinition & IncludeDefinition;\n","type":2},{"name":"node_modules/@dojo/cli-export-project/interfaces/tslint.json.d.ts","text":"export interface Ruledefinitions {\n\t/**\n\t * Enforces function overloads to be consecutive\n\t */\n\t'adjacent-overload-signatures'?: boolean;\n\t/**\n\t * Enforces vertical alignment for parameters, arguments and/or statements\n\t */\n\t'align'?: (true | false | 'parameters' | 'arguments' | 'statements')[];\n\t/**\n\t * Requires using either 'T[]' or 'Array<T>' for arrays\n\t */\n\t'array-type'?: (true | false | 'array' | 'array-simple' | 'generic')[];\n\t/**\n\t * Requires parentheses around the parameters of arrow function definitions\n\t */\n\t'arrow-parens'?: boolean | any[];\n\t/**\n\t * Bans the use of specific functions or global methods\n\t */\n\t'ban'?: boolean | any[];\n\t/**\n\t * Enforces PascalCased class and interface names\n\t */\n\t'class-name'?: boolean;\n\t/**\n\t * Enforces rules for single-line comments\n\t */\n\t'comment-format'?: (true | false | 'check-space' | 'check-lowercase' | 'check-uppercase' | {\n\t\t/**\n\t\t * Words that will be ignored at the beginning of comment\n\t\t */\n\t\t'ignore-words'?: string[];\n\t\t/**\n\t\t * RegExp pattern that will be ignored at the beginning of comment\n\t\t */\n\t\t'ignore-pattern'?: string;\n\t})[];\n\t/**\n\t * Enforces documentation for important items be filled out\n\t */\n\t'completed-docs'?: (true | false | 'classes' | 'functions' | 'methods' | 'properties')[];\n\t/**\n\t * Enforces all components having the suffix of 'Component'\n\t */\n\t'component-class-suffix'?: boolean;\n\t/**\n\t * Enforces naming conventions for components\n\t */\n\t'component-selector-name'?: (true | false | 'camelCase' | 'kebab-case')[];\n\t/**\n\t * Enforces all components to have a uniform prefix\n\t */\n\t'component-selector-prefix'?: (boolean | string)[];\n\t/**\n\t * Enforces the type of a component\n\t */\n\t'component-selector-type'?: (true | false | 'attribute' | 'element')[];\n\t/**\n\t * Enforces braces for if/for/do/while statements\n\t */\n\t'curly'?: boolean;\n\t/**\n\t * Enforces a threshold of cyclomatic complexity\n\t */\n\t'cyclomatic-complexity'?: (boolean | number)[];\n\t/**\n\t * Enforces all components having the suffix of 'Directive'\n\t */\n\t'directive-class-suffix'?: boolean;\n\t/**\n\t * Enforces naming conventions for directives\n\t */\n\t'directive-selector-name'?: (true | false | 'camelCase' | 'kebab-case')[];\n\t/**\n\t * Enforces all directives to have a uniform prefix\n\t */\n\t'directive-selector-prefix'?: (boolean | string)[];\n\t/**\n\t * Enforces the type of a directive\n\t */\n\t'directive-selector-type'?: (true | false | 'attribute' | 'element')[];\n\t/**\n\t * Enforces the file to end with a newline\n\t */\n\t'eofline'?: boolean;\n\t/**\n\t * Enforces a certain header comment for all files, matched by a regular expression\n\t */\n\t'file-header'?: (boolean | string)[];\n\t/**\n\t * Enforces a for...in statement to be filtered with an if statement\n\t */\n\t'forin'?: boolean;\n\t/**\n\t * Enforces consistent indentation levels\n\t */\n\t'indent'?: (boolean | number | string)[];\n\t/**\n\t * Enforces the rule that interface names must or must not begin with a capital 'I'\n\t */\n\t'interface-name'?: (true | false | 'always-prefix' | 'never-prefix')[];\n\t/**\n\t * Enforces basic format rules for jsdoc comments\n\t */\n\t'jsdoc-format'?: boolean;\n\t/**\n\t * Enforces labels only on sensible statements\n\t */\n\t'label-position'?: boolean;\n\t/**\n\t * Enforces a consistent linebreak styl\n\t */\n\t'linebreak-style'?: (true | false | 'CRLF' | 'LF')[];\n\t/**\n\t * A file may not contain more than the specified number of classes\n\t */\n\t'max-classes-per-file'?: (boolean | number)[];\n\t/**\n\t * Requires files to remain under a certain number of lines\n\t */\n\t'max-file-line-count'?: (boolean | number)[];\n\t/**\n\t * Sets the maximum length of a line\n\t */\n\t'max-line-length'?: (boolean | number)[];\n\t/**\n\t * Enforces using explicit visibility on class members\n\t */\n\t'member-access'?: any[] | boolean;\n\t/**\n\t * Enforces chosen member ordering\n\t */\n\t'member-ordering'?: (Object | boolean | string)[];\n\t/**\n\t * Requires parentheses when invoking a constructor via the `new` keyword\n\t */\n\t'new-parens'?: boolean;\n\t/**\n\t * Requires the use of `as Type` for type assertions instead of `<Type>`\n\t */\n\t'no-angle-bracket-type-assertion'?: boolean;\n\t/**\n\t * Disallows usages of any as a type decoration\n\t */\n\t'no-any'?: boolean;\n\t/**\n\t * Disallows access to arguments.callee\n\t */\n\t'no-arg'?: boolean;\n\t/**\n\t * Disallows bitwise operators\n\t */\n\t'no-bitwise'?: boolean;\n\t/**\n\t * Disallows any type of assignment in any conditionals; this applies to do-while, for, if, and while statements\n\t */\n\t'no-conditional-assignment'?: boolean;\n\t/**\n\t * Disallows one or more blank lines in a row\n\t */\n\t'no-consecutive-blank-lines'?: (boolean | number)[];\n\t/**\n\t * Disallows access to the specified functions on console\n\t */\n\t'no-console'?: (true | false | 'assert' | 'count' | 'debug' | 'dir' | 'dirxml' | 'error' | 'group' | 'groupCollapsed' | 'groupEnd' | 'info' | 'log' | 'profile' | 'profileEnd' | 'table' | 'time' | 'timeEnd' | 'timeStamp' | 'trace' | 'warn')[];\n\t/**\n\t * Disallows access to the constructors of String, Number and Boolean\n\t */\n\t'no-construct'?: boolean;\n\t/**\n\t * Disallows debugger statements\n\t */\n\t'no-debugger'?: boolean;\n\t/**\n\t * Disallows default exports in ES6-style modules\n\t */\n\t'no-default-export'?: boolean;\n\t/**\n\t * Disallows duplicate variable declarations in the same block scope\n\t */\n\t'no-duplicate-variable'?: boolean;\n\t/**\n\t * Disallows empty blocks\n\t */\n\t'no-empty'?: boolean;\n\t/**\n\t * Disallows `eval` function invocations\n\t */\n\t'no-eval'?: boolean;\n\t/**\n\t * Disallows iterating over an array with a for-in loop\n\t */\n\t'no-for-in-array'?: boolean;\n\t/**\n\t * Disallows explicit type declarations for variables or parameters initialized to a number, string, or boolean\n\t */\n\t'no-inferrable-types'?: (true | false | 'ignore-params')[];\n\t/**\n\t * Disallows internal module, use namespace instead\n\t */\n\t'no-internal-module'?: boolean;\n\t/**\n\t * Disallows using the `this` keyword outside of classes\n\t */\n\t'no-invalid-this'?: any;\n\t/**\n\t * Disallows mergeable namespaces in the same file\n\t */\n\t'no-mergeable-namespace'?: boolean;\n\t/**\n\t * Disallows use of internal `module`s and `namespace`s\n\t */\n\t'no-namespace'?: any;\n\t/**\n\t * Disallows use of the `null` keyword literal\n\t */\n\t'no-null-keyword'?: boolean;\n\t/**\n\t * Disallows parameter properties in class constructors\n\t */\n\t'no-parameter-properties'?: boolean;\n\t/**\n\t * Disallows `/// <reference path=>` imports (use ES6-style imports instead)\n\t */\n\t'no-reference'?: boolean;\n\t/**\n\t * Disallows require() style imports\n\t */\n\t'no-require-imports'?: boolean;\n\t/**\n\t * Disallows shadowing variable declarations\n\t */\n\t'no-shadowed-variable'?: boolean;\n\t/**\n\t * Disallows object access via string literals\n\t */\n\t'no-string-literal'?: boolean;\n\t/**\n\t * Disallows falling through case statements\n\t */\n\t'no-switch-case-fall-through'?: boolean;\n\t/**\n\t * Disallows trailing whitespace at the end of a line\n\t */\n\t'no-trailing-whitespace'?: boolean;\n\t/**\n\t * Disallows control flow statements, such as `return`, `continue`, `break` and `throws` in finally blocks\n\t */\n\t'no-unsafe-finally'?: boolean;\n\t/**\n\t * Disallows unused expression statements\n\t */\n\t'no-unused-expression'?: boolean;\n\t/**\n\t * Disallows unused 'new' expression statements\n\t */\n\t'no-unused-new'?: boolean;\n\t/**\n\t * Disallows unused imports, variables, functions and private class members\n\t */\n\t'no-unused-variable'?: any[] | boolean;\n\t/**\n\t * Disallows usage of variables before their declaration\n\t */\n\t'no-use-before-declare'?: boolean;\n\t/**\n\t * Disallows usage of the var keyword, use let or const instead\n\t */\n\t'no-var-keyword'?: boolean;\n\t/**\n\t * Disallows the use of require statements except in import statements\n\t */\n\t'no-var-requires'?: boolean;\n\t/**\n\t * Enforces consistent object literal property quote style\n\t */\n\t'object-literal-key-quotes'?: (true | false | 'always' | 'as-needed' | 'consistent' | 'consistent-as-needed')[];\n\t/**\n\t * Enforces use of ES6 object literal shorthand when possible\n\t */\n\t'object-literal-shorthand'?: boolean;\n\t/**\n\t * Requires keys in object literals to be sorted alphabetically\n\t */\n\t'object-literal-sort-keys'?: boolean;\n\t/**\n\t * Enforces the specified tokens to be on the same line as the expression preceding it\n\t */\n\t'one-line'?: (true | false | 'check-open-brace' | 'check-catch' | 'check-finally' | 'check-else' | 'check-whitespace')[];\n\t/**\n\t * Disallows multiple variable definitions in the same declaration statement\n\t */\n\t'one-variable-per-declaration'?: (true | false | 'ignore-for-loop')[];\n\t/**\n\t * Disallows traditional (non-arrow) function expressions\n\t */\n\t'only-arrow-functions'?: (true | false | 'allow-declarations' | 'allow-named-functions')[];\n\t/**\n\t * Requires that import statements be alphabetized\n\t */\n\t'ordered-imports'?: (Object | boolean | string)[];\n\t/**\n\t * Recommends a 'for-of' loop over a standard 'for' loop if the index is only used to access the array being iterated\n\t */\n\t'prefer-for-of'?: boolean;\n\t/**\n\t * Enforces consistent single or double quoted string literals\n\t */\n\t'quotemark'?: (true | false | 'double' | 'single' | 'jsx-double' | 'jsx-single' | 'avoid-escape')[];\n\t/**\n\t * Enforces the radix parameter of parseInt\n\t */\n\t'radix'?: boolean;\n\t/**\n\t * When adding two variables, operands must both be of type number or of type string\n\t */\n\t'restrict-plus-operands'?: boolean;\n\t/**\n\t * Enforces semicolons at the end of every statement\n\t */\n\t'semicolon'?: (true | false | 'always' | 'never' | 'ignore-bound-class-methods' | 'ignore-interfaces')[];\n\t/**\n\t * Enforces a default case in switch statements\n\t */\n\t'switch-default'?: boolean;\n\t/**\n\t * Requires or disallows trailing commas in array and object literals, destructuring assignments, function and tuple typings, named imports and function parameters\n\t */\n\t'trailing-comma'?: (Object | boolean | string)[];\n\t/**\n\t * Enforces === and !== in favor of == and !=\n\t */\n\t'triple-equals'?: any[] | boolean;\n\t/**\n\t * Enforces type definitions to exist\n\t */\n\t'typedef'?: (true | false | 'call-signature' | 'parameter' | 'arrow-parameter' | 'property-declaration' | 'variable-declaration' | 'member-variable-declaration')[];\n\t/**\n\t * Enforces spacing whitespace for type definitions\n\t */\n\t'typedef-whitespace'?: (Object | boolean)[];\n\t/**\n\t * Enforces use of the `isNaN()` function to check for NaN references instead of a comparison to the `NaN` constant\n\t */\n\t'use-isnan'?: boolean;\n\t/**\n\t * Allows only camelCased or UPPER_CASED variable names\n\t */\n\t'variable-name'?: any[] | boolean;\n\t/**\n\t * Enforces spacing whitespace\n\t */\n\t'whitespace'?: (true | false | 'check-branch' | 'check-decl' | 'check-operator' | 'check-module' | 'check-separator' | 'check-type' | 'check-typecast')[];\n\t[k: string]: any;\n}\nexport interface Jsruledefinitions {\n\t/**\n\t * Enforces vertical alignment for parameters, arguments and/or statements\n\t */\n\t'align'?: (true | false | 'parameters' | 'arguments' | 'statements')[];\n\t/**\n\t * Requires parentheses around the parameters of arrow function definitions\n\t */\n\t'arrow-parens'?: boolean;\n\t/**\n\t * Bans the use of specific functions or global methods\n\t */\n\t'ban'?: boolean | any[];\n\t/**\n\t * Enforces PascalCased class and interface names\n\t */\n\t'class-name'?: boolean;\n\t/**\n\t * Enforces rules for single-line comments\n\t */\n\t'comment-format'?: (true | false | 'check-space' | 'check-lowercase' | 'check-uppercase')[];\n\t/**\n\t * Enforces documentation for important items be filled out\n\t */\n\t'completed-docs'?: (true | false | 'classes' | 'functions' | 'methods' | 'properties')[];\n\t/**\n\t * Enforces all components having the suffix of 'Component'\n\t */\n\t'component-class-suffix'?: boolean;\n\t/**\n\t * Enforces naming conventions for components\n\t */\n\t'component-selector-name'?: (true | false | 'camelCase' | 'kebab-case')[];\n\t/**\n\t * Enforces all components to have a uniform prefix\n\t */\n\t'component-selector-prefix'?: (boolean | string)[];\n\t/**\n\t * Enforces the type of a component\n\t */\n\t'component-selector-type'?: (true | false | 'attribute' | 'element')[];\n\t/**\n\t * Enforces braces for if/for/do/while statements\n\t */\n\t'curly'?: boolean;\n\t/**\n\t * Enforces a threshold of cyclomatic complexity\n\t */\n\t'cyclomatic-complexity'?: (boolean | number)[];\n\t/**\n\t * Enforces all components having the suffix of 'Directive'\n\t */\n\t'directive-class-suffix'?: boolean;\n\t/**\n\t * Enforces naming conventions for directives\n\t */\n\t'directive-selector-name'?: (true | false | 'camelCase' | 'kebab-case')[];\n\t/**\n\t * Enforces all directives to have a uniform prefix\n\t */\n\t'directive-selector-prefix'?: (boolean | string)[];\n\t/**\n\t * Enforces the type of a directive\n\t */\n\t'directive-selector-type'?: (true | false | 'attribute' | 'element')[];\n\t/**\n\t * Enforces the file to end with a newline\n\t */\n\t'eofline'?: boolean;\n\t/**\n\t * Enforces a certain header comment for all files, matched by a regular expression\n\t */\n\t'file-header'?: (boolean | string)[];\n\t/**\n\t * Enforces a for...in statement to be filtered with an if statement\n\t */\n\t'forin'?: boolean;\n\t/**\n\t * Enforces consistent indentation levels\n\t */\n\t'indent'?: (boolean | number | string)[];\n\t/**\n\t * Enforces basic format rules for jsdoc comments\n\t */\n\t'jsdoc-format'?: boolean;\n\t/**\n\t * Enforces labels only on sensible statements\n\t */\n\t'label-position'?: boolean;\n\t/**\n\t * Enforces a consistent linebreak styl\n\t */\n\t'linebreak-style'?: (true | false | 'CRLF' | 'LF')[];\n\t/**\n\t * A file may not contain more than the specified number of classes\n\t */\n\t'max-classes-per-file'?: (boolean | number)[];\n\t/**\n\t * Requires files to remain under a certain number of lines\n\t */\n\t'max-file-line-count'?: (boolean | number)[];\n\t/**\n\t * Sets the maximum length of a line\n\t */\n\t'max-line-length'?: (boolean | number)[];\n\t/**\n\t * Requires parentheses when invoking a constructor via the `new` keyword\n\t */\n\t'new-parens'?: boolean;\n\t/**\n\t * Disallows access to arguments.callee\n\t */\n\t'no-arg'?: boolean;\n\t/**\n\t * Disallows bitwise operators\n\t */\n\t'no-bitwise'?: boolean;\n\t/**\n\t * Disallows any type of assignment in any conditionals; this applies to do-while, for, if, and while statements\n\t */\n\t'no-conditional-assignment'?: boolean;\n\t/**\n\t * Disallows one or more blank lines in a row\n\t */\n\t'no-consecutive-blank-lines'?: (boolean | number)[];\n\t/**\n\t * Disallows access to the specified functions on console\n\t */\n\t'no-console'?: (true | false | 'assert' | 'count' | 'debug' | 'dir' | 'dirxml' | 'error' | 'group' | 'groupCollapsed' | 'groupEnd' | 'info' | 'log' | 'profile' | 'profileEnd' | 'table' | 'time' | 'timeEnd' | 'timeStamp' | 'trace' | 'warn')[];\n\t/**\n\t * Disallows access to the constructors of String, Number and Boolean\n\t */\n\t'no-construct'?: boolean;\n\t/**\n\t * Disallows debugger statements\n\t */\n\t'no-debugger'?: boolean;\n\t/**\n\t * Disallows default exports in ES6-style modules\n\t */\n\t'no-default-export'?: boolean;\n\t/**\n\t * Disallows duplicate variable declarations in the same block scope\n\t */\n\t'no-duplicate-variable'?: boolean;\n\t/**\n\t * Disallows empty blocks\n\t */\n\t'no-empty'?: boolean;\n\t/**\n\t * Disallows `eval` function invocations\n\t */\n\t'no-eval'?: boolean;\n\t/**\n\t * Disallows iterating over an array with a for-in loop\n\t */\n\t'no-for-in-array'?: boolean;\n\t/**\n\t * Disallows using the `this` keyword outside of classes\n\t */\n\t'no-invalid-this'?: any;\n\t/**\n\t * Disallows use of the `null` keyword literal\n\t */\n\t'no-null-keyword'?: boolean;\n\t/**\n\t * Disallows `/// <reference path=>` imports (use ES6-style imports instead)\n\t */\n\t'no-reference'?: boolean;\n\t/**\n\t * Disallows require() style imports\n\t */\n\t'no-require-imports'?: boolean;\n\t/**\n\t * Disallows shadowing variable declarations\n\t */\n\t'no-shadowed-variable'?: boolean;\n\t/**\n\t * Disallows object access via string literals\n\t */\n\t'no-string-literal'?: boolean;\n\t/**\n\t * Disallows falling through case statements\n\t */\n\t'no-switch-case-fall-through'?: boolean;\n\t/**\n\t * Disallows trailing whitespace at the end of a line\n\t */\n\t'no-trailing-whitespace'?: boolean;\n\t/**\n\t * Disallows control flow statements, such as `return`, `continue`, `break` and `throws` in finally blocks\n\t */\n\t'no-unsafe-finally'?: boolean;\n\t/**\n\t * Disallows unused expression statements\n\t */\n\t'no-unused-expression'?: boolean;\n\t/**\n\t * Disallows unused 'new' expression statements\n\t */\n\t'no-unused-new'?: boolean;\n\t/**\n\t * Disallows usage of variables before their declaration\n\t */\n\t'no-use-before-declare'?: boolean;\n\t/**\n\t * Disallows usage of the var keyword, use let or const instead\n\t */\n\t'no-var-keyword'?: boolean;\n\t/**\n\t * Enforces consistent object literal property quote style\n\t */\n\t'object-literal-key-quotes'?: (true | false | 'always' | 'as-needed')[];\n\t/**\n\t * Enforces use of ES6 object literal shorthand when possible\n\t */\n\t'object-literal-shorthand'?: boolean;\n\t/**\n\t * Requires keys in object literals to be sorted alphabetically\n\t */\n\t'object-literal-sort-keys'?: boolean;\n\t/**\n\t * Enforces the specified tokens to be on the same line as the expression preceding it\n\t */\n\t'one-line'?: (true | false | 'check-open-brace' | 'check-catch' | 'check-finally' | 'check-else' | 'check-whitespace')[];\n\t/**\n\t * Disallows multiple variable definitions in the same declaration statement\n\t */\n\t'one-variable-per-declaration'?: (true | false | 'ignore-for-loop')[];\n\t/**\n\t * Disallows traditional (non-arrow) function expressions\n\t */\n\t'only-arrow-functions'?: (true | false | 'allow-declarations')[];\n\t/**\n\t * Requires that import statements be alphabetized\n\t */\n\t'ordered-imports'?: (Object | boolean | string)[];\n\t/**\n\t * Recommends a 'for-of' loop over a standard 'for' loop if the index is only used to access the array being iterated\n\t */\n\t'prefer-for-of'?: boolean;\n\t/**\n\t * Enforces consistent single or double quoted string literals\n\t */\n\t'quotemark'?: (true | false | 'double' | 'single' | 'jsx-double' | 'jsx-single' | 'avoid-escape')[];\n\t/**\n\t * Enforces the radix parameter of parseInt\n\t */\n\t'radix'?: boolean;\n\t/**\n\t * When adding two variables, operands must both be of type number or of type string\n\t */\n\t'restrict-plus-operands'?: boolean;\n\t/**\n\t * Enforces semicolons at the end of every statement\n\t */\n\t'semicolon'?: (true | false | 'always' | 'never' | 'ignore-bound-class-methods' | 'ignore-interfaces')[];\n\t/**\n\t * Enforces a default case in switch statements\n\t */\n\t'switch-default'?: boolean;\n\t/**\n\t * Requires or disallows trailing commas in array and object literals, destructuring assignments, function and tuple typings, named imports and function parameters\n\t */\n\t'trailing-comma'?: (Object | boolean | string)[];\n\t/**\n\t * Enforces === and !== in favor of == and !=\n\t */\n\t'triple-equals'?: any[] | boolean;\n\t/**\n\t * Enforces use of the `isNaN()` function to check for NaN references instead of a comparison to the `NaN` constant\n\t */\n\t'use-isnan'?: boolean;\n\t/**\n\t * Allows only camelCased or UPPER_CASED variable names\n\t */\n\t'variable-name'?: any[] | boolean;\n\t/**\n\t * Enforces spacing whitespace\n\t */\n\t'whitespace'?: (true | false | 'check-branch' | 'check-decl' | 'check-operator' | 'check-module' | 'check-separator' | 'check-type' | 'check-typecast')[];\n\t[k: string]: any;\n}\nexport interface JsonSchemaForTheTsLintConfigurationFiles {\n\t/**\n\t * The directory where the codelytics rules live\n\t */\n\t'rulesDirectory'?: string[];\n\t'rules'?: Ruledefinitions;\n\t'jsRules'?: Jsruledefinitions;\n\t/**\n\t * Extend another configuration (built in config OR a node resolvable .json file)\n\t */\n\t'extends'?: any[] | string;\n\t[k: string]: any;\n}\n","type":2},{"name":"node_modules/@dojo/cli-export-project/log.d.ts","text":"export declare let verboseFlag: boolean;\n/**\n * Log a message to the console\n * @param text The message to be logged\n */\nexport declare function log(...text: any[]): void;\n/**\n * Log a message to the console if verbose messages are desired\n * @param text The message to be logged\n */\nexport declare function verbose(...text: any[]): void;\n/**\n * Indents a message\n * @param num the number of indents\n * @param message an optional message to add at the end\n */\nexport declare function indent(num?: number, message?: string): string;\nexport declare function setVerbose(verbose: boolean): void;\n","type":2},{"name":"node_modules/@dojo/cli-export-project/main.d.ts","text":"import { Command } from '@dojo/interfaces/cli';\nexport interface ExportArgs {\n    content: string | undefined;\n    out: string;\n    index: string | undefined;\n    project: string;\n    verbose: boolean;\n}\ndeclare const command: Command<ExportArgs>;\nexport default command;\n","type":2},{"name":"node_modules/@dojo/cli-test-intern/dirname.d.ts","text":"export default __dirname;\nexport declare function projectName(): any;\n","type":2},{"name":"node_modules/@dojo/cli-test-intern/interfaces.d.ts","text":"declare module 'remap-istanbul/lib/main' {\n\tmodule main {\n\t\texport interface ReportMap {\n\t\t\t[type: string]: string | null;\n\t\t}\n\n\t\texport interface RemapOptions {\n\t\t\t[option: string]: any;\n\t\t\texclude?: string | RegExp | ((filename: string) => boolean);\n\t\t\tmapFileName?: (filename: string) => string;\n\t\t\twarn?: (...args: any[]) => void;\n\t\t}\n\n\t\texport function loadCoverage(sources: string | string[], options?: RemapOptions): any;\n\n\t\texport function remap(coverage: any, options?: RemapOptions): any;\n\n\t\texport function writeReport(collector: any, reportType: string, reportOptions: object, dest: string | ((output: string) => void) | null, sources?: any): Promise<void>;\n\t}\n\n\tfunction main(sources: string | string[], reports: main.ReportMap, options?: main.RemapOptions): Promise<void>;\n\n\texport = main;\n}\n","type":2},{"name":"node_modules/@dojo/cli-test-intern/javaCheck.d.ts","text":"import { TestArgs } from './main';\nexport default function (args: TestArgs): Promise<boolean>;\n","type":2},{"name":"node_modules/@dojo/cli-test-intern/main.d.ts","text":"import { Command } from '@dojo/interfaces/cli';\nexport interface TestArgs {\n    all: boolean;\n    browser: boolean;\n    config?: string;\n    coverage?: boolean;\n    functional: boolean;\n    reporters?: string;\n    testingKey?: string;\n    secret?: string;\n    userName?: string;\n    unit: boolean;\n    verbose: boolean;\n    internConfig: string;\n    node: boolean;\n    filter: string;\n}\ndeclare const command: Command<TestArgs>;\nexport default command;\n","type":2},{"name":"node_modules/@dojo/cli-test-intern/runTests.d.ts","text":"export interface TestOptions {\n    nodeUnit?: boolean;\n    remoteUnit?: boolean;\n    remoteFunctional?: boolean;\n    childConfig?: string;\n    internConfig?: string;\n    reporters?: string;\n    userName?: string;\n    secret?: string;\n    testingKey?: string;\n    verbose?: boolean;\n    coverage?: boolean;\n    filter?: string;\n}\nexport declare function parseArguments(testArgs: TestOptions): string[];\nexport declare function setLogger(value: (message: any, ...optionalParams: any[]) => void): void;\nexport default function (testArgs: TestOptions): Promise<{}>;\n","type":2},{"name":"node_modules/@dojo/core/aspect.d.ts","text":"import { Handle } from '@dojo/interfaces/core';\n/**\n * An object that provides the necessary APIs to be MapLike\n */\nexport interface MapLike<K, V> {\n    get(key: K): V;\n    set(key: K, value?: V): this;\n}\nexport interface Indexable {\n    [method: string]: any;\n}\n/**\n * The types of objects or maps where advice can be applied\n */\nexport declare type Targetable = MapLike<string, any> | Indexable;\nexport interface JoinPointDispatchAdvice<T> {\n    before?: JoinPointBeforeAdvice[];\n    after?: JoinPointAfterAdvice<T>[];\n    readonly joinPoint: Function;\n}\nexport interface JoinPointAfterAdvice<T> {\n    /**\n     * Advice which is applied *after*, receiving the result and arguments from the join point.\n     *\n     * @param result The result from the function being advised\n     * @param args The arguments that were supplied to the advised function\n     * @returns The value returned from the advice is then the result of calling the method\n     */\n    (result: T, ...args: any[]): T;\n}\nexport interface JoinPointAroundAdvice<T> {\n    /**\n     * Advice which is applied *around*.  The advising function receives the original function and\n     * needs to return a new function which will then invoke the original function.\n     *\n     * @param origFn The original function\n     * @returns A new function which will invoke the original function.\n     */\n    (origFn: GenericFunction<T>): (...args: any[]) => T;\n}\nexport interface JoinPointBeforeAdvice {\n    /**\n     * Advice which is applied *before*, receiving the original arguments, if the advising\n     * function returns a value, it is passed further along taking the place of the original\n     * arguments.\n     *\n     * @param args The arguments the method was called with\n     */\n    (...args: any[]): any[] | void;\n}\nexport interface GenericFunction<T> {\n    (...args: any[]): T;\n}\n/**\n * Attaches \"after\" advice to be executed after the original method.\n * The advising function will receive the original method's return value and arguments object.\n * The value it returns will be returned from the method when it is called (even if the return value is undefined).\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original method's return value and arguments object\n * @return A handle which will remove the aspect when destroy is called\n */\nexport declare function after(target: Targetable, methodName: string, advice: (originalReturn: any, originalArgs: IArguments) => any): Handle;\n/**\n * Apply advice *after* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The after advice\n */\nexport declare function after<F extends GenericFunction<T>, T>(joinPoint: F, advice: JoinPointAfterAdvice<T>): F;\n/**\n * Apply advice *around* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The around advice\n */\nexport declare function aroundJoinPoint<F extends GenericFunction<T>, T>(joinPoint: F, advice: JoinPointAroundAdvice<T>): F;\n/**\n * Attaches \"around\" advice around the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original function\n * @return A handle which will remove the aspect when destroy is called\n */\nexport declare function aroundObject(target: Targetable, methodName: string, advice: ((previous: Function) => Function)): Handle;\n/**\n * Attaches \"around\" advice around the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original function\n * @return A handle which will remove the aspect when destroy is called\n */\nexport declare function around(target: Targetable, methodName: string, advice: ((previous: Function) => Function)): Handle;\n/**\n * Apply advice *around* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The around advice\n */\nexport declare function around<F extends GenericFunction<T>, T>(joinPoint: F, advice: JoinPointAroundAdvice<T>): F;\n/**\n * Apply advice *before* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The before advice\n */\nexport declare function beforeJoinPoint<F extends GenericFunction<any>>(joinPoint: F, advice: JoinPointBeforeAdvice): F;\n/**\n * Attaches \"before\" advice to be executed before the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n * @return A handle which will remove the aspect when destroy is called\n */\nexport declare function beforeObject(target: Targetable, methodName: string, advice: (...originalArgs: any[]) => any[] | void): Handle;\n/**\n * Attaches \"before\" advice to be executed before the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n * @return A handle which will remove the aspect when destroy is called\n */\nexport declare function before(target: Targetable, methodName: string, advice: (...originalArgs: any[]) => any[] | void): Handle;\n/**\n * Apply advice *before* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The before advice\n */\nexport declare function before<F extends GenericFunction<any>>(joinPoint: F, advice: JoinPointBeforeAdvice): F;\n/**\n * Attaches advice to be executed after the original method.\n * The advising function will receive the same arguments as the original method.\n * The value it returns will be returned from the method when it is called *unless* its return value is undefined.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original method\n * @return A handle which will remove the aspect when destroy is called\n */\nexport declare function on(target: Targetable, methodName: string, advice: (...originalArgs: any[]) => any): Handle;\n","type":2},{"name":"node_modules/@dojo/core/async/ExtensiblePromise.d.ts","text":"import { Thenable } from '@dojo/shim/interfaces';\nimport { Iterable } from '@dojo/shim/iterator';\nimport { Executor } from '@dojo/shim/Promise';\nimport '@dojo/shim/Symbol';\n/**\n * Take a list of values, and if any are ExtensiblePromise objects, insert the wrapped Promise in its place,\n * otherwise use the original object. We use this to help use the native Promise methods like `all` and `race`.\n *\n * @param iterable    The list of objects to iterate over\n * @returns {any[]}    The list of objects, as an array, with ExtensiblePromises being replaced by Promises.\n */\nexport declare function unwrapPromises(iterable: Iterable<any> | any[]): any[];\nexport declare type DictionaryOfPromises<T> = {\n    [_: string]: T | Promise<T> | Thenable<T>;\n};\nexport declare type ListOfPromises<T> = Iterable<(T | Thenable<T>)>;\n/**\n * An extensible base to allow Promises to be extended in ES5. This class basically wraps a native Promise object,\n * giving an API like a native promise.\n */\nexport default class ExtensiblePromise<T> {\n    /**\n     * Return a rejected promise wrapped in an ExtensiblePromise\n     *\n     * @param reason    The reason for the rejection\n     * @returns An extensible promise\n     */\n    static reject<T>(reason?: any): ExtensiblePromise<never>;\n    /**\n     * Return a resolved promise wrapped in an ExtensiblePromise\n     *\n     * @param value The value to resolve the promise with\n     *\n     * @returns An extensible promise\n     */\n    static resolve<P extends ExtensiblePromise<void>>(): P;\n    /**\n     * Return a resolved promise wrapped in an ExtensiblePromise\n     *\n     * @param value The value to resolve the promise with\n     *\n     * @returns An extensible promise\n     */\n    static resolve<T, P extends ExtensiblePromise<T>>(value: T | PromiseLike<T>): P;\n    /**\n     * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n     * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n     *\n     * @example\n     * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n     * // { one: 1, two: 2 }\n     *\n     * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns An extensible promise\n     */\n    static all<T>(iterable: DictionaryOfPromises<T>): ExtensiblePromise<{\n        [key: string]: T;\n    }>;\n    /**\n     * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n     * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n     *\n     * @example\n     * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n     * // { one: 1, two: 2 }\n     *\n     * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns An extensible promise\n     */\n    static all<T>(iterable: (T | Thenable<T>)[]): ExtensiblePromise<T[]>;\n    /**\n     * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n     * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n     *\n     * @example\n     * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n     * // { one: 1, two: 2 }\n     *\n     * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns An extensible promise\n     */\n    static all<T>(iterable: T | Thenable<T>): ExtensiblePromise<T[]>;\n    /**\n     * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n     * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n     *\n     * @example\n     * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n     * // { one: 1, two: 2 }\n     *\n     * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns An extensible promise\n     */\n    static all<T>(iterable: ListOfPromises<T>): ExtensiblePromise<T[]>;\n    /**\n     * Return a ExtensiblePromise that resolves when one of the passed in objects have resolved\n     *\n     * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns {ExtensiblePromise}\n     */\n    static race<T>(iterable: Iterable<(T | PromiseLike<T>)> | (T | PromiseLike<T>)[]): ExtensiblePromise<T>;\n    /**\n     * @type {Promise}\n     * The wrapped promise\n     */\n    readonly _promise: Promise<T>;\n    /**\n     * Creates a new extended Promise.\n     *\n     * @constructor\n     *\n     * @param executor\n     * The executor function is called immediately when the Promise is instantiated. It is responsible for\n     * starting the asynchronous operation when it is invoked.\n     *\n     * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n     * successfully, or the `reject` function when the operation fails.\n     */\n    constructor(executor: Executor<T>);\n    /**\n     * Adds a callback to be invoked when the wrapped Promise is rejected.\n     *\n     * @param {Function} onRejected A function to call to handle the error. The parameter to the function will be the caught error.\n     *\n     * @returns {ExtensiblePromise}\n     */\n    catch<TResult = never>(onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): ExtensiblePromise<T | TResult>;\n    /**\n     * Adds a callback to be invoked when the wrapped Promise resolves or is rejected.\n     *\n     * @param {Function} onFulfilled   A function to call to handle the resolution. The paramter to the function will be the resolved value, if any.\n     * @param {Function} onRejected    A function to call to handle the error. The parameter to the function will be the caught error.\n     *\n     * @returns {ExtensiblePromise}\n     */\n    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2> | void) | undefined | null): ExtensiblePromise<TResult1 | TResult2>;\n    readonly [Symbol.toStringTag]: 'Promise';\n}\n","type":2},{"name":"node_modules/@dojo/core/async/iteration.d.ts","text":"import { Iterable } from '@dojo/shim/iterator';\nimport { Thenable } from '@dojo/shim/interfaces';\n/**\n * Test whether all elements in the array pass the provided callback\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return eventually returns true if all values pass; otherwise false\n */\nexport declare function every<T>(items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Filterer<T>): Promise<boolean>;\n/**\n * Returns an array of elements which pass the provided callback\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return eventually returns a new array with only values that have passed\n */\nexport declare function filter<T>(items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Filterer<T>): Promise<T[]>;\n/**\n * Find the first value matching a filter function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return a promise eventually containing the item or undefined if a match is not found\n */\nexport declare function find<T>(items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Filterer<T>): Promise<T | undefined>;\n/**\n * Find the first index with a value matching the filter function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return a promise eventually containing the index of the matching item or -1 if a match is not found\n */\nexport declare function findIndex<T>(items: Iterable<T | Promise<T>> | (T | Thenable<T>)[], callback: Filterer<T>): Promise<number>;\n/**\n * transform a list of items using a mapper function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous transform function\n * @return a promise eventually containing a collection of each transformed value\n */\nexport declare function map<T, U>(items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Mapper<T, U>): Promise<U[] | null | undefined>;\n/**\n * reduce a list of items down to a single value\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous reducer function\n * @param [initialValue] the first value to pass to the callback\n * @return a promise eventually containing a value that is the result of the reduction\n */\nexport declare function reduce<T, U>(this: any, items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Reducer<T, U>, initialValue?: U): Promise<U>;\nexport declare function reduceRight<T, U>(this: any, items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Reducer<T, U>, initialValue?: U): Promise<U>;\nexport declare function series<T, U>(items: Iterable<T | Promise<T>> | (T | Promise<T>)[], operation: Mapper<T, U>): Promise<U[]>;\nexport declare function some<T>(items: Iterable<T | Promise<T>> | Array<T | Promise<T>>, callback: Filterer<T>): Promise<boolean>;\nexport interface Filterer<T> extends Mapper<T, boolean> {\n}\nexport interface Mapper<T, U> {\n    (value: T, index: number, array: T[]): (U | Thenable<U>);\n}\nexport interface Reducer<T, U> {\n    (previousValue: U, currentValue: T, index: number, array: T[]): (U | Thenable<U>);\n}\n","type":2},{"name":"node_modules/@dojo/core/async/Task.d.ts","text":"import { Thenable } from '@dojo/shim/interfaces';\nimport { Iterable } from '@dojo/shim/iterator';\nimport { Executor } from '@dojo/shim/Promise';\nimport ExtensiblePromise, { DictionaryOfPromises, ListOfPromises } from './ExtensiblePromise';\n/**\n * Describe the internal state of a task.\n */\nexport declare const enum State {\n    Fulfilled = 0,\n    Pending = 1,\n    Rejected = 2,\n    Canceled = 3,\n}\n/**\n * A type guard that determines if `value` is a `Task`\n * @param value The value to guard\n */\nexport declare function isTask<T>(value: any): value is Task<T>;\n/**\n * Returns true if a given value has a `then` method.\n * @param {any} value The value to check if is Thenable\n * @returns {is Thenable<T>} A type guard if the value is thenable\n */\nexport declare function isThenable<T>(value: any): value is Thenable<T>;\n/**\n * Task is an extension of Promise that supports cancellation and the Task#finally method.\n */\nexport default class Task<T> extends ExtensiblePromise<T> {\n    /**\n     * Return a Task that resolves when one of the passed in objects have resolved\n     *\n     * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns {Task}\n     */\n    static race<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Task<T>;\n    /**\n     * Return a rejected promise wrapped in a Task\n     *\n     * @param reason The reason for the rejection\n     * @returns A task\n     */\n    static reject<T>(reason?: Error): Task<T>;\n    /**\n     * Return a resolved task.\n     *\n     * @param value The value to resolve with\n     *\n     * @return A task\n     */\n    static resolve(): Task<void>;\n    /**\n     * Return a resolved task.\n     *\n     * @param value The value to resolve with\n     *\n     * @return A task\n     */\n    static resolve<T>(value: (T | Thenable<T>)): Task<T>;\n    /**\n     * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n     * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n     *\n     * @example\n     * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n     * // { one: 1, two: 2 }\n     *\n     * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns An extensible promise\n     */\n    static all<T>(iterable: DictionaryOfPromises<T>): Task<{\n        [key: string]: T;\n    }>;\n    /**\n     * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n     * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n     *\n     * @example\n     * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n     * // { one: 1, two: 2 }\n     *\n     * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns An extensible promise\n     */\n    static all<T>(iterable: (T | Thenable<T>)[]): Task<T[]>;\n    /**\n     * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n     * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n     *\n     * @example\n     * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n     * // { one: 1, two: 2 }\n     *\n     * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns An extensible promise\n     */\n    static all<T>(iterable: T | Thenable<T>): Task<T[]>;\n    /**\n     * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n     * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n     *\n     * @example\n     * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n     * // { one: 1, two: 2 }\n     *\n     * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n     * @returns An extensible promise\n     */\n    static all<T>(iterable: ListOfPromises<T>): Task<T[]>;\n    /**\n     * A cancelation handler that will be called if this task is canceled.\n     */\n    private canceler;\n    /**\n     * Children of this Task (i.e., Tasks that were created from this Task with `then` or `catch`).\n     */\n    private readonly children;\n    /**\n     * The finally callback for this Task (if it was created by a call to `finally`).\n     */\n    private _finally;\n    /**\n     * The state of the task\n     */\n    protected _state: State;\n    readonly state: State;\n    /**\n     * @constructor\n     *\n     * Create a new task. Executor is run immediately. The canceler will be called when the task is canceled.\n     *\n     * @param executor Method that initiates some task\n     * @param canceler Method to call when the task is canceled\n     *\n     */\n    constructor(executor: Executor<T>, canceler?: () => void);\n    /**\n     * Propagates cancellation down through a Task tree. The Task's state is immediately set to canceled. If a Thenable\n     * finally task was passed in, it is resolved before calling this Task's finally callback; otherwise, this Task's\n     * finally callback is immediately executed. `_cancel` is called for each child Task, passing in the value returned\n     * by this Task's finally callback or a Promise chain that will eventually resolve to that value.\n     */\n    private _cancel(finallyTask?);\n    /**\n     * Immediately cancels this task if it has not already resolved. This Task and any descendants are synchronously set\n     * to the Canceled state and any `finally` added downstream from the canceled Task are invoked.\n     */\n    cancel(): void;\n    catch<TResult = never>(onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined): Task<T | TResult>;\n    /**\n     * Allows for cleanup actions to be performed after resolution of a Promise.\n     */\n    finally(callback: () => void): Task<T>;\n    /**\n     * Adds a callback to be invoked when the Task resolves or is rejected.\n     *\n     * @param onFulfilled   A function to call to handle the resolution. The paramter to the function will be the resolved value, if any.\n     * @param onRejected    A function to call to handle the error. The parameter to the function will be the caught error.\n     *\n     * @returns A task\n     */\n    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Task<TResult1 | TResult2>;\n}\n","type":2},{"name":"node_modules/@dojo/core/async/timing.d.ts","text":"import Promise from './ExtensiblePromise';\nimport { Thenable } from '@dojo/shim/interfaces';\n/**\n * Used for delaying a Promise chain for a specific number of milliseconds.\n *\n * @param milliseconds the number of milliseconds to delay\n * @return {function (value: T | (() => T | Thenable<T>)): Promise<T>} a function producing a promise that eventually returns the value or executes the value function passed to it; usable with Thenable.then()\n */\nexport declare function delay<T>(milliseconds: number): Identity<T>;\nexport interface Identity<T> {\n    (value?: T | (() => T | Thenable<T>)): Promise<T>;\n}\n/**\n * Reject a promise chain if a result hasn't been found before the timeout\n *\n * @param milliseconds after this number of milliseconds a rejection will be returned\n * @param reason The reason for the rejection\n * @return {function(T): Promise<T>} a function that produces a promise that is rejected or resolved based on your timeout\n */\nexport declare function timeout<T>(milliseconds: number, reason: Error): Identity<T>;\n/**\n * A Promise that will reject itself automatically after a time.\n * Useful for combining with other promises in Promise.race.\n */\nexport declare class DelayedRejection extends Promise<any> {\n    /**\n     * @param milliseconds the number of milliseconds to wait before triggering a rejection\n     * @param reason the reason for the rejection\n     */\n    constructor(milliseconds: number, reason?: Error);\n}\n","type":2},{"name":"node_modules/@dojo/core/base64.d.ts","text":"/**\n * Take a string encoded in base64 and decode it\n * @param encodedString The base64 encoded string\n */\nexport declare const decode: (encodedString: string) => string;\n/**\n * Take a string and encode it to base64\n * @param rawString The string to encode\n */\nexport declare const encode: (rawString: string) => string;\n","type":2},{"name":"node_modules/@dojo/core/compare.d.ts","text":"import Set from '@dojo/shim/Set';\nexport declare type IgnorePropertyFunction = (name: string, a: any, b: any) => boolean;\nexport interface DiffOptions {\n    /**\n     * Allow functions to be values.  Values will be considered equal if the `typeof` both values are `function`.\n     * When adding or updating the property, the value of the property of `a` will be used in the record, which\n     * will be a reference to the function.\n     */\n    allowFunctionValues?: boolean;\n    /**\n     * An array of strings or regular expressions which flag certain properties to be ignored.  Alternatively\n     * a function, which returns `true` to have the property ignored or `false` to diff the property.\n     */\n    ignoreProperties?: (string | RegExp)[] | IgnorePropertyFunction;\n    /**\n     * An array of strings or regular expressions which flag certain values to be ignored.  For flagged properties,\n     * if the property is present in both `a` and `b` the value will be ignored.  If adding the property,\n     * whatever the value of the property of `a` will be used, which could be a reference.\n     */\n    ignorePropertyValues?: (string | RegExp)[] | IgnorePropertyFunction;\n}\n/**\n * Interface for a generic constructor function\n */\nexport interface Constructor {\n    new (...args: any[]): object;\n    prototype: object;\n}\n/**\n * A partial property descriptor that provides the property descriptor flags supported by the\n * complex property construction of `patch()`\n *\n * All properties are value properties, with the value being supplied by the `ConstructRecord`\n */\nexport interface ConstructDescriptor {\n    /**\n     * Is the property configurable?\n     */\n    configurable?: boolean;\n    /**\n     * Is the property enumerable?\n     */\n    enumerable?: boolean;\n    /**\n     * Is the property configurable?\n     */\n    writable?: boolean;\n}\n/**\n * A record that describes a constructor function and arguments necessary to create an instance of\n * an object\n */\nexport interface AnonymousConstructRecord {\n    /**\n     * Any arguments to pass to the constructor function\n     */\n    args?: any[];\n    /**\n     * The constructor function to use to create the instance\n     */\n    Ctor: Constructor;\n    /**\n     * The partial descriptor that is used to set the value of the instance\n     */\n    descriptor?: ConstructDescriptor;\n    /**\n     * Any patches to properties that need to occur on the instance\n     */\n    propertyRecords?: (ConstructRecord | PatchRecord)[];\n}\nexport interface ConstructRecord extends AnonymousConstructRecord {\n    /**\n     * The name of the property on the Object\n     */\n    name: string;\n}\n/**\n * A record that describes the mutations necessary to a property of an object to make that property look\n * like another\n */\nexport declare type PatchRecord = {\n    /**\n     * The name of the property on the Object\n     */\n    name: string;\n    /**\n     * The type of the patch\n     */\n    type: 'delete';\n} | {\n    /**\n     * A property descriptor that describes the property in `name`\n     */\n    descriptor: PropertyDescriptor;\n    /**\n     * The name of the property on the Object\n     */\n    name: string;\n    /**\n     * The type of the patch\n     */\n    type: 'add' | 'update';\n    /**\n     * Additional patch records which describe the value of the property\n     */\n    valueRecords?: (ConstructRecord | PatchRecord | SpliceRecord)[];\n};\n/**\n * The different types of patch records supported\n */\nexport declare type PatchTypes = 'add' | 'update' | 'delete';\n/**\n * A record that describes a splice operation to perform on an array to make the array look like another array\n */\nexport interface SpliceRecord {\n    /**\n     * Any items that are being added to the array\n     */\n    add?: any[];\n    /**\n     * The number of items in the array to delete\n     */\n    deleteCount: number;\n    /**\n     * The type, set to `splice`\n     */\n    type: 'splice';\n    /**\n     * The index of where to start the splice\n     */\n    start: number;\n}\n/**\n * A record that describes how to instantiate a new object via a constructor function\n * @param Ctor The constructor function\n * @param args Any arguments to be passed to the constructor function\n */\nexport declare function createConstructRecord(Ctor: Constructor, args?: any[], descriptor?: ConstructDescriptor): AnonymousConstructRecord;\n/**\n * A function that returns a constructor record or `undefined` when diffing a value\n */\nexport declare type CustomDiffFunction<T> = (value: T, nameOrIndex: string | number, parent: object) => AnonymousConstructRecord | void;\n/**\n * A class which is used when making a custom comparison of a non-plain object or array\n */\nexport declare class CustomDiff<T> {\n    private _differ;\n    constructor(diff: CustomDiffFunction<T>);\n    /**\n     * Get the difference of the `value`\n     * @param value The value to diff\n     * @param nameOrIndex A `string` if comparing a property or a `number` if comparing an array element\n     * @param parent The outer parent that this value is part of\n     */\n    diff(value: T, nameOrIndex: string | number, parent: object): ConstructRecord | void;\n}\n/**\n * Takes two plain objects to be compared, as well as options customizing the behavior of the comparison, and returns\n * two new objects that contain only those properties that should be compared. If a property is ignored\n * it will not be included in either returned object. If a property's value should be ignored it will be excluded\n * if it is present in both objects.\n * @param a The first object to compare\n * @param b The second object to compare\n * @param options An options bag indicating which properties should be ignored or have their values ignored, if any.\n */\nexport declare function getComparableObjects(a: any, b: any, options: DiffOptions): {\n    comparableA: {\n        [key: string]: any;\n    };\n    comparableB: {\n        [key: string]: any;\n    };\n    ignore: Set<string>;\n};\n/**\n * Compares two plain objects or arrays and return a set of records which describe the differences between the two\n *\n * The records describe what would need to be applied to the second argument to make it look like the first argument\n *\n * @param a The plain object or array to compare with\n * @param b The plain object or array to compare to\n * @param options An options bag that allows configuration of the behaviour of `diff()`\n */\nexport declare function diff(a: any, b: any, options?: DiffOptions): (ConstructRecord | PatchRecord | SpliceRecord)[];\n/**\n * Apply a set of patch records to a target.\n *\n * @param target The plain object or array that the patch records should be applied to\n * @param records A set of patch records to be applied to the target\n */\nexport declare function patch(target: any, records: (ConstructRecord | PatchRecord | SpliceRecord)[]): any;\n","type":2},{"name":"node_modules/@dojo/core/DateObject.d.ts","text":"export interface KwArgs {\n    dayOfMonth?: number;\n    hours?: number;\n    milliseconds?: number;\n    minutes?: number;\n    month: number;\n    seconds?: number;\n    year: number;\n}\nexport interface OperationKwArgs {\n    days?: number;\n    hours?: number;\n    milliseconds?: number;\n    minutes?: number;\n    months?: number;\n    seconds?: number;\n    years?: number;\n}\n/**\n * The properties of a complete date\n */\nexport interface DateProperties {\n    dayOfMonth: number;\n    readonly dayOfWeek: number;\n    readonly daysInMonth: number;\n    hours: number;\n    readonly isLeapYear: boolean;\n    milliseconds: number;\n    minutes: number;\n    month: number;\n    seconds: number;\n    year: number;\n}\nexport default class DateObject implements DateProperties {\n    static parse(str: string): DateObject;\n    static now(): DateObject;\n    private readonly _date;\n    readonly utc: DateProperties;\n    constructor(value: number);\n    constructor(value: string);\n    constructor(value: Date);\n    constructor(value: KwArgs);\n    constructor();\n    readonly isLeapYear: boolean;\n    readonly daysInMonth: number;\n    year: number;\n    month: number;\n    dayOfMonth: number;\n    hours: number;\n    minutes: number;\n    seconds: number;\n    milliseconds: number;\n    time: number;\n    readonly dayOfWeek: number;\n    readonly timezoneOffset: number;\n    add(value: number): DateObject;\n    add(value: OperationKwArgs): DateObject;\n    compare(value: DateObject): number;\n    compareDate(value: KwArgs): number;\n    compareTime(value: KwArgs): number;\n    toString(): string;\n    toDateString(): string;\n    toTimeString(): string;\n    toLocaleString(): string;\n    toLocaleDateString(): string;\n    toLocaleTimeString(): string;\n    toISOString(): string;\n    toJSON(key?: any): string;\n    valueOf(): number;\n}\n","type":2},{"name":"node_modules/@dojo/core/Destroyable.d.ts","text":"import { Handle } from '@dojo/interfaces/core';\nexport declare class Destroyable {\n    /**\n     * register handles for the instance\n     */\n    private handles;\n    /**\n     * @constructor\n     */\n    constructor();\n    /**\n     * Register handles for the instance that will be destroyed when `this.destroy` is called\n     *\n     * @param {Handle} handle The handle to add for the instance\n     * @returns {Handle} a handle for the handle, removes the handle for the instance and calls destroy\n     */\n    own(handle: Handle): Handle;\n    /**\n     * Destrpys all handers registered for the instance\n     *\n     * @returns {Promise<any} a promise that resolves once all handles have been destroyed\n     */\n    destroy(): Promise<any>;\n}\nexport default Destroyable;\n","type":2},{"name":"node_modules/@dojo/core/Evented.d.ts","text":"import { EventedListenerOrArray, EventedListenersMap } from '@dojo/interfaces/bases';\nimport { EventTargettedObject, EventErrorObject, Handle } from '@dojo/interfaces/core';\nimport Map from '@dojo/shim/Map';\nimport { Destroyable } from './Destroyable';\n/**\n * The base event object, which provides a `type` property\n */\nexport interface EventObject {\n    /**\n     * The type of the event\n     */\n    readonly type: string | symbol;\n}\nexport interface EventedCallback<E extends EventObject> {\n    /**\n     * A callback that takes an `event` argument\n     *\n     * @param event The event object\n     */\n    (event: E): boolean | void;\n}\n/**\n * Interface for Evented constructor options\n */\nexport interface EventedOptions {\n    /**\n     * Optional listeners to add\n     */\n    listeners?: EventedListenersMap<any>;\n}\nexport interface BaseEventedEvents {\n    /**\n     * Regsister a callback for a specific event type\n     *\n     * @param listeners map of listeners\n     */\n    (listeners: EventedListenersMap<Evented>): Handle;\n    /**\n     * @param type the type of the event\n     * @param listener the listener to attach\n     */\n    (type: string | symbol, listener: EventedListenerOrArray<Evented, EventTargettedObject<Evented>>): Handle;\n    /**\n     * @param type the type for `error`\n     * @param listener the listener to attach\n     */\n    (type: 'error', listener: EventedListenerOrArray<Evented, EventErrorObject<Evented>>): Handle;\n}\nexport interface Evented {\n    on: BaseEventedEvents;\n}\n/**\n * Determines is the event type glob has been matched\n *\n * @returns boolean that indicates if the glob is matched\n */\nexport declare function isGlobMatch(globString: string | symbol, targetString: string | symbol): boolean;\n/**\n * Event Class\n */\nexport declare class Evented extends Destroyable implements Evented {\n    /**\n     * map of listeners keyed by event type\n     */\n    protected listenersMap: Map<string, EventedCallback<EventObject>>;\n    /**\n     * @constructor\n     * @param options The constructor argurments\n     */\n    constructor(options?: EventedOptions);\n    /**\n     * Emits the event objet for the specified type\n     *\n     * @param event the event to emit\n     */\n    emit<E extends EventObject>(event: E): void;\n    /**\n     * Catch all handler for various call signatures. The signatures are defined in\n     * `BaseEventedEvents`.  You can add your own event type -> handler types by extending\n     * `BaseEventedEvents`.  See example for details.\n     *\n     * @param args\n     *\n     * @example\n     *\n     * interface WidgetBaseEvents extends BaseEventedEvents {\n     *     (type: 'properties:changed', handler: PropertiesChangedHandler): Handle;\n     * }\n     * class WidgetBase extends Evented {\n     *    on: WidgetBaseEvents;\n     * }\n     *\n     * @return {any}\n     */\n    on: BaseEventedEvents;\n}\nexport default Evented;\n","type":2},{"name":"node_modules/@dojo/core/global.d.ts","text":"import globalObject from '@dojo/shim/global';\nexport default globalObject;\n","type":2},{"name":"node_modules/@dojo/core/has.d.ts","text":"import has from '@dojo/shim/support/has';\nexport * from '@dojo/shim/support/has';\nexport default has;\n","type":2},{"name":"node_modules/@dojo/core/IdentityRegistry.d.ts","text":"import { Iterable, IterableIterator } from '@dojo/shim/iterator';\nimport { Handle } from '@dojo/interfaces/core';\nimport '@dojo/shim/Symbol';\n/**\n * Registry identities can be strings or symbols. Note that the empty string is allowed.\n */\nexport declare type Identity = string | symbol;\n/**\n * A registry of values, mapped by identities.\n */\nexport default class IdentityRegistry<V extends object> implements Iterable<[Identity, V]> {\n    constructor();\n    /**\n     * Look up a value by its identifier.\n     *\n     * Throws if no value has been registered for the given identifier.\n     *\n     * @param id The identifier\n     * @return The value\n     */\n    get(id: Identity): V;\n    /**\n     * Determine whether the value has been registered.\n     * @param value The value\n     * @return `true` if the value has been registered, `false` otherwise\n     */\n    contains(value: V): boolean;\n    /**\n     * Remove from the registry the value for a given identifier.\n     * @param id The identifier\n     * @return `true` if the value was removed, `false` otherwise\n     */\n    delete(id: Identity): boolean;\n    /**\n     * Determine whether a value has been registered for the given identifier.\n     * @param id The identifier\n     * @return `true` if a value has been registered, `false` otherwise\n     */\n    has(id: Identity): boolean;\n    /**\n     * Look up the identifier for which the given value has been registered.\n     *\n     * Throws if the value hasn't been registered.\n     *\n     * @param value The value\n     * @return The identifier otherwise\n     */\n    identify(value: V): Identity | undefined;\n    /**\n     * Register a new value with a new identity.\n     *\n     * Throws if a different value has already been registered for the given identity,\n     * or if the value has already been registered with a different identity.\n     *\n     * @param id The identifier\n     * @param value The value\n     * @return A handle for deregistering the value. Note that when called repeatedly with\n     *   the same identifier and value combination, the same handle is returned\n     */\n    register(id: Identity, value: V): Handle;\n    entries(): IterableIterator<[Identity, V]>;\n    values(): IterableIterator<V>;\n    ids(): IterableIterator<Identity>;\n    [Symbol.iterator](): IterableIterator<[Identity, V]>;\n}\n","type":2},{"name":"node_modules/@dojo/core/instrument.d.ts","text":"export interface DeprecatedOptions {\n    /**\n     * The message to use when warning\n     */\n    message?: string;\n    /**\n     * The name of the method or function to use\n     */\n    name?: string;\n    /**\n     * An alternative function to log the warning to\n     */\n    warn?: (...args: any[]) => void;\n    /**\n     * Reference an URL for more information when warning\n     */\n    url?: string;\n}\n/**\n * A function that will console warn that a function has been deprecated\n *\n * @param options Provide options which change the display of the message\n */\nexport declare function deprecated({message, name, warn, url}?: DeprecatedOptions): void;\n/**\n * A function that generates before advice that can be used to warn when an API has been deprecated\n *\n * @param options Provide options which change the display of the message\n */\nexport declare function deprecatedAdvice(options?: DeprecatedOptions): (...args: any[]) => any[];\n/**\n * A method decorator that will console warn when a method if invoked that is deprecated\n *\n * @param options Provide options which change the display of the message\n */\nexport declare function deprecatedDecorator(options?: DeprecatedOptions): MethodDecorator;\n/**\n * A function that will set the warn function that will be used instead of `console.warn` when\n * logging warning messages\n *\n * @param warn The function (or `undefined`) to use instead of `console.warn`\n */\nexport declare function setWarn(warn?: ((message?: any, ...optionalParams: any[]) => void)): void;\n","type":2},{"name":"node_modules/@dojo/core/interfaces.d.ts","text":"/**\n * A general interface that can be used to renference a general index map of values of a particular type\n */\nexport interface Hash<T> {\n    [id: string]: T;\n}\n/**\n * A base map of styles where each key is the name of the style attribute and the value is a string\n * which represents the style\n */\nexport interface StylesMap {\n    [style: string]: string;\n}\n","type":2},{"name":"node_modules/@dojo/core/lang.d.ts","text":"import { Handle } from '@dojo/interfaces/core';\nexport { assign } from '@dojo/shim/object';\n/**\n * Creates a new object from the given prototype, and copies all enumerable own properties of one or more\n * source objects to the newly created target object.\n *\n * @param prototype The prototype to create a new object from\n * @param mixins Any number of objects whose enumerable own properties will be copied to the created object\n * @return The new object\n */\nexport declare function create<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(prototype: T, mixin1: U, mixin2: V, mixin3: W, mixin4: X, mixin5: Y, mixin6: Z): T & U & V & W & X & Y & Z;\nexport declare function create<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(prototype: T, mixin1: U, mixin2: V, mixin3: W, mixin4: X, mixin5: Y): T & U & V & W & X & Y;\nexport declare function create<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(prototype: T, mixin1: U, mixin2: V, mixin3: W, mixin4: X): T & U & V & W & X;\nexport declare function create<T extends {}, U extends {}, V extends {}, W extends {}>(prototype: T, mixin1: U, mixin2: V, mixin3: W): T & U & V & W;\nexport declare function create<T extends {}, U extends {}, V extends {}>(prototype: T, mixin1: U, mixin2: V): T & U & V;\nexport declare function create<T extends {}, U extends {}>(prototype: T, mixin: U): T & U;\nexport declare function create<T extends {}>(prototype: T): T;\n/**\n * Copies the values of all enumerable own properties of one or more source objects to the target object,\n * recursively copying all nested objects and arrays as well.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable own properties will be copied to the target object\n * @return The modified target object\n */\nexport declare function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y, source6: Z): T & U & V & W & X & Y & Z;\nexport declare function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y): T & U & V & W & X & Y;\nexport declare function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(target: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\nexport declare function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport declare function deepAssign<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport declare function deepAssign<T extends {}, U extends {}>(target: T, source: U): T & U;\n/**\n * Copies the values of all enumerable (own or inherited) properties of one or more source objects to the\n * target object, recursively copying all nested objects and arrays as well.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable properties will be copied to the target object\n * @return The modified target object\n */\nexport declare function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y, source6: Z): T & U & V & W & X & Y & Z;\nexport declare function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y): T & U & V & W & X & Y;\nexport declare function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(target: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\nexport declare function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport declare function deepMixin<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport declare function deepMixin<T extends {}, U extends {}>(target: T, source: U): T & U;\n/**\n * Creates a new object using the provided source's prototype as the prototype for the new object, and then\n * deep copies the provided source's values into the new target.\n *\n * @param source The object to duplicate\n * @return The new object\n */\nexport declare function duplicate<T extends {}>(source: T): T;\n/**\n * Determines whether two values are the same value.\n *\n * @param a First value to compare\n * @param b Second value to compare\n * @return true if the values are the same; false otherwise\n */\nexport declare function isIdentical(a: any, b: any): boolean;\n/**\n * Returns a function that binds a method to the specified object at runtime. This is similar to\n * `Function.prototype.bind`, but instead of a function it takes the name of a method on an object.\n * As a result, the function returned by `lateBind` will always call the function currently assigned to\n * the specified property on the object as of the moment the function it returns is called.\n *\n * @param instance The context object\n * @param method The name of the method on the context object to bind to itself\n * @param suppliedArgs An optional array of values to prepend to the `instance[method]` arguments list\n * @return The bound function\n */\nexport declare function lateBind(instance: {}, method: string, ...suppliedArgs: any[]): (...args: any[]) => any;\n/**\n * Copies the values of all enumerable (own or inherited) properties of one or more source objects to the\n * target object.\n *\n * @return The modified target object\n */\nexport declare function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y, source6: Z): T & U & V & W & X & Y & Z;\nexport declare function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y): T & U & V & W & X & Y;\nexport declare function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(target: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\nexport declare function mixin<T extends {}, U extends {}, V extends {}, W extends {}>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport declare function mixin<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport declare function mixin<T extends {}, U extends {}>(target: T, source: U): T & U;\n/**\n * Returns a function which invokes the given function with the given arguments prepended to its argument list.\n * Like `Function.prototype.bind`, but does not alter execution context.\n *\n * @param targetFunction The function that needs to be bound\n * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list\n * @return The bound function\n */\nexport declare function partial(targetFunction: (...args: any[]) => any, ...suppliedArgs: any[]): (...args: any[]) => any;\n/**\n * Returns an object with a destroy method that, when called, calls the passed-in destructor.\n * This is intended to provide a unified interface for creating \"remove\" / \"destroy\" handlers for\n * event listeners, timers, etc.\n *\n * @param destructor A function that will be called when the handle's `destroy` method is invoked\n * @return The handle object\n */\nexport declare function createHandle(destructor: () => void): Handle;\n/**\n * Returns a single handle that can be used to destroy multiple handles simultaneously.\n *\n * @param handles An array of handles with `destroy` methods\n * @return The handle object\n */\nexport declare function createCompositeHandle(...handles: Handle[]): Handle;\n","type":2},{"name":"node_modules/@dojo/core/List.d.ts","text":"import { Iterable, IterableIterator } from '@dojo/shim/iterator';\nexport default class List<T> {\n    [Symbol.iterator](): IterableIterator<T>;\n    readonly size: number;\n    constructor(source?: Iterable<T> | ArrayLike<T>);\n    add(value: T): this;\n    clear(): void;\n    delete(idx: number): boolean;\n    entries(): IterableIterator<[number, T]>;\n    forEach(fn: (value: T, idx: number, list: this) => void, thisArg?: any): void;\n    has(idx: number): boolean;\n    includes(value: T): boolean;\n    indexOf(value: T): number;\n    join(separator?: string): string;\n    keys(): IterableIterator<number>;\n    lastIndexOf(value: T): number;\n    push(value: T): void;\n    pop(): T | undefined;\n    splice(start: number, deleteCount?: number, ...newItems: T[]): T[];\n    values(): IterableIterator<T>;\n}\n","type":2},{"name":"node_modules/@dojo/core/load.d.ts","text":"import { Require } from '@dojo/interfaces/loader';\nimport { isPlugin, useDefault } from './load/util';\nexport interface NodeRequire {\n    (moduleId: string): any;\n}\nexport declare type Require = Require | NodeRequire;\nexport interface Load {\n    (require: Require, ...moduleIds: string[]): Promise<any[]>;\n    (...moduleIds: string[]): Promise<any[]>;\n}\ndeclare const load: Load;\nexport default load;\nexport { isPlugin, useDefault };\n","type":2},{"name":"node_modules/@dojo/core/load/util.d.ts","text":"import { Load } from '../load';\nexport interface LoadPlugin<T> {\n    /**\n     * An optional method that normmalizes a resource id.\n     *\n     * @param resourceId\n     * The raw resource id.\n     *\n     * @param resolver\n     * A method that can resolve an id to an absolute path. Depending on the environment, this will\n     * usually be either `require.toUrl` or `require.resolve`.\n     */\n    normalize?: (resourceId: string, resolver: (resourceId: string) => string) => string;\n    /**\n     * A method that loads the specified resource.\n     *\n     * @param resourceId\n     * The id of the resource to load.\n     *\n     * @param load\n     * The `load` method that was used to load and execute the plugin.\n     *\n     * @return\n     * A promise that resolves to the loaded resource.\n     */\n    load(resourceId: string, load: Load): Promise<T>;\n}\nexport declare function isPlugin(value: any): value is LoadPlugin<any>;\nexport declare function useDefault(modules: any[]): any[];\nexport declare function useDefault(module: any): any;\n","type":2},{"name":"node_modules/@dojo/core/load/webpack.d.ts","text":"import { isPlugin, useDefault } from './util';\n/**\n * A webpack-specific function that replaces `@dojo/core/load` in its builds. In order for a module to be loaded,\n * it must first be included in a webpack chunk, whether that chunk is included in the main build, or lazy-loaded.\n * Note that this module is not intended for direct use, but rather is intended for use by a webpack plugin\n * that sets the module ID map used to translate resolved module paths to webpack module IDs.\n *\n * @param contextRequire\n * An optional function that returns the base path to use when resolving relative module IDs.\n *\n * @param ...mids\n * One or more IDs for modules to load.\n *\n * @return\n * A promise to the loaded module values.\n */\nexport default function load(contextRequire: () => string, ...mids: string[]): Promise<any[]>;\nexport default function load(...mids: string[]): Promise<any[]>;\nexport { isPlugin, useDefault };\n","type":2},{"name":"node_modules/@dojo/core/main.d.ts","text":"import * as aspect from './aspect';\nimport DateObject from './DateObject';\nimport Evented from './Evented';\nimport IdentityRegistry from './IdentityRegistry';\nimport * as lang from './lang';\nimport * as base64 from './base64';\nimport load from './load';\nimport MatchRegistry from './MatchRegistry';\nimport on, { emit } from './on';\nimport * as queue from './queue';\nimport request from './request';\nimport Scheduler from './Scheduler';\nimport * as stringExtras from './stringExtras';\nimport * as text from './text';\nimport UrlSearchParams from './UrlSearchParams';\nimport * as util from './util';\nimport * as iteration from './async/iteration';\nimport Task from './async/Task';\nimport * as timing from './async/timing';\ndeclare const async: {\n    iteration: typeof iteration;\n    Task: typeof Task;\n    timing: typeof timing;\n};\nexport { aspect, async, base64, DateObject, emit, Evented, IdentityRegistry, lang, load, MatchRegistry, on, queue, request, Scheduler, stringExtras, text, UrlSearchParams, util };\n","type":2},{"name":"node_modules/@dojo/core/MatchRegistry.d.ts","text":"import { Handle } from '@dojo/interfaces/core';\n/**\n * A registry of values tagged with matchers.\n */\nexport default class MatchRegistry<T> {\n    protected _defaultValue: T | undefined;\n    private readonly _entries;\n    /**\n     * Construct a new MatchRegistry, optionally containing a given default value.\n     */\n    constructor(defaultValue?: T);\n    /**\n     * Return the first entry in this registry that matches the given arguments. If no entry matches and the registry\n     * was created with a default value, that value will be returned. Otherwise, an exception is thrown.\n     *\n     * @param ...args Arguments that will be used to select a matching value.\n     * @returns the matching value, or a default value if one exists.\n     */\n    match(...args: any[]): T;\n    /**\n     * Register a test + value pair with this registry.\n     *\n     * @param test The test that will be used to determine if the registered value matches a set of arguments.\n     * @param value A value being registered.\n     * @param first If true, the newly registered test and value will be the first entry in the registry.\n     */\n    register(test: Test | null, value: T | null, first?: boolean): Handle;\n}\n/**\n * The interface that a test function must implement.\n */\nexport interface Test {\n    (...args: any[]): boolean | null;\n}\n","type":2},{"name":"node_modules/@dojo/core/MultiMap.d.ts","text":"import { Iterable, IterableIterator } from '@dojo/shim/iterator';\nimport Map from '@dojo/shim/Map';\nimport '@dojo/shim/Symbol';\n/**\n * A map implmentation that supports multiple keys for specific value.\n *\n * @param T Accepts the type of the value\n */\nexport default class MultiMap<T> implements Map<any[], T> {\n    private _map;\n    private _key;\n    /**\n     * @constructor\n     *\n     * @param iterator an array or iterator of tuples to initialize the map with.\n     */\n    constructor(iterable?: ArrayLike<[any[], T]> | Iterable<[any[], T]>);\n    /**\n     * Sets the value for the array of keys provided\n     *\n     * @param keys The array of keys to store the value against\n     * @param value the value of the map entry\n     *\n     * @return the multi map instance\n     */\n    set(keys: any[], value: T): this;\n    /**\n     * Returns the value entry for the array of keys\n     *\n     * @param keys The array of keys to look up the value for\n     *\n     * @return The value if found otherwise `undefined`\n     */\n    get(keys: any[]): T | undefined;\n    /**\n     * Returns a boolean indicating if the key exists in the map\n     *\n     * @return boolean true if the key exists otherwise false\n     */\n    has(keys: any[]): boolean;\n    /**\n     * Returns the size of the map, based on the number of unique keys\n     */\n    readonly size: number;\n    /**\n     * Deletes the entry for the key provided.\n     *\n     * @param keys the key of the entry to remove\n     * @return boolean trus if the entry was deleted, false if the entry was not found\n     */\n    delete(keys: any[]): boolean;\n    /**\n     * Return an iterator that yields each value in the map\n     *\n     * @return An iterator containing the instance's values.\n     */\n    values(): IterableIterator<T>;\n    /**\n     * Return an iterator that yields each key array in the map\n     *\n     * @return An iterator containing the instance's keys.\n     */\n    keys(): IterableIterator<any[]>;\n    /**\n     * Returns an iterator that yields each key/value pair as an array.\n     *\n     * @return An iterator for each key/value pair in the instance.\n     */\n    entries(): IterableIterator<[any[], T]>;\n    /**\n     * Executes a given function for each map entry. The function\n     * is invoked with three arguments: the element value, the\n     * element key, and the associated Map instance.\n     *\n     * @param callback The function to execute for each map entry,\n     * @param context The value to use for `this` for each execution of the calback\n     */\n    forEach(callback: (value: T, key: any[], mapInstance: MultiMap<T>) => any, context?: {}): void;\n    /**\n     * Deletes all keys and their associated values.\n     */\n    clear(): void;\n    [Symbol.iterator](): IterableIterator<[any[], T]>;\n    [Symbol.toStringTag]: string;\n}\n","type":2},{"name":"node_modules/@dojo/core/Observable.d.ts","text":"import ObservableShim, { ObservableObject, Subscribable, SubscriptionObserver } from '@dojo/shim/Observable';\nimport { Iterable } from '@dojo/shim/iterator';\nexport default class Observable<T> extends ObservableShim<T> {\n    static of<T>(...items: T[]): Observable<T>;\n    static from<T>(item: Iterable<T> | ArrayLike<T> | ObservableObject): Observable<T>;\n    static defer<T>(deferFunction: () => Subscribable<T>): Observable<T>;\n    toPromise(): Promise<T>;\n    map<U>(mapFunction: (x: T) => U): Observable<U>;\n    filter(filterFunction: (x: T) => boolean): Observable<T>;\n    toArray(): Observable<T[]>;\n    mergeAll(concurrent: number): Observable<any>;\n}\nexport { Observable, Subscribable, SubscriptionObserver as Observer };\n","type":2},{"name":"node_modules/@dojo/core/on.d.ts","text":"import { Handle } from '@dojo/interfaces/core';\nimport Evented, { EventObject } from './Evented';\nexport interface EventCallback {\n    (event: EventObject): void;\n}\nexport interface EventEmitter {\n    on(event: string, listener: EventCallback): EventEmitter;\n    removeListener(event: string, listener: EventCallback): EventEmitter;\n}\n/**\n * Provides a normalized mechanism for dispatching events for event emitters, Evented objects, or DOM nodes.\n * @param target The target to emit the event from\n * @param event The event object to emit\n * @return Boolean indicating if preventDefault was called on the event object (only relevant for DOM events;\n *     always false for other event emitters)\n */\nexport declare function emit<T extends EventObject>(target: Evented | EventTarget | EventEmitter, event: T | EventObject): boolean;\n/**\n * Provides a normalized mechanism for listening to events from event emitters, Evented objects, or DOM nodes.\n * @param target Target to listen for event on\n * @param type Event event type(s) to listen for; may a string or an array of strings\n * @param listener Callback to handle the event when it fires\n * @param capture Whether the listener should be registered in the capture phase (DOM events only)\n * @return A handle which will remove the listener when destroy is called\n */\nexport default function on(target: EventTarget, type: string | string[], listener: EventCallback, capture?: boolean): Handle;\nexport default function on(target: EventEmitter | Evented, type: string | string[], listener: EventCallback): Handle;\n/**\n * Provides a mechanism for listening to the next occurrence of an event from event\n * emitters, Evented objects, or DOM nodes.\n * @param target Target to listen for event on\n * @param type Event event type(s) to listen for; may be a string or an array of strings\n * @param listener Callback to handle the event when it fires\n * @param capture Whether the listener should be registered in the capture phase (DOM events only)\n * @return A handle which will remove the listener when destroy is called\n */\nexport declare function once(target: EventTarget, type: string | string[], listener: EventCallback, capture?: boolean): Handle;\nexport declare function once(target: EventEmitter | Evented, type: string | string[], listener: EventCallback): Handle;\nexport interface PausableHandle extends Handle {\n    pause(): void;\n    resume(): void;\n}\n/**\n * Provides a mechanism for creating pausable listeners for events from event emitters, Evented objects, or DOM nodes.\n * @param target Target to listen for event on\n * @param type Event event type(s) to listen for; may a string or an array of strings\n * @param listener Callback to handle the event when it fires\n * @param capture Whether the listener should be registered in the capture phase (DOM events only)\n * @return A handle with additional pause and resume methods; the listener will never fire when paused\n */\nexport declare function pausable(target: EventTarget, type: string | string[], listener: EventCallback, capture?: boolean): PausableHandle;\nexport declare function pausable(target: EventEmitter | Evented, type: string | string[], listener: EventCallback): PausableHandle;\n","type":2},{"name":"node_modules/@dojo/core/queue.d.ts","text":"export * from '@dojo/shim/support/queue';\n","type":2},{"name":"node_modules/@dojo/core/QueuingEvented.d.ts","text":"import Evented, { EventObject } from './Evented';\n/**\n * An implementation of the Evented class that queues up events when no listeners are\n * listening. When a listener is subscribed, the queue will be published to the listener.\n * When the queue is full, the oldest events will be discarded to make room for the newest ones.\n *\n * @property maxEvents  The number of events to queue before old events are discarded. If zero (default), an unlimited number of events is queued.\n */\nexport default class QueuingEvented extends Evented {\n    private _queue;\n    private _originalOn;\n    maxEvents: number;\n    constructor();\n    emit<E extends EventObject>(event: E): void;\n}\n","type":2},{"name":"node_modules/@dojo/core/request.d.ts","text":"import Task from './async/Task';\nimport { RequestOptions, Response, Provider, UploadObservableTask } from './request/interfaces';\nimport ProviderRegistry from './request/ProviderRegistry';\nexport declare const providerRegistry: ProviderRegistry;\ndeclare const request: {\n    (url: string, options?: RequestOptions): Task<Response>;\n    delete(url: string, options?: RequestOptions): Task<Response>;\n    get(url: string, options?: RequestOptions): Task<Response>;\n    head(url: string, options?: RequestOptions): Task<Response>;\n    options(url: string, options?: RequestOptions): Task<Response>;\n    post(url: string, options?: RequestOptions): UploadObservableTask<Response>;\n    put(url: string, options?: RequestOptions): UploadObservableTask<Response>;\n    setDefaultProvider(provider: Provider): void;\n};\nexport default request;\nexport * from './request/interfaces';\nexport { default as Headers } from './request/Headers';\nexport { default as TimeoutError } from './request/TimeoutError';\nexport { default as Response, ResponseData } from './request/Response';\n","type":2},{"name":"node_modules/@dojo/core/request/Headers.d.ts","text":"import { Headers as HeadersInterface } from './interfaces';\nimport { IterableIterator } from '@dojo/shim/iterator';\nimport Map from '@dojo/shim/Map';\nexport default class Headers implements HeadersInterface {\n    protected map: Map<string, string[]>;\n    constructor(headers?: {\n        [key: string]: string;\n    } | HeadersInterface);\n    append(name: string, value: string): void;\n    delete(name: string): void;\n    entries(): IterableIterator<[string, string]>;\n    get(name: string): string | null;\n    getAll(name: string): string[];\n    has(name: string): boolean;\n    keys(): IterableIterator<string>;\n    set(name: string, value: string): void;\n    values(): IterableIterator<string>;\n    [Symbol.iterator](): IterableIterator<[string, string]>;\n}\n","type":2},{"name":"node_modules/@dojo/core/request/interfaces.d.ts","text":"import { IterableIterator } from '@dojo/shim/iterator';\nimport Task from '../async/Task';\nimport UrlSearchParams, { ParamList } from '../UrlSearchParams';\nimport Observable from '../Observable';\n\nexport interface Body {\n\treadonly bodyUsed: boolean;\n\n\tarrayBuffer(): Task<ArrayBuffer>;\n\tblob(): Task<Blob>;\n\tformData(): Task<FormData>;\n\tjson<T>(): Task<T>;\n\ttext(): Task<string>;\n}\n\nexport interface Headers {\n\tappend(name: string, value: string): void;\n\tdelete(name: string): void;\n\tentries(): IterableIterator<[string, string]>;\n\tget(name: string): string | null;\n\tgetAll(name: string): string[];\n\thas(name: string): boolean;\n\tkeys(): IterableIterator<string>;\n\tset(name: string, value: string): void;\n\tvalues(): IterableIterator<string>;\n\t[Symbol.iterator](): IterableIterator<[string, string]>;\n}\n\nexport interface UploadObservableTask<T> extends Task<T> {\n\tupload: Observable<number>;\n}\n\nexport type Provider = (url: string, options?: RequestOptions) => UploadObservableTask<Response>;\n\nexport type ProviderTest = (url: string, options?: RequestOptions) => boolean | null;\n\nexport interface RequestOptions {\n\t/**\n\t * Enable cache busting (default false). Cache busting will make a new URL by appending a parameter to the\n\t * requested URL\n\t */\n\tcacheBust?: boolean;\n\tcredentials?: 'omit' | 'same-origin' | 'include';\n\t/**\n\t * Body to send along with the http request\n\t */\n\tbody?: Blob | BufferSource | FormData | UrlSearchParams | string;\n\t/**\n\t * Headers to send along with the http request\n\t */\n\theaders?: Headers | { [key: string]: string; };\n\t/**\n\t * HTTP method\n\t */\n\tmethod?: string;\n\t/**\n\t * Password for HTTP authentication\n\t */\n\tpassword?: string;\n\t/**\n\t * Number of milliseconds before the request times out and is canceled\n\t */\n\ttimeout?: number;\n\t/**\n\t * User for HTTP authentication\n\t */\n\tuser?: string;\n\t/**\n\t * Optional query parameter(s) for the URL. The requested url will have these query parameters appended.\n\t */\n\tquery?: string | ParamList;\n}\n\nexport interface Response extends Body {\n\treadonly headers: Headers;\n\treadonly ok: boolean;\n\treadonly status: number;\n\treadonly statusText: string;\n\treadonly url: string;\n\n\treadonly download: Observable<number>;\n\treadonly data: Observable<any>;\n}\n","type":2},{"name":"node_modules/@dojo/core/request/ProviderRegistry.d.ts","text":"import { Provider, ProviderTest } from './interfaces';\nimport MatchRegistry from '../MatchRegistry';\nimport { Handle } from '@dojo/interfaces/core';\nexport default class ProviderRegistry extends MatchRegistry<Provider> {\n    setDefaultProvider(provider: Provider): void;\n    register(test: string | RegExp | ProviderTest | null, value: Provider, first?: boolean): Handle;\n}\n","type":2},{"name":"node_modules/@dojo/core/request/providers/node.d.ts","text":"/// <reference types=\"node\" />\nimport * as http from 'http';\nimport Task from '../../async/Task';\nimport Headers from '../Headers';\nimport { RequestOptions, UploadObservableTask } from '../interfaces';\nimport Response from '../Response';\nimport { Readable } from 'stream';\nimport Observable from '../../Observable';\n/**\n * Request options specific to a node request. For HTTPS options, see\n * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback for more details.\n */\nexport interface NodeRequestOptions extends RequestOptions {\n    /**\n     * User-agent header\n     */\n    agent?: any;\n    /**\n     * If specified, the request body is read from the stream specified here, rather than from the `body` field.\n     */\n    bodyStream?: Readable;\n    /**\n     * HTTPS optionally override the trusted CA certificates\n     */\n    ca?: any;\n    /**\n     * HTTPS optional cert chains in PEM format. One cert chain should be provided per private key.\n     */\n    cert?: string;\n    /**\n     * HTTPS optional cipher suite specification\n     */\n    ciphers?: string;\n    dataEncoding?: string;\n    /**\n     * Whether or not to automatically follow redirects (default true)\n     */\n    followRedirects?: boolean;\n    /**\n     * HTTPS optional private key in PEM format.\n     */\n    key?: string;\n    /**\n     * Local interface to bind for network connections.\n     */\n    localAddress?: string;\n    /**\n     * HTTPS optional shared passphrase used for a single private key and/or a PFX.\n     */\n    passphrase?: string;\n    /**\n     * HTTPS optional PFX or PKCS12 encoded private key and certificate chain.\n     */\n    pfx?: any;\n    /**\n     * Optional proxy address. If specified, requests will be sent through this url.\n     */\n    proxy?: string;\n    /**\n     * HTTPS If not false the server will reject any connection which is not authorized with the list of supplied CAs\n     */\n    rejectUnauthorized?: boolean;\n    /**\n     * HTTPS optional SSL method to use, default is \"SSLv23_method\"\n     */\n    secureProtocol?: string;\n    /**\n     * Unix Domain Socket (use one of host:port or socketPath)\n     */\n    socketPath?: string;\n    /**\n     * Whether or not to add the gzip and deflate accept headers (default true)\n     */\n    acceptCompression?: boolean;\n    /**\n     * A set of options to set on the HTTP request\n     */\n    socketOptions?: {\n        /**\n         * Enable/disable keep-alive functionality, and optionally set the initial delay before the first keepalive probe is sent on an idle socket.\n         */\n        keepAlive?: number;\n        /**\n         * Disables the Nagle algorithm. By default TCP connections use the Nagle algorithm, they buffer data before sending it off.\n         */\n        noDelay?: boolean;\n        /**\n         * Number of milliseconds before the HTTP request times out\n         */\n        timeout?: number;\n    };\n    /**\n     * Stream encoding on incoming HTTP response\n     */\n    streamEncoding?: string;\n    /**\n     * Options to control redirect follow logic\n     */\n    redirectOptions?: {\n        /**\n         * The limit to the number of redirects that will be followed (default 15). This is used to prevent infinite\n         * redirect loops.\n         */\n        limit?: number;\n        count?: number;\n        /**\n         * Whether or not to keep the original HTTP method during 301 redirects (default false).\n         */\n        keepOriginalMethod?: boolean;\n    };\n}\n/**\n * Turn a node native response object into something that resembles the fetch api\n */\nexport declare class NodeResponse extends Response {\n    readonly headers: Headers;\n    readonly ok: boolean;\n    readonly status: number;\n    readonly statusText: string;\n    downloadBody: boolean;\n    readonly bodyUsed: boolean;\n    readonly nativeResponse: http.IncomingMessage;\n    readonly requestOptions: NodeRequestOptions;\n    readonly url: string;\n    readonly download: Observable<number>;\n    readonly data: Observable<any>;\n    constructor(response: http.IncomingMessage);\n    arrayBuffer(): Task<ArrayBuffer>;\n    blob(): Task<Blob>;\n    formData(): Task<FormData>;\n    text(): Task<string>;\n}\nexport declare function getAuth(proxyAuth: string | undefined, options: NodeRequestOptions): string | undefined;\nexport default function node(url: string, options?: NodeRequestOptions): UploadObservableTask<Response>;\n","type":2},{"name":"node_modules/@dojo/core/request/providers/xhr.d.ts","text":"import Task from '../../async/Task';\nimport Observable from '../../Observable';\nimport Headers from '../Headers';\nimport { RequestOptions, UploadObservableTask } from '../interfaces';\nimport Response from '../Response';\n/**\n * Request options specific to an XHR request\n */\nexport interface XhrRequestOptions extends RequestOptions {\n    /**\n     * Controls whether or not the request is synchronous (blocks the main thread) or asynchronous (default).\n     */\n    blockMainThread?: boolean;\n    /**\n     * Controls whether or not the X-Requested-With header is added to the request (default true). Set to false to not\n     * include the header.\n     */\n    includeRequestedWithHeader?: boolean;\n}\n/**\n * Wraps an XHR request in a response that mimics the fetch API\n */\nexport declare class XhrResponse extends Response {\n    readonly headers: Headers;\n    readonly ok: boolean;\n    readonly status: number;\n    readonly statusText: string;\n    readonly bodyUsed: boolean;\n    readonly nativeResponse: XMLHttpRequest;\n    readonly requestOptions: XhrRequestOptions;\n    readonly url: string;\n    readonly download: Observable<number>;\n    readonly data: Observable<any>;\n    constructor(request: XMLHttpRequest);\n    arrayBuffer(): Task<ArrayBuffer>;\n    blob(): Task<Blob>;\n    formData(): Task<FormData>;\n    text(): Task<string>;\n    xml(): Task<Document>;\n}\nexport default function xhr(url: string, options?: XhrRequestOptions): UploadObservableTask<Response>;\n","type":2},{"name":"node_modules/@dojo/core/request/Response.d.ts","text":"import Task from '../async/Task';\nimport Headers from './Headers';\nimport { Response as ResponseInterface, RequestOptions } from './interfaces';\nimport Observable from '../Observable';\nexport interface ResponseData {\n    task: Task<any>;\n    used: boolean;\n}\ndeclare abstract class Response implements ResponseInterface {\n    readonly abstract headers: Headers;\n    readonly abstract ok: boolean;\n    readonly abstract status: number;\n    readonly abstract statusText: string;\n    readonly abstract url: string;\n    readonly abstract bodyUsed: boolean;\n    readonly requestOptions: RequestOptions;\n    readonly abstract download: Observable<number>;\n    readonly abstract data: Observable<any>;\n    json<T>(): Task<T>;\n    abstract arrayBuffer(): Task<ArrayBuffer>;\n    abstract blob(): Task<Blob>;\n    abstract formData(): Task<FormData>;\n    abstract text(): Task<string>;\n}\nexport default Response;\nexport declare function getFileReaderPromise<T>(reader: FileReader): Promise<T>;\nexport declare function getTextFromBlob(blob: Blob): Promise<string>;\nexport declare function getArrayBufferFromBlob(blob: Blob): Promise<ArrayBuffer>;\nexport declare function getTextFromArrayBuffer(buffer: ArrayBuffer): string;\n","type":2},{"name":"node_modules/@dojo/core/request/SubscriptionPool.d.ts","text":"import { SubscriptionObserver } from '@dojo/shim/Observable';\nexport default class SubscriptionPool<T> {\n    private _observers;\n    private _queue;\n    private _queueMaxLength;\n    constructor(maxLength?: number);\n    add(subscription: SubscriptionObserver<T>): () => void;\n    next(value: T): void;\n    complete(): void;\n}\n","type":2},{"name":"node_modules/@dojo/core/request/TimeoutError.d.ts","text":"export default class TimeoutError implements Error {\n    readonly message: string;\n    readonly name: string;\n    constructor(message?: string);\n}\n","type":2},{"name":"node_modules/@dojo/core/request/util.d.ts","text":"import { RequestOptions } from './interfaces';\n/**\n * Returns a URL formatted with optional query string and cache-busting segments.\n *\n * @param url The base URL.\n * @param options The RequestOptions used to generate the query string or cacheBust.\n */\nexport declare function generateRequestUrl(url: string, options?: RequestOptions): string;\nexport declare function getStringFromFormData(formData: any): string;\n","type":2},{"name":"node_modules/@dojo/core/Scheduler.d.ts","text":"import { Handle } from '@dojo/interfaces/core';\nimport { QueueItem } from './queue';\nexport interface KwArgs {\n    deferWhileProcessing?: boolean;\n    queueFunction?: (callback: (...args: any[]) => any) => Handle;\n}\nexport default class Scheduler {\n    protected readonly _boundDispatch: () => void;\n    protected _deferred: QueueItem[] | null;\n    protected _isProcessing: boolean;\n    protected readonly _queue: QueueItem[];\n    protected _task: Handle | null;\n    /**\n     * Determines whether any callbacks registered during should be added to the current batch (`false`)\n     * or deferred until the next batch (`true`, default).\n     */\n    deferWhileProcessing: boolean | undefined;\n    /**\n     * Allows users to specify the function that should be used to schedule callbacks.\n     * If no function is provided, then `queueTask` will be used.\n     */\n    queueFunction: (callback: (...args: any[]) => any) => Handle;\n    protected _defer(callback: (...args: any[]) => void): Handle;\n    protected _dispatch(): void;\n    protected _schedule(item: QueueItem): void;\n    constructor(kwArgs?: KwArgs);\n    schedule(callback: (...args: any[]) => void): Handle;\n}\n","type":2},{"name":"node_modules/@dojo/core/stringExtras.d.ts","text":"/**\n * Escapes a string so that it can safely be passed to the RegExp constructor.\n * @param text The string to be escaped\n * @return The escaped string\n */\nexport declare function escapeRegExp(text: string): string;\n/**\n * Sanitizes a string to protect against tag injection.\n * @param xml The string to be escaped\n * @param forAttribute Whether to also escape ', \", and > in addition to < and &\n * @return The escaped string\n */\nexport declare function escapeXml(xml: string, forAttribute?: boolean): string;\n","type":2},{"name":"node_modules/@dojo/core/text.d.ts","text":"import { Config, Require } from '@dojo/interfaces/loader';\nexport declare function get(url: string): Promise<string | null>;\nexport declare function normalize(id: string, toAbsMid: (moduleId: string) => string): string;\nexport declare function load(id: string, require: Require, load: (value?: any) => void, config?: Config): void;\n","type":2},{"name":"node_modules/@dojo/core/UrlSearchParams.d.ts","text":"import { Hash } from '@dojo/interfaces/core';\n/**\n * Object with string keys and string or string array values that describes a query string.\n */\nexport declare type ParamList = Hash<string | string[]>;\n/**\n * Represents a set of URL query search parameters.\n */\nexport default class UrlSearchParams {\n    /**\n     * Constructs a new UrlSearchParams from a query string, an object of parameters and values, or another\n     * UrlSearchParams.\n     */\n    constructor(input?: string | ParamList | UrlSearchParams);\n    /**\n     * Maps property keys to arrays of values. The value for any property that has been set will be an array containing\n     * at least one item. Properties that have been deleted will have a value of 'undefined'.\n     */\n    protected readonly _list: Hash<string[] | undefined>;\n    /**\n     * Appends a new value to the set of values for a key.\n     * @param key The key to add a value for\n     * @param value The value to add\n     */\n    append(key: string, value: string): void;\n    /**\n     * Deletes all values for a key.\n     * @param key The key whose values are to be removed\n     */\n    delete(key: string): void;\n    /**\n     * Returns the first value associated with a key.\n     * @param key The key to return the first value for\n     * @return The first string value for the key\n     */\n    get(key: string): string | undefined;\n    /**\n     * Returns all the values associated with a key.\n     * @param key The key to return all values for\n     * @return An array of strings containing all values for the key\n     */\n    getAll(key: string): string[] | undefined;\n    /**\n     * Returns true if a key has been set to any value, false otherwise.\n     * @param key The key to test for existence\n     * @return A boolean indicating if the key has been set\n     */\n    has(key: string): boolean;\n    /**\n     * Returns an array of all keys which have been set.\n     * @return An array of strings containing all keys set in the UrlSearchParams instance\n     */\n    keys(): string[];\n    /**\n     * Sets the value associated with a key.\n     * @param key The key to set the value of\n     */\n    set(key: string, value: string): void;\n    /**\n     * Returns this object's data as an encoded query string.\n     * @return A string in application/x-www-form-urlencoded format containing all of the set keys/values\n     */\n    toString(): string;\n}\n","type":2},{"name":"node_modules/@dojo/core/util.d.ts","text":"import { Handle } from '@dojo/interfaces/core';\n/**\n * Wraps a setTimeout call in a handle, allowing the timeout to be cleared by calling destroy.\n *\n * @param callback Callback to be called when the timeout elapses\n * @param delay Number of milliseconds to wait before calling the callback\n * @return Handle which can be destroyed to clear the timeout\n */\nexport declare function createTimer(callback: (...args: any[]) => void, delay?: number): Handle;\n/**\n * Wraps a callback, returning a function which fires after no further calls are received over a set interval.\n *\n * @param callback Callback to wrap\n * @param delay Number of milliseconds to wait after any invocations before calling the original callback\n * @return Debounced function\n */\nexport declare function debounce<T extends (this: any, ...args: any[]) => void>(callback: T, delay: number): T;\n/**\n * Wraps a callback, returning a function which fires at most once per set interval.\n *\n * @param callback Callback to wrap\n * @param delay Number of milliseconds to wait before allowing the original callback to be called again\n * @return Throttled function\n */\nexport declare function throttle<T extends (this: any, ...args: any[]) => void>(callback: T, delay: number): T;\n/**\n * Like throttle, but calls the callback at the end of each interval rather than the beginning.\n * Useful for e.g. resize or scroll events, when debounce would appear unresponsive.\n *\n * @param callback Callback to wrap\n * @param delay Number of milliseconds to wait before calling the original callback and allowing it to be called again\n * @return Throttled function\n */\nexport declare function throttleAfter<T extends (this: any, ...args: any[]) => void>(callback: T, delay: number): T;\nexport declare function guaranteeMinimumTimeout(callback: (...args: any[]) => void, delay?: number): Handle;\n","type":2},{"name":"node_modules/@dojo/core/uuid.d.ts","text":"/**\n * Returns a v4 compliant UUID.\n *\n * @returns {string}\n */\nexport default function uuid(): string;\n","type":2},{"name":"node_modules/@dojo/has/has.d.ts","text":"import { Require, Config } from './loader';\n/**\n * The valid return types from a feature test\n */\nexport declare type FeatureTestResult = boolean | string | number | undefined | void;\n/**\n * A function that tests for a feature and returns a result\n */\nexport declare type FeatureTest = () => FeatureTestResult;\nexport declare type FeatureTestThenable = PromiseLike<FeatureTestResult>;\n/**\n * A cache of results of feature tests\n */\nexport declare const testCache: {\n    [feature: string]: FeatureTestResult;\n};\n/**\n * A cache of the un-resolved feature tests\n */\nexport declare const testFunctions: {\n    [feature: string]: FeatureTest;\n};\nexport interface StaticHasFeatures {\n    [feature: string]: FeatureTestResult;\n}\nexport interface DojoHasEnvironment {\n    /**\n     * Static features defined in the enviornment that should be used by the `has` module\n     * instead of run-time detection.\n     */\n    staticFeatures?: StaticHasFeatures | (() => StaticHasFeatures);\n}\ndeclare global  {\n    interface Window {\n        /**\n         * The `dojo/has` enviornment which provides configuration when the module is\n         * loaded.\n         */\n        DojoHasEnvironment?: DojoHasEnvironment;\n    }\n}\nexport declare function load(resourceId: string, require: Require, load: (value?: any) => void, config?: Config): void;\n/**\n * AMD plugin function.\n *\n * Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test\n * value(s).\n *\n * @param resourceId The id of the module\n * @param normalize Resolves a relative module id into an absolute module id\n */\nexport declare function normalize(resourceId: string, normalize: (moduleId: string) => string): string | null;\n/**\n * Check if a feature has already been registered\n *\n * @param feature the name of the feature\n */\nexport declare function exists(feature: string): boolean;\n/**\n * Register a new test for a named feature.\n *\n * @example\n * has.add('dom-addeventlistener', !!document.addEventListener);\n *\n * @example\n * has.add('touch-events', function () {\n *    return 'ontouchstart' in document\n * });\n *\n * @param feature the name of the feature\n * @param value the value reported of the feature, or a function that will be executed once on first test\n * @param overwrite if an existing value should be overwritten. Defaults to false.\n */\nexport declare function add(feature: string, value: FeatureTest | FeatureTestResult | FeatureTestThenable, overwrite?: boolean): void;\n/**\n * Return the current value of a named feature.\n *\n * @param feature The name (if a string) or identifier (if an integer) of the feature to test.\n */\nexport default function has(feature: string): FeatureTestResult;\n","type":2},{"name":"node_modules/@dojo/has/loader.d.ts","text":"export interface Config {\n    baseUrl?: string;\n    map?: ModuleMap;\n    packages?: Package[];\n    paths?: {\n        [path: string]: string;\n    };\n    pkgs?: {\n        [path: string]: Package;\n    };\n}\nexport interface ModuleMap extends ModuleMapItem {\n    [sourceMid: string]: ModuleMapReplacement;\n}\nexport interface ModuleMapItem {\n    [mid: string]: any;\n}\nexport interface ModuleMapReplacement extends ModuleMapItem {\n    [findMid: string]: string;\n}\nexport interface Package {\n    location?: string;\n    main?: string;\n    name?: string;\n}\nexport interface Require {\n    (dependencies: string[], callback: RequireCallback): void;\n    <ModuleType>(moduleId: string): ModuleType;\n    toAbsMid(moduleId: string): string;\n    toUrl(path: string): string;\n}\nexport interface Has {\n    (name: string): any;\n    add(name: string, value: (global: Window, document?: HTMLDocument, element?: HTMLDivElement) => any, now?: boolean, force?: boolean): void;\n    add(name: string, value: any, now?: boolean, force?: boolean): void;\n}\nexport declare type SignalType = 'error';\nexport interface RootRequire extends Require {\n    has: Has;\n    on(type: SignalType, listener: any): {\n        remove: () => void;\n    };\n    config(config: Config): void;\n    inspect?(name: string): any;\n    nodeRequire?(id: string): any;\n    undef(moduleId: string): void;\n}\nexport interface RequireCallback {\n    (...modules: any[]): void;\n}\n","type":2},{"name":"node_modules/@dojo/has/main.d.ts","text":"import has from './has';\nexport * from './has';\nexport default has;\n","type":2},{"name":"node_modules/@dojo/i18n/cldr/load.d.ts","text":"import { CldrData, CldrGroup, LocaleData, isLoaded, mainPackages, reset, supplementalPackages } from './load/default';\n/**\n * Load the specified CLDR data with the i18n ecosystem.\n *\n * @param contextRequire\n * An optional contextual require that can be used to resolve relative paths.\n *\n * @param data\n * Either a data object to load directly, or an array of URLs to CLDR data objects. Note that the response for\n * dynamically-loaded data must satisfy the `CldrData` interface.\n *\n * @return\n * A promise that resolves once all data have been loaded and registered.\n */\nexport default function loadCldrData(contextRequire: Function, data: CldrData | string[]): Promise<void>;\nexport default function loadCldrData(data: CldrData | string[]): Promise<void>;\nexport { CldrData, CldrGroup, LocaleData, isLoaded, mainPackages, reset, supplementalPackages };\n","type":2},{"name":"node_modules/@dojo/i18n/cldr/load/default.d.ts","text":"import 'cldrjs/dist/cldr/unresolved';\nexport interface CldrData {\n    main?: LocaleData;\n    supplemental?: any;\n}\nexport declare type CldrGroup = 'main' | 'supplemental';\nexport interface LocaleData {\n    [locale: string]: any;\n}\n/**\n * A list of all required CLDR packages for an individual locale.\n */\nexport declare const mainPackages: ReadonlyArray<string>;\n/**\n * A list of all required CLDR supplement packages.\n */\nexport declare const supplementalPackages: ReadonlyArray<string>;\n/**\n * Determine whether a particular CLDR package has been loaded.\n *\n * Example: to check that `supplemental.likelySubtags` has been loaded, `isLoaded` would be called as\n * `isLoaded('supplemental', 'likelySubtags')`.\n *\n * @param groupName\n * The group to check; either \"main\" or \"supplemental\".\n *\n * @param ...args\n * Any remaining keys in the path to the desired package.\n *\n * @return\n * `true` if the deepest value exists; `false` otherwise.\n */\nexport declare function isLoaded(groupName: CldrGroup, ...args: string[]): boolean;\n/**\n * Load the specified CLDR data with the i18n ecosystem.\n *\n * @param data\n * A data object containing `main` and/or `supplemental` objects with CLDR data.\n */\nexport default function loadCldrData(data: CldrData): Promise<void>;\n/**\n * Clear the load cache, either the entire cache for the specified group. After calling this method,\n * `isLoaded` will return false for keys within the specified group(s).\n *\n * @param group\n * An optional group name. If not provided, then both the \"main\" and \"supplemental\" caches will be cleared.\n */\nexport declare function reset(group?: CldrGroup): void;\n","type":2},{"name":"node_modules/@dojo/i18n/cldr/load/webpack.d.ts","text":"import '@dojo/shim/Promise';\nimport { CldrData, LocaleData, mainPackages, reset, supplementalPackages } from './default';\n/**\n * A webpack-specific function used to load CLDR data from a preset cache.\n */\nexport default function loadCldrData(contextRequire: Function, data: CldrData | string[]): Promise<void>;\nexport default function loadCldrData(data: CldrData | string[]): Promise<void>;\n/**\n * A light wrapper around the base `isLoaded` method that ensures the injected CLDR data have been registered\n * with the i18n ecosystem.\n */\nexport declare function isLoaded(groupName: 'main' | 'supplemental', ...args: string[]): boolean;\nexport { CldrData, LocaleData, mainPackages, reset, supplementalPackages };\n","type":2},{"name":"node_modules/@dojo/i18n/cldr/locales.d.ts","text":"/**\n * A list of `cldr-data/main` directories used to load the correct CLDR data for a given locale.\n */\ndeclare const localesList: string[];\nexport default localesList;\n","type":2},{"name":"node_modules/@dojo/i18n/date.d.ts","text":"import 'globalize';\nimport 'globalize/dist/globalize/date';\nimport 'globalize/dist/globalize/relative-time';\nimport { NumberFormatter } from './number';\nexport declare type DateLength = 'short' | 'medium' | 'long' | 'full';\nexport declare type RelativeTimeLength = 'short' | 'narrow';\nexport interface DateFormatter {\n    /**\n     * Any function that converts a date object into a string.\n     */\n    (value: Date): string;\n}\nexport declare type DateFormatterOptions = {\n    /**\n     * String value indicating a skeleton, eg. { skeleton: \"GyMMMd\" }.\n     * Skeleton provides a more flexible formatting mechanism than the predefined list full, long, medium, or short represented by date, time, or datetime.\n     * Instead, they are an open-ended list of patterns containing only date field information, and in a canonical order.\n     */\n    skeleton?: string;\n    /**\n     * One of the following String values: full, long, medium, or short, eg. { date: \"full\" }.\n     */\n    date?: DateLength;\n    /**\n     * One of the following String values: full, long, medium, or short, eg. { time: \"full\" }.\n     */\n    time?: DateLength;\n    /**\n     * One of the following String values: full, long, medium, or short, eg. { datetime: \"full\" }\n     */\n    datetime?: DateLength;\n};\nexport interface DateParser {\n    /**\n     * Any function that parses a Date object from a string.\n     */\n    (value: string): Date;\n}\nexport declare type RelativeTimeFormatterOptions = {\n    /**\n     * eg. \"short\" or \"narrow\". Or falsy for default long form\n     */\n    form?: RelativeTimeLength;\n};\n/**\n * Format a date according to the specified options for the specified or current locale.\n *\n * @param value\n * The date to format.\n *\n * @param options\n * An optional object of formatting options.\n *\n * @param locale\n * An optional locale. Defaults to the root locale.\n *\n * @return\n * The formatted date string.\n */\nexport declare function formatDate(value: Date, options?: DateFormatterOptions, locale?: string): string;\nexport declare function formatDate(value: Date, locale?: string): string;\n/**\n * Format a number as a unit of relative time for the specified unit and optional locale.\n * E.g., `formatRelativeTime(1, 'week', { form: 'short' }, 'fr'` (\"la semaine prochaine\")\n *\n * @param value\n * The relative unit number. Positive numbers indicate future events (e.g., \"in 2 days\") while negative numbers\n * represent past events (e.g., \"1 day ago\").\n *\n * @param unit\n * E.g., \"week\", \"day\", \"month\", etc.\n *\n * @param options\n * An optional object of formatting options.\n *\n * @param locale\n * An optional locale. Defaults to the current locale.\n */\nexport declare function formatRelativeTime(value: number, unit: string, options?: RelativeTimeFormatterOptions, locale?: string): string;\nexport declare function formatRelativeTime(value: number, unit: string, locale?: string): string;\n/**\n * Return a date formatter that accepts a date and formats it according to the specified options for the\n * specified or current locale.\n *\n * @param options\n * An optional object of formatting options.\n *\n * @param locale\n * The optional locale. Defaults to the root locale.\n *\n * @return\n * A function that accepts a date and returns a formatted date string.\n */\nexport declare function getDateFormatter(options?: DateFormatterOptions, locale?: string): DateFormatter;\nexport declare function getDateFormatter(locale?: string): DateFormatter;\n/**\n * Return a function that parses a string into a date object, according any optional settings or locale.\n *\n * @param options\n * An optional config that describes the format of the string.\n *\n * @param locale\n * The optional locale. Defaults to the root locale.\n *\n * @return\n * A function that accepts a string and returns a date object.\n */\nexport declare function getDateParser(options?: DateFormatterOptions, locale?: string): DateParser;\nexport declare function getDateParser(locale?: string): DateParser;\n/**\n * Format a number as a unit of relative time for the specified unit and optional locale.\n * E.g., `formatRelativeTime(1, 'week', { form: 'short' }, 'fr'` (\"la semaine prochaine\")\n *\n * @param unit\n * E.g., \"week\", \"day\", \"month\", etc.\n *\n * @param options\n * An optional object of formatting options.\n *\n * @param locale\n * The optional locale. Defaults to the root locale.\n *\n * @return\n * A function that accepts a relative time number and returns a formatted string. Positive numbers indicate future\n * events (e.g., \"in 2 days\") while negative numbers represent past events (e.g., \"1 day ago\").\n */\nexport declare function getRelativeTimeFormatter(unit: string, options?: RelativeTimeFormatterOptions, locale?: string): NumberFormatter;\nexport declare function getRelativeTimeFormatter(unit: string, locale?: string): NumberFormatter;\n/**\n * Convert a string into a date object, according any optional settings or locale.\n *\n * @param value\n * The date string to convert.\n *\n * @param options\n * An optional config that describes the format of the string.\n *\n * @param locale\n * The optional locale. Defaults to the root locale.\n *\n * @return\n * The formatted date.\n */\nexport declare function parseDate(value: string, options?: DateFormatterOptions, locale?: string): Date;\nexport declare function parseDate(value: string, locale?: string): Date;\n","type":2},{"name":"node_modules/@dojo/i18n/i18n.d.ts","text":"import { Observer, Subscription } from '@dojo/shim/Observable';\n/**\n * A default bundle used as basis for loading locale-specific bundles.\n */\nexport interface Bundle<T extends Messages> {\n    /**\n     * The absolute module ID used by the loader to resolve paths to locale-specific paths. This MUST follow the format\n     * \"{basePath}{separator}{filename}\". For example, if the module ID for a bundle is \"nls/common\", the loader will\n     * look for locale-specific bundles at \"nls/{locale}/common\".\n     */\n    readonly bundlePath: string;\n    /**\n     * A list of supported locales. Any included locale MUST have an associated bundle.\n     */\n    readonly locales?: string[];\n    /**\n     * The map of default messages that will be used when locale-specific messages are unavailable.\n     * Note that any message key used in the i18n system MUST have a default specified here.\n     */\n    readonly messages: T;\n}\n/**\n * Options object passed to message formatters and used for token replacement.\n */\nexport interface FormatOptions {\n    [key: string]: any;\n}\nexport interface I18n<T extends Messages> {\n    (bundle: Bundle<T>, locale?: string): Promise<T>;\n    /**\n     * The current namespace as set via `switchLocale`. Defaults to `systemLocale`.\n     */\n    readonly locale: string;\n}\n/**\n * Describes a compiled ICU message formatter function.\n */\nexport interface MessageFormatter {\n    (options?: FormatOptions): string;\n}\n/**\n * An object of keys to locale messages.\n */\nexport interface Messages {\n    [key: string]: string;\n}\n/**\n * Return a formatted message.\n *\n * If both the \"supplemental/likelySubtags\" and \"supplemental/plurals-type-cardinal\" CLDR data have been loaded, then\n * the ICU message format is supported. Otherwise, a simple token-replacement mechanism is used.\n *\n * Usage:\n * formatMessage(bundle.bundlePath, 'guestInfo', {\n *   host: 'Bill',\n *   guest: 'John'\n * }, 'fr');\n *\n * @param bundlePath\n * The message's bundle path.\n *\n * @param key\n * The message's key.\n *\n * @param options\n * An optional value used by the formatter to replace tokens with values.\n *\n * @param locale\n * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the\n * default locale is used.\n *\n * @return\n * The formatted message.\n */\nexport declare function formatMessage(bundlePath: string, key: string, options?: FormatOptions, locale?: string): string;\n/**\n * Return the cached messages for the specified bundle and locale. If messages have not been previously loaded for the\n * specified locale, no value will be returned. If messages for the specified locale were added via\n * `setLocaleMessages`, then those messages will be returned regardless of whether the locale is listed in the bundle's\n * `locales` array.\n *\n * @param bundle\n * The default bundle that is used to determine where the locale-specific bundles are located.\n *\n * @param locale\n * The locale of the desired messages.\n *\n * @return The cached messages object, if it exists.\n */\nexport declare function getCachedMessages<T extends Messages>(bundle: Bundle<T>, locale: string): T | void;\n/**\n * Return a function that formats a specific message, and takes an optional value for token replacement.\n *\n * If both the \"supplemental/likelySubtags\" and \"supplemental/plurals-type-cardinal\" CLDR data have been loaded, then\n * the returned function will have ICU message format support. Otherwise, the returned function will perform a simple\n * token replacement on the message string.\n *\n * Usage:\n * const formatter = getMessageFormatter(bundlePath, 'guestInfo', 'fr');\n * const message = formatter({\n *   host: 'Miles',\n *   gender: 'male',\n *   guest: 'Oscar',\n *   guestCount: '15'\n * });\n *\n * @param bundlePath\n * The message's bundle path.\n *\n * @param key\n * The message's key.\n *\n * @param locale\n * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the\n * default locale is used.\n *\n * @return\n * The message formatter.\n */\nexport declare function getMessageFormatter(bundlePath: string, key: string, locale?: string): MessageFormatter;\ndeclare const _default: I18n<Messages>;\nexport default _default;\n/**\n * Invalidate the cache for a particular bundle, or invalidate the entire cache. Note that cached messages for all\n * locales for a given bundle will be cleared.\n *\n * @param bundlePath\n * The optional path of the bundle to invalidate. If no path is provided, then the cache is cleared for all bundles.\n */\nexport declare function invalidate(bundlePath?: string): void;\n/**\n * Register an observer to be notified when the root locale changes.\n *\n * @param observer\n * The observer whose `next` method will receive the locale string on updates, and whose `error` method will receive\n * an Error object if the locale switch fails.\n *\n * @return\n * A subscription object that can be used to unsubscribe from updates.\n */\nexport declare const observeLocale: (observer: Observer<string>) => Subscription;\n/**\n * Pre-load locale-specific messages into the i18n system.\n *\n * @param bundle\n * The default bundle that is used to merge locale-specific messages with the default messages.\n *\n * @param messages\n * The messages to cache.\n *\n * @param locale\n * The locale for the messages\n */\nexport declare function setLocaleMessages<T extends Messages>(bundle: Bundle<T>, localeMessages: T, locale: string): void;\n/**\n * Change the root locale, and notify any registered observers.\n *\n * @param locale\n * The new locale.\n */\nexport declare function switchLocale(locale: string): void;\n/**\n * The default environment locale.\n *\n * It should be noted that while the system locale will be normalized to a single\n * format when loading message bundles, this value represents the unaltered\n * locale returned directly by the environment.\n */\nexport declare const systemLocale: string;\n","type":2},{"name":"node_modules/@dojo/i18n/main.d.ts","text":"import { DateFormatterOptions, DateLength, formatDate, formatRelativeTime, getDateFormatter, getDateParser, getRelativeTimeFormatter, parseDate, RelativeTimeFormatterOptions, RelativeTimeLength } from './date';\nimport i18n, { Bundle, formatMessage, getCachedMessages, getMessageFormatter, I18n, invalidate, MessageFormatter, Messages, setLocaleMessages, switchLocale, systemLocale } from './i18n';\nimport { CurrencyFormatterOptions, CurrencyStyleOption, formatCurrency, formatNumber, getCurrencyFormatter, getNumberFormatter, getNumberParser, getPluralGenerator, NumberFormatterOptions, NumberParserOptions, NumberStyleOption, parseNumber, PluralGeneratorOptions, PluralGroup, pluralize, PluralTypeOption, RoundNumberOption } from './number';\nimport { formatUnit, getUnitFormatter, UnitFormatterOptions, UnitLength } from './unit';\nimport { generateLocales, normalizeLocale } from './util/main';\nimport loadCldrData from './cldr/load';\nexport default i18n;\nexport { Bundle, CurrencyFormatterOptions, CurrencyStyleOption, DateFormatterOptions, DateLength, formatCurrency, formatDate, formatMessage, formatNumber, formatRelativeTime, formatUnit, generateLocales, getCachedMessages, getCurrencyFormatter, getDateFormatter, getDateParser, getMessageFormatter, getNumberFormatter, getNumberParser, getPluralGenerator, getRelativeTimeFormatter, getUnitFormatter, I18n, invalidate, loadCldrData, MessageFormatter, Messages, normalizeLocale, NumberFormatterOptions, NumberParserOptions, NumberStyleOption, parseDate, parseNumber, PluralGeneratorOptions, PluralGroup, pluralize, PluralTypeOption, RelativeTimeFormatterOptions, RelativeTimeLength, RoundNumberOption, setLocaleMessages, switchLocale, systemLocale, UnitFormatterOptions, UnitLength };\n","type":2},{"name":"node_modules/@dojo/i18n/number.d.ts","text":"import 'globalize';\nimport 'globalize/dist/globalize/currency';\nimport 'globalize/dist/globalize/number';\nimport 'globalize/dist/globalize/plural';\nexport declare type CurrencyStyleOption = 'accounting' | 'code' | 'name' | 'symbol';\nexport declare type NumberStyleOption = 'decimal' | 'percent';\nexport declare type PluralGroup = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\nexport declare type PluralTypeOption = 'cardinal' | 'ordinal';\nexport declare type RoundNumberOption = 'ceil' | 'floor' | 'round' | 'truncate';\nexport interface CommonNumberFormatterOptions {\n    /**\n     * Non-negative integer Number value indicating the minimum integer digits to be used. Numbers will be padded with\n     * leading zeroes if necessary.\n     */\n    minimumIntegerDigits?: number;\n    /**\n     * Non-negative integer Number values indicating the minimum and maximum fraction digits to be used.\n     * Numbers will be rounded or padded with trailing zeroes if necessary.\n     * Either one or both of these properties must be present.\n     * If they are, they will override minimum and maximum fraction digits derived from the CLDR patterns.\n     */\n    minimumFractionDigits?: number;\n    /**\n     * Non-negative integer Number values indicating the minimum and maximum fraction digits to be used.\n     * Numbers will be rounded or padded with trailing zeroes if necessary.\n     * Either one or both of these properties must be present.\n     * If they are, they will override minimum and maximum fraction digits derived from the CLDR patterns.\n     */\n    maximumFractionDigits?: number;\n    /**\n     * Positive integer Number values indicating the minimum and maximum fraction digits to be shown.\n     * Either none or both of these properties are present\n     * If they are, they override minimum and maximum integer and fraction digits.\n     * The formatter uses however many integer and fraction digits are required to display the specified number of\n     * significant digits.\n     */\n    minimumSignificantDigits?: number;\n    /**\n     * Positive integer Number values indicating the minimum and maximum fraction digits to be shown.\n     * Either none or both of these properties are present.\n     * If they are, they override minimum and maximum integer and fraction digits.\n     * The formatter uses however many integer and fraction digits are required to display the specified number of\n     * significant digits.\n     */\n    maximumSignificantDigits?: number;\n    /**\n     * String with rounding method ceil, floor, round (default), or truncate.\n     */\n    round?: RoundNumberOption;\n    /**\n     * Boolean (default is true) value indicating whether a grouping separator should be used.\n     */\n    useGrouping?: boolean;\n}\nexport declare type CurrencyFormatterOptions = CommonNumberFormatterOptions & {\n    /**\n     * symbol (default), accounting, code or name.\n     */\n    style?: CurrencyStyleOption;\n};\nexport interface NumberFormatter {\n    /**\n     * Any function that formats a number as string.\n     */\n    (value: number): string;\n}\nexport declare type NumberFormatterOptions = CommonNumberFormatterOptions & {\n    /**\n     * decimal (default), or percent\n     */\n    style?: NumberStyleOption;\n};\nexport interface NumberParser {\n    /**\n     * Any function that parses a number value from a string.\n     */\n    (value: string): number;\n}\nexport declare type NumberParserOptions = {\n    /**\n     * decimal (default), or percent.\n     */\n    style?: NumberStyleOption;\n};\nexport declare type PluralGeneratorOptions = {\n    /**\n     * cardinal (default), or ordinal.\n     */\n    type?: PluralTypeOption;\n};\n/**\n * Format a number as the specified currency, according to the specified configuration and or locale.\n *\n * @param value\n * The number to format.\n *\n * @param currency\n * The currency to which the number should be converted.\n *\n * @param options\n * An optional configuration of settings that determine how the currency string will be formatted.\n *\n * @param locale\n * An optional locale. Defaults to the root locale.\n *\n * @return\n * The formatted currency string.\n */\nexport declare function formatCurrency(value: number, currency: string, options?: CurrencyFormatterOptions, locale?: string): string;\nexport declare function formatCurrency(value: number, currency: string, locale?: string): string;\n/**\n * Format a number according to the specified configuration and or locale.\n *\n * @param value\n * The number to format.\n *\n * @param options\n * An optional configuration of settings that determine how the number string will be formatted.\n *\n * @param locale\n * An optional locale. Defaults to the root locale.\n *\n * @return\n * The formatted number string.\n */\nexport declare function formatNumber(value: number, options?: NumberFormatterOptions, locale?: string): string;\nexport declare function formatNumber(value: number, locale?: string): string;\n/**\n * Return a function that formats a number as the specified currency, according to the specified configuration\n * and or locale.\n *\n * @param currency\n * The currency to which the number should be converted.\n *\n * @param options\n * An optional configuration of settings that determine how the currency string will be formatted.\n *\n * @param locale\n * An optional locale. Defaults to the root locale.\n *\n * @return\n * A function that accepts a number and returns a formatted currency string.\n */\nexport declare function getCurrencyFormatter(currency: string, options?: CurrencyFormatterOptions, locale?: string): NumberFormatter;\nexport declare function getCurrencyFormatter(currency: string, locale?: string): NumberFormatter;\n/**\n * Return a function that formats a number according to the specified configuration and or locale.\n *\n * @param options\n * An optional configuration of settings that determine how the number string will be formatted.\n *\n * @param locale\n * An optional locale. Defaults to the root locale.\n *\n * @return\n * A function that accepts a number and returns a formatted string.\n */\nexport declare function getNumberFormatter(options?: NumberFormatterOptions, locale?: string): NumberFormatter;\nexport declare function getNumberFormatter(locale?: string): NumberFormatter;\n/**\n * Parse a number from a string based on the provided configuration and or locale.\n *\n * @param options\n * An optional config that describes the format of the string.\n *\n * @param locale\n * An optional locale. Defaults to the root locale.\n *\n * @return\n * The parsed number.\n */\nexport declare function getNumberParser(options?: NumberFormatterOptions, locale?: string): NumberParser;\nexport declare function getNumberParser(locale?: string): NumberParser;\n/**\n * Return a function that accepts a number and returns that number's plural group.\n *\n * @param options\n * An optional configuration that determines whether the numerical value should be treated as a cardinal\n * or ordinal number.\n *\n * @param locale\n * An optional locale. Defaults to the root locale.\n *\n * @return\n * A function that accepts a number and returns the corresponding plural group.\n */\nexport declare function getPluralGenerator(options?: PluralGeneratorOptions, locale?: string): NumberFormatter;\nexport declare function getPluralGenerator(locale?: string): NumberFormatter;\n/**\n * Return a function that parses a number from a string based on the provided configuration and or locale.\n *\n * @param value\n * The string to parse.\n *\n * @param options\n * An optional config that describes the format of the string.\n *\n * @param locale\n * An optional locale. Defaults to the root locale.\n *\n * @return\n * A function that accepts a string and returns a number.\n */\nexport declare function parseNumber(value: string, options?: NumberFormatterOptions, locale?: string): number;\nexport declare function parseNumber(value: string, locale?: string): number;\n/**\n * Return the plural group from a number.\n *\n * @param value\n * The number.\n *\n * @param options\n * An optional configuration that determines whether the numerical value should be treated as a cardinal\n * or ordinal number.\n *\n * @param locale\n * An optional locale. Defaults to the root locale.\n *\n * @return\n * The plural group.\n */\nexport declare function pluralize(value: number, options?: PluralGeneratorOptions, locale?: string): string;\nexport declare function pluralize(value: number, locale?: string): string;\n","type":2},{"name":"node_modules/@dojo/i18n/unit.d.ts","text":"import 'globalize';\nimport 'globalize/dist/globalize/unit';\nimport { NumberFormatter, NumberFormatterOptions } from './number';\nexport declare type UnitLength = 'long' | 'narrow' | 'short';\nexport declare type UnitFormatterOptions = {\n    /**\n     * form: [String] eg. \"long\", \"short\" or \"narrow\".\n     */\n    form?: UnitLength;\n    /**\n     * numberFormatter: [Function] a number formatter function. Defaults to Globalize .numberFormatter() for the current locale using the default options.\n     */\n    numberFormatter?: NumberFormatterOptions;\n};\n/**\n * Return a string formatted for the specified number, unit, and options/locale.\n *\n * @param value\n * The number of units.\n *\n * @param unit\n * The unit, singular (e.g., \"day\", \"meter\", \"foot\").\n *\n * @param options\n * An optional configuration object that determines how the number and unit are formatted.\n *\n * @param locale\n * The optional locale. Defaults to the root locale.\n *\n * @return\n * The formatted string.\n */\nexport declare function formatUnit(value: number, unit: string, options?: UnitFormatterOptions, locale?: string): string;\nexport declare function formatUnit(value: number, unit: string, locale?: string): string;\n/**\n * Return a function that formats a number according to specified unit and options/locale.\n *\n * @param unit\n * The unit, singular (e.g., \"day\", \"meter\", \"foot\").\n *\n * @param options\n * An optional configuration object that determines how the number and unit are formatted.\n *\n * @param locale\n * The optional locale. Defaults to the root locale.\n *\n * @return\n * A function that accepts a number and returns a string formatted according to the specified unit and options/locale.\n */\nexport declare function getUnitFormatter(unit: string, options?: UnitFormatterOptions, locale?: string): NumberFormatter;\nexport declare function getUnitFormatter(unit: string, locale?: string): NumberFormatter;\n","type":2},{"name":"node_modules/@dojo/i18n/util/globalize.d.ts","text":"export interface DelegatorOptions<O> {\n    locale?: string;\n    optionsOrLocale?: O | string;\n}\nexport interface FormatterDelegatorOptions<T, O> extends DelegatorOptions<O> {\n    unit?: string;\n    value?: T;\n}\n/**\n * Return a Globalize.js object for the specified locale. If no locale is provided, then the root\n * locale is assumed.\n *\n * @param string\n * An optional locale for the Globalize.js object.\n *\n * @return\n * The localized Globalize.js object.\n */\nexport default function getGlobalize(locale?: string): GlobalizeStatic;\n/**\n * Call the specified Globalize.js method with the specified value, unit, and options, for the specified locale.\n *\n * @param method\n * The name of the static method on the `Globalize` object (required).\n *\n * @param args\n * An object containing any locale, options, value, or unit required by the underlying Globalize.js method.\n *\n * @return\n * The value returned by the underlying Globalize.js method.\n */\nexport declare function globalizeDelegator<O, R>(method: string, args: DelegatorOptions<O>): R;\nexport declare function globalizeDelegator<T, O, R>(method: string, args: FormatterDelegatorOptions<T, O>): R;\n","type":2},{"name":"node_modules/@dojo/i18n/util/main.d.ts","text":"/**\n * Retrieve a list of locales that can provide substitute for the specified locale\n * (including itself).\n *\n * For example, if 'fr-CA' is specified, then `[ 'fr', 'fr-CA' ]` is returned.\n *\n * @param locale\n * The target locale.\n *\n * @return\n * A list of locales that match the target locale.\n */\nexport declare function generateLocales(locale: string): string[];\n/**\n * Normalize a locale so that it can be converted to a bundle path.\n *\n * @param locale\n * The target locale.\n *\n * @return The normalized locale.\n */\nexport declare const normalizeLocale: (locale: string) => string;\n/**\n * Validates that the provided locale at least begins with a ISO 639.1/639.2 comptabile language subtag,\n * and that any additional subtags contain only valid characters.\n *\n * While locales should adhere to the guidelines set forth by RFC 5646 (https://tools.ietf.org/html/rfc5646),\n * only the language subtag is strictly enforced.\n *\n * @param locale\n * The locale to validate.\n *\n * @return\n * `true` if the locale is valid; `false` otherwise.\n */\nexport declare function validateLocale(locale: string): boolean;\n","type":2},{"name":"node_modules/@dojo/interfaces/abilities.d.ts","text":"/**\n * This definition module contains interfaces that are partial interfaces of likely larger interfaces\n * which have a very narrow ability which the a consumer might want to guard against or interface with\n *\n * It is very unlikely that these interfaces would be actually implemented as they stand\n */\n\nimport Promise from '@dojo/shim/Promise';\nimport Map from '@dojo/shim/Map';\nimport Observable from '@dojo/shim/Observable';\nimport { Destroyable, EventedListener } from './bases';\nimport { EventTargettedObject, Handle } from './core';\nimport { VNode } from './vdom';\n\n/**\n * The abstract interface for items that are Actionable\n */\nexport interface Actionable<T, E extends EventTargettedObject<T>> {\n\t/**\n\t * The *do* method of an Action, which can take a `options` property of an `event`\n\t *\n\t * @param options Options passed which includes an `event` object\n\t */\n\tdo(options?: ActionableOptions<T, E>): any;\n}\n\n/**\n * A base interface for typing the options which are passed to an Actionable\n */\nexport interface ActionableOptions<T, E extends EventTargettedObject<T>> {\n\t[ option: string ]: any;\n\n\t/**\n\t * An event object\n\t */\n\tevent: E;\n}\n\nexport interface Invalidatable {\n\t/**\n\t * Signal to the instance that it is in an invalide state\n\t */\n\tinvalidate(): void;\n\n\t/**\n\t * Attach a listener to the invalidated event, which is emitted when the `.invalidate()` method is called\n\t *\n\t * @param type The event type to listen for\n\t * @param listener The listener to call when the event is emitted\n\t */\n\ton(type: 'invalidated', listener: EventedListener<Renderable, EventTargettedObject<Renderable>>): Handle;\n}\n\nexport interface Renderable extends Destroyable, Invalidatable {\n\t/**\n\t * The ID of the child\n\t */\n\treadonly id: string;\n\n\t/**\n\t * Takes no arguments and returns a VNode\n\t */\n\trender(): VNode;\n\n\t/**\n\t * The tag name to be used\n\t */\n\ttagName: string;\n}\n\nexport interface RenderableParent extends Renderable {\n\t/**\n\t * Append the child to the children which are managed by the parent\n\t *\n\t * @param child The child to append\n\t */\n\tappend(child: Renderable[] | Renderable): Handle;\n\n\t/* TODO: Add Insert API */\n\n\t/**\n\t * The immutable list of children *owned* by the parent\n\t */\n\treadonly children: Map<string, Renderable>;\n}\n\nexport interface ObservableStore<T> {\n\t/**\n\t * A method that allows the return of an `Observable` interface for a particular `id`\n\t * @param id The ID to observe\n\t */\n\tobserve(id: string): Observable<T>;\n\n\t/**\n\t * A method to retrieve item(s) by ids\n\t * @param ids The IDs of the item(s)\n\t */\n\tget(ids: string | string[]): Promise<T | undefined | T[]>;\n}\n\nexport type ObservablePatchableStore<T> = ObservableStore<T> & PatchableStore<T>;\n\nexport interface PatchableStore<T> {\n\t/**\n\t * A method that allows an partial object to be passed to patch the object\n\t * and receive the full object back as a resolution to a Promise\n\t * @param partial The partial object to be *patched*\n\t * @param options A map of options, which includes the `id` being patched\n\t */\n\tpatch(partial: any, options?: { id?: string }): Promise<T>;\n}\n","type":2},{"name":"node_modules/@dojo/interfaces/bases.d.ts","text":"/**\n * These are the bases of the Dojo 2 class system, where the most common functionality is located.\n *\n * These interfaces will have specific implementations but likely have significant cross cutting concerns\n * and therefore are extracted out into this package.\n */\n\nimport Promise from '@dojo/shim/Promise';\nimport { Actionable } from './abilities';\nimport { EventErrorObject, EventObject, EventTargettedObject, EventTypedObject, Handle } from './core';\n\nexport interface Destroyable {\n\t/**\n\t * Take a handle and *own* it, which ensures that the handle's `destroy()` method is called when the\n\t * *owner* is destroyed.\n\t *\n\t * @param handle The handle to own\n\t * @returns A handle to *unown* the passed handle\n\t */\n\town(handle: Handle): Handle;\n\n\t/**\n\t * Invoke `destroy()` on any owned handles.\n\t *\n\t * @returns A promise that resolves to `true` if successful, otherwise `false`\n\t */\n\tdestroy(): Promise<boolean>;\n}\n\n/**\n * A base class, which provides the functionality of emitting events and attaching listeners to those\n * events\n */\nexport interface Evented extends Destroyable {\n\t/**\n\t * Emit an event.\n\t *\n\t * The event is determined by the `event.type`, if there are no listeners for an event type,\n\t * `emit` is essentially a noop.\n\t *\n\t * @param event The `EventTargettedObject` to be delivered to listeners based on `event.type`\n\t */\n\temit<E extends EventObject>(event: E): void;\n\n\t/**\n\t * Attach a map to events *types* specified by the key of the map and the value being the *listener* or\n\t * array of *listeners*.\n\t *\n\t * @param listeners An object which contains key value pairs of event types and listeners.\n\t * @returns A handle which can be used to remove the listeners\n\t */\n\ton<T>(listeners: EventedListenersMap<T>): Handle;\n\n\t/**\n\t * Attach a listener (or array of listeners) to an `error` event.\n\t *\n\t * @param type The type of event to listen for (`error`)\n\t * @param listener A listener or array of listeners that accept error events\n\t * @returns A handle which can be used to remove the listeners\n\t */\n\ton<T extends Evented>(type: 'error', listener: EventedListenerOrArray<T, EventErrorObject<T>>): Handle;\n\n\t/**\n\t * Attach a `listener` to a particular event `type`.\n\t *\n\t * @param type The event to attach the listener to\n\t * @param listener Either a function which takes an emitted `event` object, something that is `Actionable`,\n\t *                 or an array of of such listeners.\n\t * @returns A handle which can be used to remove the listener\n\t */\n\ton<T>(type: string, listener: EventedListenerOrArray<T, EventTargettedObject<T>>): Handle;\n}\n\n/**\n * Evented options interface\n */\nexport interface EventedOptions {\n\tlisteners?: EventedListenersMap<any>;\n}\n\nexport interface EventedCallback<E extends EventObject> {\n\t/**\n\t * A callback that takes an `event` argument\n\t *\n\t * @param event The event object\n\t */\n\t(event: E): boolean | void;\n}\n\n/**\n * Either an EventedCallback or an Actionable, which are valid listeners for Evented events\n */\nexport type EventedListener<T, E extends EventTargettedObject<T>> = EventedCallback<E> | Actionable<T, E>;\n\n/**\n * A map of listeners to be applied, where the key of the map is the `event.type` to listen for\n */\nexport interface EventedListenersMap<T> {\n\t[type: string]: EventedListenerOrArray<T, EventTargettedObject<T>>;\n}\n\n/**\n * A type which is either a targeted event listener or an array of listeners\n * @template T The type of target for the events\n * @template E The event type for the events\n */\nexport type EventedListenerOrArray<T, E extends EventTargettedObject<T>> = EventedListener<T, E> | EventedListener<T, E>[];\n\nexport interface StateChangeEvent<S, T extends Stateful<S>> extends EventTypedObject<'state:changed'> {\n\t/**\n\t * The state of the target\n\t */\n\tstate: S;\n\n\t/**\n\t * A Stateful instance\n\t */\n\ttarget: T;\n}\n\nexport interface State {\n\t[index: string]: any;\n}\n\n/**\n * The stateful mixin interface\n */\nexport interface StatefulMixin<S extends State> extends Evented {\n\t/**\n\t * A state of the instannce\n\t */\n\treadonly state: S;\n\n\t/**\n\t * Set the state on the instance.\n\t *\n\t * Set state can take a partial value, therefore if a key is ommitted from the value, it will not be changed.\n\t * To *clear* a value, set a key to `undefined`\n\t *\n\t * @param value The state (potentially partial) to be set\n\t */\n\tsetState(state: Partial<S>): void;\n}\n\n/**\n * Stateful type\n */\nexport type Stateful<S extends State> = StatefulMixin<S> & {\n\t/**\n\t * Add a listener for a `state:changed` event, which occurs whenever the state changes on the instance.\n\t *\n\t * @param type The event type to listen for\n\t * @param listener The listener that will be called when the event occurs\n\t */\n\ton(type: 'state:changed', listener: EventedListener<Stateful<S>, StateChangeEvent<S, Stateful<S>>>): Handle;\n};\n\n/**\n * Options for a stateful object\n */\nexport interface StatefulOptions<S extends State> extends EventedOptions {}\n","type":2},{"name":"node_modules/@dojo/interfaces/cli.d.ts","text":"import { Argv, Options } from 'yargs';\n\nexport interface Config {\n\t[key: string]: any;\n}\n\nexport interface ConfigurationHelper {\n\tset(config: Config): void;\n\tget(): {};\n}\n\nexport interface CommandHelper {\n\trun(group: string, commandName?: string, args?: Argv): Promise<any>;\n\texists(group: string, commandName?: string): boolean;\n}\n\nexport interface Helper {\n\tyargs: Argv;\n\tcommand: CommandHelper;\n\tcontext: any;\n\tconfiguration: ConfigurationHelper;\n}\n\nexport type OptionsHelper = (key: string, options: Options) => void;\n\nexport interface NpmPackage {\n\tdevDependencies?: {\n\t\t[name: string]: string\n\t};\n\tdependencies?: {\n\t\t[name: string]: string\n\t};\n}\n\nexport interface Alias {\n\tname: string;\n\tdescription?: string;\n\toptions: AliasOption[];\n}\n\n/**\n * Represents one alias option. The option name is the full name of the option, and not the abbreviation. For\n * example, if an option is (-w or --watch), you will specify \"watch\" as the option name.\n */\nexport interface AliasOption {\n\toption: string;\n\tvalue: string | boolean | number;\n}\n\nexport interface FileCopyConfig {\n\tpath: string;\n\tfiles: string[];\n}\n\nexport interface EjectOutput {\n\tnpm?: NpmPackage;\n\tcopy?: FileCopyConfig;\n\thints?: string[];\n}\n\n/**\n * Inbuilt commands specify their name and group - installed commands have these props parsed out of their package dir name\n */\nexport interface Command<T = any> {\n\tdescription: string;\n\tregister(options: OptionsHelper, helper: Helper): void;\n\trun(helper: Helper, args?: T): Promise<any>;\n\teject?(helper: Helper): EjectOutput;\n\tname?: string;\n\tgroup?: string;\n\talias?: Alias[] | Alias;\n}\n\nexport interface CommandError {\n\texitCode?: number;\n\tmessage: string;\n}\n","type":2},{"name":"node_modules/@dojo/interfaces/core.d.ts","text":"/**\n * An interface for an object which provides a cancelable event API.  By calling the\n * `.preventDefault()` method on the object, the event should be cancelled and not\n * proceed any further\n */\nexport interface EventCancelableObject<T extends string, U> {\n\t/**\n\t * Can the event be canceled?\n\t */\n\treadonly cancelable: boolean;\n\n\t/**\n\t * Was the event canceled?\n\t */\n\treadonly defaultPrevented: boolean;\n\n\t/**\n\t * Cancel the event\n\t */\n\tpreventDefault(): void;\n\n\t/**\n\t * The target for the event\n\t */\n\treadonly target: U;\n\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: T;\n}\n\nexport interface EventErrorObject<T> {\n\t/**\n\t * The error that is the subject of this event\n\t */\n\treadonly error: Error;\n\n\t/**\n\t * The target for the event\n\t */\n\treadonly target: T;\n\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: 'error';\n}\n\n/**\n * The base event object, which provides a `type` property\n */\nexport interface EventObject {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: string;\n}\n\n/**\n * An event object which has a typed target\n */\nexport interface EventTargettedObject<T> {\n\t/**\n\t * The target of the event\n\t */\n\treadonly target: T;\n\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: string;\n}\n\n/**\n * An event object which has a string literal type\n */\nexport interface EventTypedObject<T extends string> {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: T;\n}\n\n/**\n * A generic definition for a factory function which, given an optional set of options will\n * return an instance of the supplied generic type\n */\nexport interface Factory<T, O> {\n\t/**\n\t * Create an instance\n\t *\n\t * @param options The options used to create the instance\n\t */\n\t(options?: O): T;\n\n\t/**\n\t * The prototype that will be used when constructing the instance\n\t */\n\tprototype: T;\n}\n\n/**\n * Used for inserting an item into a posistion\n */\nexport type InsertPosition = number | 'first' | 'last' | 'before' | 'after';\n\n/**\n * Used through the toolkit as a consistent API to manage how callers can \"cleanup\"\n * when doing a function.\n */\nexport interface Handle {\n\t/**\n\t * Perform the destruction/cleanup logic associated with this handle\n\t */\n\tdestroy(): void;\n}\n\n/**\n * A general interface that can be used to renference a general index map of values of a particular type\n */\nexport interface Hash<T> {\n\t[ id: string ]: T;\n}\n\n/**\n * A base map of styles where each key is the name of the style attribute and the value is a string\n * which represents the style\n */\nexport interface StylesMap {\n\t[style: string]: string;\n}\n","type":2},{"name":"node_modules/@dojo/interfaces/loader.d.ts","text":"/**\n * The interfaces to the `@dojo/loader` AMD loader\n */\n\nexport interface Config {\n\t/**\n\t * The base URL that the loader will use to resolve modules\n\t */\n\tbaseUrl?: string;\n\n\t/**\n\t * A map of module identifiers and their replacement meta data\n\t */\n\tmap?: ModuleMap;\n\n\t/**\n\t * An array of packages that the loader should use when resolving a module ID\n\t */\n\tpackages?: Package[];\n\n\t/**\n\t * A map of paths to use when resolving modules names\n\t */\n\tpaths?: { [ path: string ]: string; };\n\n\t/**\n\t * A map of packages that the loader should use when resolving a module ID\n\t */\n\tpkgs?: { [ path: string ]: Package; };\n}\n\nexport interface Define {\n\t/**\n\t * Define a module\n\t *\n\t * @param moduleId the MID to use for the module\n\t * @param dependencies an array of MIDs this module depends upon\n\t * @param factory the factory function that will return the module\n\t */\n\t(moduleId: string, dependencies: string[], factory: Factory): void;\n\n\t/**\n\t * Define a module\n\t *\n\t * @param dependencies an array of MIDs this module depends upon\n\t * @param factory the factory function that will return the module\n\t */\n\t(dependencies: string[], factory: Factory): void;\n\n\t/**\n\t * Define a module\n\t *\n\t * @param factory the factory function that will return the module\n\t */\n\t(factory: Factory): void;\n\n\t/**\n\t * Define a module\n\t *\n\t * @param value the value for the module\n\t */\n\t(value: any): void;\n\n\t/**\n\t * Meta data about this particular AMD loader\n\t */\n\tamd: { [prop: string]: string | number | boolean };\n}\n\nexport interface Factory {\n\t/**\n\t * The module factory\n\t *\n\t * @param modules The arguments that represent the resolved versions of the module dependencies\n\t */\n\t(...modules: any[]): any;\n}\n\nexport interface Has {\n\t/**\n\t * Determine if a feature is present\n\t *\n\t * @param name the feature name to check\n\t */\n\t(name: string): any;\n\n\t/**\n\t * Register a feature test\n\t *\n\t * @param name The name of the feature to register\n\t * @param value The test for the feature\n\t * @param now If `true` the test will be executed immediatly, if not, it will be lazily executed\n\t * @param force If `true` the test value will be overwritten if already registered\n\t */\n\tadd(name: string, value: (global: Window, document?: HTMLDocument, element?: HTMLDivElement) => any,\n\t\tnow?: boolean, force?: boolean): void;\n\tadd(name: string, value: any, now?: boolean, force?: boolean): void;\n}\n\nexport interface ModuleMap extends ModuleMapItem {\n\t[ sourceMid: string ]: ModuleMapReplacement;\n}\n\nexport interface ModuleMapItem {\n\t[ mid: string ]: any;\n}\n\nexport interface ModuleMapReplacement extends ModuleMapItem {\n\t[ findMid: string ]: string;\n}\n\nexport interface Package {\n\t/**\n\t * The path to the root of the package\n\t */\n\tlocation?: string;\n\n\t/**\n\t * The main module of the package (defaults to `main.js`)\n\t */\n\tmain?: string;\n\n\t/**\n\t * The package name\n\t */\n\tname?: string;\n}\n\nexport interface Require {\n\t/**\n\t * Resolve a list of module dependencies and pass them to the callback\n\t *\n\t * @param dependencies The array of MIDs to resolve\n\t * @param callback The function to invoke with the resolved dependencies\n\t */\n\t(dependencies: string[], callback: RequireCallback): void;\n\n\t/**\n\t * Resolve and return a single module (compatability with CommonJS `require`)\n\t *\n\t * @param moduleId The module ID to resolve and return\n\t */\n\t<ModuleType>(moduleId: string): ModuleType;\n\n\t/**\n\t * Take a relative MID and return an absolute MID\n\t *\n\t * @param moduleId The relative module ID to resolve\n\t */\n\ttoAbsMid(moduleId: string): string;\n\n\t/**\n\t * Take a path and resolve the full URL for the path\n\t *\n\t * @param path The path to resolve and return as a URL\n\t */\n\ttoUrl(path: string): string;\n}\n\nexport interface RequireCallback {\n\t/**\n\t * The `require` callback\n\t *\n\t * @param modules The arguments that represent the resolved versions of dependencies\n\t */\n\t(...modules: any[]): void;\n}\n\nexport interface RootRequire extends Require {\n\t/**\n\t * The minimalist `has` API integrated with the `@dojo/loader`\n\t */\n\thas: Has;\n\n\t/**\n\t * Register an event listener\n\t *\n\t * @param type The event type to listen for\n\t * @param listener The listener to call when the event is emitted\n\t */\n\ton(type: SignalType, listener: any): { remove: () => void };\n\n\t/**\n\t * Configure the loader\n\t *\n\t * @param config The configuration to apply to the loader\n\t */\n\tconfig(config: Config): void;\n\n\t/**\n\t * Return internal values of loader for debug purposes\n\t *\n\t * @param name The name of the internal label\n\t */\n\tinspect?(name: string): any;\n\n\t/**\n\t * If running in the node environment, a reference to the original NodeJS `require`\n\t */\n\tnodeRequire?(id: string): any;\n\n\t/**\n\t * Undefine a module, based on absolute MID that should be removed from the loader cache\n\t */\n\tundef(moduleId: string): void;\n}\n\n/**\n * The signal type for the `require.on` API\n */\nexport type SignalType = 'error';\n","type":2},{"name":"node_modules/@dojo/interfaces/main.d.ts","text":"import * as abilities from './abilities';\nimport * as bases from './bases';\nimport * as core from './core';\nimport * as loader from './loader';\nimport * as shim from './shim';\nimport * as vdom from './vdom';\ndeclare const _default: {\n    abilities: typeof abilities;\n    bases: typeof bases;\n    core: typeof core;\n    loader: typeof loader;\n    shim: typeof shim;\n    vdom: typeof vdom;\n};\nexport = _default;\n","type":2},{"name":"node_modules/@dojo/interfaces/shim.d.ts","text":"/**\n * ArrayLike represents a generic object which has a `length` and is number index based\n */\nexport interface ArrayLike<T> {\n\tlength: number;\n\t[n: number]: T;\n}\n\n/**\n * Thenable represents any object with a callable `then` property.\n */\nexport interface Thenable<T> {\n\tthen<U>(onFulfilled?: (value: T) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Thenable<U>;\n\tthen<U>(onFulfilled?: (value: T) => U | Thenable<U>, onRejected?: (error: any) => void): Thenable<U>;\n}\n","type":2},{"name":"node_modules/@dojo/interfaces/vdom.d.ts","text":"/**\n * These interfaces are derived from Maquette.\n *\n * https://github.com/AFASSoftware/maquette\n *\n * Copyright (c) 2015 Maquette contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Options that may be passed when creating the [[Projector]]\n */\nexport interface ProjectorOptions {\n\t/**\n\t * A transition strategy to invoke when enterAnimation and exitAnimation properties are provided as strings.\n\t * The module `cssTransitions` in the provided `css-transitions.js` file provides such a strategy.\n\t * A transition strategy is not needed when enterAnimation and exitAnimation properties are provided as functions.\n\t */\n\treadonly transitions?: TransitionStrategy;\n\t/**\n\t * May be used to add vendor prefixes when applying inline styles when needed.\n\t * This function is called when [[styles]] is used.\n\t * This function should execute `domNode.style[styleName] = value` or do something smarter.\n\t *\n\t * @param domNode   The DOM Node that needs to receive the style\n\t * @param styleName The name of the style that should be applied, for example `transform`.\n\t * @param value     The value of this style, for example `rotate(45deg)`.\n\t */\n\tstyleApplyer?(domNode: HTMLElement, styleName: string, value: string): void;\n}\n\n/**\n * Options that influence how the DOM is rendered and updated.\n */\nexport interface ProjectionOptions extends ProjectorOptions {\n\t/**\n\t * Only for internal use. Used for rendering SVG Nodes.\n\t */\n\treadonly namespace?: string;\n\t/**\n\t * May be used to intercept registration of event-handlers.\n\t *\n\t * Used by the [[Projector]] to wrap eventHandler-calls to call [[scheduleRender]] as well.\n\t *\n\t * @param propertyName             The name of the property to be assigned, for example onclick\n\t * @param eventHandler             The function that was registered on the [[VNode]]\n\t * @param domNode                  The real DOM element\n\t * @param properties               The whole set of properties that was put on the VNode\n\t * @returns                        The function that is to be placed on the DOM node as the event handler, instead of `eventHandler`.\n\t */\n\teventHandlerInterceptor?: (propertyName: string, eventHandler: Function, domNode: Node, properties: VNodeProperties) => Function;\n}\n\n/**\n * These functions are called when [[VNodeProperties.enterAnimation]] and [[VNodeProperties.exitAnimation]] are provided as strings.\n * See [[ProjectionOptions.transitions]].\n */\nexport interface TransitionStrategy {\n\t/**\n\t * Function that is called when a [[VNode]] with an `enterAnimation` string is added to an already existing parent [[VNode]].\n\t *\n\t * @param element         Element that was just added to the DOM.\n\t * @param properties      The properties object that was supplied to the [[h]] method\n\t * @param enterAnimation  The string that was passed to [[VNodeProperties.enterAnimation]].\n\t */\n\tenter(element: Element, properties: VNodeProperties, enterAnimation: string): void;\n\t/**\n\t * Function that is called when a [[VNode]] with an `exitAnimation` string is removed from a existing parent [[VNode]] that remains.\n\t *\n\t * @param element         Element that ought to be removed from to the DOM.\n\t * @param properties      The properties object that was supplied to the [[h]] method that rendered this [[VNode]] the previous time.\n\t * @param exitAnimation   The string that was passed to [[VNodeProperties.exitAnimation]].\n\t * @param removeElement   Function that removes the element from the DOM.\n\t *                        This argument is provided purely for convenience.\n\t *                        You may use this function to remove the element when the animation is done.\n\t */\n\texit(element: Element, properties: VNodeProperties, exitAnimation: string, removeElement: () => void): void;\n}\n\n/**\n * A virtual representation of a DOM Node. Maquette assumes that [[VNode]] objects are never modified externally.\n * Instances of [[VNode]] can be created using [[h]].\n */\nexport interface VNode {\n\t/**\n\t * The CSS selector containing tagname, css classnames and id. An empty string is used to denote a text node.\n\t */\n\treadonly vnodeSelector: string;\n\t/**\n\t * Object containing attributes, properties, event handlers and more, see [[h]].\n\t */\n\treadonly properties: VNodeProperties | undefined;\n\t/**\n\t * Array of [[VNode]]s to be used as children. This array is already flattened.\n\t */\n\treadonly children: Array<VNode> | undefined;\n\t/**\n\t * Used in a special case when a [[VNode]] only has one childnode which is a textnode. Only used in combination with children === undefined.\n\t */\n\treadonly text: string | undefined;\n\t/**\n\t * Used by maquette to store the domNode that was produced from this [[VNode]].\n\t */\n\tdomNode: Node | null;\n}\n\n/**\n * Object containing attributes, properties, event handlers and more that can be put on DOM nodes.\n *\n * For your convenience, all common attributes, properties and event handlers are listed here and are\n * type-checked when using Typescript.\n */\nexport interface VNodeProperties {\n\t/**\n\t * The animation to perform when this node is added to an already existing parent.\n\t * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the\n\t * projector using [[createProjector]].\n\t * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n\t * @param element - Element that was just added to the DOM.\n\t * @param properties - The properties object that was supplied to the [[h]] method\n\t */\n\tenterAnimation?: ((element: Element, properties?: VNodeProperties) => void) | string;\n\t/**\n\t * The animation to perform when this node is removed while its parent remains.\n\t * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector using [[createProjector]].\n\t * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n\t * @param element - Element that ought to be removed from to the DOM.\n\t * @param removeElement - Function that removes the element from the DOM.\n\t * This argument is provided purely for convenience.\n\t * You may use this function to remove the element when the animation is done.\n\t * @param properties - The properties object that was supplied to the [[h]] method that rendered this [[VNode]] the previous time.\n\t */\n\texitAnimation?: ((element: Element, removeElement: () => void, properties?: VNodeProperties) => void) | string;\n\t/**\n\t * The animation to perform when the properties of this node change.\n\t * This also includes attributes, styles, css classes. This callback is also invoked when node contains only text and that text changes.\n\t * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n\t * @param element - Element that was modified in the DOM.\n\t * @param properties - The last properties object that was supplied to the [[h]] method\n\t * @param previousProperties - The previous properties object that was supplied to the [[h]] method\n\t */\n\tupdateAnimation?: (element: Element, properties?: VNodeProperties, previousProperties?: VNodeProperties) => void;\n\t/**\n\t * Callback that is executed after this node is added to the DOM. Childnodes and properties have\n\t * already been applied.\n\t * @param element - The element that was added to the DOM.\n\t * @param projectionOptions - The projection options that were used see [[createProjector]].\n\t * @param vnodeSelector - The selector passed to the [[h]] function.\n\t * @param properties - The properties passed to the [[h]] function.\n\t * @param children - The children that were created.\n\t */\n\tafterCreate?(element: Element, projectionOptions: ProjectionOptions, vnodeSelector: string, properties: VNodeProperties,\n\tchildren: VNode[]): void;\n\t/**\n\t * Callback that is executed every time this node may have been updated. Childnodes and properties\n\t * have already been updated.\n\t * @param element - The element that may have been updated in the DOM.\n\t * @param projectionOptions - The projection options that were used see [[createProjector]].\n\t * @param vnodeSelector - The selector passed to the [[h]] function.\n\t * @param properties - The properties passed to the [[h]] function.\n\t * @param children - The children for this node.\n\t */\n\tafterUpdate?(element: Element, projectionOptions: ProjectionOptions, vnodeSelector: string, properties: VNodeProperties,\n\tchildren: VNode[]): void;\n\t/**\n\t * When specified, the event handlers will be invoked with 'this' pointing to the value.\n\t * This is useful when using the prototype/class based implementation of Components.\n\t *\n\t * When no [[key]] is present, this object is also used to uniquely identify a DOM node.\n\t */\n\treadonly bind?: Object;\n\t/**\n\t * Used to uniquely identify a DOM node among siblings.\n\t * A key is required when there are more children with the same selector and these children are added or removed dynamically.\n\t * NOTE: this does not have to be a string or number, a [[Component]] Object for instance is also possible.\n\t */\n\treadonly key?: Object;\n\t/**\n\t * An object literal like `{important:true}` which allows css classes, like `important` to be added and removed\n\t * dynamically.\n\t */\n\treadonly classes?: { [index: string]: boolean | null | undefined };\n\t/**\n\t * An object literal like `{height:'100px'}` which allows styles to be changed dynamically. All values must be strings.\n\t */\n\treadonly styles?: { [index: string]: string | null | undefined };\n\n\t// From Element\n\tontouchcancel?(ev?: TouchEvent): boolean | void;\n\tontouchend?(ev?: TouchEvent): boolean | void;\n\tontouchmove?(ev?: TouchEvent): boolean | void;\n\tontouchstart?(ev?: TouchEvent): boolean | void;\n\t// From HTMLFormElement\n\treadonly action?: string;\n\treadonly encoding?: string;\n\treadonly enctype?: string;\n\treadonly method?: string;\n\treadonly name?: string;\n\treadonly target?: string;\n\t// From HTMLElement\n\tonblur?(ev?: FocusEvent): boolean | void;\n\tonchange?(ev?: Event): boolean | void;\n\tonclick?(ev?: MouseEvent): boolean | void;\n\tondblclick?(ev?: MouseEvent): boolean | void;\n\tonfocus?(ev?: FocusEvent): boolean | void;\n\toninput?(ev?: Event): boolean | void;\n\tonkeydown?(ev?: KeyboardEvent): boolean | void;\n\tonkeypress?(ev?: KeyboardEvent): boolean | void;\n\tonkeyup?(ev?: KeyboardEvent): boolean | void;\n\tonload?(ev?: Event): boolean | void;\n\tonmousedown?(ev?: MouseEvent): boolean | void;\n\tonmouseenter?(ev?: MouseEvent): boolean | void;\n\tonmouseleave?(ev?: MouseEvent): boolean | void;\n\tonmousemove?(ev?: MouseEvent): boolean | void;\n\tonmouseout?(ev?: MouseEvent): boolean | void;\n\tonmouseover?(ev?: MouseEvent): boolean | void;\n\tonmouseup?(ev?: MouseEvent): boolean | void;\n\tonmousewheel?(ev?: WheelEvent | MouseWheelEvent): boolean | void;\n\tonscroll?(ev?: UIEvent): boolean | void;\n\tonsubmit?(ev?: Event): boolean | void;\n\treadonly spellcheck?: boolean;\n\treadonly tabIndex?: number;\n\treadonly disabled?: boolean;\n\treadonly title?: string;\n\treadonly accessKey?: string;\n\treadonly id?: string;\n\t// From HTMLInputElement\n\treadonly type?: string;\n\treadonly autocomplete?: string;\n\treadonly checked?: boolean;\n\treadonly placeholder?: string;\n\treadonly readOnly?: boolean;\n\treadonly src?: string;\n\treadonly value?: string;\n\t// From HTMLImageElement\n\treadonly alt?: string;\n\treadonly srcset?: string;\n\t/**\n\t * Puts a non-interactive piece of html inside the DOM node.\n\t *\n\t * Note: if you use innerHTML, maquette cannot protect you from XSS vulnerabilities and you must make sure that the innerHTML value is safe.\n\t */\n\treadonly innerHTML?: string;\n\n\t/**\n\t * Everything that is not explicitly listed (properties and attributes that are either uncommon or custom).\n\t */\n\treadonly [index: string]: any;\n}\n","type":2},{"name":"node_modules/@dojo/loader/dojo-loader.d.ts","text":"declare namespace DojoLoader {\n\n\t/**\n\t * Common AMD Configuration\n\t *\n\t * See [Common Config](https://github.com/amdjs/amdjs-api/blob/master/CommonConfig.md)\n\t */\n\texport interface Config {\n\t\t/**\n\t\t * Indicates the root used for ID-to-path resolutions. Relative paths are relative to the current\n\t\t * working directory. In web browsers, the current working directory is the directory containing\n\t\t * the web page running the script.\n\t\t */\n\t\tbaseUrl?: string;\n\n\t\t/**\n\t\t * Specifies for a given module ID prefix, what module ID prefix to use in place of another\n\t\t * module ID prefix. For example, how to express \"when `bar` asks for module ID `foo`,\n\t\t * actually use module ID 'foo1.2'\".\n\t\t *\n\t\t * This sort of capability is important for larger projects which may have two sets of\n\t\t * modules that need to use two different versions of `foo`, but they still need to\n\t\t * cooperate with each other.\n\t\t *\n\t\t * This is different from `paths` config. `paths` is only for setting up root paths for\n\t\t * module IDs, not for mapping one module ID to another one.\n\t\t */\n\t\tmap?: ModuleMap;\n\n\t\t/**\n\t\t * Array of package configuration (packageConfig) objects. Package configuration is for\n\t\t * traditional CommonJS packages, which has different path lookup rules than the default\n\t\t * ID-to-path lookup rules used by an AMD loader.\n\t\t *\n\t\t * Default lookup rules are ,baseUrl + 'module/id' + .js, where paths config can be used\n\t\t * to map part of 'module/id' to another path.\n\t\t */\n\t\tpackages?: Package[];\n\n\t\t/**\n\t\t * For specifying a path for a the given module ID prefix.\n\t\t *\n\t\t * A property in the paths object is an absolute module ID prefix.\n\t\t */\n\t\tpaths?: { [ path: string ]: string; };\n\n\t\t/* TODO: We should remove internal APIs like this */\n\t\tpkgs?: { [ path: string ]: Package; };\n\n\t\tshim?: { [path: string]: ModuleShim | string[] };\n\n\t\tcrossOrigin?: false | 'anonymous' | 'use-credentials';\n\t}\n\n\tinterface Define {\n\t\t(moduleId: string, dependencies: string[], factory: Factory): void;\n\t\t(dependencies: string[], factory: Factory): void;\n\t\t(factory: Factory): void;\n\t\t(value: any): void;\n\t\tamd: { [prop: string]: string | number | boolean };\n\t}\n\n\tinterface Factory {\n\t\t(...modules: any[]): any;\n\t}\n\n\tinterface Has {\n\t\t(name: string): any;\n\t\tadd(name: string, value: (global: Window, document?: HTMLDocument, element?: HTMLDivElement) => any,\n\t\t\tnow?: boolean, force?: boolean): void;\n\t\tadd(name: string, value: any, now?: boolean, force?: boolean): void;\n\t}\n\n\tinterface LoaderError extends Error {\n\t\treadonly src: string;\n\t\treadonly info: { module: Module, url: string, parentMid: string, details?: string };\n\t}\n\n\t/**\n\t * AMD Loader Plugin API\n\t *\n\t * See [Loader Plugin API](https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md)\n\t */\n\tinterface LoaderPlugin {\n\t\t/**\n\t\t * A function that is called to load a resource. This is the only mandatory API method that needs\n\t\t * to be implemented for the plugin to be useful, assuming the resource IDs do not need special\n\t\t * ID normalization.\n\t\t * @param resourceId The resource ID that the plugin should load. This ID MUST be normalized.\n\t\t * @param require A local require function to use to load other modules. This require function\n\t\t *                has some utilities on it:\n\t\t *                * **require.toUrl('moduleId+extension')** See the `require.toUrl` API notes\n\t\t *                  for more information.\n\t\t * @param load A function to call once the value of the resource ID has been determined. This\n\t\t *             tells the loader that the plugin is done loading the resource.\n\t\t * @param config A configuration object. This is a way for the optimizer and the web app to\n\t\t *               pass configuration information to the plugin. An optimization tool may set\n\t\t *               an `isBuild` property in the config to true if this plugin is being called\n\t\t *               as part of an optimizer build.\n\t\t */\n\t\tload?(resourceId: string, require: Require, load: (value?: any) => void, config?: { [ prop: string ]: any; }): void;\n\n\t\t/**\n\t\t * A function to normalize the passed-in resource ID. Normalization of an module ID normally\n\t\t * means converting relative paths, like `./some/path` or `../another/path` to be non-relative,\n\t\t * absolute IDs\n\t\t * @param resourceId The resource ID to normalize.\n\t\t * @param normalize A normalization function that accepts a string ID to normalize using the\n\t\t *                  standard relative module normalization rules using the loader's current\n\t\t *                  configuration.\n\t\t */\n\t\tnormalize?(resourceId: string, normalize: (moduleId: string) => string): string;\n\t}\n\n\tinterface MapItem extends Array<any> {\n\t\t/* prefix */      0: string;\n\t\t/* replacement */ 1: any;\n\t\t/* regExp */      2: RegExp;\n\t\t/* length */      3: number;\n\t}\n\n\tinterface MapReplacement extends MapItem {\n\t\t/* replacement */ 1: string;\n\t}\n\n\tinterface MapRoot extends Array<MapSource> {\n\t\tstar?: MapSource;\n\t}\n\n\tinterface MapSource extends MapItem {\n\t\t/* replacement */ 1: MapReplacement[];\n\t}\n\n\t// TODO are we still abbreviating these properties?\n\t// TODO shouldn't extend for LoaderPlugin because technically `load` is not optional\n\tinterface Module extends LoaderPlugin {\n\t\tcjs: {\n\t\t\texports: any;\n\t\t\tid: string;\n\t\t\tsetExports: (exports: any) => void;\n\t\t\turi: string;\n\t\t};\n\t\tdef: Factory;\n\t\tdeps: Module[];\n\t\texecuted: any; // TODO: enum\n\t\tinjected: boolean;\n\t\tfix?: (module: Module) => void;\n\t\tgc: boolean;\n\t\tmid: string;\n\t\tpack: Package;\n\t\treq: Require;\n\t\trequire?: Require; // TODO: WTF?\n\t\tresult: any;\n\t\turl: string;\n\n\t\t// plugin interface\n\t\tloadQ?: Module[];\n\t\tplugin?: Module;\n\t\tprid: string;\n\t}\n\n\tinterface ModuleDefinitionArguments extends Array<any> {\n\t\t0: string[];\n\t\t1: Factory;\n\t}\n\n\tinterface ModuleMap extends ModuleMapItem {\n\t\t[ sourceMid: string ]: ModuleMapReplacement | string;\n\t}\n\n\tinterface ModuleMapItem {\n\t\t[ mid: string ]: /* ModuleMapReplacement | ModuleMap */ any;\n\t}\n\n\tinterface ModuleMapReplacement extends ModuleMapItem {\n\t\t[ findMid: string ]: /* replaceMid */ string;\n\t}\n\n\tinterface ObjectMap { [ key: string ]: any; }\n\n\tinterface Package {\n\t\tlocation?: string;\n\t\tmain?: string;\n\t\tname?: string;\n\t}\n\n\tinterface PackageMap {\n\t\t[ packageId: string ]: Package;\n\t}\n\n\tinterface PathMap extends MapReplacement {}\n\n\tinterface ModuleShim {\n\t\tdeps?: string[];\n\t\texports?: string;\n\t\tinit?: (...dependencies: any[]) => any;\n\t}\n\n\tinterface Require {\n\t\t(dependencies: string[], callback: RequireCallback): void;\n\t\t<ModuleType>(moduleId: string): ModuleType;\n\n\t\ttoAbsMid(moduleId: string): string;\n\t\ttoUrl(path: string): string;\n\t}\n\n\tinterface RequireCallback {\n\t\t(...modules: any[]): void;\n\t}\n\n\tinterface RootRequire extends Require {\n\t\tcache(cache: DojoLoader.ObjectMap): void;\n\t\thas: Has;\n\t\ton(type: SignalType, listener: any): { remove: () => void };\n\t\tconfig(config: Config): void;\n\t\tinspect?(name: string): any;\n\t\tnodeRequire?(id: string): any;\n\t\tundef(moduleId: string, recursive?: boolean): void;\n\t}\n\n\ttype SignalType = 'error';\n}\n\ndeclare const define: DojoLoader.Define;\n\ndeclare interface NodeRequire {\n\t(dependencies: string[], callback: DojoLoader.RequireCallback): void;\n\n\tconfig(config: DojoLoader.Config): void;\n\thas: DojoLoader.Has;\n\tinspect?(name: string): any;\n\tnodeRequire?: NodeRequire;\n\ton(type: DojoLoader.SignalType, listener: any): { remove: () => void };\n\ttoAbsMid(moduleId: string): string;\n\ttoUrl(path: string): string;\n\tundef(moduleId: string, recursive?: boolean): void;\n}\n\ndeclare const arguments: IArguments;\nimport ModuleShim = DojoLoader.ModuleShim;\nimport Module = DojoLoader.Module;\nimport Package = DojoLoader.Package;\ndeclare const load: (module: string) => any;\ndeclare const Packages: {} | undefined;\ndeclare const importScripts: ((url: string) => void);\n","type":2},{"name":"node_modules/@dojo/routing/history/_alias-ambient-history.d.ts","text":"export declare type BrowserHistory = History;\n","type":2},{"name":"node_modules/@dojo/routing/history/HashHistory.d.ts","text":"import { HistoryBase } from './HistoryBase';\nimport { History, HistoryOptions } from './interfaces';\n/**\n * Options for creating HashHistory instances.\n */\nexport interface HashHistoryOptions extends HistoryOptions {\n    /**\n     * A DOM window object. HashHistory uses the `location` property and\n     * listens to `hashchange` events. The current value is initialized to the\n     * initial hash.\n     */\n    window: Window;\n}\nexport declare class HashHistory extends HistoryBase implements History {\n    private _current;\n    private _browserLocation;\n    readonly current: string;\n    constructor({window}?: HashHistoryOptions);\n    prefix(path: string): string;\n    normalizePath(path: string): string;\n    set(path: string): void;\n    replace(path: string): void;\n}\nexport default HashHistory;\n","type":2},{"name":"node_modules/@dojo/routing/history/HistoryBase.d.ts","text":"import { BaseEventedEvents, Evented } from '@dojo/core/Evented';\nimport { EventedListenerOrArray } from '@dojo/interfaces/bases';\nimport { Handle } from '@dojo/interfaces/core';\nimport { History, HistoryChangeEvent } from './interfaces';\nexport interface HistoryEvents extends BaseEventedEvents {\n    (type: 'change', listener: EventedListenerOrArray<History, HistoryChangeEvent>): Handle;\n}\nexport declare class HistoryBase extends Evented {\n    on: HistoryEvents;\n    normalizePath(path: string): string;\n}\nexport default HistoryBase;\n","type":2},{"name":"node_modules/@dojo/routing/history/interfaces.d.ts","text":"import { Evented } from '@dojo/core/Evented';\nimport { EventedOptions, EventedListenerOrArray, EventedListenersMap } from '@dojo/interfaces/bases';\nimport { EventTargettedObject, Handle } from '@dojo/interfaces/core';\nexport { BrowserHistory } from './_alias-ambient-history';\n/**\n * Event object that is emitted for the 'change' event.\n */\nexport interface HistoryChangeEvent extends EventTargettedObject<History> {\n    /**\n     * The new (current) value of the history. This is a path string.\n     */\n    value: string;\n}\nexport interface History extends Evented {\n    /**\n     * Get the current value. This is a path string.\n     *\n     * Implementations may ensure that the value always starts with a slash.\n     */\n    readonly current: string;\n    /**\n     * Prefixes the value in order to create a path that can be used with a browser.\n     */\n    prefix(path: string): string;\n    /**\n     * Set the current value. If used with a browser implementation causes a new history entry\n     * to be added. Fires the 'change' event.\n     */\n    set(path: string): void;\n    /**\n     * Replace the current value. If used with a browser implementation causes the current\n     * history entry to be replaced. Fires the 'change' event.\n     */\n    replace(path: string): void;\n    /**\n     * Function that will normalize the path for the history manager\n     */\n    normalizePath(path: string): string;\n    /**\n     * Event emitted when the current value is changed, after the browser's history has\n     * been updated.\n     */\n    on(type: 'change', listener: EventedListenerOrArray<History, HistoryChangeEvent>): Handle;\n    on<T>(type: string, listener: EventedListenerOrArray<T, EventTargettedObject<T>>): Handle;\n    on<T>(listeners: EventedListenersMap<T>): Handle;\n}\nexport interface HistoryOptions extends EventedOptions {\n}\n","type":2},{"name":"node_modules/@dojo/routing/history/MemoryHistory.d.ts","text":"import { HistoryBase } from './HistoryBase';\nimport { History, HistoryOptions } from './interfaces';\n/**\n * Options for creating MemoryHistory instances.\n */\nexport interface MemoryHistoryOptions extends HistoryOptions {\n    /**\n     * The current value is set to the path.\n     */\n    path: string;\n}\n/**\n * A memory-backed history manager. Can be used outside of browsers.\n */\nexport declare class MemoryHistory extends HistoryBase implements History {\n    private _current;\n    readonly current: string;\n    constructor({path: current}?: MemoryHistoryOptions);\n    prefix(path: string): string;\n    set(path: string): void;\n    replace(path: string): void;\n}\nexport default MemoryHistory;\n","type":2},{"name":"node_modules/@dojo/routing/history/StateHistory.d.ts","text":"import { HistoryBase } from './HistoryBase';\nimport { History, HistoryOptions } from './interfaces';\n/**\n * Options for creating StateHistory instances.\n */\nexport interface StateHistoryOptions extends HistoryOptions {\n    /**\n     * A base pathname. The current value, as well as the emitted change value, will be relative to this base (though\n     * starting with a slash). If not set the DOM window's location's path will be used in its entirety. If the\n     * location's path is not a suffix of the base, the value will be a single slash instead.\n     *\n     * Must not contain fragment identifiers or search components.\n     */\n    base?: string;\n    /**\n     * A DOM window object. StateHistory uses the `history` and `location` properties and\n     * listens to `popstate` events. The current value is initialized to the current path.\n     */\n    window: Window;\n}\n/**\n * A browser-based history manager that uses the history object to store the current value.\n *\n * This manager ensures the current value always starts with a slash.\n */\nexport declare class StateHistory extends HistoryBase implements History {\n    private _base;\n    private _current;\n    private _browserHistory;\n    readonly current: string;\n    prefix(path: string): string;\n    set(path: string): void;\n    replace(path: string): void;\n    constructor({base, window}?: StateHistoryOptions);\n}\nexport default StateHistory;\n","type":2},{"name":"node_modules/@dojo/routing/interfaces.d.ts","text":"import Task from '@dojo/core/async/Task';\nimport Evented, { BaseEventedEvents } from '@dojo/core/Evented';\nimport { PausableHandle } from '@dojo/core/on';\nimport UrlSearchParams from '@dojo/core/UrlSearchParams';\nimport { EventedListener, EventedOptions } from '@dojo/interfaces/bases';\nimport { EventErrorObject, EventTargettedObject, Handle, Hash } from '@dojo/interfaces/core';\nimport { Thenable } from '@dojo/interfaces/shim';\nimport { Constructor, RegistryLabel, WidgetBaseInterface } from '@dojo/widget-core/interfaces';\nimport { History } from './history/interfaces';\nimport { DeconstructedPath } from './lib/path';\n/**\n * Routes created without a `params()` function will receive a `params` object of this type.\n */\nexport interface DefaultParameters extends Parameters {\n    [param: string]: string;\n}\n/**\n * Describes the context object used when dispatching. Extend this interface for custom contexts.\n */\nexport interface Context {\n}\n/**\n * Describes extracted parameters.\n */\nexport interface Parameters {\n    [param: string]: any;\n}\n/**\n * Describes the object passed to various route handlers.\n */\nexport interface Request<C extends Context, P extends Parameters> {\n    /**\n     * The dispatch context.\n     */\n    context: C;\n    /**\n     * The extracted parameters.\n     */\n    params: P;\n}\n/**\n * Component type\n */\nexport declare type Component<W extends WidgetBaseInterface = WidgetBaseInterface> = Constructor<W> | RegistryLabel;\n/**\n * Outlet component options\n */\nexport interface OutletComponents<W extends WidgetBaseInterface, I extends WidgetBaseInterface, E extends WidgetBaseInterface> {\n    main?: Component<W>;\n    index?: Component<I>;\n    error?: Component<E>;\n}\n/**\n * Options for map params callback\n */\nexport interface MapParamsOptions {\n    params: any;\n    type: MatchType;\n    location: string;\n    router: RouterInterface<any>;\n}\n/**\n * Interface for the map params callback\n */\nexport interface MapParams {\n    (options: MapParamsOptions): any;\n}\n/**\n * Outlet properties\n */\nexport interface OutletProperties<W extends WidgetBaseInterface = WidgetBaseInterface, I extends WidgetBaseInterface = WidgetBaseInterface, E extends WidgetBaseInterface = WidgetBaseInterface> {\n    outlet: string;\n    mainComponent?: Component<W>;\n    indexComponent?: Component<I>;\n    errorComponent?: Component<E>;\n    mapParams?: MapParams;\n}\n/**\n * An object to resume or cancel router dispatch.\n */\nexport interface DispatchDeferral {\n    /**\n     * Call to prevent a path from being dispatched.\n     */\n    cancel(): void;\n    /**\n     * Call to resume a path being dispatched.\n     */\n    resume(): void;\n}\n/**\n * Event object that is emitted for the 'navstart' event.\n */\nexport interface NavigationStartEvent extends EventTargettedObject<RouterInterface<Context>> {\n    /**\n     * The path that has been navigated to.\n     */\n    path: string;\n    /**\n     * The context for the route\n     */\n    context: Context;\n    /**\n     * Call to prevent the path to be dispatched.\n     */\n    cancel?(): void;\n    /**\n     * Call to defer dispatching of the path\n     * @return an object which allows the caller to resume or cancel dispatch.\n     */\n    defer?(): DispatchDeferral;\n}\n/**\n * Event object that is emitted for the 'error' event.\n */\nexport interface ErrorEvent<C extends Context> extends EventErrorObject<RouterInterface<C>> {\n    /**\n     * The context that was being dispatched when the error occurred.\n     */\n    context: C;\n    /**\n     * The path that was being dispatched when the error occurred.\n     */\n    path: string;\n}\nexport interface RouterEvents<C extends Context> extends BaseEventedEvents {\n    /**\n     * Event emitted when dispatch is called, but before routes are selected.\n     */\n    (type: 'navstart', listener: EventedListener<RouterInterface<C>, NavigationStartEvent>): Handle;\n    /**\n     * Event emitted when errors occur during dispatch.\n     *\n     * Certain errors may reject the task returned when dispatching, but this task is not always accessible and may\n     * hide errors if it's canceled.\n     */\n    (type: 'error', listener: EventedListener<RouterInterface<C>, ErrorEvent<C>>): Handle;\n}\n/**\n * Config for registering routes\n */\nexport interface RouteConfig {\n    /**\n     * The path of the route\n     */\n    path: string;\n    /**\n     * The optional outlet associated to the path\n     */\n    outlet?: string;\n    /**\n     * Optional child route configuration\n     */\n    children?: RouteConfig[];\n    /**\n     * Default params used to generate a link\n     */\n    defaultParams?: any;\n    /**\n     * To be used as the default route on router start up\n     * if the current route doesn't match\n     */\n    defaultRoute?: boolean;\n}\n/**\n * Describes the result of a dispatch.\n */\nexport interface DispatchResult {\n    /**\n     * Whether a route requested a redirect to a different path.\n     */\n    redirect?: string;\n    /**\n     * False if dispatch was canceled (via the navstart event) or if no routes could be selected. True otherwise.\n     */\n    success: boolean;\n}\nexport declare type LinkParams = Hash<string | string[] | undefined>;\n/**\n * The options for the router.\n */\nexport interface RouterOptions<C extends Context> extends EventedOptions {\n    /**\n     * A Context object to be used for all requests, or a function that provides such an object, called for each\n     * dispatch.\n     */\n    context?: C | (() => C);\n    /**\n     * A handler called when no routes match the dispatch path.\n     * @param request An object whose `context` property contains the dispatch context. No extracted parameters\n     *   are available.\n     */\n    fallback?: (request: Request<C, Parameters>) => void | Thenable<any>;\n    /**\n     * The history manager. Routes will be dispatched in response to change events emitted by the manager.\n     */\n    history?: History;\n    /**\n     * Routing configuration to set up on router creation\n     */\n    config?: RouteConfig[];\n}\n/**\n * The options for the router's start() method.\n */\nexport interface StartOptions {\n    /**\n     * Whether to immediately dispatch with the history's current value.\n     */\n    dispatchCurrent: boolean;\n}\n/**\n * The outlet context\n */\nexport interface OutletContext {\n    /**\n     * The type of match for the outlet\n     */\n    type: MatchType;\n    /**\n     * The location of the route (link)\n     */\n    location: string;\n    /**\n     * The params for the specific outlet\n     */\n    params: any;\n}\nexport interface RouterInterface<C extends Context> extends Evented {\n    on: RouterEvents<C>;\n    register(config: RouteConfig[], from: string | RouterInterface<any> | RouteInterface<any, any>): void;\n    append(add: RouteInterface<Context, Parameters> | RouteInterface<Context, Parameters>[]): void;\n    dispatch(context: Context, path: string): Task<DispatchResult>;\n    link(routeOrOutlet: RouteInterface<Context, Parameters> | string, params?: LinkParams): string;\n    replacePath(path: string): void;\n    setPath(path: string): void;\n    hasOutlet(outletId: string): boolean;\n    getOutlet(outletId: string): OutletContext | undefined;\n    getCurrentParams(): Parameters;\n    start(startOptions: StartOptions): PausableHandle;\n}\n/**\n * Hash object where keys are parameter names and keys are arrays of one or more\n * parameter values.\n */\nexport declare type SearchParams = Hash<string[]>;\n/**\n * Describes whether a route matched.\n */\nexport interface MatchResult<P> {\n    /**\n     * Whether there are path segments that weren't matched by this route.\n     */\n    hasRemaining: boolean;\n    /**\n     * Position in the segments array that the remaining unmatched segments start.\n     */\n    offset: number;\n    /**\n     * Any extracted parameters. Only available if the route matched.\n     */\n    params: P;\n    /**\n     * Values for named segments in the path, in order of occurrence.\n     */\n    rawPathValues: string[];\n    /**\n     * Values for known named query parameters that were actually present in the\n     * path.\n     */\n    rawSearchParams: SearchParams;\n}\n/**\n * The type of match for a route\n */\nexport declare enum MatchType {\n    INDEX = 0,\n    PARTIAL = 1,\n    ERROR = 2,\n}\n/**\n * A request handler.\n */\nexport declare type Handler = (request: Request<Context, Parameters>) => void | Thenable<any>;\n/**\n * Describes the selection of a particular route.\n */\nexport interface Selection {\n    /**\n     * Which handler should be called when the route is executed.\n     */\n    handler: Handler;\n    /**\n     * The selected path.\n     */\n    path: DeconstructedPath;\n    /**\n     * The selected outlet\n     */\n    outlet: string | undefined;\n    /**\n     * The extracted parameters.\n     */\n    params: Parameters;\n    /**\n     * Values for named segments in the path, in order of occurrence.\n     */\n    rawPathValues: string[];\n    /**\n     * Values for known named query parameters that were actually present in the\n     * path.\n     */\n    rawSearchParams: SearchParams;\n    /**\n     * The selected route.\n     */\n    route: RouteInterface<Context, Parameters>;\n    /**\n     * The selection type\n     */\n    type: MatchType;\n}\nexport interface RouteInterface<C extends Context, P extends Parameters> {\n    readonly parent: RouteInterface<Context, Parameters> | undefined;\n    readonly path: DeconstructedPath;\n    readonly outlet: string | undefined;\n    readonly defaultParams: P;\n    append(add: RouteInterface<Context, Parameters> | RouteInterface<Context, Parameters>[]): void;\n    link(params?: LinkParams): string;\n    match(segments: string[], hasTrailingSlash: boolean, searchParams: UrlSearchParams): null | MatchResult<DefaultParameters | P>;\n    select(context: C, segments: string[], hasTrailingSlash: boolean, searchParams: UrlSearchParams): string | Selection[];\n}\n","type":2},{"name":"node_modules/@dojo/routing/lib/path.d.ts","text":"import UrlSearchParams from '@dojo/core/UrlSearchParams';\nexport interface ParsedPath {\n    /**\n     * Parameters extracted from the search component.\n     */\n    searchParams: UrlSearchParams;\n    /**\n     * Pathname segments.\n     */\n    segments: string[];\n    /**\n     * Whether the pathname ended with a trailing slash.\n     */\n    trailingSlash: boolean;\n}\n/**\n * Parses a path\n * @param path The path to parse.\n * @return The search params, pathname segments, and whether it ended with a trailing slash.\n */\nexport declare function parse(path: string): ParsedPath;\nexport interface MatchResult {\n    /**\n     * Whether there are remaining segments that weren't matched.\n     */\n    hasRemaining: boolean;\n    /**\n     * Position in the segments array that the remaining unmatched segments start.\n     */\n    offset: number;\n    /**\n     * Values for named segments.\n     */\n    values: string[];\n}\n/**\n * Determines whether a DeconstructedPath is a (partial) match for given pathname segments.\n * @param expectedSegments Part of a DeconstructedPath object.\n * @param segments Pathname segments as returned by `parse()`\n * @return A result object.\n */\nexport declare function match({expectedSegments}: DeconstructedPath, segments: string[]): MatchResult | null;\nexport interface LiteralSegment {\n    literal: string;\n}\nexport interface NamedSegment {\n    name: string;\n}\nexport declare type Segment = LiteralSegment | NamedSegment;\n/**\n * Determine whether the segment is a NamedSegment.\n *\n * @param segment The segment to be checked\n * @return true if the segment is a NamedSegment, false otherwise\n */\nexport declare function isNamedSegment(segment: Segment): segment is NamedSegment;\n/**\n * Describes a route path, broken down into its constituent parts.\n */\nexport interface DeconstructedPath {\n    /**\n     * Segments (literal and named) that are expected to be present when matching paths.\n     */\n    expectedSegments: Segment[];\n    /**\n     * Whether the pathname started with a slash.\n     */\n    leadingSlash: boolean;\n    /**\n     * Named path parameters, in the order that they occurred in the path.\n     */\n    parameters: string[];\n    /**\n     * Named query parameters, in the order that they occurred in the path.\n     */\n    searchParameters: string[];\n    /**\n     * Whether the pathname ended with a slash.\n     */\n    trailingSlash: boolean;\n}\n/**\n * Deconstruct a route path into its constituent parts.\n * @param path The path to deconstruct.\n * @return An object describing the path's constituent parts.\n */\nexport declare function deconstruct(path: string): DeconstructedPath;\n","type":2},{"name":"node_modules/@dojo/routing/lib/router.d.ts","text":"import WeakMap from '@dojo/shim/WeakMap';\nimport { Context, Parameters, RouteInterface, RouterInterface } from '../interfaces';\nexport declare const parentMap: WeakMap<RouteInterface<Context, Parameters>, RouterInterface<Context>>;\n/**\n * Whether the route has been appended to another route or router.\n */\nexport declare function hasBeenAppended(route: RouteInterface<Context, Parameters>): boolean;\n/**\n * Finds the router whose route hierarchy the route has been appended to.\n *\n * Throws if the route was not appended to any router.\n */\nexport declare function findRouter(route: RouteInterface<Context, Parameters>): RouterInterface<Context>;\n","type":2},{"name":"node_modules/@dojo/routing/Link.d.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { Constructor, DNode, VirtualDomProperties } from '@dojo/widget-core/interfaces';\nexport interface LinkProperties extends VirtualDomProperties {\n    key?: string;\n    isOutlet?: boolean;\n    params?: any;\n    onClick?: (event: MouseEvent) => void;\n    to: string;\n}\nexport declare class BaseLink extends WidgetBase<LinkProperties> {\n    private _onClick(event);\n    protected render(): DNode;\n}\nexport declare function createLink(routerKey: any): Constructor<BaseLink>;\nexport declare const Link: Constructor<BaseLink>;\n","type":2},{"name":"node_modules/@dojo/routing/main.d.ts","text":"import Route from './Route';\nexport { Route };\nimport Router from './Router';\nexport { Router };\nimport HashHistory from './history/HashHistory';\nimport MemoryHistory from './history/MemoryHistory';\nimport StateHistory from './history/StateHistory';\nexport declare const history: {\n    HashHistory: typeof HashHistory;\n    MemoryHistory: typeof MemoryHistory;\n    StateHistory: typeof StateHistory;\n};\n","type":2},{"name":"node_modules/@dojo/routing/Outlet.d.ts","text":"import { Constructor, RegistryLabel, WidgetBaseInterface, WidgetProperties } from '@dojo/widget-core/interfaces';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { Component, MapParams, OutletComponents } from './interfaces';\nexport declare function isComponent<W extends WidgetBaseInterface>(value: any): value is Component<W>;\nexport declare type Outlet<W extends WidgetBaseInterface, F extends WidgetBaseInterface, E extends WidgetBaseInterface> = Constructor<WidgetBase<Partial<E['properties']> & Partial<W['properties']> & Partial<F['properties']> & WidgetProperties, null>>;\nexport declare function Outlet<W extends WidgetBaseInterface, F extends WidgetBaseInterface, E extends WidgetBaseInterface>(outletComponents: Component<W> | OutletComponents<W, F, E>, outlet: string | string[], mapParams?: MapParams, key?: RegistryLabel): Outlet<W, F, E>;\nexport default Outlet;\n","type":2},{"name":"node_modules/@dojo/routing/Route.d.ts","text":"import UrlSearchParams from '@dojo/core/UrlSearchParams';\nimport { Thenable } from '@dojo/shim/interfaces';\nimport { Context, DefaultParameters, LinkParams, MatchResult, Parameters, Request, RouteInterface, Selection } from './interfaces';\nimport { DeconstructedPath } from './lib/path';\n/**\n * The options for the route.\n */\nexport interface RouteOptions<C, P extends Parameters> {\n    /**\n     * Path the route matches against. Pathname segments may be named, same for query parameters. Leading slashes are\n     * ignored. Defaults to `/`.\n     */\n    path?: string;\n    /**\n     * The outlet associated with the path\n     */\n    outlet?: string;\n    /**\n     * If the `path` option contains a trailing slash (in the pathname component), the route will only match against\n     * another pathname that contains a trailing slash, and vice-versa if the path does not contain a trailing slash.\n     * Defaults to `true`, change to `false` to allow routes to match regardless of trailing slashes.\n     */\n    trailingSlashMustMatch?: boolean;\n    /**\n     * A handler called when the route is executed.\n     * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n     *   available under `params`.\n     */\n    exec?(request: Request<C, P>): void | Thenable<any>;\n    /**\n     * If specified, causes the route to be selected if there are no nested routes that match the remainder of\n     * the dispatched path. When the route is executed, this handler is called rather than `exec()`.\n     * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n     *   available under `params`.\n     */\n    fallback?(request: Request<C, P>): void | Thenable<any>;\n    /**\n     * Callback used to determine whether the route should be selected after it's been matched.\n     * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n     *   available under `params`.\n     * @return Returning `true` causes the route to be selected. Returning a string indicates that a redirect is\n     *   required; the string should be the path to redirect to.\n     */\n    guard?(request: Request<C, P>): string | boolean;\n    /**\n     * If specified, and the route is the final route in the hierarchy, when the route is executed, this handler is\n     * called rather than `exec()`.\n     * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n     *   available under `params`.\n     */\n    index?(request: Request<C, P>): void | Thenable<any>;\n    /**\n     * Callback used for constructing the `params` object from extracted parameters, and validating the parameters.\n     * @param fromPathname Array of parameter values extracted from the pathname.\n     * @param searchParams Parameters extracted from the search component.\n     * @return If `null` prevents the route from being selected, else the value for the `params` object.\n     */\n    params?(fromPathname: string[], searchParams: UrlSearchParams): null | P;\n    /**\n     * Default params to use when generating a link.\n     */\n    defaultParams?: null | P;\n}\nexport declare class Route<C extends Context, P extends Parameters> implements RouteInterface<C, P> {\n    private _path;\n    private _outlet;\n    private _routes;\n    private _trailingSlashMustMatch;\n    private _computeParams;\n    private _exec?;\n    private _fallback?;\n    private _guard;\n    private _index?;\n    private _defaultParams;\n    readonly parent: Route<Context, Parameters> | undefined;\n    readonly path: DeconstructedPath;\n    readonly outlet: string | undefined;\n    readonly defaultParams: P;\n    constructor(options?: RouteOptions<C, P>);\n    append(add: Route<Context, Parameters> | Route<Context, Parameters>[]): void;\n    link(params?: LinkParams): string;\n    match(segments: string[], hasTrailingSlash: boolean, searchParams: UrlSearchParams): null | MatchResult<DefaultParameters | P>;\n    select(context: C, segments: string[], hasTrailingSlash: boolean, searchParams: UrlSearchParams): string | Selection[];\n}\nexport default Route;\n","type":2},{"name":"node_modules/@dojo/routing/Router.d.ts","text":"import Task from '@dojo/core/async/Task';\nimport Evented from '@dojo/core/Evented';\nimport { PausableHandle } from '@dojo/core/on';\nimport { Context, DispatchResult, LinkParams, OutletContext, Parameters, RouteConfig, RouteInterface, RouterEvents, RouterInterface, RouterOptions, StartOptions } from './interfaces';\nexport declare const errorOutlet = \"errorOutlet\";\nexport declare class Router<C extends Context> extends Evented implements RouterInterface<C> {\n    private _contextFactory;\n    private _currentSelection;\n    private _dispatchFromStart;\n    private _fallback?;\n    private _history?;\n    private _routes;\n    private _started?;\n    private _outletContextMap;\n    private _outletRouteMap;\n    private _currentParams;\n    private _defaultParams;\n    private _defaultRoute;\n    on: RouterEvents<C>;\n    constructor(options?: RouterOptions<C>);\n    register(config: RouteConfig[], from?: string | RouterInterface<any> | RouteInterface<any, any>): void;\n    append(add: RouteInterface<Context, Parameters> | RouteInterface<Context, Parameters>[]): void;\n    private _dispatch(context, path, canceled?, emit?);\n    dispatch(context: Context, path: string): Task<DispatchResult>;\n    link(routeOrOutlet: RouteInterface<Context, Parameters> | string, params?: LinkParams): string;\n    replacePath(path: string): void;\n    setPath(path: string): void;\n    hasOutlet(outletId: string): boolean;\n    getOutlet(outletId: string | string[]): OutletContext | undefined;\n    getCurrentParams(): Parameters;\n    start(startOptions?: StartOptions): PausableHandle;\n}\nexport default Router;\n","type":2},{"name":"node_modules/@dojo/routing/RouterInjector.d.ts","text":"import { Registry } from '@dojo/widget-core/Registry';\nimport { RegistryLabel } from '@dojo/widget-core/interfaces';\nimport { History } from './history/interfaces';\nimport { Router } from './Router';\nimport { RouteConfig } from './interfaces';\n/**\n * Key for the router injector\n */\nexport declare const routerKey: symbol;\n/**\n * Router Injector Options\n *\n */\nexport interface RouterInjectorOptions {\n    history?: History;\n    key?: RegistryLabel;\n}\n/**\n * Creates a router instance for a specific History manager (default is `HashHistory`) and registers\n * the route configuration.\n *\n * @param config The route config to register for the router\n * @param registry An optional registry that defaults to the global registry\n * @param options The router injector options\n */\nexport declare function registerRouterInjector(config: RouteConfig[], registry: Registry, options?: RouterInjectorOptions): Router<any>;\n","type":2},{"name":"node_modules/@dojo/shim/array.d.ts","text":"import { Iterable } from './iterator';\nexport interface MapCallback<T, U> {\n    /**\n     * A callback function when mapping\n     *\n     * @param element The element that is currently being mapped\n     * @param index The current index of the element\n     */\n    (element: T, index: number): U;\n}\nexport interface FindCallback<T> {\n    /**\n     * A callback function when using find\n     *\n     * @param element The element that is currenty being analysed\n     * @param index The current index of the element that is being analysed\n     * @param array The source array\n     */\n    (element: T, index: number, array: ArrayLike<T>): boolean;\n}\nexport interface From {\n    /**\n     * The Array.from() method creates a new Array instance from an array-like or iterable object.\n     *\n     * @param source An array-like or iterable object to convert to an array\n     * @param mapFunction A map function to call on each element in the array\n     * @param thisArg The execution context for the map function\n     * @return The new Array\n     */\n    <T, U>(source: ArrayLike<T> | Iterable<T>, mapFunction: MapCallback<T, U>, thisArg?: any): Array<U>;\n    /**\n     * The Array.from() method creates a new Array instance from an array-like or iterable object.\n     *\n     * @param source An array-like or iterable object to convert to an array\n     * @return The new Array\n     */\n    <T>(source: ArrayLike<T> | Iterable<T>): Array<T>;\n}\nexport declare let from: From;\n/**\n * Creates a new array from the function parameters.\n *\n * @param arguments Any number of arguments for the array\n * @return An array from the given arguments\n */\nexport declare let of: <T>(...items: T[]) => Array<T>;\n/**\n * Copies data internally within an array or array-like object.\n *\n * @param target The target array-like object\n * @param offset The index to start copying values to; if negative, it counts backwards from length\n * @param start The first (inclusive) index to copy; if negative, it counts backwards from length\n * @param end The last (exclusive) index to copy; if negative, it counts backwards from length\n * @return The target\n */\nexport declare let copyWithin: <T>(target: ArrayLike<T>, offset: number, start: number, end?: number) => ArrayLike<T>;\n/**\n * Fills elements of an array-like object with the specified value.\n *\n * @param target The target to fill\n * @param value The value to fill each element of the target with\n * @param start The first index to fill\n * @param end The (exclusive) index at which to stop filling\n * @return The filled target\n */\nexport declare let fill: <T>(target: ArrayLike<T>, value: T, start?: number, end?: number) => ArrayLike<T>;\n/**\n * Finds and returns the first instance matching the callback or undefined if one is not found.\n *\n * @param target An array-like object\n * @param callback A function returning if the current value matches a criteria\n * @param thisArg The execution context for the find function\n * @return The first element matching the callback, or undefined if one does not exist\n */\nexport declare let find: <T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}) => T | undefined;\n/**\n * Performs a linear search and returns the first index whose value satisfies the passed callback,\n * or -1 if no values satisfy it.\n *\n * @param target An array-like object\n * @param callback A function returning true if the current value satisfies its criteria\n * @param thisArg The execution context for the find function\n * @return The first index whose value satisfies the passed callback, or -1 if no values satisfy it\n */\nexport declare let findIndex: <T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}) => number;\n/**\n * Determines whether an array includes a given value\n *\n * @param target the target array-like object\n * @param searchElement the item to search for\n * @param fromIndex the starting index to search from\n * @return `true` if the array includes the element, otherwise `false`\n */\nexport declare let includes: <T>(target: ArrayLike<T>, searchElement: T, fromIndex?: number) => boolean;\n","type":2},{"name":"node_modules/@dojo/shim/browser.d.ts","text":"import 'pepjs';\nimport 'intersection-observer';\n","type":2},{"name":"node_modules/@dojo/shim/global.d.ts","text":"declare const globalObject: any;\nexport default globalObject;\n","type":2},{"name":"node_modules/@dojo/shim/interfaces.d.ts","text":"export interface Handle {\n\t/**\n\t * Perform the destruction/cleanup logic associated with this handle\n\t */\n\tdestroy(): void;\n}\n\n/**\n * Something that is _thenable_\n * @deprecated Use `PromiseLike` from TypeScript lib instead\n */\nexport type Thenable<T> = PromiseLike<T>;\n","type":2},{"name":"node_modules/@dojo/shim/iterator.d.ts","text":"import './Symbol';\nexport interface IteratorResult<T> {\n    readonly done: boolean;\n    readonly value: T;\n}\nexport interface Iterator<T> {\n    next(value?: any): IteratorResult<T>;\n    return?(value?: any): IteratorResult<T>;\n    throw?(e?: any): IteratorResult<T>;\n}\nexport interface Iterable<T> {\n    [Symbol.iterator](): Iterator<T>;\n}\nexport interface IterableIterator<T> extends Iterator<T> {\n    [Symbol.iterator](): IterableIterator<T>;\n}\n/**\n * A class that _shims_ an iterator interface on array like objects.\n */\nexport declare class ShimIterator<T> {\n    private _list;\n    private _nextIndex;\n    private _nativeIterator;\n    constructor(list: ArrayLike<T> | Iterable<T>);\n    /**\n     * Return the next iteration result for the Iterator\n     */\n    next(): IteratorResult<T>;\n    [Symbol.iterator](): IterableIterator<T>;\n}\n/**\n * A type guard for checking if something has an Iterable interface\n *\n * @param value The value to type guard against\n */\nexport declare function isIterable(value: any): value is Iterable<any>;\n/**\n * A type guard for checking if something is ArrayLike\n *\n * @param value The value to type guard against\n */\nexport declare function isArrayLike(value: any): value is ArrayLike<any>;\n/**\n * Returns the iterator for an object\n *\n * @param iterable The iterable object to return the iterator for\n */\nexport declare function get<T>(iterable: Iterable<T> | ArrayLike<T>): Iterator<T> | undefined;\nexport interface ForOfCallback<T> {\n    /**\n     * A callback function for a forOf() iteration\n     *\n     * @param value The current value\n     * @param object The object being iterated over\n     * @param doBreak A function, if called, will stop the iteration\n     */\n    (value: T, object: Iterable<T> | ArrayLike<T> | string, doBreak: () => void): void;\n}\n/**\n * Shims the functionality of `for ... of` blocks\n *\n * @param iterable The object the provides an interator interface\n * @param callback The callback which will be called for each item of the iterable\n * @param thisArg Optional scope to pass the callback\n */\nexport declare function forOf<T>(iterable: Iterable<T> | ArrayLike<T> | string, callback: ForOfCallback<T>, thisArg?: any): void;\n","type":2},{"name":"node_modules/@dojo/shim/main.d.ts","text":"import './tslib';\nimport * as array from './array';\nimport * as iterator from './iterator';\nimport Map from './Map';\nimport * as math from './math';\nimport * as number from './number';\nimport * as object from './object';\nimport Set from './Set';\nimport * as string from './string';\nimport Symbol from './Symbol';\nimport WeakMap from './WeakMap';\nimport './Promise';\nimport './Symbol';\nexport { array, iterator, Map, math, number, object, Set, string, Symbol, WeakMap };\n","type":2},{"name":"node_modules/@dojo/shim/Map.d.ts","text":"import { Iterable, IterableIterator } from './iterator';\nimport './Symbol';\nexport interface Map<K, V> {\n    /**\n     * Deletes all keys and their associated values.\n     */\n    clear(): void;\n    /**\n     * Deletes a given key and its associated value.\n     *\n     * @param key The key to delete\n     * @return true if the key exists, false if it does not\n     */\n    delete(key: K): boolean;\n    /**\n     * Returns an iterator that yields each key/value pair as an array.\n     *\n     * @return An iterator for each key/value pair in the instance.\n     */\n    entries(): IterableIterator<[K, V]>;\n    /**\n     * Executes a given function for each map entry. The function\n     * is invoked with three arguments: the element value, the\n     * element key, and the associated Map instance.\n     *\n     * @param callbackfn The function to execute for each map entry,\n     * @param thisArg The value to use for `this` for each execution of the calback\n     */\n    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;\n    /**\n     * Returns the value associated with a given key.\n     *\n     * @param key The key to look up\n     * @return The value if one exists or undefined\n     */\n    get(key: K): V | undefined;\n    /**\n     * Returns an iterator that yields each key in the map.\n     *\n     * @return An iterator containing the instance's keys.\n     */\n    keys(): IterableIterator<K>;\n    /**\n     * Checks for the presence of a given key.\n     *\n     * @param key The key to check for\n     * @return true if the key exists, false if it does not\n     */\n    has(key: K): boolean;\n    /**\n     * Sets the value associated with a given key.\n     *\n     * @param key The key to define a value to\n     * @param value The value to assign\n     * @return The Map instance\n     */\n    set(key: K, value: V): this;\n    /**\n     * Returns the number of key / value pairs in the Map.\n     */\n    readonly size: number;\n    /**\n     * Returns an iterator that yields each value in the map.\n     *\n     * @return An iterator containing the instance's values.\n     */\n    values(): IterableIterator<V>;\n    /** Returns an iterable of entries in the map. */\n    [Symbol.iterator](): IterableIterator<[K, V]>;\n    readonly [Symbol.toStringTag]: string;\n}\nexport interface MapConstructor {\n    /**\n     * Creates a new Map\n     *\n     * @constructor\n     */\n    new (): Map<any, any>;\n    /**\n     * Creates a new Map\n     *\n     * @constructor\n     *\n     * @param iterator\n     * Array or iterator containing two-item tuples used to initially populate the map.\n     * The first item in each tuple corresponds to the key of the map entry.\n     * The second item corresponds to the value of the map entry.\n     */\n    new <K, V>(iterator?: [K, V][]): Map<K, V>;\n    /**\n     * Creates a new Map\n     *\n     * @constructor\n     *\n     * @param iterator\n     * Array or iterator containing two-item tuples used to initially populate the map.\n     * The first item in each tuple corresponds to the key of the map entry.\n     * The second item corresponds to the value of the map entry.\n     */\n    new <K, V>(iterator: Iterable<[K, V]>): Map<K, V>;\n    readonly prototype: Map<any, any>;\n    readonly [Symbol.species]: MapConstructor;\n}\nexport declare let Map: MapConstructor;\nexport default Map;\n","type":2},{"name":"node_modules/@dojo/shim/math.d.ts","text":"export declare const FRACTION_UNITS: number;\nexport declare const MAX_FLOAT32 = 3.4028234663852886e+38;\nexport declare const MIN_FLOAT32 = 1.401298464324817e-45;\n/**\n * Returns the hyperbolic arccosine of a number.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let acosh: (n: number) => number;\n/**\n * Returns the hyperbolic arcsine of a number.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let asinh: (n: number) => number;\n/**\n * Returns the hyperbolic arctangent of a number.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let atanh: (n: number) => number;\n/**\n * Returns the cube root of a number.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let cbrt: (n: number) => number;\n/**\n * Returns the number of leading zero bits in the 32-bit\n * binary representation of a number.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let clz32: (n: number) => number;\n/**\n * Returns the hyperbolic cosine of a number.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let cosh: (n: number) => number;\n/**\n * Returns e raised to the specified power minus one.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let expm1: (n: number) => number;\n/**\n * Returns the nearest single-precision float representation of a number.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let fround: (n: number) => number;\n/**\n * Returns the square root of the sum of squares of its arguments.\n *\n * @return The result\n */\nexport declare let hypot: (...args: number[]) => number;\n/**\n * Returns the result of the 32-bit multiplication of the two parameters.\n *\n * @param n The number to use in calculation\n * @param m The number to use in calculation\n * @return The result\n */\nexport declare let imul: (n: number, m: number) => number;\n/**\n * Returns the base 2 logarithm of a number.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let log2: (n: number) => number;\n/**\n * Returns the base 10 logarithm of a number.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let log10: (n: number) => number;\n/**\n * Returns the natural logarithm of 1 + a number.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let log1p: (n: number) => number;\n/**\n * Returns the sign of a number, indicating whether the number is positive.\n *\n * @param n The number to use in calculation\n * @return 1 if the number is positive, -1 if the number is negative, or 0 if the number is 0\n */\nexport declare let sign: (n: number) => number;\n/**\n * Returns the hyperbolic sine of a number.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let sinh: (n: number) => number;\n/**\n * Returns the hyperbolic tangent of a number.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let tanh: (n: number) => number;\n/**\n * Returns the integral part of a number by removing any fractional digits.\n *\n * @param n The number to use in calculation\n * @return The result\n */\nexport declare let trunc: (n: number) => number;\n","type":2},{"name":"node_modules/@dojo/shim/number.d.ts","text":"/**\n * The smallest interval between two representable numbers.\n */\nexport declare const EPSILON = 1;\n/**\n * The maximum safe integer in JavaScript\n */\nexport declare const MAX_SAFE_INTEGER: number;\n/**\n * The minimum safe integer in JavaScript\n */\nexport declare const MIN_SAFE_INTEGER: number;\n/**\n * Determines whether the passed value is NaN without coersion.\n *\n * @param value The value to test\n * @return true if the value is NaN, false if it is not\n */\nexport declare function isNaN(value: any): boolean;\n/**\n * Determines whether the passed value is a finite number without coersion.\n *\n * @param value The value to test\n * @return true if the value is finite, false if it is not\n */\nexport declare function isFinite(value: any): value is number;\n/**\n * Determines whether the passed value is an integer.\n *\n * @param value The value to test\n * @return true if the value is an integer, false if it is not\n */\nexport declare function isInteger(value: any): value is number;\n/**\n * Determines whether the passed value is an integer that is 'safe,' meaning:\n *   1. it can be expressed as an IEEE-754 double precision number\n *   2. it has a one-to-one mapping to a mathematical integer, meaning its\n *      IEEE-754 representation cannot be the result of rounding any other\n *      integer to fit the IEEE-754 representation\n *\n * @param value The value to test\n * @return true if the value is an integer, false if it is not\n */\nexport declare function isSafeInteger(value: any): value is number;\n","type":2},{"name":"node_modules/@dojo/shim/object.d.ts","text":"export interface ObjectAssign {\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source The source object from which to copy properties.\n     */\n    <T, U>(target: T, source: U): T & U;\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source1 The first source object from which to copy properties.\n     * @param source2 The second source object from which to copy properties.\n     */\n    <T, U, V>(target: T, source1: U, source2: V): T & U & V;\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source1 The first source object from which to copy properties.\n     * @param source2 The second source object from which to copy properties.\n     * @param source3 The third source object from which to copy properties.\n     */\n    <T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param sources One or more source objects from which to copy properties\n     */\n    (target: object, ...sources: any[]): any;\n}\nexport interface ObjectEnteries {\n    /**\n     * Returns an array of key/values of the enumerable properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    <T extends {\n        [key: string]: any;\n    }, K extends keyof T>(o: T): [keyof T, T[K]][];\n    /**\n     * Returns an array of key/values of the enumerable properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    (o: object): [string, any][];\n}\nexport interface ObjectGetOwnPropertyDescriptors {\n    <T>(o: T): {\n        [K in keyof T]: PropertyDescriptor;\n    };\n    (o: any): {\n        [key: string]: PropertyDescriptor;\n    };\n}\nexport interface ObjectValues {\n    /**\n     * Returns an array of values of the enumerable properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    <T>(o: {\n        [s: string]: T;\n    }): T[];\n    /**\n     * Returns an array of values of the enumerable properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    (o: object): any[];\n}\nexport declare let assign: ObjectAssign;\n/**\n * Gets the own property descriptor of the specified object.\n * An own property descriptor is one that is defined directly on the object and is not\n * inherited from the object's prototype.\n * @param o Object that contains the property.\n * @param p Name of the property.\n */\nexport declare let getOwnPropertyDescriptor: <T, K extends keyof T>(o: T, propertyKey: K) => PropertyDescriptor | undefined;\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly\n * on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions.\n * @param o Object that contains the own properties.\n */\nexport declare let getOwnPropertyNames: (o: any) => string[];\n/**\n * Returns an array of all symbol properties found directly on object o.\n * @param o Object to retrieve the symbols from.\n */\nexport declare let getOwnPropertySymbols: (o: any) => symbol[];\n/**\n * Returns true if the values are the same value, false otherwise.\n * @param value1 The first value.\n * @param value2 The second value.\n */\nexport declare let is: (value1: any, value2: any) => boolean;\n/**\n * Returns the names of the enumerable properties and methods of an object.\n * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n */\nexport declare let keys: (o: object) => string[];\nexport declare let getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors;\nexport declare let entries: ObjectEnteries;\nexport declare let values: ObjectValues;\n","type":2},{"name":"node_modules/@dojo/shim/Observable.d.ts","text":"import { Iterable } from './iterator';\nimport './Symbol';\nexport interface Observable<T> extends ObservableObject {\n    /**\n     * Registers handlers for handling emitted values, error and completions from the observable, and\n     * executes the observable's subscriber function, which will take action to set up the underlying data stream.\n     *\n     * @param observer    The observer object that will handle events\n     *\n     * @return A Subscription object that can be used to manage the subscription.\n     */\n    subscribe(observer: Observer<T>): Subscription;\n    /**\n     * Registers handlers for handling emitted values, error and completions from the observable, and\n     * executes the observable's subscriber function, which will take action to set up the underlying data stream.\n     *\n     * @param onNext A function to handle an emitted value. Value is passed in as the first parameter to the function.\n     * @param onError A function to handle errors that occur during onNext, or during subscription.\n     * @param onComplete A function that gets called when the subscription is complete, and will not send any more values. This function will also get called if an error occurs and onError is not defined.\n     *\n     * @return {Subscription} A Subscription object that can be used to manage the subscription.\n     */\n    subscribe(onNext: (value: T) => any, onError?: (error: any) => any, onComplete?: (completeValue?: any) => void): Subscription;\n    [Symbol.observable](): this;\n}\nexport interface ObservableConstructor {\n    /**\n     * Create a new observerable with a subscriber function. The subscriber function will get called with a\n     * SubscriptionObserver parameter for controlling the subscription.  I a function is returned, it will be\n     * run when the subscription is complete.\n     *\n     * @param subscriber The subscription function to be called when observers are subscribed\n     *\n     * @example\n     * ```ts\n     * const source = new Observer<number>((observer) => {\n     *     observer.next(1);\n     *     observer.next(2);\n     *     observer.next(3);\n     * });\n     * ```ts\n     */\n    new <T>(subscriber: Subscriber<T>): Observable<T>;\n    /**\n     * Create an Observable from another object. If the object is in itself Observable, the object will be returned.\n     * Otherwise, the value will be wrapped in an Observable. If the object is iterable, an Observable will be created\n     * that emits each item of the iterable.\n     *\n     * @param item The item to be turned into an Observable\n     * @return An observable for the item you passed in\n     */\n    from<T>(item: Iterable<T> | ArrayLike<T> | ObservableObject): Observable<T>;\n    /**\n     * Create an Observable from a list of values.\n     *\n     * @param items The values to be emitted\n     * @return An Observable that will emit the specified values\n     *\n     * @example\n     * ```ts\n     * let source = Observable.of(1, 2, 3);\n     * // will emit three separate values, 1, 2, and 3.\n     * ```\n     */\n    of<T>(...items: T[]): Observable<T>;\n}\n/**\n * An object that implements a Symbol.observerable method.\n */\nexport interface ObservableObject {\n    [Symbol.observable]: () => any;\n}\n/**\n * Handles events emitted from the subscription\n */\nexport interface Observer<T> {\n    /**\n     * Called to handle a single emitted event.\n     *\n     * @param value The value that was emitted.\n     */\n    next?(value: T): any;\n    /**\n     * An optional method to be called when the subscription starts (before any events are emitted).\n     * @param observer\n     */\n    start?(observer: Subscription): void;\n    /**\n     * An optional method to be called if an error occurs during subscription or handling.\n     *\n     * @param errorValue The error\n     */\n    error?(errorValue: any): any;\n    /**\n     * An optional method to be called when the subscription is completed (unless an error occurred and the error method was specified)\n     *\n     * @param completeValue The value passed to the completion method.\n     */\n    complete?(completeValue?: any): void;\n}\n/**\n * Describes an object that can be subscribed to\n */\nexport interface Subscribable<T> {\n    subscribe(observer: Observer<T>): Subscription;\n    subscribe(onNext: (value: T) => any, onError?: (error: any) => any, onComplete?: (completeValue?: any) => void): Subscription;\n}\nexport interface Subscriber<T> {\n    (observer: SubscriptionObserver<T>): (() => void) | void | {\n        unsubscribe: () => void;\n    };\n}\n/**\n * Handles an individual subscription to an Observable.\n */\nexport interface Subscription {\n    /**\n     * Whether or not the subscription is closed. Closed subscriptions will not emit values.\n     */\n    closed: boolean;\n    /**\n     * A function to call to close the subscription. Calling this will call any associated tear down methods.\n     */\n    unsubscribe: (() => void);\n}\n/**\n * An object used to control a single subscription and an observer.\n */\nexport interface SubscriptionObserver<T> {\n    /**\n     * Whether or not the subscription is closed.\n     */\n    readonly closed: boolean;\n    /**\n     * Emit an event to the observer.\n     *\n     * @param value The value to be emitted.\n     */\n    next(value: T): any;\n    /**\n     * Report an error. The subscription will be closed after an error has occurred.\n     *\n     * @param errorValue The error to be reported.\n     */\n    error(errorValue: any): any;\n    /**\n     * Report completion of the subscription. The subscription will be closed, and no new values will be emitted,\n     * after completion.\n     *\n     * @param completeValue A value to pass to the completion handler.\n     */\n    complete(completeValue?: any): void;\n}\nexport declare let Observable: ObservableConstructor;\nexport default Observable;\n","type":2},{"name":"node_modules/@dojo/shim/Promise.d.ts","text":"import './Symbol';\n/**\n * Executor is the interface for functions used to initialize a Promise.\n */\nexport interface Executor<T> {\n    /**\n     * The executor for the promise\n     *\n     * @param resolve The resolver callback of the promise\n     * @param reject The rejector callback of the promise\n     */\n    (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void): void;\n}\nexport declare let ShimPromise: typeof Promise;\nexport declare const isThenable: <T>(value: any) => value is PromiseLike<T>;\nexport default ShimPromise;\n","type":2},{"name":"node_modules/@dojo/shim/Set.d.ts","text":"import { IterableIterator, Iterable } from './iterator';\nimport './Symbol';\nexport interface Set<T> {\n    /**\n     * Adds a `value` to the `Set`\n     *\n     * @param value The value to add to the set\n     * @returns The instance of the `Set`\n     */\n    add(value: T): this;\n    /**\n     * Removes all the values from the `Set`.\n     */\n    clear(): void;\n    /**\n     * Removes a `value` from the set\n     *\n     * @param value The value to be removed\n     * @returns `true` if the value was removed\n     */\n    delete(value: T): boolean;\n    /**\n     * Returns an iterator that yields each entry.\n     *\n     * @return An iterator for each key/value pair in the instance.\n     */\n    entries(): IterableIterator<[T, T]>;\n    /**\n     * Executes a given function for each set entry. The function\n     * is invoked with three arguments: the element value, the\n     * element key, and the associated `Set` instance.\n     *\n     * @param callbackfn The function to execute for each map entry,\n     * @param thisArg The value to use for `this` for each execution of the calback\n     */\n    forEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: any): void;\n    /**\n     * Identifies if a value is part of the set.\n     *\n     * @param value The value to check\n     * @returns `true` if the value is part of the set otherwise `false`\n     */\n    has(value: T): boolean;\n    /**\n     * Despite its name, returns an iterable of the values in the set,\n     */\n    keys(): IterableIterator<T>;\n    /**\n     * Returns the number of values in the `Set`.\n     */\n    readonly size: number;\n    /**\n     * Returns an iterable of values in the set.\n     */\n    values(): IterableIterator<T>;\n    /** Iterates over values in the set. */\n    [Symbol.iterator](): IterableIterator<T>;\n    readonly [Symbol.toStringTag]: 'Set';\n}\nexport interface SetConstructor {\n    /**\n     * Creates a new Set\n     *\n     * @constructor\n     */\n    new (): Set<any>;\n    /**\n     * Creates a new Set\n     *\n     * @constructor\n     *\n     * @param iterator The iterable structure to initialize the set with\n     */\n    new <T>(iterator?: T[]): Set<T>;\n    /**\n     * Creates a new Set\n     *\n     * @constructor\n     *\n     * @param iterator The iterable structure to initialize the set with\n     */\n    new <T>(iterator: Iterable<T>): Set<T>;\n    readonly prototype: Set<any>;\n}\nexport declare let Set: SetConstructor;\nexport default Set;\n","type":2},{"name":"node_modules/@dojo/shim/string.d.ts","text":"export interface StringNormalize {\n    /**\n     * Returns the String value result of normalizing the string into the normalization form\n     * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n     * @param target The target string\n     * @param form Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\n     * is \"NFC\"\n     */\n    (target: string, form: 'NFC' | 'NFD' | 'NFKC' | 'NFKD'): string;\n    /**\n     * Returns the String value result of normalizing the string into the normalization form\n     * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n     * @param target The target string\n     * @param form Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\n     * is \"NFC\"\n     */\n    (target: string, form?: string): string;\n}\n/**\n * The minimum location of high surrogates\n */\nexport declare const HIGH_SURROGATE_MIN = 55296;\n/**\n * The maximum location of high surrogates\n */\nexport declare const HIGH_SURROGATE_MAX = 56319;\n/**\n * The minimum location of low surrogates\n */\nexport declare const LOW_SURROGATE_MIN = 56320;\n/**\n * The maximum location of low surrogates\n */\nexport declare const LOW_SURROGATE_MAX = 57343;\n/**\n * Return the String value whose elements are, in order, the elements in the List elements.\n * If length is 0, the empty string is returned.\n * @param codePoints The code points to generate the string\n */\nexport declare let fromCodePoint: (...codePoints: number[]) => string;\n/**\n * `raw` is intended for use as a tag function of a Tagged Template String. When called\n * as such the first argument will be a well formed template call site object and the rest\n * parameter will contain the substitution values.\n * @param template A well-formed template string call site representation.\n * @param substitutions A set of substitution values.\n */\nexport declare let raw: (template: TemplateStringsArray, ...substitutions: any[]) => string;\n/**\n * Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\n * value of the UTF-16 encoded code point starting at the string element at position pos in\n * the String resulting from converting this object to a String.\n * If there is no element at that position, the result is undefined.\n * If a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.\n */\nexport declare let codePointAt: (target: string, pos?: number) => number | undefined;\n/**\n * Returns true if the sequence of elements of searchString converted to a String is the\n * same as the corresponding elements of this object (converted to a String) starting at\n * endPosition – length(this). Otherwise returns false.\n */\nexport declare let endsWith: (target: string, searchString: string, endPosition?: number) => boolean;\n/**\n * Returns true if searchString appears as a substring of the result of converting this\n * object to a String, at one or more positions that are\n * greater than or equal to position; otherwise, returns false.\n * @param target The target string\n * @param searchString search string\n * @param position If position is undefined, 0 is assumed, so as to search all of the String.\n */\nexport declare let includes: (target: string, searchString: string, position?: number) => boolean;\n/**\n * Returns the String value result of normalizing the string into the normalization form\n * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n * @param target The target string\n * @param form Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\n * is \"NFC\"\n */\nexport declare let normalize: StringNormalize;\n/**\n * Returns a String value that is made from count copies appended together. If count is 0,\n * T is the empty String is returned.\n * @param count number of copies to append\n */\nexport declare let repeat: (target: string, count?: number) => string;\n/**\n * Returns true if the sequence of elements of searchString converted to a String is the\n * same as the corresponding elements of this object (converted to a String) starting at\n * position. Otherwise returns false.\n */\nexport declare let startsWith: (target: string, searchString: string, position?: number) => boolean;\n/**\n * Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\n * The padding is applied from the end (right) of the current string.\n *\n * @param target The target string\n * @param maxLength The length of the resulting string once the current string has been padded.\n *        If this parameter is smaller than the current string's length, the current string will be returned as it is.\n *\n * @param fillString The string to pad the current string with.\n *        If this string is too long, it will be truncated and the left-most part will be applied.\n *        The default value for this parameter is \" \" (U+0020).\n */\nexport declare let padEnd: (target: string, maxLength: number, fillString?: string) => string;\n/**\n * Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\n * The padding is applied from the start (left) of the current string.\n *\n * @param target The target string\n * @param maxLength The length of the resulting string once the current string has been padded.\n *        If this parameter is smaller than the current string's length, the current string will be returned as it is.\n *\n * @param fillString The string to pad the current string with.\n *        If this string is too long, it will be truncated and the left-most part will be applied.\n *        The default value for this parameter is \" \" (U+0020).\n */\nexport declare let padStart: (target: string, maxLength: number, fillString?: string) => string;\n","type":2},{"name":"node_modules/@dojo/shim/support/decorators.d.ts","text":"/**\n * A class decorator that provides either a native class or a shimmed class based on a feature\n * test\n * @param feature The has feature to check\n * @param trueClass The class to use if feature test returns `true`\n * @param falseClass The class to use if the feature test returns `false` or is not defined\n */\nexport declare function hasClass(feature: string, trueClass: Function, falseClass: Function): ClassDecorator;\n","type":2},{"name":"node_modules/@dojo/shim/support/has.d.ts","text":"import has from '@dojo/has/has';\nexport default has;\nexport * from '@dojo/has/has';\n","type":2},{"name":"node_modules/@dojo/shim/support/queue.d.ts","text":"import { Handle } from '../interfaces';\nexport interface QueueItem {\n    isActive: boolean;\n    callback: null | ((...args: any[]) => any);\n}\n/**\n * Schedules a callback to the macrotask queue.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexport declare const queueTask: (callback: (...args: any[]) => any) => Handle;\n/**\n * Schedules an animation task with `window.requestAnimationFrame` if it exists, or with `queueTask` otherwise.\n *\n * Since requestAnimationFrame's behavior does not match that expected from `queueTask`, it is not used there.\n * However, at times it makes more sense to delegate to requestAnimationFrame; hence the following method.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexport declare const queueAnimationTask: (callback: (...args: any[]) => any) => Handle;\n/**\n * Schedules a callback to the microtask queue.\n *\n * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native\n * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask\n * registered with `queueTask` or `queueAnimationTask`.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexport declare let queueMicroTask: (callback: (...args: any[]) => any) => Handle;\n","type":2},{"name":"node_modules/@dojo/shim/support/util.d.ts","text":"/**\n * Helper function to generate a value property descriptor\n *\n * @param value        The value the property descriptor should be set to\n * @param enumerable   If the property should be enumberable, defaults to false\n * @param writable     If the property should be writable, defaults to true\n * @param configurable If the property should be configurable, defaults to true\n * @return             The property descriptor object\n */\nexport declare function getValueDescriptor<T>(value: T, enumerable?: boolean, writable?: boolean, configurable?: boolean): TypedPropertyDescriptor<T>;\n/**\n * A helper function which wraps a function where the first argument becomes the scope\n * of the call\n *\n * @param nativeFunction The source function to be wrapped\n */\nexport declare function wrapNative<T, U, R>(nativeFunction: (arg1: U) => R): (target: T, arg1: U) => R;\nexport declare function wrapNative<T, U, V, R>(nativeFunction: (arg1: U, arg2: V) => R): (target: T, arg1: U, arg2: V) => R;\nexport declare function wrapNative<T, U, V, W, R>(nativeFunction: (arg1: U, arg2: V, arg3: W) => R): (target: T, arg1: U, arg2: V, arg3: W) => R;\nexport declare function wrapNative<T, U, V, W, X, R>(nativeFunction: (arg1: U, arg2: V, arg3: W) => R): (target: T, arg1: U, arg2: V, arg3: W) => R;\nexport declare function wrapNative<T, U, V, W, X, Y, R>(nativeFunction: (arg1: U, arg2: V, arg3: W, arg4: Y) => R): (target: T, arg1: U, arg2: V, arg3: W, arg4: Y) => R;\n","type":2},{"name":"node_modules/@dojo/shim/Symbol.d.ts","text":"declare global  {\n    interface SymbolConstructor {\n        observable: symbol;\n    }\n}\nexport declare let Symbol: SymbolConstructor;\n/**\n * A custom guard function that determines if an object is a symbol or not\n * @param  {any}       value The value to check to see if it is a symbol or not\n * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)\n */\nexport declare function isSymbol(value: any): value is symbol;\nexport default Symbol;\nexport {};\n","type":2},{"name":"node_modules/@dojo/shim/tslib.d.ts","text":"","type":2},{"name":"node_modules/@dojo/shim/util/amd.d.ts","text":"declare function addIfNotPresent(packages: any[], newPackage: any): void;\ndeclare function shimAmdDependencies(config: any): any;\n","type":2},{"name":"node_modules/@dojo/shim/WeakMap.d.ts","text":"import { Iterable } from './iterator';\nimport './Symbol';\nexport interface WeakMap<K extends object, V> {\n    /**\n     * Remove a `key` from the map\n     *\n     * @param key The key to remove\n     * @return `true` if the value was removed, otherwise `false`\n     */\n    delete(key: K): boolean;\n    /**\n     * Retrieve the value, based on the supplied `key`\n     *\n     * @param key The key to retrieve the `value` for\n     * @return the `value` based on the `key` if found, otherwise `false`\n     */\n    get(key: K): V | undefined;\n    /**\n     * Determines if a `key` is present in the map\n     *\n     * @param key The `key` to check\n     * @return `true` if the key is part of the map, otherwise `false`.\n     */\n    has(key: K): boolean;\n    /**\n     * Set a `value` for a particular `key`.\n     *\n     * @param key The `key` to set the `value` for\n     * @param value The `value` to set\n     * @return the instances\n     */\n    set(key: K, value: V): this;\n    readonly [Symbol.toStringTag]: 'WeakMap';\n}\nexport interface WeakMapConstructor {\n    /**\n     * Create a new instance of a `WeakMap`\n     *\n     * @constructor\n     */\n    new (): WeakMap<object, any>;\n    /**\n     * Create a new instance of a `WeakMap`\n     *\n     * @constructor\n     *\n     * @param iterable An iterable that contains yields up key/value pair entries\n     */\n    new <K extends object, V>(iterable?: [K, V][]): WeakMap<K, V>;\n    /**\n     * Create a new instance of a `WeakMap`\n     *\n     * @constructor\n     *\n     * @param iterable An iterable that contains yields up key/value pair entries\n     */\n    new <K extends object, V>(iterable: Iterable<[K, V]>): WeakMap<K, V>;\n    readonly prototype: WeakMap<object, any>;\n}\nexport declare let WeakMap: WeakMapConstructor;\nexport default WeakMap;\n","type":2},{"name":"node_modules/@dojo/test-extras/harness.d.ts","text":"import 'pepjs';\nimport Evented from '@dojo/core/Evented';\nimport { Handle } from '@dojo/interfaces/core';\nimport { Constructor, DNode, WidgetMetaBase, WidgetProperties } from '@dojo/widget-core/interfaces';\nimport WidgetBase from '@dojo/widget-core/WidgetBase';\nimport { CallListenerOptions } from './support/callListener';\nimport { SendEventOptions } from './support/sendEvent';\nexport interface HarnessSendEventOptions<I extends EventInit> extends SendEventOptions<I> {\n    /**\n     * Find the target node by `key`\n     */\n    key?: any;\n    /**\n     * Provide an alternative target instead of the root DOM node\n     */\n    target?: Element;\n}\n/**\n * Provides a run time context for methods of a meta mock.\n */\nexport declare type MetaMockContext<T extends WidgetMetaBase = WidgetMetaBase> = T & {\n    /**\n     * Retrieve a reference to a node that is rendered in the DOM based on its key\n     */\n    getNode(key: string | number): HTMLElement | undefined;\n    /**\n     * Invalidate the widget.\n     */\n    invalidate(): void;\n};\n/**\n * Harness a widget constructor, providing an API to interact with the widget for testing purposes.\n */\nexport declare class Harness<W extends WidgetBase<WidgetProperties>> extends Evented {\n    private _children;\n    private _metaMap;\n    private _projectorHandle;\n    private _properties;\n    private _root;\n    private _scheduleRender;\n    private _widgetHarness;\n    private _invalidate();\n    constructor(widgetConstructor: Constructor<W>, root?: HTMLElement);\n    /**\n     * Provides a reference to a function that can be used when creating an expected render value\n     */\n    listener: () => boolean;\n    /**\n     * Call a listener on a target node of the virtual DOM.\n     * @param method The method to call on the target node\n     * @param options A map of options that effect the behavior of `callListener`\n     */\n    callListener(method: string, options?: CallListenerOptions): void;\n    /**\n     * Assert an expected virtual DOM (`DNode`) against what is actually being rendered.  Will throw if the expected does\n     * not match the actual.\n     * @param expected The expected render (`DNode`)\n     * @param message Any message to be part of an error that gets thrown if the actual and expected do not match\n     */\n    expectRender(expected: DNode | DNode[], message?: string): this;\n    /**\n     * Get the root element of the harnessed widget.  This will refresh the render.\n     */\n    getDom(): HTMLElement;\n    /**\n     * Provide a mock for a meta provider that will be used instead of source provider\n     * @param provider The meta provider to mock\n     * @param mocks A set of methods/properties to mock on the provider\n     */\n    mockMeta<T extends WidgetMetaBase>(provider: Constructor<T>, mocks: Partial<T>): Handle;\n    /**\n     * Refresh the render and return the last render's root `DNode`.\n     */\n    getRender(): DNode;\n    /**\n     * Dispatch an event to the root DOM element of the rendered harnessed widget.  You can use the options to change the\n     * event class, provide additional event properties, or select a different `target`.\n     *\n     * By default, the event class is `CustomEvent` and `bubbles` and `cancelable` are both `true` on events dispatched by\n     * the harness.\n     * @param type The type of event (e.g. `click` or `mousedown`)\n     * @param options Options which can modify the event sent, like using a different EventClass or selecting a different\n     *                        node to target, or provide the event initialisation properties\n     */\n    sendEvent<I extends EventInit>(type: string, options?: HarnessSendEventOptions<I>): this;\n    /**\n     * Set the children that will be used when rendering the harnessed widget\n     * @param children The children to be set on the harnessed widget\n     */\n    setChildren(children: W['children']): this;\n    /**\n     * Set the properties that will be passed to the harnessed widget on the next render\n     * @param properties The properties to set\n     */\n    setProperties(properties: W['properties']): this;\n}\n/**\n * Harness a widget class for testing purposes, returning an API to interact with the harness widget class.\n * @param widgetConstructor The constructor function/class of widget that should be harnessed.\n * @param root The root where the harness should append itself to the DOM.  Defaults to `document.body`\n */\nexport default function harness<W extends WidgetBase<WidgetProperties>>(widgetConstructor: Constructor<W>, root?: HTMLElement): Harness<W>;\n","type":2},{"name":"node_modules/@dojo/test-extras/main.d.ts","text":"import harness from './harness';\nimport assertRender from './support/assertRender';\nimport callListener from './support/callListener';\nimport sendEvent from './support/sendEvent';\nimport { assignChildProperties, assignProperties, findIndex, findKey, replaceChild, replaceChildProperties, replaceProperties } from './support/d';\nexport { assertRender, assignChildProperties, assignProperties, callListener, findIndex, findKey, harness, replaceChild, replaceChildProperties, replaceProperties, sendEvent };\n","type":2},{"name":"node_modules/@dojo/test-extras/support/AssertionError.d.ts","text":"export interface AssertionError extends Error {\n    [prop: string]: any;\n    showDiff: boolean;\n}\nexport interface AssertionErrorConstructor {\n    new (message?: string, _props?: any, ssf?: Function): AssertionError;\n    prototype: AssertionError;\n}\ndeclare const AssertionErrorConstructor: AssertionErrorConstructor;\nexport default AssertionErrorConstructor;\n","type":2},{"name":"node_modules/@dojo/test-extras/support/assertRender.d.ts","text":"import { DNode, HNode, WNode } from '@dojo/widget-core/interfaces';\nimport { DiffOptions } from './compare';\nexport interface AssertRenderOptions extends DiffOptions {\n    /**\n     * A replacement type guard for `isHNode`\n     */\n    isHNode?(child: DNode): child is HNode;\n    /**\n     * A replacement type guard for `isWNode`\n     */\n    isWNode?(child: DNode): child is WNode;\n}\n/**\n * A function that asserts Dojo virtual DOM against expected virtual DOM.  When the actual and\n * expected differ, the function will throw an `AssertionError`.  It is expected to be used\n * in conjunction with `w` and `v` from `@dojo/widget-core/d` and would look something like this:\n *\n * @param actual The actual rendered DNode or DNode Array to be asserted\n * @param expected The expected DNode or DNode Array to be asserted against the actual\n * @param options A set of options that effect the behaviour of `assertRender`\n * @param message Any message to be part of an error thrown if actual and expected do not match\n */\nexport default function assertRender(actual: DNode | DNode[], expected: DNode | DNode[], message?: string): void;\nexport default function assertRender(actual: DNode | DNode[], expected: DNode | DNode[], options: AssertRenderOptions, message?: string): void;\n","type":2},{"name":"node_modules/@dojo/test-extras/support/callListener.d.ts","text":"import { HNode, WNode } from '@dojo/widget-core/interfaces';\n/**\n * Options that can be passed to `callListener`\n */\nexport interface CallListenerOptions {\n    /**\n     * Arguments to be passed to the listener when called\n     */\n    args?: any[];\n    /**\n     * Target a child of the `node` based on the _index_ which can be either a number, or a string of numbers\n     * deliminated by a comma.\n     */\n    index?: number | string;\n    /**\n     * Target the node based on a `key`.\n     */\n    key?: string | object;\n    /**\n     * Supply your own `target`\n     */\n    target?: HNode | WNode;\n    /**\n     * The `thisArg` to call a listener with.  It defaults to `properties.bind` of the target or `undefined`.\n     */\n    thisArg?: any;\n}\n/**\n * Call a listener on a virtual DOM node or one of its children.\n * @param node The node to resolve the listener and call\n * @param method The listener name in the `node.properties` to call\n * @param options Options that effect how the listener is called\n */\nexport default function callListener(node: HNode | WNode, method: string, options?: CallListenerOptions): void;\n","type":2},{"name":"node_modules/@dojo/test-extras/support/compare.d.ts","text":"import Set from '@dojo/shim/Set';\nexport declare type IgnorePropertyFunction = (name: string, a: any, b: any) => boolean;\nexport interface DiffOptions {\n    /**\n     * Allow functions to be values.  Values will be considered equal if the `typeof` both values are `function`.\n     * When adding or updating the property, the value of the property of `a` will be used in the record, which\n     * will be a reference to the function.\n     */\n    allowFunctionValues?: boolean;\n    /**\n     * An array of strings or regular expressions which flag certain properties to be ignored.  Alternatively\n     * a function, which returns `true` to have the property ignored or `false` to diff the property.\n     */\n    ignoreProperties?: (string | RegExp)[] | IgnorePropertyFunction;\n    /**\n     * An array of strings or regular expressions which flag certain values to be ignored.  For flagged properties,\n     * if the property is present in both `a` and `b` the value will be ignored.  If adding the property,\n     * whatever the value of the property of `a` will be used, which could be a reference.\n     */\n    ignorePropertyValues?: (string | RegExp)[] | IgnorePropertyFunction;\n}\n/**\n * Interface for a generic constructor function\n */\nexport interface Constructor {\n    new (...args: any[]): object;\n    prototype: object;\n}\n/**\n * A partial property descriptor that provides the property descriptor flags supported by the\n * complex property construction of `patch()`\n *\n * All properties are value properties, with the value being supplied by the `ConstructRecord`\n */\nexport interface ConstructDescriptor {\n    /**\n     * Is the property configurable?\n     */\n    configurable?: boolean;\n    /**\n     * Is the property enumerable?\n     */\n    enumerable?: boolean;\n    /**\n     * Is the property configurable?\n     */\n    writable?: boolean;\n}\n/**\n * A record that describes a constructor function and arguments necessary to create an instance of\n * an object\n */\nexport interface AnonymousConstructRecord {\n    /**\n     * Any arguments to pass to the constructor function\n     */\n    args?: any[];\n    /**\n     * The constructor function to use to create the instance\n     */\n    Ctor: Constructor;\n    /**\n     * The partial descriptor that is used to set the value of the instance\n     */\n    descriptor?: ConstructDescriptor;\n    /**\n     * Any patches to properties that need to occur on the instance\n     */\n    propertyRecords?: (ConstructRecord | PatchRecord)[];\n}\nexport interface ConstructRecord extends AnonymousConstructRecord {\n    /**\n     * The name of the property on the Object\n     */\n    name: string;\n}\n/**\n * A record that describes the mutations necessary to a property of an object to make that property look\n * like another\n */\nexport declare type PatchRecord = {\n    /**\n     * The name of the property on the Object\n     */\n    name: string;\n    /**\n     * The type of the patch\n     */\n    type: 'delete';\n} | {\n    /**\n     * A property descriptor that describes the property in `name`\n     */\n    descriptor: PropertyDescriptor;\n    /**\n     * The name of the property on the Object\n     */\n    name: string;\n    /**\n     * The type of the patch\n     */\n    type: 'add' | 'update';\n    /**\n     * Additional patch records which describe the value of the property\n     */\n    valueRecords?: (ConstructRecord | PatchRecord | SpliceRecord)[];\n};\n/**\n * The different types of patch records supported\n */\nexport declare type PatchTypes = 'add' | 'update' | 'delete';\n/**\n * A record that describes a splice operation to perform on an array to make the array look like another array\n */\nexport interface SpliceRecord {\n    /**\n     * Any items that are being added to the array\n     */\n    add?: any[];\n    /**\n     * The number of items in the array to delete\n     */\n    deleteCount: number;\n    /**\n     * The type, set to `splice`\n     */\n    type: 'splice';\n    /**\n     * The index of where to start the splice\n     */\n    start: number;\n}\n/**\n * A record that describes how to instantiate a new object via a constructor function\n * @param Ctor The constructor function\n * @param args Any arguments to be passed to the constructor function\n */\nexport declare function createConstructRecord(Ctor: Constructor, args?: any[], descriptor?: ConstructDescriptor): AnonymousConstructRecord;\n/**\n * A function that returns a constructor record or `undefined` when diffing a value\n */\nexport declare type CustomDiffFunction<T> = (value: T, nameOrIndex: string | number, parent: object) => AnonymousConstructRecord | void;\n/**\n * A class which is used when making a custom comparison of a non-plain object or array\n */\nexport declare class CustomDiff<T> {\n    private _differ;\n    constructor(diff: CustomDiffFunction<T>);\n    /**\n     * Get the difference of the `value`\n     * @param value The value to diff\n     * @param nameOrIndex A `string` if comparing a property or a `number` if comparing an array element\n     * @param parent The outer parent that this value is part of\n     */\n    diff(value: T, nameOrIndex: string | number, parent: object): ConstructRecord | void;\n}\n/**\n * Takes two plain objects to be compared, as well as options customizing the behavior of the comparison, and returns\n * two new objects that contain only those properties that should be compared. If a property is ignored\n * it will not be included in either returned object. If a property's value should be ignored it will be excluded\n * if it is present in both objects.\n * @param a The first object to compare\n * @param b The second object to compare\n * @param options An options bag indicating which properties should be ignored or have their values ignored, if any.\n */\nexport declare function getComparableObjects(a: any, b: any, options: DiffOptions): {\n    comparableA: {\n        [key: string]: any;\n    };\n    comparableB: {\n        [key: string]: any;\n    };\n    ignore: Set<string>;\n};\n/**\n * A guard that determines if the value is a `CustomDiff`\n * @param value The value to check\n */\nexport declare function isCustomDiff<T>(value: any): value is CustomDiff<T>;\n/**\n * Compares to plain objects or arrays and return a set of records which describe the differences between the two\n *\n * The records describe what would need to be applied to the second argument to make it look like the first argument\n *\n * @param a The plain object or array to compare with\n * @param b The plain object or array to compare to\n * @param options An options bag that allows configuration of the behaviour of `diff()`\n */\nexport declare function diff(a: any, b: any, options?: DiffOptions): (ConstructRecord | PatchRecord | SpliceRecord)[];\n/**\n * Apply a set of patch records to a target.\n *\n * @param target The plain object or array that the patch records should be applied to\n * @param records A set of patch records to be applied to the target\n */\nexport declare function patch(target: any, records: (ConstructRecord | PatchRecord | SpliceRecord)[]): any;\n","type":2},{"name":"node_modules/@dojo/test-extras/support/d.d.ts","text":"import { DNode, HNode, VirtualDomProperties, WidgetProperties, WNode } from '@dojo/widget-core/interfaces';\nimport { CustomDiff } from './compare';\nexport declare function assignChildProperties(target: WNode | HNode, index: number | string, properties: WidgetProperties | VirtualDomProperties): WNode | HNode;\nexport declare function assignChildPropertiesByKey(target: WNode | HNode, key: string | object, properties: WidgetProperties | VirtualDomProperties): WNode | HNode;\nexport declare function assignProperties(target: HNode, properties: VirtualDomProperties): HNode;\nexport declare function assignProperties(target: WNode, properties: WidgetProperties): WNode;\nexport declare function assignProperties(target: WNode | HNode, properties: WidgetProperties | VirtualDomProperties): WNode | HNode;\n/**\n * Creates a function which, when placed in an expected render, will call the `callback`.  If the `callback` returns `true`, the value\n * of the property is considered equal, otherwise it is considered not equal and the expected render will fail.\n * @param callback A function that is invoked when comparing the property value\n */\nexport declare function compareProperty<T>(callback: (value: T, name: string, parent: WidgetProperties | VirtualDomProperties) => boolean): CustomDiff<T>;\n/**\n * Finds the child of the target that has the provided key, and replaces it with the provided node.\n *\n * *NOTE:* The replacement modifies the passed `target` and does not return a new instance of the `DNode`.\n * @param target The DNode to replace a child element on\n * @param key The key of the node to replace\n * @param replacement The DNode that replaces the found node\n * @returns {WNode | HNode}\n */\nexport declare function replaceChildByKey(target: WNode | HNode, key: string | object, replacement: DNode): WNode | HNode;\n/**\n * Replace a child of DNode.\n *\n * *NOTE:* The replacement modifies the passed `target` and does not return a new instance of the `DNode`.\n * @param target The DNode to replace a child element on\n * @param index A number of the index of a child, or a string with comma separated indexes that would navigate\n * @param replacement The DNode to be replaced\n */\nexport declare function replaceChild(target: WNode | HNode, index: number | string, replacement: DNode): WNode | HNode;\n/**\n * Find a virtual DOM node (`WNode` or `HNode`) based on it having a matching `key` property.\n *\n * The function returns `undefined` if no node was found, otherwise it returns the node.  *NOTE* it will return the first node\n * matching the supplied `key`, but will `console.warn` if more than one node was found.\n */\nexport declare function findKey(target: WNode | HNode, key: string | object): WNode | HNode | undefined;\n/**\n * Return a `DNode` that is identified by supplied index\n * @param target The target `WNode` or `HNode` to resolve the index for\n * @param index A number or a string indicating the child index\n */\nexport declare function findIndex(target: WNode | HNode, index: number | string): DNode | undefined;\nexport declare function replaceChildProperties(target: WNode | HNode, index: number | string, properties: WidgetProperties | VirtualDomProperties): WNode | HNode;\nexport declare function replaceChildPropertiesByKey(target: WNode | HNode, key: string | object, properties: WidgetProperties | VirtualDomProperties): WNode | HNode;\nexport declare function replaceProperties(target: HNode, properties: VirtualDomProperties): HNode;\nexport declare function replaceProperties(target: WNode, properties: WidgetProperties): WNode;\nexport declare function replaceProperties(target: WNode | HNode, properties: WidgetProperties | VirtualDomProperties): WNode | HNode;\n","type":2},{"name":"node_modules/@dojo/test-extras/support/interfaces.d.ts","text":"declare module 'assertion-error' {\n\tclass AssertionError implements Error {\n\t\tconstructor(message: string, props?: any, ssf?: Function);\n\t\tname: string;\n\t\tmessage: string;\n\t\tshowDiff: boolean;\n\t\tstack: string;\n\t}\n\n\tmodule AssertionError { }\n\n\texport = AssertionError;\n}\n","type":2},{"name":"node_modules/@dojo/test-extras/support/loadJsdom.d.ts","text":"import { VirtualConsole } from 'jsdom';\ndeclare global  {\n    interface Window {\n        CustomEvent: typeof CustomEvent;\n        CSSStyleDeclaration: typeof CSSStyleDeclaration;\n    }\n}\n/**\n * If `jsdom` loads, this is a reference to the virtual console for the global `window` and `document`\n */\nexport declare let virtualConsole: VirtualConsole | undefined;\ndeclare let doc: Document;\nexport default doc;\n","type":2},{"name":"node_modules/@dojo/test-extras/support/sendEvent.d.ts","text":"export declare type EventClass = 'AnimationEvent' | 'AudioProcessingEvent' | 'BeforeInputEvent' | 'BeforeUnloadEvent' | 'BlobEvent' | 'ClipboardEvent' | 'CloseEvent' | 'CompositionEvent' | 'CSSFontFaceLoadEvent' | 'CustomEvent' | 'DeviceLightEvent' | 'DeviceMotionEvent' | 'DeviceOrientationEvent' | 'DeviceProximityEvent' | 'DOMTransactionEvent' | 'DragEvent' | 'EditingBeforeInputEvent' | 'ErrorEvent' | 'FetchEvent' | 'FocusEvent' | 'GamepadEvent' | 'HashChangeEvent' | 'IDBVersionChangeEvent' | 'InputEvent' | 'KeyboardEvent' | 'MediaStreamEvent' | 'MessageEvent' | 'MouseEvent' | 'MutationEvent' | 'OfflineAudioCompletionEvent' | 'PageTransitionEvent' | 'PointerEvent' | 'PopStateEvent' | 'ProgressEvent' | 'RelatedEvent' | 'RTCDataChannelEvent' | 'RTCIdentityErrorEvent' | 'RTCIdentityEvent' | 'RTCPeerConnectionIceEvent' | 'SensorEvent' | 'StorageEvent' | 'SVGEvent' | 'SVGZoomEvent' | 'TimeEvent' | 'TouchEvent' | 'TrackEvent' | 'TransitionEvent' | 'UIEvent' | 'UserProximityEvent' | 'WebGLContextEvent' | 'WheelEvent';\nexport interface SendEventOptions<I extends EventInit> {\n    /**\n     * The event class to use to create the event, defaults to `CustomEvent`\n     */\n    eventClass?: EventClass;\n    /**\n     * An object which is used to initialise the event\n     */\n    eventInit?: I;\n    /**\n     * A CSS selector string, used to query the target to identify the element to\n     * dispatch the event to\n     */\n    selector?: string;\n}\nexport interface EventInitializer {\n    (type: string, bubbles: boolean, cancelable: boolean, detail: any): void;\n}\n/**\n * Create and dispatch an event to an element\n * @param type The event type to dispatch\n * @param options A map of options to configure the event\n */\nexport default function sendEvent<I extends EventInit>(target: Element, type: string, options?: SendEventOptions<I>): void;\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/css-module-decorator-loader/index.d.ts","text":"","type":2},{"name":"node_modules/@dojo/webpack-contrib/css-module-decorator-loader/loader.d.ts","text":"import webpack = require('webpack');\nexport default function (this: webpack.LoaderContext, content: string, map?: any): string;\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/css-module-dts-loader/index.d.ts","text":"","type":2},{"name":"node_modules/@dojo/webpack-contrib/css-module-dts-loader/loader.d.ts","text":"import webpack = require('webpack');\nimport '@dojo/shim/Promise';\nexport default function (this: webpack.LoaderContext, content: string, sourceMap?: string): void;\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/css-module-plugin/CssModulePlugin.d.ts","text":"import { Compiler } from 'webpack';\nexport default class CssModulePlugin {\n    private basePath;\n    constructor(basePath: string);\n    apply(compiler: Compiler): void;\n}\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/external-loader-plugin/ExternalLoaderPlugin.d.ts","text":"import { Compiler } from 'webpack';\nexport declare type ExternalDescriptor = {\n    /**\n     * The path that will be used to load this module. This property is used to configure the build to defer to the\n     * external loader.\n     */\n    name?: string;\n    /**\n     * If this is a boolean, it indicates whether to inject this dependency into the application. If inject is set to\n     * true, this dependency should be a script or stylesheet. If this dependency is a directory and contains one or\n     * more stylesheets or scripts that  should be injected into the application inject can be set to a string or array\n     * of strings that point to the resource(s) to be injected. Only scripts and stylehseets can be injected.\n     */\n    inject?: boolean | string | string[];\n    /**\n     * Optional property to indicate how this external should be loaded\n     */\n    type?: string;\n    /**\n     * This is used to specify the location, relative to the project root, from where the dependency should be copied.\n     */\n    from?: string;\n    /**\n     * This can be used to specify the location, relative to the externals folder, where the dependency should be copied.\n     */\n    to?: string;\n};\n/**\n * Describes an external dependency\n */\nexport declare type ExternalDep = string | ExternalDescriptor;\nexport interface ExternalLoaderOptions {\n    /**\n     * The external dependencies\n     */\n    dependencies: ExternalDep[];\n    /**\n     * Whether to use the build's hash to cache bust injected dependencies.\n     *\n     */\n    hash?: boolean;\n    /**\n     * Where to copy dependencies to; defaults to \"externals\"\n     */\n    outputPath?: string;\n    /**\n     * Used to modify where files are placed(e.g. an alternate location for testing)\n     */\n    pathPrefix?: string;\n}\nexport default class ExternalLoaderPlugin {\n    private _dependencies;\n    private _outputPath;\n    private _pathPrefix;\n    private _hash;\n    constructor({dependencies, outputPath, pathPrefix, hash}: ExternalLoaderOptions);\n    apply(compiler: Compiler): void;\n}\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/i18n-plugin/dependencies/InjectedModuleDependency.d.ts","text":"import ModuleDependency = require('webpack/lib/dependencies/ModuleDependency');\n/**\n * A custom Webpack dependency used to inject an arbitrary `require` to the beginning of the target source.\n */\nexport default class InjectedModuleDependency extends ModuleDependency {\n    /**\n     * An optional string representing the variable name to which the require should be assigned. If no\n     * variable is provided, then the module is not assigned to a variable and is assumed to contain\n     * only side effects.\n     */\n    variable?: string;\n}\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/i18n-plugin/I18nPlugin.d.ts","text":"import { Compiler } from 'webpack';\nexport interface I18nPluginOptions {\n    /**\n     * An optional list of CLDR JSON paths used to inject CLDR data into the application.\n     */\n    cldrPaths?: string[];\n    /**\n     * The default locale for the application or custom element.\n     */\n    defaultLocale: string;\n    /**\n     * An optional list of supported locales beyond the default. When the application starts, this list\n     * is checked for the user's locale. If found, then the locale is set to the user's locale. Otherwise,\n     * the default locale is used.\n     */\n    supportedLocales?: string[];\n    /**\n     * An optional entry point into which the i18n module should be injected. Defaults to 'src/main.ts'.\n     * Since this is compared to the fully-resolved resource path, an extension should be used whenever\n     * possible.\n     */\n    target?: string;\n}\n/**\n * A custom Webpack plugin that injects into the specified entry point a module responsible to setting the locale\n * and registering CLDR data.\n */\nexport default class I18nPlugin {\n    readonly cldrPaths?: string[];\n    readonly defaultLocale: string;\n    readonly supportedLocales?: string[];\n    readonly target: RegExp;\n    constructor({cldrPaths, defaultLocale, supportedLocales, target}: I18nPluginOptions);\n    /**\n     * Inject a module that sets the locale and CLDR data for the bundled application or custom element.\n     *\n     * @param compiler The Webpack compiler\n     */\n    apply(compiler: Compiler): void;\n    /**\n     * @private\n     * Load CLDR data from the provided mids and merge the data into a single object.\n     *\n     * @return The CLDR data object\n     */\n    private _loadCldrData();\n}\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/i18n-plugin/templates/setLocaleData.d.ts","text":"declare const i18n: any;\ndeclare const loadCldrData: any;\ndeclare const systemLocale: any;\ndeclare const __cldrData__: any;\ndeclare const __defaultLocale__: string;\ndeclare const __supportedLocales__: string[];\ndeclare const userLocale: any;\ndeclare const isUserLocaleSupported: boolean;\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/main.d.ts","text":"export { default as staticOptimizeLoader } from './static-build-loader/loader';\nexport * from './static-build-loader/loader';\nexport { default as cssModuleDtsLoader } from './css-module-dts-loader/loader';\nexport * from './css-module-dts-loader/loader';\nexport { default as cssModuleDecoratorLoader } from './css-module-decorator-loader/loader';\nexport * from './css-module-decorator-loader/loader';\nexport { default as ExternalLoaderPlugin } from './external-loader-plugin/ExternalLoaderPlugin';\nexport * from './external-loader-plugin/ExternalLoaderPlugin';\nexport { default as I18nPlugin } from './i18n-plugin/I18nPlugin';\nexport * from './i18n-plugin/I18nPlugin';\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/promise-loader/index.d.ts","text":"export declare function pitch(this: any, remainingRequest: string): string;\ndeclare const _default: () => void;\nexport default _default;\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/static-build-loader/getFeatures.d.ts","text":"export declare type FeatureMap = {\n    [feature: string]: boolean;\n};\nexport declare type Features = string | string[];\n/**\n * Retrieve the largest set of non-conflicting features for the supplied feature sets.\n * @param features The features to look for\n * this is running in Node or a browser environment.\n */\nexport default function getFeatures(features?: Features): FeatureMap;\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/static-build-loader/index.d.ts","text":"","type":2},{"name":"node_modules/@dojo/webpack-contrib/static-build-loader/loader.d.ts","text":"import { LoaderContext, RawSourceMap } from 'webpack';\n/**\n * A map of features that should be statically replaced in the code\n */\nexport interface StaticHasFeatures {\n    [feature: string]: boolean;\n}\n/**\n * Checks code for usage of has pragmas or other calls to @dojo/has and optimizes them out based on the flags or\n * feature sets specified statically. This loader should act on JavaScript, so it should run after the compiler\n * if using TypeScript\n * @param content The JavaScript code to optimize\n * @param sourceMap Optional Source map for the code. If provided it will be updated to reflect the optimizations made\n */\nexport default function loader(this: LoaderContext, content: string, sourceMap?: RawSourceMap): string | void;\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/static-build-loader/recast.d.ts","text":"declare module 'recast' {\n\timport recast = require('recast/main');\n\n\texport = recast;\n}\n\ndeclare module 'recast/main' {\n\timport {\n\t\tBaseNode,\n\t\tProgram,\n\t\tComment,\n\t\tLiteral,\n\t\tIdentifier,\n\t\tCallExpression,\n\t\tExpressionStatement,\n\t\tVariableDeclaration,\n\t\tMemberExpression\n\t} from 'estree';\n\n\tnamespace recast {\n\t\tinterface NamedType<T> {\n\t\t\tcheck(node: BaseNode): node is T;\n\t\t}\n\n\t\tinterface NamedTypes {\n\t\t\t// Not an exhaustive list\n\t\t\tLiteral: Literal;\n\t\t\tIdentifier: Identifier;\n\t\t\tCallExpression: CallExpression;\n\t\t\tMemberExpression: MemberExpression;\n\t\t\tExpressionStatement: ExpressionStatement;\n\t\t\tVariableDeclaration: VariableDeclaration;\n\t\t}\n\n\t\tinterface AST {\n\t\t\tprogram: Program;\n\t\t}\n\n\t\tinterface Path<T extends BaseNode = BaseNode> {\n\t\t\tvalue: any;\n\t\t\tnode: T;\n\t\t\tparentPath: Path<BaseNode>;\n\t\t\tname: string;\n\t\t\treplace(node: BaseNode | null): void;\n\t\t}\n\n\t\tinterface VisitFunction<T extends BaseNode = BaseNode> {\n\t\t\t(this: { traverse(path: Path<BaseNode>): void }, path: Path<T>): void | false;\n\t\t}\n\n\t\tnamespace types {\n\t\t\texport const namedTypes: { [type in keyof NamedTypes]: NamedType<NamedTypes[type]> };\n\n\t\t\texport const builders: {\n\t\t\t\tcommentLine(comment: string, trailing?: boolean, leading?: boolean): Comment;\n\t\t\t\tliteral(value: boolean | string | number | null | RegExp): Literal;\n\t\t\t};\n\t\t\texport function visit(\n\t\t\t\tast: AST,\n\t\t\t\tvisitCallbacks: Partial<{\n\t\t\t\t\tvisitCallExpression: VisitFunction<CallExpression>;\n\t\t\t\t\tvisitVariableDeclaration: VisitFunction<VariableDeclaration>;\n\t\t\t\t\tvisitExpressionStatement: VisitFunction<ExpressionStatement>;\n\t\t\t\t}>\n\t\t\t): void;\n\t\t}\n\n\t\tfunction parse(code: string, options?: { sourceFileName: string }): AST;\n\n\t\tfunction print(ast: AST, options?: { sourceMapName: string }): { code: string; map: any };\n\t}\n\n\texport = recast;\n}\n\ndeclare module 'recast/lib/util' {\n\texport function composeSourceMaps(sourceMap: { file: string }, map: any): any;\n}\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/typings/webpack-lib.d.ts","text":"declare abstract class Tapable {\n\tapply(...args: any[]): void;\n\tplugin(name: string | string[], fn: Function): void;\n}\n\ndeclare module 'webpack/lib/Chunk' {\n\timport Module = require('webpack/lib/Module');\n\timport DependenciesBlock = require('webpack/lib/DependenciesBlock');\n\n\tclass Chunk {\n\t\tid: number;\n\t\tids: number[];\n\t\tdebugId: number;\n\t\tname: string;\n\t\tmodules: Module[];\n\t\tchunks: Chunk[];\n\t\tparents: Chunk[];\n\t\tblocks: DependenciesBlock[];\n\t\torigins: Chunk.Origin[];\n\t\tfiles: any[];\n\t\trendered: boolean;\n\n\t\tconstructor(name: string, module: Module, loc: any);\n\n\t\taddChunk(chunk: Chunk): boolean;\n\t\taddParent(chunk: Chunk): boolean;\n\t\thasRuntime(): boolean;\n\t\tisInitial(): boolean;\n\t\thasEntryModule(): boolean;\n\t\taddModule(module: Module): boolean;\n\t\tremoveModule(module: Module): void;\n\t\tremoveChunk(chunk: Chunk): void;\n\t\tremoveParent(chunk: Chunk): void;\n\n\t\taddBlock(block: DependenciesBlock): boolean;\n\t\taddOrigin(origin: Chunk.Origin): void;\n\n\t\tremove(reason: string): void;\n\n\t\tmoveModule(module: Module, other: Chunk): void;\n\t}\n\n\tnamespace Chunk {\n\t\tinterface Origin {\n\t\t\tmodule: Module;\n\t\t\tloc: any;\n\t\t\tname: string;\n\t\t}\n\t}\n\n\texport = Chunk;\n}\n\ndeclare module 'webpack/lib/Compilation' {\n\timport MainTemplate = require('webpack/lib/MainTemplate');\n\timport NormalModule = require('webpack/lib/NormalModule');\n\timport Chunk = require('webpack/lib/Chunk');\n\timport Source = require('webpack-sources/lib/Source');\n\timport ModuleTemplate = require('webpack/lib/ModuleTemplate');\n\timport Dependency = require('webpack/lib/Dependency');\n\n\timport { Compiler, Module } from 'webpack';\n\n\tclass Compilation extends Tapable {\n\t\tdependencyFactories: Map<typeof Dependency, any>;\n\t\tdependencyTemplates: Map<typeof Dependency, any>;\n\t\tmainTemplate: MainTemplate;\n\t\tmodules: NormalModule[];\n\t\tmoduleTemplate: ModuleTemplate;\n\n\t\tconstructor(compiler: Compiler);\n\n\t\taddModule(module: Module, cacheGroup?: string): Module | boolean;\n\t\tbuildModule(\n\t\t\tmodule: Module,\n\t\t\toptional: boolean,\n\t\t\torigin: Module | null,\n\t\t\tdependencies: any[] | null,\n\t\t\tcallback: (error?: Error) => void\n\t\t): void;\n\t\tprocessModuleDependencies(module: Module, callback: (error?: Error) => void): void;\n\n\t\tplugin(name: 'normal-module-loader', fn: (this: Compilation, loaderContext: any, module: Module) => void): void;\n\t\tplugin(name: 'seal', fn: (this: Compilation) => void): void;\n\t\tplugin(name: 'optimize', fn: (this: Compilation) => void): void;\n\t\tplugin(name: 'optimize-chunks-basic', fn: (this: Compilation, chunks: Chunk[]) => void): void;\n\t\tplugin(\n\t\t\tname: 'optimize-tree',\n\t\t\tfn: (this: Compilation, chunks: Chunk[], modules: Module[], callback: (error?: Error) => void) => void\n\t\t): void;\n\t\tplugin(name: 'optimize-modules', fn: (this: Compilation, modules: Module[]) => any): void;\n\t\tplugin(name: 'after-optimize-modules', fn: (this: Compilation, modules: Module[]) => void): void;\n\t\tplugin(name: 'optimize-chunks', fn: (this: Compilation, chunks: Chunk[]) => any): void;\n\t\tplugin(name: 'after-optimize-chunks', fn: (this: Compilation, chunks: Chunk[]) => void): void;\n\t\tplugin(name: 'revive-modules', fn: (this: Compilation, modules: Module[], records: any) => void): void;\n\t\tplugin(name: 'optimize-module-order', fn: (this: Compilation, modules: Module[]) => void): void;\n\t\tplugin(name: 'optimize-module-ids', fn: (this: Compilation, modules: Module[]) => void): void;\n\t\tplugin(name: 'after-optimize-module-ids', fn: (this: Compilation, modules: Module[]) => void): void;\n\t\tplugin(name: 'revive-chunks', fn: (this: Compilation, chunks: Chunk[], records: any) => void): void;\n\t\tplugin(name: 'optimize-chunk-order', fn: (this: Compilation, chunks: Chunk[]) => void): void;\n\t\tplugin(name: 'optimize-chunk-ids', fn: (this: Compilation, chunks: Chunk[]) => void): void;\n\t\tplugin(name: 'after-optimize-chunk-ids', fn: (this: Compilation, chunks: Chunk[]) => void): void;\n\t\tplugin(name: 'record-modules', fn: (this: Compilation, modules: Module[], records: any) => void): void;\n\t\tplugin(name: 'record-chunks', fn: (this: Compilation, chunks: Chunk[], records: any) => void): void;\n\t\tplugin(name: 'before-hash', fn: (this: Compilation) => void): void;\n\t\tplugin(name: 'after-hash', fn: (this: Compilation) => void): void;\n\t\tplugin(name: 'before-chunk-assets', fn: (this: Compilation) => void): void;\n\t\tplugin(name: 'additional-chunk-assets', fn: (this: Compilation, chunks: Chunk[]) => void): void;\n\t\tplugin(name: 'record', fn: (this: Compilation, compilation: Compilation, records: any) => void): void;\n\t\tplugin(\n\t\t\tname: 'optimize-chunk-assets',\n\t\t\tfn: (this: Compilation, chunks: Chunk[], callback: (error?: Error) => void) => void\n\t\t): void;\n\t\tplugin(name: 'after-optimize-chunk-assets', fn: (this: Compilation, chunks: Chunk[]) => void): void;\n\t\tplugin(\n\t\t\tname: 'optimize-assets',\n\t\t\tfn: (this: Compilation, assets: { [key: string]: Source }, callback: (error?: Error) => void) => void\n\t\t): void;\n\t\tplugin(name: 'after-optimize-assets', fn: (this: Compilation, assets: { [key: string]: Source }) => void): void;\n\t\tplugin(name: 'build-module', fn: (this: Compilation, module: Module) => void): void;\n\t\tplugin(name: 'succeed-module', fn: (this: Compilation, module: Module) => void): void;\n\t\tplugin(name: 'failed-module', fn: (this: Compilation, module: Module, error: Error) => void): void;\n\t\tplugin(name: 'module-asset', fn: (this: Compilation, module: Module, file: string) => void): void;\n\t\tplugin(name: 'chunk-asset', fn: (this: Compilation, chunk: Chunk, file: string) => void): void;\n\t\tplugin(name: 'need-additional-pass', fn: (this: Compilation) => boolean): void;\n\n\t\trebuildModule(module: Module, callback: (error: Error) => void): void;\n\t}\n\n\texport = Compilation;\n}\n\ndeclare module 'webpack/lib/ContextModuleFactory' {\n\timport Parser = require('webpack/lib/Parser');\n\timport Dependency = require('webpack/lib/Dependency');\n\n\tclass ContextModuleFactory extends Tapable {\n\t\tplugin(name: 'before-resolve', fn: ContextModuleFactory.BeforeHandler): void;\n\t\tplugin(name: 'parser', fn: (this: ContextModuleFactory, parser: Parser, options: any) => void): void;\n\t}\n\n\tnamespace ContextModuleFactory {\n\t\tinterface BeforeData {\n\t\t\tcontextInfo?: any;\n\t\t\tcontext: string;\n\t\t\tdependencies?: Dependency[];\n\t\t\trequest: string;\n\t\t}\n\n\t\ttype BeforeHandler = (this: ContextModuleFactory, current: BeforeData, callback: Callback<BeforeData>) => void;\n\n\t\ttype Callback<T> = (error?: Error | null, nextValue?: T) => void;\n\t}\n\n\texport = ContextModuleFactory;\n}\n\ndeclare module 'webpack/lib/DependenciesBlock' {\n\timport Dependency = require('webpack/lib/Dependency');\n\timport DependenciesBlockVariable = require('webpack/lib/DependenciesBlockVariable');\n\timport * as crypto from 'crypto';\n\n\tclass DependenciesBlock {\n\t\tdependencies: Dependency[];\n\t\tblocks: DependenciesBlock[];\n\t\tvariables: DependenciesBlockVariable[];\n\n\t\taddBlock(block: DependenciesBlock): void;\n\t\taddDependency(dependency: Dependency): void;\n\t\taddVariable(name: string, expression: string, dependencies?: Dependency[]): void;\n\t\tupdateHash(hash: crypto.Hash): void;\n\t\tdisconnect(): void;\n\t\tunseal(): void;\n\t\thasDependencies(filter: (dependency: Dependency) => boolean): boolean;\n\t\tsortItems(): void;\n\t}\n\texport = DependenciesBlock;\n}\n\ndeclare module 'webpack/lib/DependenciesBlockVariable' {\n\timport Dependency = require('webpack/lib/Dependency');\n\timport * as crypto from 'crypto';\n\n\tclass DependenciesBlockVariable {\n\t\tname: string;\n\t\texpression: string;\n\t\tdependencies: Dependency[];\n\n\t\tconstructor(name: string, expression: string, dependencies?: Dependency[]);\n\n\t\tupdateHash(hash: crypto.Hash): void;\n\t}\n\n\texport = DependenciesBlockVariable;\n}\n\ndeclare module 'webpack/lib/dependencies/ConstDependency' {\n\timport NullDependency = require('webpack/lib/dependencies/NullDependency');\n\n\tclass ConstDependencyTemplate {\n\t\tapply(dep: any, source: any): void;\n\t}\n\n\tclass ConstDependency extends NullDependency {\n\t\tconstructor(expression?: any, range?: [number, number]);\n\n\t\tpublic expression?: any;\n\t\tpublic loc?: any;\n\t\tpublic range?: [number, number];\n\n\t\tupdateHash(hash: any): void;\n\n\t\tstatic Template: typeof ConstDependencyTemplate;\n\t}\n\n\texport = ConstDependency;\n}\n\ndeclare module 'webpack/lib/dependencies/ModuleDependency' {\n\timport Dependency = require('webpack/lib/Dependency');\n\n\tclass ModuleDependencyTemplate {\n\t\tapply(dep: any, source: any): void;\n\t}\n\n\tclass ModuleDependency extends Dependency {\n\t\tconstructor(request: string);\n\n\t\tpublic request: string;\n\t\tpublic userRequest: string;\n\n\t\tstatic Template: typeof ModuleDependencyTemplate;\n\t}\n\n\texport = ModuleDependency;\n}\n\ndeclare module 'webpack/lib/dependencies/NullDependency' {\n\timport Dependency = require('webpack/lib/Dependency');\n\n\tclass NullDependencyTemplate {\n\t\tapply(dep: any, source: any): void;\n\t}\n\n\tclass NullDependency extends Dependency {\n\t\treadonly type: string;\n\t\tisEqualResource(): boolean;\n\t\tupdateHash(hash: any): void;\n\t\tstatic Template: typeof NullDependencyTemplate;\n\t}\n\n\texport = NullDependency;\n}\n\ndeclare module 'webpack/lib/dependencies/WebpackMissingModule' {\n\tnamespace WebpackMissingModule {\n\t\tconst module: (request: string) => string;\n\t\tconst moduleCode: (request: string) => string;\n\t\tconst promise: (request: string) => string;\n\t}\n\texport = WebpackMissingModule;\n}\n\ndeclare module 'webpack/lib/Dependency' {\n\timport Module = require('webpack/lib/Module');\n\timport * as crypto from 'crypto';\n\n\tclass Dependency {\n\t\tstatic compare(a: any, b: any): boolean;\n\n\t\tloc?: any;\n\t\tmodule: Module;\n\t\trange?: [number, number];\n\n\t\tisEqualResource(): boolean;\n\t\tgetReference(): { module: Module; importedNames: boolean } | null;\n\t\tgetExports(): string[] | null;\n\t\tgetWarnings(): string[] | null;\n\t\tgetErrors(): string[] | null;\n\t\tupdateHash(hash: crypto.Hash): void;\n\t\tdisconnect(): void;\n\t\tcompare(a: any, b: any): boolean;\n\t}\n\texport = Dependency;\n}\n\ndeclare module 'webpack/lib/MainTemplate' {\n\tclass MainTemplate {}\n\texport = MainTemplate;\n}\n\ndeclare module 'webpack/lib/Module' {\n\timport DependenciesBlock = require('webpack/lib/DependenciesBlock');\n\timport Chunk = require('webpack/lib/Chunk');\n\n\tclass Module extends DependenciesBlock {\n\t\tcontext: any;\n\t\treasons: any[];\n\t\tdebugId: number;\n\t\tlastId: number;\n\t\tid: number;\n\t\tportableId: number;\n\t\tchunks: Chunk[];\n\t\tstrict: boolean;\n\t\tmeta: any;\n\n\t\taddChunk(chunk: Chunk): void;\n\t\tremoveChunk(chunk: Chunk): void;\n\t}\n\n\texport = Module;\n}\n\ndeclare module 'webpack/lib/ModuleTemplate' {\n\timport Template = require('webpack/lib/Template');\n\timport Module = require('webpack/lib/Module');\n\timport Chunk = require('webpack/lib/Chunk');\n\timport Source = require('webpack-sources/lib/Source');\n\timport * as crypto from 'crypto';\n\n\tclass ModuleTemplate extends Template {\n\t\tplugin(\n\t\t\tname: 'module',\n\t\t\tfn: (\n\t\t\t\tthis: ModuleTemplate,\n\t\t\t\tmoduleSource: Source,\n\t\t\t\tmodule: Module,\n\t\t\t\tchunk: Chunk,\n\t\t\t\tdependencyTemplates: Template[]\n\t\t\t) => Source\n\t\t): void;\n\t\tplugin(\n\t\t\tname: 'render',\n\t\t\tfn: (\n\t\t\t\tthis: ModuleTemplate,\n\t\t\t\tmoduleSource: Source,\n\t\t\t\tmodule: Module,\n\t\t\t\tchunk: Chunk,\n\t\t\t\tdependencyTemplates: Template[]\n\t\t\t) => Source\n\t\t): void;\n\t\tplugin(\n\t\t\tname: 'package',\n\t\t\tfn: (\n\t\t\t\tthis: ModuleTemplate,\n\t\t\t\tmoduleSource: Source,\n\t\t\t\tmodule: Module,\n\t\t\t\tchunk: Chunk,\n\t\t\t\tdependencyTemplates: Template[]\n\t\t\t) => Source\n\t\t): void;\n\t\tplugin(name: 'hash', fn: (this: ModuleTemplate, hash: crypto.Hash) => void): void;\n\t}\n\n\texport = ModuleTemplate;\n}\n\ndeclare module 'webpack/lib/NormalModule' {\n\timport Module = require('webpack/lib/Module');\n\timport Parser = require('webpack/lib/Parser');\n\n\tclass NormalModule extends Module {\n\t\trequest: string;\n\t\tuserRequest: string;\n\t\trawRequest: string;\n\t\tparser: Parser;\n\t\tresource: string;\n\t\tcontext: any;\n\t\tloaders: string[];\n\n\t\tconstructor(\n\t\t\trequest: string,\n\t\t\tuserRequest: string,\n\t\t\trawRequest: string,\n\t\t\tloaders: string[],\n\t\t\tresource: string,\n\t\t\tparser: Parser\n\t\t);\n\t}\n\n\texport = NormalModule;\n}\n\ndeclare module 'webpack/lib/NormalModuleFactory' {\n\timport Parser = require('webpack/lib/Parser');\n\timport Dependency = require('webpack/lib/Dependency');\n\n\tclass NormalModuleFactory extends Tapable {\n\t\tplugin(name: 'after-resolve', fn: NormalModuleFactory.AfterHandler): void;\n\t\tplugin(name: 'before-resolve', fn: NormalModuleFactory.BeforeHandler): void;\n\t\tplugin(name: 'parser', fn: (this: NormalModuleFactory, parser: Parser, options: any) => void): void;\n\t\tplugin(\n\t\t\tname: 'resolver',\n\t\t\tfn: (this: NormalModuleFactory, resolver: NormalModuleFactory.Resolver) => NormalModuleFactory.Resolver\n\t\t): void;\n\t}\n\tnamespace NormalModuleFactory {\n\t\tinterface BeforeData {\n\t\t\tcontextInfo?: any;\n\t\t\tcontext: string;\n\t\t\tdependencies?: Dependency[];\n\t\t\trequest: string;\n\t\t}\n\n\t\ttype BeforeHandler = (this: NormalModuleFactory, current: BeforeData, callback: Callback<BeforeData>) => void;\n\n\t\ttype Callback<T> = (error?: Error | null, nextValue?: T) => void;\n\n\t\tinterface AfterData {\n\t\t\tcontext: string;\n\t\t\trequest: string;\n\t\t\tuserRequest: string;\n\t\t\trawRequest: string;\n\t\t\tloaders: string[];\n\t\t\tresource: string;\n\t\t\tparser: Parser;\n\t\t}\n\n\t\ttype AfterHandler = (this: NormalModuleFactory, current: AfterData, callback: Callback<AfterData>) => void;\n\n\t\ttype Resolver = (data: BeforeData, callback: ResolverCallback) => void;\n\t\ttype ResolverCallback = (error?: Error | null, value?: AfterData) => void;\n\t}\n\n\texport = NormalModuleFactory;\n}\n\ndeclare module 'webpack/lib/NullFactory' {\n\tclass NullFactory {\n\t\tcreate(data: any, callback: () => void): void;\n\t}\n\n\texport = NullFactory;\n}\n\ndeclare module 'webpack/lib/Parser' {\n\timport NormalModule = require('webpack/lib/NormalModule');\n\timport Module = require('webpack/lib/Module');\n\timport Compilation = require('webpack/lib/Compilation');\n\timport Dependency = require('webpack/lib/Dependency');\n\n\tclass Parser extends Tapable {\n\t\tstate: Parser.NormalModuleState | Parser.ParsedVariableState;\n\t\tplugin(name: string, fn: (this: Parser, ...args: any[]) => any): void;\n\t}\n\n\tnamespace Parser {\n\t\tinterface NormalModuleState {\n\t\t\tcurrent: NormalModule;\n\t\t\tmodule: NormalModule;\n\t\t\tcompilation: Compilation;\n\t\t\toptions: any;\n\t\t}\n\t\tinterface ParsedVariableState {\n\t\t\tcurrent: {\n\t\t\t\taddDependency(dependency: Dependency): void;\n\t\t\t};\n\t\t\tmodule: Module;\n\t\t}\n\t}\n\n\texport = Parser;\n}\n\ndeclare module 'webpack/lib/Template' {\n\tclass Template extends Tapable {\n\t\tconstructor(options: any);\n\t}\n\n\texport = Template;\n}\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/typings/webpack-sources.d.ts","text":"declare module 'webpack-sources/lib/ConcatSource' {\n\timport Source = require('webpack-sources/lib/Source');\n\timport sourceMap = require('source-map');\n\n\tclass ConcatSource extends Source {\n\t\tconstructor(...children: (string | Source)[]);\n\n\t\tadd(child: string | Source): void;\n\t\tnode(options: Source.Options): sourceMap.SourceNode;\n\t}\n\n\texport = ConcatSource;\n}\n\ndeclare module 'webpack-sources/lib/RawSource' {\n\timport * as Source from 'webpack-sources/lib/Source';\n\n\tclass RawSource extends Source {\n\t\tconstructor(value: string);\n\t}\n\n\tnamespace RawSource {\n\n\t}\n\n\texport = RawSource;\n}\n\ndeclare module 'webpack-sources/lib/ReplaceSource' {\n\timport Source = require('webpack-sources/lib/Source');\n\timport sourceMap = require('source-map');\n\n\tclass ReplaceSource extends Source {\n\t\tconstructor(...children: (string | Source)[]);\n\n\t\tadd(child: string | Source): void;\n\t\tinsert(position: number, content: string): void;\n\t\tnode(options: Source.Options): sourceMap.SourceNode;\n\t\toriginal(): Source;\n\t\treplace(start: number, end: number, content: string): void;\n\t}\n\n\texport = ReplaceSource;\n}\n\ndeclare module 'webpack-sources/lib/Source' {\n\timport * as crypto from 'crypto';\n\n\tabstract class Source {\n\t\tmap(options: Source.Options): string;\n\t\tsize(): number;\n\t\tsource(): string;\n\t\tsourceAndMap(options: Source.Options): { code: string; map: any };\n\t\tupdateHash(hash: crypto.Hash): void;\n\t}\n\n\tnamespace Source {\n\t\tinterface Options {\n\t\t\tcolumns?: boolean;\n\t\t\tmodule?: boolean;\n\t\t}\n\t}\n\n\texport = Source;\n}\n\ndeclare module 'webpack-sources/lib/SourceMapSource' {\n\timport * as Source from 'webpack-sources/lib/Source';\n\timport * as sourceMap from 'source-map';\n\n\tclass SourceMapSource extends Source {\n\t\tconstructor(value: string, name?: string, sourceMap?: string, originalSource?: string, innerSourceMap?: string);\n\t}\n\n\tnamespace SourceMapSource {\n\n\t}\n\n\texport = SourceMapSource;\n}\n","type":2},{"name":"node_modules/@dojo/webpack-contrib/typings/webpack.d.ts","text":"import * as webpack from 'webpack';\n\ndeclare module 'webpack' {\n\tinterface LoaderContext {\n\t\tversion: number;\n\t\tcontext: string;\n\t\trequest: string;\n\t\tquery: string;\n\t\tdata: any;\n\t\tloaders: any[];\n\t\tloaderIndex: number;\n\t\tresource: string;\n\t\tresourcePath: string;\n\t\tvalue: any;\n\t\tinputValue: any;\n\t\toptions: any;\n\t\tdebug: boolean;\n\t\tminimize: boolean;\n\t\tsourceMap: boolean;\n\t\ttarget: string;\n\t\twebpack: boolean;\n\n\t\tasync(): (error?: Error | null, content?: string | Buffer, sourceMap?: any) => void;\n\t\tcallback(error?: Error | null, content?: string | Buffer, sourceMap?: any, ast?: any): void;\n\t\tcacheable(flag?: boolean): void;\n\t\temitWarning(warning: string): void;\n\t\temitError(error: string): void;\n\t\texec(code: string, filename: string): void;\n\t\tresolve(context: string, request: string, callback: (error?: Error | null, result?: string) => void): void;\n\t\taddDependency(file: string): void;\n\t\tdependency(file: string): void;\n\t\taddContextDependency(directory: string): void;\n\t\tclearDependencies(): void;\n\t\temitFile(name: string, content: String | Buffer, sourceMap: any): void;\n\t}\n\n\tinterface RawSourceMap {\n\t\tfile: string;\n\t}\n}\n","type":2},{"name":"node_modules/@dojo/widget-core/animations/cssTransitions.d.ts","text":"import { VirtualDomProperties } from './../interfaces';\ndeclare const _default: {\n    enter: (node: HTMLElement, properties: VirtualDomProperties, enterAnimation: string) => void;\n    exit: (node: HTMLElement, properties: VirtualDomProperties, exitAnimation: string, removeNode: () => void) => void;\n};\nexport default _default;\n","type":2},{"name":"node_modules/@dojo/widget-core/Container.d.ts","text":"import { WidgetBase } from './WidgetBase';\nimport { GetProperties } from './decorators/inject';\nimport { Constructor, RegistryLabel } from './interfaces';\nexport declare type Container<T extends WidgetBase> = Constructor<WidgetBase<Partial<T['properties']>>>;\nexport declare function Container<W extends WidgetBase>(component: Constructor<W> | RegistryLabel, name: RegistryLabel, {getProperties}: {\n    getProperties: GetProperties;\n}): Container<W>;\nexport default Container;\n","type":2},{"name":"node_modules/@dojo/widget-core/customElements.d.ts","text":"import { Constructor, VirtualDomProperties, WidgetProperties } from './interfaces';\nimport { WidgetBase } from './WidgetBase';\nimport { ProjectorMixin } from './mixins/Projector';\n/**\n * @type CustomElementAttributeDescriptor\n *\n * Describes a custom element attribute\n *\n * @property attributeName   The name of the attribute on the DOM element\n * @property propertyName    The name of the property on the widget\n * @property value           A function that takes a string or null value, and returns a new value. The widget's property will be set to the new value.\n */\nexport interface CustomElementAttributeDescriptor {\n    attributeName: string;\n    propertyName?: string;\n    value?: (value: string | null) => any;\n}\n/**\n * @type CustomElementPropertyDescriptor\n *\n * Describes a widget property exposed via a custom element\n *\n * @property propertyName        The name of the property on the DOM element\n * @property widgetPropertyName  The name of the property on the widget\n * @property getValue            A transformation function on the widget's property value\n * @property setValue            A transformation function on the DOM elements property value\n */\nexport interface CustomElementPropertyDescriptor {\n    propertyName: string;\n    widgetPropertyName?: string;\n    getValue?: (value: any) => any;\n    setValue?: (value: any) => any;\n}\n/**\n * @type CustomElementEventDescriptor\n *\n * Describes a custom element event\n *\n * @property propertyName    The name of the property on the widget that takes a function\n * @property eventName       The type of the event to emit (it will be a CustomEvent object of this type)\n */\nexport interface CustomElementEventDescriptor {\n    propertyName: string;\n    eventName: string;\n}\n/**\n * Defines a custom element initializing function. Passes in initial properties so they can be extended\n * by the initializer.\n */\nexport interface CustomElementInitializer {\n    (properties: WidgetProperties): void;\n}\nexport declare enum ChildrenType {\n    DOJO = \"DOJO\",\n    ELEMENT = \"ELEMENT\",\n}\n/**\n * @type CustomElementDescriptor\n *\n * Describes a custom element.\n *\n * @property tagName             The tag name to register this widget under. Tag names must contain a \"-\"\n * @property widgetConstructor   widget Constructor that will return the widget to be wrapped in a custom element\n * @property attributes          A list of attributes to define on this element\n * @property properties          A list of properties to define on this element\n * @property events              A list of events to expose on this element\n * @property initialization      A method to run to set custom properties on the wrapped widget\n */\nexport interface CustomElementDescriptor {\n    /**\n     * The name of the custom element tag\n     */\n    tagName: string;\n    /**\n     * Widget constructor that will create the widget\n     */\n    widgetConstructor: Constructor<WidgetBase<WidgetProperties>>;\n    /**\n     * List of attributes on the custom element to map to widget properties\n     */\n    attributes?: CustomElementAttributeDescriptor[];\n    /**\n     * List of widget properties to expose as properties on the custom element\n     */\n    properties?: CustomElementPropertyDescriptor[];\n    /**\n     * List of events to expose\n     */\n    events?: CustomElementEventDescriptor[];\n    /**\n     * Initialization function called before the widget is created (for custom property setting)\n     */\n    initialization?: CustomElementInitializer;\n    /**\n     * The type of children that the custom element accepts\n     */\n    childrenType?: ChildrenType;\n}\n/**\n * @type CustomElement\n *\n * A custom element extends upon a regular HTMLElement but adds fields for describing and wrapping a widget constructor.\n *\n * @property getWidgetConstructor Return the widget constructor for this element\n * @property getDescriptor        Return the element descriptor for this element\n * @property getWidgetInstance    Return the widget instance that this element wraps\n * @property setWidgetInstance    Set the widget instance for this element\n */\nexport interface CustomElement extends HTMLElement {\n    getWidgetConstructor(): Constructor<WidgetBase<WidgetProperties>>;\n    getDescriptor(): CustomElementDescriptor;\n    getWidgetInstance(): ProjectorMixin<any>;\n    setWidgetInstance(instance: ProjectorMixin<any>): void;\n}\n/**\n * Properties for DomToWidgetWrapper\n */\nexport declare type DomToWidgetWrapperProperties = VirtualDomProperties & WidgetProperties;\n/**\n * DomToWidgetWrapper type\n */\nexport declare type DomToWidgetWrapper = Constructor<WidgetBase<DomToWidgetWrapperProperties>>;\n/**\n * DomToWidgetWrapper HOC\n *\n * @param domNode The dom node to wrap\n */\nexport declare function DomToWidgetWrapper(domNode: CustomElement): DomToWidgetWrapper;\nexport declare let customEventClass: any;\n/**\n * Called by HTMLElement subclass to initialize itself with the appropriate attributes/properties/events.\n *\n * @param element The element to initialize.\n */\nexport declare function initializeElement(element: CustomElement): () => void;\n/**\n * Called by HTMLElement subclass when an HTML attribute has changed.\n *\n * @param element     The element whose attributes are being watched\n * @param name        The name of the attribute\n * @param newValue    The new value of the attribute\n * @param oldValue    The old value of the attribute\n */\nexport declare function handleAttributeChanged(element: CustomElement, name: string, newValue: string | null, oldValue: string | null): void;\n","type":2},{"name":"node_modules/@dojo/widget-core/d.d.ts","text":"import { Constructor, DefaultWidgetBaseInterface, DeferredVirtualProperties, DNode, HNode, RegistryLabel, VirtualDomProperties, WidgetBaseInterface, WNode } from './interfaces';\n/**\n * The symbol identifier for a WNode type\n */\nexport declare const WNODE: symbol;\n/**\n * The symbol identifier for a HNode type\n */\nexport declare const HNODE: symbol;\n/**\n * Helper function that returns true if the `DNode` is a `WNode` using the `type` property\n */\nexport declare function isWNode<W extends WidgetBaseInterface = DefaultWidgetBaseInterface>(child: DNode<W>): child is WNode<W>;\n/**\n * Helper function that returns true if the `DNode` is a `HNode` using the `type` property\n */\nexport declare function isHNode(child: DNode): child is HNode;\n/**\n * Generic decorate function for DNodes. The nodes are modified in place based on the provided predicate\n * and modifier functions.\n *\n * The children of each node are flattened and added to the array for decoration.\n *\n * If no predicate is supplied then the modifier will be executed on all nodes.\n */\nexport declare function decorate(dNodes: DNode, modifier: (dNode: DNode) => void, predicate?: (dNode: DNode) => boolean): DNode;\nexport declare function decorate(dNodes: DNode[], modifier: (dNode: DNode) => void, predicate?: (dNode: DNode) => boolean): DNode[];\nexport declare function decorate(dNodes: DNode | DNode[], modifier: (dNode: DNode) => void, predicate?: (dNode: DNode) => boolean): DNode | DNode[];\n/**\n * Wrapper function for calls to create a widget.\n */\nexport declare function w<W extends WidgetBaseInterface>(widgetConstructor: Constructor<W> | RegistryLabel, properties: W['properties'], children?: W['children']): WNode<W>;\n/**\n * Wrapper function for calls to create HNodes.\n */\nexport declare function v(tag: string, properties: VirtualDomProperties | DeferredVirtualProperties, children?: DNode[]): HNode;\nexport declare function v(tag: string, children: undefined | DNode[]): HNode;\nexport declare function v(tag: string): HNode;\n","type":2},{"name":"node_modules/@dojo/widget-core/decorators/afterRender.d.ts","text":"/**\n * Decorator that can be used to register a function to run as an aspect to `render`\n */\nexport declare function afterRender(method: Function): (target: any) => void;\nexport declare function afterRender(): (target: any, propertyKey: string) => void;\nexport default afterRender;\n","type":2},{"name":"node_modules/@dojo/widget-core/decorators/beforeProperties.d.ts","text":"import { BeforeProperties } from './../interfaces';\n/**\n * Decorator that adds the function passed of target method to be run\n * in the `beforeProperties` lifecycle.\n */\nexport declare function beforeProperties(method: BeforeProperties): (target: any) => void;\nexport declare function beforeProperties(): (target: any, propertyKey: string) => void;\nexport default beforeProperties;\n","type":2},{"name":"node_modules/@dojo/widget-core/decorators/beforeRender.d.ts","text":"/**\n * Decorator that can be used to register a reducer function to run as an aspect before to `render`\n */\nexport declare function beforeRender(method: Function): (target: any) => void;\nexport declare function beforeRender(): (target: any, propertyKey: string) => void;\nexport default beforeRender;\n","type":2},{"name":"node_modules/@dojo/widget-core/decorators/diffProperty.d.ts","text":"import { DiffPropertyFunction } from './../interfaces';\n/**\n * Decorator that can be used to register a function as a specific property diff\n *\n * @param propertyName  The name of the property of which the diff function is applied\n * @param diffType      The diff type, default is DiffType.AUTO.\n * @param diffFunction  A diff function to run if diffType if DiffType.CUSTOM\n */\nexport declare function diffProperty(propertyName: string, diffFunction: DiffPropertyFunction, reactionFunction?: Function): (target: any, propertyKey?: string | undefined, descriptor?: PropertyDescriptor | undefined) => void;\nexport default diffProperty;\n","type":2},{"name":"node_modules/@dojo/widget-core/decorators/handleDecorator.d.ts","text":"/**\n * Generic decorator handler to take care of whether or not the decorator was called at the class level\n * or the method level.\n *\n * @param handler\n */\nexport declare function handleDecorator(handler: (target: any, propertyKey?: string) => void): (target: any, propertyKey?: string | undefined, descriptor?: PropertyDescriptor | undefined) => void;\nexport default handleDecorator;\n","type":2},{"name":"node_modules/@dojo/widget-core/decorators/inject.d.ts","text":"import { RegistryLabel } from './../interfaces';\n/**\n * Defines the contract requires for the get properties function\n * used to map the injected properties.\n */\nexport interface GetProperties<T = any> {\n    (payload: any, properties: T): T;\n}\n/**\n * Defines the inject configuration required for use of the `inject` decorator\n */\nexport interface InjectConfig {\n    /**\n     * The label of the registry injector\n     */\n    name: RegistryLabel;\n    /**\n     * Function that returns propertues to inject using the passed properties\n     * and the injected payload.\n     */\n    getProperties: GetProperties;\n}\n/**\n * Decorator retrieves an injector from an available registry using the name and\n * calls the `getProperties` function with the payload from the injector\n * and current properties with the the injected properties returned.\n *\n * @param InjectConfig the inject configuration\n */\nexport declare function inject({name, getProperties}: InjectConfig): (target: any, propertyKey?: string | undefined, descriptor?: PropertyDescriptor | undefined) => void;\nexport default inject;\n","type":2},{"name":"node_modules/@dojo/widget-core/diff.d.ts","text":"import { PropertyChangeRecord } from './interfaces';\nexport declare function always(previousProperty: any, newProperty: any): PropertyChangeRecord;\nexport declare function ignore(previousProperty: any, newProperty: any): PropertyChangeRecord;\nexport declare function reference(previousProperty: any, newProperty: any): PropertyChangeRecord;\nexport declare function shallow(previousProperty: any, newProperty: any): PropertyChangeRecord;\nexport declare function auto(previousProperty: any, newProperty: any): PropertyChangeRecord;\n","type":2},{"name":"node_modules/@dojo/widget-core/Injector.d.ts","text":"import { Evented } from '@dojo/core/Evented';\nexport declare class Injector<T = any> extends Evented {\n    private _payload;\n    constructor(payload: T);\n    get(): T;\n    set(payload: T): void;\n}\nexport default Injector;\n","type":2},{"name":"node_modules/@dojo/widget-core/interfaces.d.ts","text":"import { Destroyable } from '@dojo/core/Destroyable';\nimport { Evented } from '@dojo/core/Evented';\nimport { EventTargettedObject } from '@dojo/interfaces/core';\nimport Map from '@dojo/shim/Map';\nimport WeakMap from '@dojo/shim/WeakMap';\n\n/**\n * Generic constructor type\n */\nexport type Constructor<T> = new (...args: any[]) => T;\n\n/**\n * Typed target event\n */\nexport interface TypedTargetEvent<T extends EventTarget> extends Event {\n\ttarget: T;\n}\n\n/*\n These are the event handlers.\n */\nexport type EventHandlerResult = boolean | void;\n\nexport interface EventHandler {\n\t(event?: Event): EventHandlerResult;\n}\n\nexport interface FocusEventHandler {\n\t(event?: FocusEvent): EventHandlerResult;\n}\n\nexport interface KeyboardEventHandler {\n\t(event?: KeyboardEvent): EventHandlerResult;\n}\n\nexport interface MouseEventHandler {\n\t(event?: MouseEvent): EventHandlerResult;\n}\n\nexport type BlurEventHandler = FocusEventHandler;\nexport type ChangeEventHandler = EventHandler;\nexport type ClickEventHandler = MouseEventHandler;\nexport type DoubleClickEventHandler = MouseEventHandler;\nexport type InputEventHandler = EventHandler;\nexport type KeyDownEventHandler = KeyboardEventHandler;\nexport type KeyPressEventHandler = KeyboardEventHandler;\nexport type KeyUpEventHandler = KeyboardEventHandler;\nexport type LoadEventHandler = EventHandler;\nexport type MouseDownEventHandler = MouseEventHandler;\nexport type MouseEnterEventHandler = MouseEventHandler;\nexport type MouseLeaveEventHandler = MouseEventHandler;\nexport type MouseMoveEventHandler = MouseEventHandler;\nexport type MouseOutEventHandler = MouseEventHandler;\nexport type MouseOverEventHandler = MouseEventHandler;\nexport type MouseUpEventHandler = MouseEventHandler;\nexport type MouseWheelEventHandler = (event?: MouseWheelEvent | WheelEvent) => EventHandlerResult;\nexport type ScrollEventHandler = (event?: UIEvent) => EventHandlerResult;\nexport type SubmitEventHandler = EventHandler;\n\nexport interface TransitionStrategy {\n\tenter(element: Element, properties: VirtualDomProperties, enterAnimation: string): void;\n\texit(element: Element, properties: VirtualDomProperties, exitAnimation: string, removeElement: () => void): void;\n}\n\nexport interface ProjectorOptions {\n\treadonly transitions?: TransitionStrategy;\n\tstyleApplyer?(domNode: HTMLElement, styleName: string, value: string): void;\n}\n\nexport interface ProjectionOptions extends ProjectorOptions {\n\tnamespace?: string;\n\tdeferredRenderCallbacks: Function [];\n\tafterRenderCallbacks: Function[];\n\tmerge: boolean;\n\tsync: boolean;\n\tmergeElement?: Element;\n\tnodeMap: WeakMap<Node, WeakMap<Function, EventListener>>;\n\trootNode: Element;\n}\n\nexport interface Projection {\n\treadonly domNode: Element;\n\tupdate(updatedDNode: DNode | DNode[]): void;\n}\n\nexport type SupportedClassName = string | null | undefined;\n\nexport type DeferredVirtualProperties = (inserted: boolean) => VirtualDomProperties;\n\n/**\n * Animation controls are used to control the web animation that has been applied\n * to a vdom node.\n */\nexport interface AnimationControls {\n\tplay?: boolean;\n\tonFinish?: () => void;\n\tonCancel?: () => void;\n\treverse?: boolean;\n\tcancel?: boolean;\n\tfinish?: boolean;\n\tplaybackRate?: number;\n\tstartTime?: number;\n\tcurrentTime?: number;\n}\n\n/**\n * Animation timing properties passed to a new KeyframeEffect.\n */\nexport interface AnimationTimingProperties {\n\tduration?: number;\n\tdelay?: number;\n\tdirection?: 'normal' | 'reverse' | 'alternate' | 'alternate-reverse';\n\teasing?: string;\n\tendDelay?: number;\n\tfill?: 'none' | 'forwards' | 'backwards' | 'both' | 'auto';\n\titerations?: number;\n\titerationStart?: number;\n}\n\n/**\n * Animation propertiues that can be passed as vdom property `animate`\n */\nexport interface AnimationProperties {\n\tid: string;\n\teffects: any[];\n\tcontrols?: AnimationControls;\n\ttiming?: AnimationTimingProperties;\n}\n\n/**\n * Info returned by the `get` function on WebAnimation meta\n */\nexport interface AnimationInfo {\n\tcurrentTime: number;\n\tplayState: 'idle' | 'pending' | 'running' | 'paused' | 'finished';\n\tplaybackRate: number;\n\tstartTime: number;\n}\n\nexport interface VirtualDomProperties {\n\t/**\n\t * The animation to perform when this node is added to an already existing parent.\n\t * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the\n\t * projector using [[createProjector]].\n\t * @param element - Element that was just added to the DOM.\n\t * @param properties - The properties object that was supplied to the [[h]] method\n\t */\n\tenterAnimation?: ((element: Element, properties?: VirtualDomProperties) => void) | string;\n\t/**\n\t * The animation to perform when this node is removed while its parent remains.\n\t * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector using [[createProjector]].\n\t * @param element - Element that ought to be removed from the DOM.\n\t * @param removeElement - Function that removes the element from the DOM.\n\t * This argument is provided purely for convenience.\n\t * You may use this function to remove the element when the animation is done.\n\t * @param properties - The properties object that was supplied to the [[v]] method that rendered this [[HNode]] the previous time.\n\t */\n\texitAnimation?: ((element: Element, removeElement: () => void, properties?: VirtualDomProperties) => void) | string;\n\t/**\n\t * The animation to perform when the properties of this node change.\n\t * This also includes attributes, styles, css classes. This callback is also invoked when node contains only text and that text changes.\n\t * @param element - Element that was modified in the DOM.\n\t * @param properties - The last properties object that was supplied to the [[h]] method\n\t * @param previousProperties - The previous properties object that was supplied to the [[h]] method\n\t */\n\tupdateAnimation?: (element: Element, properties?: VirtualDomProperties, previousProperties?: VirtualDomProperties) => void;\n\t/**\n\t * Bind should not be defined.\n\t */\n\treadonly bind?: void;\n\t/**\n\t * Used to uniquely identify a DOM node among siblings.\n\t * A key is required when there are more children with the same selector and these children are added or removed dynamically.\n\t * NOTE: this does not have to be a string or number, a [[Component]] Object for instance is also possible.\n\t */\n\treadonly key?: Object;\n\t/**\n\t * An array of supported class names to be added to classList on a DOM node\n\t */\n\treadonly classes?: SupportedClassName | SupportedClassName[];\n\t/**\n\t * An object literal like `{height:'100px'}` which allows styles to be changed dynamically. All values must be strings.\n\t */\n\treadonly styles?: { [index: string]: string | null | undefined };\n\n\t// Pointer Events\n\tonpointermove?(ev?: PointerEvent): boolean | void;\n\tonpointerdown?(ev?: PointerEvent): boolean | void;\n\tonpointerup?(ev?: PointerEvent): boolean | void;\n\tonpointerover?(ev?: PointerEvent): boolean | void;\n\tonpointerout?(ev?: PointerEvent): boolean | void;\n\tonpointerenter?(ev?: PointerEvent): boolean | void;\n\tonpointerleave?(ev?: PointerEvent): boolean | void;\n\tonpointercancel?(ev?: PointerEvent): boolean | void;\n\t// For Pointer Event Polyfill see: https://github.com/jquery/PEP\n\treadonly 'touch-action'?: string;\n\t// From Element\n\tontouchcancel?(ev?: TouchEvent): boolean | void;\n\tontouchend?(ev?: TouchEvent): boolean | void;\n\tontouchmove?(ev?: TouchEvent): boolean | void;\n\tontouchstart?(ev?: TouchEvent): boolean | void;\n\t// From HTMLFormElement\n\treadonly action?: string;\n\treadonly encoding?: string;\n\treadonly enctype?: string;\n\treadonly method?: string;\n\treadonly name?: string;\n\treadonly target?: string;\n\t// From HTMLElement\n\tonblur?(ev?: FocusEvent): boolean | void;\n\tonchange?(ev?: Event): boolean | void;\n\tonclick?(ev?: MouseEvent): boolean | void;\n\tondblclick?(ev?: MouseEvent): boolean | void;\n\tonfocus?(ev?: FocusEvent): boolean | void;\n\toninput?(ev?: Event): boolean | void;\n\tonkeydown?(ev?: KeyboardEvent): boolean | void;\n\tonkeypress?(ev?: KeyboardEvent): boolean | void;\n\tonkeyup?(ev?: KeyboardEvent): boolean | void;\n\tonload?(ev?: Event): boolean | void;\n\tonmousedown?(ev?: MouseEvent): boolean | void;\n\tonmouseenter?(ev?: MouseEvent): boolean | void;\n\tonmouseleave?(ev?: MouseEvent): boolean | void;\n\tonmousemove?(ev?: MouseEvent): boolean | void;\n\tonmouseout?(ev?: MouseEvent): boolean | void;\n\tonmouseover?(ev?: MouseEvent): boolean | void;\n\tonmouseup?(ev?: MouseEvent): boolean | void;\n\tonmousewheel?(ev?: WheelEvent | MouseWheelEvent): boolean | void;\n\tonscroll?(ev?: UIEvent): boolean | void;\n\tonsubmit?(ev?: Event): boolean | void;\n\treadonly spellcheck?: boolean;\n\treadonly tabIndex?: number;\n\treadonly disabled?: boolean;\n\treadonly title?: string;\n\treadonly accessKey?: string;\n\treadonly id?: string;\n\t// From HTMLInputElement\n\treadonly type?: string;\n\treadonly autocomplete?: string;\n\treadonly checked?: boolean;\n\treadonly placeholder?: string;\n\treadonly readOnly?: boolean;\n\treadonly src?: string;\n\treadonly value?: string;\n\t// From HTMLImageElement\n\treadonly alt?: string;\n\treadonly srcset?: string;\n\t/**\n\t * Puts a non-interactive string of html inside the DOM node.\n\t *\n\t * Note: if you use innerHTML, cannot protect you from XSS vulnerabilities and you must make sure that the innerHTML value is safe.\n\t */\n\treadonly innerHTML?: string;\n\n\t/**\n\t * Everything that is not explicitly listed (properties and attributes that are either uncommon or custom).\n\t */\n\treadonly [index: string]: any;\n}\n\n/**\n * Type of the `WidgetRegistry` label\n */\nexport type RegistryLabel = string | symbol;\n\n/**\n * Base widget properties\n */\nexport interface WidgetProperties {\n\n\t/**\n\t * The key for a widget. Used to differentiate uniquely identify child widgets for\n\t * rendering and instance management\n\t */\n\tkey?: string | number;\n}\n\n/**\n * Widget properties that require a key\n */\nexport interface KeyedWidgetProperties extends WidgetProperties {\n\n\t/**\n\t * The key for a widget. Used to differentiate uniquely identify child widgets for\n\t * rendering and instance management\n\t */\n\tkey: string | number;\n}\n\n/**\n *\n */\ninterface CoreProperties {\n\n\t/**\n\t * The default registry for the projection\n\t */\n\tbaseRegistry: any;\n\n\t/**\n\t * The scope used to bind functions\n\t */\n\tbind: any;\n}\n\n/**\n * Wrapper for v\n */\nexport interface HNode {\n\t/**\n\t * Specified children\n\t */\n\tchildren?: DNode[];\n\n\t/**\n\t * HNode properties\n\t */\n\tproperties: VirtualDomProperties;\n\n\t/**\n\t * Deferred callback for HNode properties\n\t */\n\tdeferredPropertiesCallback?: DeferredVirtualProperties;\n\n\t/**\n\t * The tag of the HNode\n\t */\n\ttag: string;\n\n\t/**\n\t * The type of node\n\t */\n\ttype: symbol;\n\n\t/**\n\t * Text node string\n\t */\n\ttext?: string;\n}\n\n/**\n * Wrapper for `w`\n */\nexport interface WNode<W extends WidgetBaseInterface = DefaultWidgetBaseInterface> {\n\t/**\n\t * Constructor to create a widget or string constructor label\n\t */\n\twidgetConstructor: Constructor<W> | RegistryLabel;\n\n\t/**\n\t * Properties to set against a widget instance\n\t */\n\tproperties: W['properties'];\n\n\t/**\n\t * DNode children\n\t */\n\tchildren: DNode[];\n\n\t/**\n\t * The type of node\n\t */\n\ttype: symbol;\n}\n\n/**\n * union type for all possible return types from render\n */\nexport type DNode<W extends WidgetBaseInterface = DefaultWidgetBaseInterface> = HNode | WNode<W> | undefined | null | string;\n\n/**\n * Property Change record for specific property diff functions\n */\nexport interface PropertyChangeRecord {\n\tchanged: boolean;\n\tvalue: any;\n}\n\nexport interface DiffPropertyFunction {\n\t(previousProperty: any, newProperty: any): PropertyChangeRecord;\n}\n\nexport interface DiffPropertyReaction {\n\t(previousProperties: any, newProperties: any): void;\n}\n\n/**\n * WidgetBase constructor type\n */\nexport type WidgetBaseConstructor<\n\tP extends WidgetProperties = WidgetProperties,\n\tC extends DNode = DNode> = Constructor<WidgetBaseInterface<P, C>>;\n\nexport interface DefaultWidgetBaseInterface extends WidgetBaseInterface<WidgetProperties, DNode> {}\n\n/**\n * The interface for WidgetBase\n */\nexport interface WidgetBaseInterface<\n\tP = WidgetProperties,\n\tC extends DNode = DNode> {\n\n\t/**\n\t * Widget properties\n\t */\n\treadonly properties: P & WidgetProperties;\n\n\t/**\n\t * Returns the widget's children\n\t */\n\treadonly children: (C | null)[];\n\n\t/**\n\t * Sets the properties for the widget. Responsible for calling the diffing functions for the properties against the\n\t * previous properties. Runs though any registered specific property diff functions collecting the results and then\n\t * runs the remainder through the catch all diff function. The aggregate of the two sets of the results is then\n\t * set as the widget's properties\n\t *\n\t * @param properties The new widget properties\n\t */\n\t__setProperties__(properties: P & { [index: string]: any }): void;\n\n\t/**\n\t * Sets core properties on the widget.\n\t *\n\t * @param coreProperties The core properties\n\t */\n\t__setCoreProperties__(coreProperties?: CoreProperties): any;\n\n\t/**\n\t * Sets the widget's children\n\t */\n\t__setChildren__(children: (C | null)[]): void;\n\n\t/**\n\t * Main internal function for dealing with widget rendering\n\t */\n\t__render__(): DNode | DNode[];\n}\n\n/**\n * Meta Base type\n */\nexport interface WidgetMetaBase extends Destroyable {\n\thas(key: string | number): boolean;\n\tafterRender(): void;\n}\n\n/**\n * Meta Base constructor type\n */\nexport interface WidgetMetaConstructor<T extends WidgetMetaBase> {\n\tnew (properties: WidgetMetaProperties): T;\n}\n\nexport interface NodeHandlerInterface extends Evented {\n\tget(key: string | number): HTMLElement | undefined;\n\thas(key: string | number): boolean;\n\tadd(element: HTMLElement, key: string): void;\n\taddRoot(element: HTMLElement, key: string): void;\n\taddProjector(element: HTMLElement, properties: VirtualDomProperties): void;\n\tclear(): void;\n}\n\n/**\n * Properties passed to meta Base constructors\n */\nexport interface WidgetMetaProperties {\n\tinvalidate: () => void;\n\tnodeHandler: NodeHandlerInterface;\n\tbind: WidgetBaseInterface;\n}\n\nexport interface Render {\n\t(): DNode | DNode[];\n}\n\n/**\n * Interface for beforeRender function\n */\nexport interface BeforeRender {\n\t(renderFunc: Render, properties: WidgetProperties, children: DNode[]): Render | undefined;\n}\n\n/**\n * Interface for afterRender function\n */\nexport interface AfterRender {\n\t(dNode: DNode | DNode []): DNode | DNode[];\n}\n\n/**\n * Interface for beforeProperties function\n */\nexport interface BeforeProperties<P = any> {\n\t(properties: P): P;\n}\n","type":2},{"name":"node_modules/@dojo/widget-core/main.d.ts","text":"export * from './animations/cssTransitions';\nexport * from './customElements';\nexport * from './d';\nexport * from './Registry';\nexport * from './interfaces';\nexport * from './mixins/I18n';\nexport * from './mixins/Projector';\nexport * from './mixins/Themed';\nexport * from './registerCustomElement';\nexport * from './util/DomWrapper';\nexport * from './WidgetBase';\n","type":2},{"name":"node_modules/@dojo/widget-core/meta/Base.d.ts","text":"import { Destroyable } from '@dojo/core/Destroyable';\nimport { WidgetMetaBase, WidgetMetaProperties, NodeHandlerInterface, WidgetBaseInterface } from '../interfaces';\nexport declare class Base extends Destroyable implements WidgetMetaBase {\n    private _invalidate;\n    protected nodeHandler: NodeHandlerInterface;\n    private _requestedNodeKeys;\n    protected _bind: WidgetBaseInterface;\n    constructor(properties: WidgetMetaProperties);\n    has(key: string | number): boolean;\n    protected getNode(key: string | number): HTMLElement | undefined;\n    protected invalidate(): void;\n    afterRender(): void;\n}\nexport default Base;\n","type":2},{"name":"node_modules/@dojo/widget-core/meta/Dimensions.d.ts","text":"import { Base } from './Base';\nexport interface TopLeft {\n    left: number;\n    top: number;\n}\nexport interface BottomRight {\n    bottom: number;\n    right: number;\n}\nexport interface Size {\n    height: number;\n    width: number;\n}\nexport interface DimensionResults {\n    position: TopLeft & BottomRight;\n    offset: TopLeft & Size;\n    size: Size;\n    scroll: TopLeft & Size;\n}\nexport declare class Dimensions extends Base {\n    get(key: string | number): Readonly<DimensionResults>;\n}\nexport default Dimensions;\n","type":2},{"name":"node_modules/@dojo/widget-core/meta/Drag.d.ts","text":"import { Base } from './Base';\nexport interface DragResults {\n    /**\n     * The movement of pointer during the duration of the drag state\n     */\n    delta: Position;\n    /**\n     * Is the DOM node currently in a drag state\n     */\n    isDragging: boolean;\n    /**\n     * A matrix of posistions that represent the start position for the current drag interaction\n     */\n    start?: PositionMatrix;\n}\n/**\n * An x/y position structure\n */\nexport interface Position {\n    x: number;\n    y: number;\n}\n/**\n * A matrix of x/y positions\n */\nexport interface PositionMatrix {\n    /**\n     * Client x/y position\n     */\n    client: Position;\n    /**\n     * Offset x/y position\n     */\n    offset: Position;\n    /**\n     * Page x/y position\n     */\n    page: Position;\n    /**\n     * Screen x/y position\n     */\n    screen: Position;\n}\nexport declare class Drag extends Base {\n    private _boundInvalidate;\n    get(key: string | number): Readonly<DragResults>;\n}\nexport default Drag;\n","type":2},{"name":"node_modules/@dojo/widget-core/meta/Intersection.d.ts","text":"import { Base } from './Base';\nimport 'intersection-observer';\nexport interface IntersectionGetOptions {\n    root?: string;\n    rootMargin?: string;\n    threshold?: number[];\n}\nexport interface IntersectionResult {\n    intersectionRatio: number;\n    isIntersecting: boolean;\n}\nexport declare class Intersection extends Base {\n    private readonly _details;\n    /**\n     * Return an `InteractionResult` for the requested key and options.\n     *\n     * @param key The key to return the intersection meta for\n     * @param options The options for the request\n     */\n    get(key: string | number, options?: IntersectionGetOptions): IntersectionResult;\n    /**\n     * Returns true if the node for the key has intersection details\n     *\n     * @param key The key to return the intersection meta for\n     * @param options The options for the request\n     */\n    has(key: string | number, options?: IntersectionGetOptions): boolean;\n    private _createDetails(options, rootNode?);\n    private _getDetails(options?);\n    private _onIntersect;\n}\nexport default Intersection;\n","type":2},{"name":"node_modules/@dojo/widget-core/meta/Matches.d.ts","text":"import { Base } from './Base';\nexport default class Matches extends Base {\n    /**\n     * Determine if the target of a particular `Event` matches the virtual DOM key\n     * @param key The virtual DOM key\n     * @param event The event object\n     */\n    get(key: string | number, event: Event): boolean;\n}\n","type":2},{"name":"node_modules/@dojo/widget-core/meta/WebAnimation.d.ts","text":"/// <reference types=\"web-animations-js\" />\nimport 'web-animations-js/web-animations-next-lite.min';\nimport { Base } from './Base';\nimport { AnimationProperties, AnimationInfo } from '../interfaces';\nexport interface AnimationPlayer {\n    player: Animation;\n    used: boolean;\n}\nexport declare class WebAnimations extends Base {\n    private _animationMap;\n    private _createPlayer(node, properties);\n    private _updatePlayer(player, controls);\n    animate(key: string, animateProperties: AnimationProperties | AnimationProperties[]): void;\n    get(id: string): Readonly<AnimationInfo> | undefined;\n    afterRender(): void;\n}\nexport default WebAnimations;\n","type":2},{"name":"node_modules/@dojo/widget-core/mixins/I18n.d.ts","text":"import { Bundle, Messages } from '@dojo/i18n/i18n';\nimport { Constructor, WidgetProperties } from './../interfaces';\nimport { WidgetBase } from './../WidgetBase';\nexport interface I18nProperties extends WidgetProperties {\n    /**\n     * The locale for the widget. If not specified, then the root locale (as determined by `@dojo/i18n`) is assumed.\n     * If specified, the widget's node will have a `lang` property set to the locale.\n     */\n    locale?: string;\n    /**\n     * An optional flag indicating the widget's text direction. If `true`, then the underlying node's `dir`\n     * property is set to \"rtl\". If it is `false`, then the `dir` property is set to \"ltr\". Otherwise, the property\n     * is not set.\n     */\n    rtl?: boolean;\n}\nexport declare type LocalizedMessages<T extends Messages> = T & {\n    /**\n     * Formats an ICU-formatted message template for the represented bundle.\n     *\n     * @param key\n     * The message key.\n     *\n     * @param options\n     * The values to pass to the formatter.\n     *\n     * @return\n     * The formatted string.\n     */\n    format(key: string, options?: any): string;\n};\n/**\n * interface for I18n functionality\n */\nexport interface I18nMixin {\n    /**\n     * Return the cached messages for the specified bundle for the current locale, assuming they have already\n     * been loaded. If the locale-specific messages have not been loaded, they are fetched and the widget state\n     * is updated.\n     *\n     * @param bundle\n     * The required bundle object for which available locale messages should be loaded.\n     *\n     * @return\n     * The localized messages, along with a `format` method for formatting ICU-formatted templates.\n     */\n    localizeBundle<T extends Messages>(bundle: Bundle<T>): LocalizedMessages<T>;\n    properties: I18nProperties;\n}\nexport declare function I18nMixin<T extends Constructor<WidgetBase<any>>>(Base: T): T & Constructor<I18nMixin>;\nexport default I18nMixin;\n","type":2},{"name":"node_modules/@dojo/widget-core/mixins/Projector.d.ts","text":"import { Handle } from '@dojo/interfaces/core';\nimport 'pepjs';\nimport { Constructor, DNode } from './../interfaces';\nimport { WidgetBase } from './../WidgetBase';\nimport { Registry } from './../Registry';\n/**\n * Represents the attach state of the projector\n */\nexport declare enum ProjectorAttachState {\n    Attached = 1,\n    Detached = 2,\n}\n/**\n * Attach type for the projector\n */\nexport declare enum AttachType {\n    Append = 1,\n    Merge = 2,\n    Replace = 3,\n}\nexport interface AttachOptions {\n    /**\n     * If `'append'` it will appended to the root. If `'merge'` it will merged with the root. If `'replace'` it will\n     * replace the root.\n     */\n    type: AttachType;\n    /**\n     * Element to attach the projector.\n     */\n    root?: Element;\n}\nexport interface ProjectorProperties {\n    registry?: Registry;\n}\nexport interface ProjectorMixin<P> {\n    readonly properties: Readonly<P> & Readonly<ProjectorProperties>;\n    /**\n     * Append the projector to the root.\n     */\n    append(root?: Element): Handle;\n    /**\n     * Merge the projector onto the root.\n     *\n     * The `root` and any of its `children` will be re-used.  Any excess DOM nodes will be ignored and any missing DOM nodes\n     * will be created.\n     * @param root The root element that the root virtual DOM node will be merged with.  Defaults to `document.body`.\n     */\n    merge(root?: Element): Handle;\n    /**\n     * Replace the root with the projector node.\n     */\n    replace(root?: Element): Handle;\n    /**\n     * Pause the projector.\n     */\n    pause(): void;\n    /**\n     * Resume the projector.\n     */\n    resume(): void;\n    /**\n     * Attach the project to a _sandboxed_ document fragment that is not part of the DOM.\n     *\n     * When sandboxed, the `Projector` will run in a sync manner, where renders are completed within the same turn.\n     * The `Projector` creates a `DocumentFragment` which replaces any other `root` that has been set.\n     * @param doc The `Document` to use, which defaults to the global `document`.\n     */\n    sandbox(doc?: Document): void;\n    /**\n     * Schedule a render.\n     */\n    scheduleRender(): void;\n    /**\n     * Sets the properties for the widget. Responsible for calling the diffing functions for the properties against the\n     * previous properties. Runs though any registered specific property diff functions collecting the results and then\n     * runs the remainder through the catch all diff function. The aggregate of the two sets of the results is then\n     * set as the widget's properties\n     *\n     * @param properties The new widget properties\n     */\n    setProperties(properties: this['properties']): void;\n    /**\n     * Sets the widget's children\n     */\n    setChildren(children: DNode[]): void;\n    /**\n     * Return a `string` that represents the HTML of the current projection.  The projector needs to be attached.\n     */\n    toHtml(): string;\n    /**\n     * Indicates if the projectors is in async mode, configured to `true` by defaults.\n     */\n    async: boolean;\n    /**\n     * Root element to attach the projector\n     */\n    root: Element;\n    /**\n     * The status of the projector\n     */\n    readonly projectorState: ProjectorAttachState;\n    /**\n     * Exposes invalidate for projector instances\n     */\n    invalidate(): void;\n    /**\n     * Runs registered destroy handles\n     */\n    destroy(): void;\n}\nexport declare function ProjectorMixin<P, T extends Constructor<WidgetBase<P>>>(Base: T): T & Constructor<ProjectorMixin<P>>;\nexport default ProjectorMixin;\n","type":2},{"name":"node_modules/@dojo/widget-core/mixins/Themed.d.ts","text":"import { Constructor, WidgetProperties, SupportedClassName } from './../interfaces';\nimport { Registry } from './../Registry';\nimport { Injector } from './../Injector';\nimport { WidgetBase } from './../WidgetBase';\n/**\n * A lookup object for available class names\n */\nexport declare type ClassNames = {\n    [key: string]: string;\n};\n/**\n * A lookup object for available widget classes names\n */\nexport interface Theme {\n    [key: string]: object;\n}\n/**\n * Properties required for the Themed mixin\n */\nexport interface ThemedProperties<T = ClassNames> extends WidgetProperties {\n    injectedTheme?: any;\n    theme?: Theme;\n    extraClasses?: {\n        [P in keyof T]?: string;\n    };\n}\nexport declare const INJECTED_THEME_KEY: symbol;\n/**\n * Interface for the ThemedMixin\n */\nexport interface ThemedMixin<T = ClassNames> {\n    theme(classes: SupportedClassName): SupportedClassName;\n    theme(classes: SupportedClassName[]): SupportedClassName[];\n    properties: ThemedProperties<T>;\n}\n/**\n * Decorator for base css classes\n */\nexport declare function theme(theme: {}): (target: any, propertyKey?: string | undefined, descriptor?: PropertyDescriptor | undefined) => void;\n/**\n * Convenience function that is given a theme and an optional registry, the theme\n * injector is defined against the registry, returning the theme.\n *\n * @param theme the theme to set\n * @param themeRegistry registry to define the theme injector against. Defaults\n * to the global registry\n *\n * @returns the theme injector used to set the theme\n */\nexport declare function registerThemeInjector(theme: any, themeRegistry: Registry): Injector;\n/**\n * Function that returns a class decorated with with Themed functionality\n */\nexport declare function ThemedMixin<E, T extends Constructor<WidgetBase<ThemedProperties<E>>>>(Base: T): Constructor<ThemedMixin<E>> & T;\nexport default ThemedMixin;\n","type":2},{"name":"node_modules/@dojo/widget-core/NodeHandler.d.ts","text":"import { Evented } from '@dojo/core/Evented';\nimport { NodeHandlerInterface } from './interfaces';\n/**\n * Enum to identify the type of event.\n * Listening to 'Projector' will notify when projector is created or updated\n * Listening to 'Widget' will notify when widget root is created or updated\n */\nexport declare enum NodeEventType {\n    Projector = \"Projector\",\n    Widget = \"Widget\",\n}\nexport declare class NodeHandler extends Evented implements NodeHandlerInterface {\n    private _nodeMap;\n    get(key: string): HTMLElement | undefined;\n    has(key: string): boolean;\n    add(element: HTMLElement, key: string): void;\n    addRoot(): void;\n    addProjector(): void;\n    clear(): void;\n}\nexport default NodeHandler;\n","type":2},{"name":"node_modules/@dojo/widget-core/registerCustomElement.d.ts","text":"import { CustomElementDescriptor } from './customElements';\n/**\n * Describes a function that returns a CustomElementDescriptor\n */\nexport interface CustomElementDescriptorFactory {\n    (): CustomElementDescriptor;\n}\n/**\n * Register a custom element using the v1 spec of custom elements. Note that\n * this is the default export, and, expects the proposal to work in the browser.\n * This will likely require the polyfill and native shim.\n *\n * @param descriptorFactory\n */\nexport declare function registerCustomElement(descriptorFactory: CustomElementDescriptorFactory): void;\nexport default registerCustomElement;\n","type":2},{"name":"node_modules/@dojo/widget-core/Registry.d.ts","text":"import { Handle } from '@dojo/interfaces/core';\nimport { BaseEventedEvents, Evented, EventObject } from '@dojo/core/Evented';\nimport { Constructor, RegistryLabel, WidgetBaseConstructor, WidgetBaseInterface } from './interfaces';\nimport { Injector } from './Injector';\nexport declare type WidgetBaseConstructorFunction = () => Promise<WidgetBaseConstructor>;\nexport declare type RegistryItem = WidgetBaseConstructor | Promise<WidgetBaseConstructor> | WidgetBaseConstructorFunction;\n/**\n * Widget base symbol type\n */\nexport declare const WIDGET_BASE_TYPE: symbol;\nexport interface RegistryEventObject extends EventObject {\n    action: string;\n    item: WidgetBaseConstructor | Injector;\n}\nexport interface RegistryListener {\n    (event: RegistryEventObject): void;\n}\nexport interface RegistryEvents extends BaseEventedEvents {\n    (type: RegistryLabel, listener: RegistryListener | RegistryListener[]): Handle;\n}\n/**\n * Widget Registry Interface\n */\nexport interface RegistryInterface {\n    /**\n     * Define a WidgetRegistryItem against a label\n     *\n     * @param label The label of the widget to register\n     * @param registryItem The registry item to define\n     */\n    define(label: RegistryLabel, registryItem: RegistryItem): void;\n    /**\n     * Return a RegistryItem for the given label, null if an entry doesn't exist\n     *\n     * @param widgetLabel The label of the widget to return\n     * @returns The RegistryItem for the widgetLabel, `null` if no entry exists\n     */\n    get<T extends WidgetBaseInterface = WidgetBaseInterface>(label: RegistryLabel): Constructor<T> | null;\n    /**\n     * Returns a boolean if an entry for the label exists\n     *\n     * @param widgetLabel The label to search for\n     * @returns boolean indicating if a widget registry item exists\n     */\n    has(label: RegistryLabel): boolean;\n    /**\n     * Define an Injector against a label\n     *\n     * @param label The label of the injector to register\n     * @param registryItem The injector to define\n     */\n    defineInjector(label: RegistryLabel, registryItem: Injector): void;\n    /**\n     * Return an Injector registry item for the given label, null if an entry doesn't exist\n     *\n     * @param label The label of the injector to return\n     * @returns The RegistryItem for the widgetLabel, `null` if no entry exists\n     */\n    getInjector<T extends Injector>(label: RegistryLabel): T | null;\n    /**\n     * Returns a boolean if an injector for the label exists\n     *\n     * @param widgetLabel The label to search for\n     * @returns boolean indicating if a injector registry item exists\n     */\n    hasInjector(label: RegistryLabel): boolean;\n}\n/**\n * Checks is the item is a subclass of WidgetBase (or a WidgetBase)\n *\n * @param item the item to check\n * @returns true/false indicating if the item is a WidgetBaseConstructor\n */\nexport declare function isWidgetBaseConstructor<T extends WidgetBaseInterface>(item: any): item is Constructor<T>;\n/**\n * The Registry implementation\n */\nexport declare class Registry extends Evented implements RegistryInterface {\n    on: RegistryEvents;\n    /**\n     * internal map of labels and RegistryItem\n     */\n    private _widgetRegistry;\n    private _injectorRegistry;\n    /**\n     * Emit loaded event for registry label\n     */\n    private emitLoadedEvent(widgetLabel, item);\n    define(label: RegistryLabel, item: RegistryItem): void;\n    defineInjector(label: RegistryLabel, item: Injector): void;\n    get<T extends WidgetBaseInterface = WidgetBaseInterface>(label: RegistryLabel): Constructor<T> | null;\n    getInjector<T extends Injector>(label: RegistryLabel): T | null;\n    has(label: RegistryLabel): boolean;\n    hasInjector(label: RegistryLabel): boolean;\n}\nexport default Registry;\n","type":2},{"name":"node_modules/@dojo/widget-core/RegistryHandler.d.ts","text":"import { Evented } from '@dojo/core/Evented';\nimport { Constructor, RegistryLabel, WidgetBaseInterface } from './interfaces';\nimport { Registry, RegistryItem } from './Registry';\nimport { Injector } from './Injector';\nexport declare class RegistryHandler extends Evented {\n    private _registry;\n    private _baseRegistry;\n    private _registryWidgetLabelMap;\n    private _registryInjectorLabelMap;\n    constructor();\n    base: Registry;\n    define(label: RegistryLabel, widget: RegistryItem): void;\n    defineInjector(label: RegistryLabel, injector: Injector): void;\n    has(label: RegistryLabel): boolean;\n    hasInjector(label: RegistryLabel): boolean;\n    get<T extends WidgetBaseInterface = WidgetBaseInterface>(label: RegistryLabel, globalPrecedence?: boolean): Constructor<T> | null;\n    getInjector<T extends Injector>(label: RegistryLabel, globalPrecedence?: boolean): T | null;\n    private _get(label, globalPrecedence, getFunctionName, labelMap);\n}\nexport default RegistryHandler;\n","type":2},{"name":"node_modules/@dojo/widget-core/tsx.d.ts","text":"import { Constructor, DNode } from './interfaces';\nimport { WNode, VirtualDomProperties } from './interfaces';\ndeclare global  {\n    namespace JSX {\n        type Element = WNode;\n        interface ElementAttributesProperty {\n            properties: {};\n        }\n        interface IntrinsicElements {\n            [key: string]: VirtualDomProperties;\n        }\n    }\n}\nexport declare const REGISTRY_ITEM: symbol;\nexport declare class FromRegistry<P> {\n    static type: symbol;\n    properties: P;\n    name: string;\n}\nexport declare function fromRegistry<P>(tag: string): Constructor<FromRegistry<P>>;\nexport declare function tsx(tag: any, properties?: {}, ...children: any[]): DNode;\n","type":2},{"name":"node_modules/@dojo/widget-core/util/DomWrapper.d.ts","text":"import { WidgetBase } from './../WidgetBase';\nimport { Constructor, VirtualDomProperties, WidgetProperties } from './../interfaces';\nexport interface DomWrapperOptions {\n    onAttached?(): void;\n}\nexport declare type DomWrapperProperties = VirtualDomProperties & WidgetProperties;\nexport declare type DomWrapper = Constructor<WidgetBase<DomWrapperProperties>>;\nexport declare function DomWrapper(domNode: Element, options?: DomWrapperOptions): DomWrapper;\nexport default DomWrapper;\n","type":2},{"name":"node_modules/@dojo/widget-core/vdom.d.ts","text":"import { CoreProperties, DefaultWidgetBaseInterface, DNode, HNode, WNode, ProjectionOptions, Projection, VirtualDomProperties } from './interfaces';\nimport WeakMap from '@dojo/shim/WeakMap';\nimport NodeHandler from './NodeHandler';\nimport RegistryHandler from './RegistryHandler';\nexport declare type RenderResult = DNode<any> | DNode<any>[];\nexport interface InternalWNode extends WNode<DefaultWidgetBaseInterface> {\n    /**\n     * The instance of the widget\n     */\n    instance: DefaultWidgetBaseInterface;\n    /**\n     * The rendered DNodes from the instance\n     */\n    rendered: InternalDNode[];\n    /**\n     * Core properties that are used by the widget core system\n     */\n    coreProperties: CoreProperties;\n    /**\n     * Children for the WNode\n     */\n    children: InternalDNode[];\n}\nexport interface InternalHNode extends HNode {\n    /**\n     * Children for the HNode\n     */\n    children?: InternalDNode[];\n    inserted?: boolean;\n    /**\n     * Bag used to still decorate properties on a deferred properties callback\n     */\n    decoratedDeferredProperties?: VirtualDomProperties;\n    /**\n     * DOM element\n     */\n    domNode?: Element | Text;\n}\nexport declare type InternalDNode = InternalHNode | InternalWNode;\nexport interface WidgetData {\n    onElementCreated: Function;\n    onElementUpdated: Function;\n    onDetach: () => void;\n    onAttach: () => void;\n    parentInvalidate?: Function;\n    dirty: boolean;\n    registry: () => RegistryHandler;\n    nodeHandler: NodeHandler;\n    coreProperties: CoreProperties;\n    invalidate: Function;\n}\nexport declare const widgetInstanceMap: WeakMap<any, WidgetData>;\nexport declare function toTextHNode(data: any): InternalHNode;\nexport declare function filterAndDecorateChildren(children: undefined | DNode | DNode[], instance: DefaultWidgetBaseInterface): InternalDNode[];\nexport declare const dom: {\n    create: (dNode: RenderResult, instance: DefaultWidgetBaseInterface, projectionOptions?: Partial<ProjectionOptions> | undefined) => Projection;\n    append: (parentNode: Element, dNode: RenderResult, instance: DefaultWidgetBaseInterface, projectionOptions?: Partial<ProjectionOptions> | undefined) => Projection;\n    merge: (element: Element, dNode: RenderResult, instance: DefaultWidgetBaseInterface, projectionOptions?: Partial<ProjectionOptions> | undefined) => Projection;\n    replace: (element: Element, dNode: RenderResult, instance: DefaultWidgetBaseInterface, projectionOptions?: Partial<ProjectionOptions> | undefined) => Projection;\n};\n","type":2},{"name":"node_modules/@dojo/widget-core/WidgetBase.d.ts","text":"import { EventTypedObject } from '@dojo/interfaces/core';\nimport { CoreProperties, DNode, WidgetMetaBase, WidgetMetaConstructor, WidgetBaseInterface, WidgetProperties } from './interfaces';\nimport RegistryHandler from './RegistryHandler';\nexport interface WidgetAndElementEvent extends EventTypedObject<'properties:changed'> {\n    key: string;\n    element: HTMLElement;\n    target: WidgetBase;\n}\nexport declare type BoundFunctionData = {\n    boundFunc: (...args: any[]) => any;\n    scope: any;\n};\n/**\n * Main widget base for all widgets to extend\n */\nexport declare class WidgetBase<P = WidgetProperties, C extends DNode = DNode> implements WidgetBaseInterface<P, C> {\n    /**\n     * static identifier\n     */\n    static _type: symbol;\n    /**\n     * children array\n     */\n    private _children;\n    /**\n     * Indicates if it is the initial set properties cycle\n     */\n    private _initialProperties;\n    /**\n     * internal widget properties\n     */\n    private _properties;\n    /**\n     * Array of property keys considered changed from the previous set properties\n     */\n    private _changedPropertyKeys;\n    private _cachedDNode;\n    /**\n     * map of decorators that are applied to this widget\n     */\n    private _decoratorCache;\n    private _registry;\n    /**\n     * Map of functions properties for the bound function\n     */\n    private _bindFunctionPropertyMap;\n    private _renderState;\n    private _metaMap;\n    private _boundRenderFunc;\n    private _boundInvalidate;\n    private _nodeHandler;\n    /**\n     * @constructor\n     */\n    constructor();\n    protected meta<T extends WidgetMetaBase>(MetaType: WidgetMetaConstructor<T>): T;\n    /**\n     * Widget lifecycle method that is called whenever a dom node is created for a HNode.\n     * Override this method to access the dom nodes that were inserted into the dom.\n     * @param element The dom node represented by the vdom node.\n     * @param key The vdom node's key.\n     */\n    protected onElementCreated(element: Element, key: string): void;\n    /**\n     * Widget lifecycle method that is called whenever a dom node that is associated with a HNode is updated.\n     * Override this method to access the dom node.\n     * @param element The dom node represented by the vdom node.\n     * @param key The vdom node's key.\n     */\n    protected onElementUpdated(element: Element, key: string): void;\n    protected onAttach(): void;\n    protected onDetach(): void;\n    readonly properties: Readonly<P> & Readonly<WidgetProperties>;\n    readonly changedPropertyKeys: string[];\n    __setCoreProperties__(coreProperties: CoreProperties): void;\n    __setProperties__(originalProperties: this['properties']): void;\n    readonly children: (C | null)[];\n    __setChildren__(children: (C | null)[]): void;\n    __render__(): DNode | DNode[];\n    invalidate(): void;\n    protected render(): DNode | DNode[];\n    /**\n     * Function to add decorators to WidgetBase\n     *\n     * @param decoratorKey The key of the decorator\n     * @param value The value of the decorator\n     */\n    protected addDecorator(decoratorKey: string, value: any): void;\n    /**\n     * Function to build the list of decorators from the global decorator map.\n     *\n     * @param decoratorKey  The key of the decorator\n     * @return An array of decorator values\n     * @private\n     */\n    private _buildDecoratorList(decoratorKey);\n    /**\n     * Function to retrieve decorator values\n     *\n     * @param decoratorKey The key of the decorator\n     * @returns An array of decorator values\n     */\n    protected getDecorator(decoratorKey: string): any[];\n    private _mapDiffPropertyReactions(newProperties, changedPropertyKeys);\n    /**\n     * Binds unbound property functions to the specified `bind` property\n     *\n     * @param properties properties to check for functions\n     */\n    private _bindFunctionProperty(property, bind);\n    readonly registry: RegistryHandler;\n    private _runBeforeProperties(properties);\n    /**\n     * Run all registered before renders and return the updated render method\n     */\n    private _runBeforeRenders();\n    /**\n     * Run all registered after renders and return the decorated DNodes\n     *\n     * @param dNode The DNodes to run through the after renders\n     */\n    protected runAfterRenders(dNode: DNode | DNode[]): DNode | DNode[];\n}\nexport default WidgetBase;\n","type":2},{"name":"node_modules/@dojo/widgets/accordionpane/AccordionPane.d.ts","text":"import { DNode, WNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport TitlePane from '../titlepane/TitlePane';\n/**\n * @type AccordionPaneProperties\n *\n * Properties that can be set on AccordionPane components\n *\n * @property onRequestClose   Called when the title of an open pane is clicked\n * @property onRequestOpen    Called when the title of a closed pane is clicked\n * @property openKeys         Array of TitlePane keys indicating which panes should be open\n */\nexport interface AccordionPaneProperties extends ThemedProperties {\n    onRequestClose?(key: string): void;\n    onRequestOpen?(key: string): void;\n    openKeys?: string[];\n}\nexport declare const AccordionPaneBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class AccordionPane extends AccordionPaneBase<AccordionPaneProperties, WNode<TitlePane>> {\n    private _assignCallback(child, functionName, callback);\n    protected onRequestClose(key: string): void;\n    protected onRequestOpen(key: string): void;\n    protected renderChildren(): DNode[];\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/accordionpane/createAccordionPaneElement.d.ts","text":"import { CustomElementDescriptor } from '@dojo/widget-core/customElements';\n/**\n * Configures a AccordionPane web component\n */\nexport default function createAccordionPaneElement(): CustomElementDescriptor;\n","type":2},{"name":"node_modules/@dojo/widgets/accordionpane/styles/accordionPane.m.css.d.ts","text":"export const root: string;\n","type":2},{"name":"node_modules/@dojo/widgets/button/Button.d.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { DNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nexport declare type ButtonType = 'submit' | 'reset' | 'button' | 'menu';\n/**\n * @type ButtonProperties\n *\n * Properties that can be set on a Button component\n *\n * @property describedBy    ID of element with descriptive text\n * @property disabled       Whether the button is disabled or clickable\n * @property popup       \t\tControls aria-haspopup, aria-expanded, and aria-controls for popup buttons\n * @property name           The button's name attribute\n * @property pressed        Indicates status of a toggle button\n * @property type           Button type can be \"submit\", \"reset\", \"button\", or \"menu\"\n * @property value          Defines a value for the button submitted with form data\n * @property onBlur         Called when the button loses focus\n * @property onClick        Called when the button is clicked\n * @property onFocus        Called when the button is focused\n * @property onKeyDown      Called on the button's keydown event\n * @property onKeyPress     Called on the button's keypress event\n * @property onKeyUp        Called on the button's keyup event\n * @property onMouseDown    Called on the button's mousedown event\n * @property onMouseUp      Called on the button's mouseup event\n * @property onTouchCancel  Called on the button's touchcancel event\n * @property onTouchEnd     Called on the button's touchend event\n * @property onTouchStart   Called on the button's touchstart event\n */\nexport interface ButtonProperties extends ThemedProperties {\n    describedBy?: string;\n    disabled?: boolean;\n    id?: string;\n    popup?: {\n        expanded?: boolean;\n        id?: string;\n    } | boolean;\n    name?: string;\n    pressed?: boolean;\n    type?: ButtonType;\n    value?: string;\n    onBlur?(event: FocusEvent): void;\n    onClick?(event: MouseEvent): void;\n    onFocus?(event: FocusEvent): void;\n    onKeyDown?(event: KeyboardEvent): void;\n    onKeyPress?(event: KeyboardEvent): void;\n    onKeyUp?(event: KeyboardEvent): void;\n    onMouseDown?(event: MouseEvent): void;\n    onMouseUp?(event: MouseEvent): void;\n    onTouchStart?(event: TouchEvent): void;\n    onTouchEnd?(event: TouchEvent): void;\n    onTouchCancel?(event: TouchEvent): void;\n}\nexport declare const ButtonBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class Button extends ButtonBase<ButtonProperties> {\n    private _onBlur(event);\n    private _onClick(event);\n    private _onFocus(event);\n    private _onKeyDown(event);\n    private _onKeyPress(event);\n    private _onKeyUp(event);\n    private _onMouseDown(event);\n    private _onMouseUp(event);\n    private _onTouchStart(event);\n    private _onTouchEnd(event);\n    private _onTouchCancel(event);\n    protected getContent(): DNode[];\n    protected getModifierClasses(): (string | null)[];\n    protected renderPopupIcon(): DNode;\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/button/styles/button.m.css.d.ts","text":"export const root: string;\nexport const pressed: string;\nexport const popup: string;\nexport const addon: string;\nexport const disabled: string;\n","type":2},{"name":"node_modules/@dojo/widgets/calendar/Calendar.d.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { DNode } from '@dojo/widget-core/interfaces';\nimport { CalendarMessages } from './DatePicker';\nimport { Paging } from './DatePicker';\n/**\n * @type CalendarProperties\n *\n * Properties that can be set on a Calendar component\n *\n * @property labels            Customize or internationalize accessible text for the Calendar widget\n * @property month             Set the currently displayed month, 0-based\n * @property monthNames        Customize or internationalize full month names and abbreviations\n * @property selectedDate      The currently selected date\n * @property weekdayNames      Customize or internationalize weekday names and abbreviations\n * @property year              Set the currently displayed year\n * @property renderMonthLabel  Format the displayed current month and year\n * @property renderWeekdayCell Format the weekday column headers\n * @property onMonthChange     Function called when the month changes\n * @property onYearChange      Function called when the year changes\n * @property onDateSelect      Function called when the user selects a date\n */\nexport interface CalendarProperties extends ThemedProperties {\n    labels?: CalendarMessages;\n    month?: number;\n    monthNames?: {\n        short: string;\n        long: string;\n    }[];\n    selectedDate?: Date;\n    weekdayNames?: {\n        short: string;\n        long: string;\n    }[];\n    year?: number;\n    renderMonthLabel?(month: number, year: number): string;\n    renderWeekdayCell?(day: {\n        short: string;\n        long: string;\n    }): DNode;\n    onMonthChange?(month: number): void;\n    onYearChange?(year: number): void;\n    onDateSelect?(date: Date): void;\n}\nexport declare const DEFAULT_MONTHS: {\n    short: string;\n    long: string;\n}[];\nexport declare const DEFAULT_WEEKDAYS: {\n    short: string;\n    long: string;\n}[];\nexport declare const DEFAULT_LABELS: CalendarMessages;\nexport declare const CalendarBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class Calendar extends CalendarBase<CalendarProperties> {\n    private _callDateFocus;\n    private _defaultDate;\n    private _focusedDay;\n    private _monthLabelId;\n    private _popupOpen;\n    private _getMonthLength(month, year);\n    private _getMonthYear();\n    private _goToDate(day);\n    private _onDateClick(date, disabled);\n    private _onDateFocusCalled();\n    private _onDateKeyDown(event);\n    private _onMonthDecrement();\n    private _onMonthIncrement();\n    private _onMonthPageDown();\n    private _onMonthPageUp();\n    private _renderDateGrid(selectedDate?);\n    protected renderDateCell(date: number, index: number, selected: boolean, currentMonth: boolean, today: boolean): DNode;\n    protected renderDatePicker(): DNode;\n    protected renderPagingButtonContent(type: Paging): DNode[];\n    protected renderWeekdayCell(day: {\n        short: string;\n        long: string;\n    }): DNode;\n    protected render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/calendar/CalendarCell.d.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { DNode } from '@dojo/widget-core/interfaces';\n/**\n * @type CalendarCellProperties\n *\n * Properties that can be set on a Calendar Date Cell\n *\n * @property callFocus        Used to immediately call focus on the cell\n * @property date             Integer date value\n * @property disabled         Boolean, whether or not the date is in the current month\n * @property focusable        Boolean, whether or not the date can receive focus\n * @property selected         True if the date is currently selected\n * @property today            True if the date the same as the current day\n * @property onClick          Callback function for the click event\n * @property onFocusCalled    Callback function when the cell receives focus\n * @property onKeyDown        Callback function for the key down event\n */\nexport interface CalendarCellProperties extends ThemedProperties {\n    callFocus?: boolean;\n    date: number;\n    disabled?: boolean;\n    focusable?: boolean;\n    selected?: boolean;\n    today?: boolean;\n    onClick?(date: number, disabled: boolean): void;\n    onFocusCalled?(): void;\n    onKeyDown?(event: KeyboardEvent): void;\n}\nexport declare const CalendarCellBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class CalendarCell extends CalendarCellBase<CalendarCellProperties> {\n    protected onElementCreated(element: HTMLElement, key: string): void;\n    protected onElementUpdated(element: HTMLElement, key: string): void;\n    private _callFocus(element);\n    private _onClick(event);\n    private _onKeyDown(event);\n    protected formatDate(date: number): DNode;\n    protected getModifierClasses(): (string | null)[];\n    protected render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/calendar/createCalendarElement.d.ts","text":"import { CustomElementDescriptor } from '@dojo/widget-core/customElements';\n/**\n * Configures a Calendar web component\n */\nexport default function createCalendarElement(): CustomElementDescriptor;\n","type":2},{"name":"node_modules/@dojo/widgets/calendar/DatePicker.d.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { DNode } from '@dojo/widget-core/interfaces';\n/**\n * Enum for next/previous buttons\n */\nexport declare const enum Paging {\n    next = \"next\",\n    previous = \"previous\",\n}\n/**\n * Enum for month or year controls\n */\nexport declare const enum Controls {\n    month = \"month\",\n    year = \"year\",\n}\n/**\n * @type CalendarMessages\n *\n * Accessible text for Month Picker controls. Messages can be localized by passing a CalendarMessages object into the Calendar widget's labels property\n *\n * @property chooseMonth          Labels the button that opens the month picker popup\n * @property chooseYear           Labels the year spinner within the popup\n * @property previousMonth        Labels the prvious month arrow button\n * @property nextMonth            Labels the next month arrow button\n */\nexport interface CalendarMessages {\n    chooseMonth: string;\n    chooseYear: string;\n    previousMonth: string;\n    nextMonth: string;\n}\n/**\n * @type DatePickerProperties\n *\n * Properties that can be set on a Calendar component\n *\n * @property labelId              Set id to reference label containing current month and year\n * @property labels               Customize or internationalize accessible helper text\n * @property month                Currently displayed month, zero-based\n * @property monthNames           Array of full and abbreviated month names\n * @property year                 Currently displayed year\n * @property yearRange            Number of years to display in a single page of the year popup\n * @property renderMonthLabel     Format the displayed current month and year\n * @property onPopupChange        Called when a user action occurs that triggers a change in the month or year popup state\n * @property onRequestMonthChange Called when a month should change; receives the zero-based month number\n * @property onRequestYearChange  Called when a year should change; receives the year as an integer\n */\nexport interface DatePickerProperties extends ThemedProperties {\n    labelId?: string;\n    labels: CalendarMessages;\n    month: number;\n    monthNames: {\n        short: string;\n        long: string;\n    }[];\n    year: number;\n    yearRange?: number;\n    renderMonthLabel?(month: number, year: number): string;\n    onPopupChange?(open: boolean): void;\n    onRequestMonthChange?(month: number): void;\n    onRequestYearChange?(year: number): void;\n}\nexport declare const DatePickerBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class DatePicker extends DatePickerBase<DatePickerProperties> {\n    private _callMonthTriggerFocus;\n    private _callYearTriggerFocus;\n    private _callMonthPopupFocus;\n    private _callYearPopupFocus;\n    private _idBase;\n    private _monthPopupOpen;\n    private _yearPopupOpen;\n    private _yearPage;\n    private _closeMonthPopup();\n    private _closeYearPopup();\n    private _getPopupState();\n    private _getYearRange();\n    protected onElementUpdated(element: HTMLElement, key: string): void;\n    private _onMonthButtonClick();\n    private _onMonthRadioChange(event);\n    private _onPopupKeyDown(event);\n    private _onYearButtonClick();\n    private _onYearPageDown();\n    private _onYearPageUp();\n    private _onYearRadioChange(event);\n    private _openMonthPopup();\n    private _openYearPopup();\n    protected renderControlsTrigger(type: Controls): DNode;\n    protected renderMonthLabel(month: number, year: number): DNode;\n    protected renderMonthRadios(): DNode[];\n    protected renderPagingButtonContent(type: Paging): DNode[];\n    protected renderYearRadios(): DNode[];\n    protected render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/calendar/styles/calendar.m.css.d.ts","text":"export const root: string;\nexport const dateGrid: string;\nexport const weekday: string;\nexport const date: string;\nexport const inactiveDate: string;\nexport const selectedDate: string;\nexport const todayDate: string;\nexport const datePicker: string;\nexport const topMatter: string;\nexport const monthTrigger: string;\nexport const yearTrigger: string;\nexport const controls: string;\nexport const previous: string;\nexport const next: string;\nexport const monthGrid: string;\nexport const monthFields: string;\nexport const yearGrid: string;\nexport const yearFields: string;\nexport const monthRadio: string;\nexport const yearRadio: string;\nexport const monthRadioChecked: string;\nexport const yearRadioChecked: string;\nexport const monthRadioInput: string;\nexport const monthRadioLabel: string;\nexport const yearRadioInput: string;\nexport const yearRadioLabel: string;\nexport const monthTriggerActive: string;\nexport const yearTriggerActive: string;\n","type":2},{"name":"node_modules/@dojo/widgets/checkbox/Checkbox.d.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { DNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { LabelOptions } from '../label/Label';\n/**\n * @type CheckboxProperties\n *\n * Properties that can be set on a Checkbox component\n *\n * @property checked        Checked/unchecked property of the radio\n * @property describedBy    ID of an element that provides more descriptive text\n * @property disabled       Prevents the user from interacting with the form field\n * @property invalid        Indicates the valid is invalid, or required and not filled in\n * @property label          Label settings for form label text, position, and visibility\n * @property mode           The type of user interface to show for this Checkbox\n * @property name           The form widget's name\n * @property offLabel       Label to show in the \"off\" positin of a toggle\n * @property onLabel        Label to show in the \"on\" positin of a toggle\n * @property readOnly       Allows or prevents user interaction\n * @property required       Whether or not a value is required\n * @property value          The current value\n * @property onBlur         Called when the input loses focus\n * @property onChange       Called when the node's 'change' event is fired\n * @property onClick        Called when the input is clicked\n * @property onFocus        Called when the input is focused\n * @property onMouseDown    Called on the input's mousedown event\n * @property onMouseUp      Called on the input's mouseup event\n * @property onTouchStart   Called on the input's touchstart event\n * @property onTouchEnd     Called on the input's touchend event\n * @property onTouchCancel  Called on the input's touchcancel event\n */\nexport interface CheckboxProperties extends ThemedProperties {\n    checked?: boolean;\n    describedBy?: string;\n    disabled?: boolean;\n    invalid?: boolean;\n    label?: string | LabelOptions;\n    mode?: Mode;\n    name?: string;\n    offLabel?: DNode;\n    onLabel?: DNode;\n    readOnly?: boolean;\n    required?: boolean;\n    value?: string;\n    onBlur?(event: FocusEvent): void;\n    onChange?(event: Event): void;\n    onClick?(event: MouseEvent): void;\n    onFocus?(event: FocusEvent): void;\n    onMouseDown?(event: MouseEvent): void;\n    onMouseUp?(event: MouseEvent): void;\n    onTouchStart?(event: TouchEvent): void;\n    onTouchEnd?(event: TouchEvent): void;\n    onTouchCancel?(event: TouchEvent): void;\n}\n/**\n * The type of UI to show for this Checkbox\n */\nexport declare const enum Mode {\n    normal = 0,\n    toggle = 1,\n}\nexport declare const CheckboxBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class Checkbox extends CheckboxBase<CheckboxProperties> {\n    private _focused;\n    private _onBlur(event);\n    private _onChange(event);\n    private _onClick(event);\n    private _onFocus(event);\n    private _onMouseDown(event);\n    private _onMouseUp(event);\n    private _onTouchStart(event);\n    private _onTouchEnd(event);\n    private _onTouchCancel(event);\n    protected getModifierClasses(): (string | null)[];\n    protected renderToggle(): DNode[];\n    protected render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/checkbox/styles/checkbox.m.css.d.ts","text":"export const root: string;\nexport const input: string;\nexport const inputWrapper: string;\nexport const checked: string;\nexport const disabled: string;\nexport const focused: string;\nexport const readonly: string;\nexport const required: string;\nexport const invalid: string;\nexport const valid: string;\nexport const toggle: string;\nexport const onLabel: string;\nexport const offLabel: string;\nexport const toggleSwitch: string;\n","type":2},{"name":"node_modules/@dojo/widgets/combobox/ComboBox.d.ts","text":"import { DNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { LabelOptions } from '../label/Label';\nimport { TextInputProperties } from '../textinput/TextInput';\n/**\n * @type ComboBoxProperties\n *\n * Properties that can be set on a ComboBox component\n *\n * @property clearable          Determines whether the input should be able to be cleared\n * @property disabled           Prevents user interaction and styles content accordingly\n * @property getResultLabel     Can be used to get the text label of a result based on the underlying result object\n * @property id                 Optional id string for the combobox\n * @property inputProperties    TextInput properties to set on the underlying input\n * @property invalid            Determines if this input is valid\n * @property isResultDisabled   Used to determine if an item should be disabled\n * @property label              Label to show for this input\n * @property onBlur             Called when the input is blurred\n * @property onChange           Called when the value changes\n * @property onFocus            Called when the input is focused\n * @property onMenuChange       Called when menu visibility changes\n * @property onRequestResults   Called when results are shown; should be used to set `results`\n * @property openOnFocus        Determines whether the result list should open when the input is focused\n * @property readOnly           Prevents user interaction\n * @property required           Determines if this input is required, styles accordingly\n * @property results            Results for the current search term; should be set in response to `onRequestResults`\n * @property value              Value to set on the input\n */\nexport interface ComboBoxProperties extends ThemedProperties {\n    clearable?: boolean;\n    disabled?: boolean;\n    getResultLabel?(result: any): string;\n    id?: string;\n    inputProperties?: TextInputProperties;\n    invalid?: boolean;\n    isResultDisabled?(result: any): boolean;\n    label?: string | LabelOptions;\n    onBlur?(value: string, key?: string | number): void;\n    onChange?(value: string, key?: string | number): void;\n    onFocus?(value: string, key?: string | number): void;\n    onMenuChange?(open: boolean, key?: string | number): void;\n    onRequestResults?(key?: string | number): void;\n    openOnFocus?: boolean;\n    readOnly?: boolean;\n    required?: boolean;\n    results?: any[];\n    value?: string;\n}\nexport declare const enum Operation {\n    increase = 1,\n    decrease = -1,\n}\nexport declare const ThemedBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class ComboBox extends ThemedBase<ComboBoxProperties> {\n    private _activeIndex;\n    private _callInputFocus;\n    private _ignoreBlur;\n    private _idBase;\n    private _menuHasVisualFocus;\n    private _open;\n    private _wasOpen;\n    private _closeMenu();\n    private _getMenuId();\n    private _getResultLabel(result);\n    private _getResultId(result, index);\n    private _onArrowClick();\n    private _onClearClick();\n    private _onInput(event);\n    private _onInputBlur(event);\n    private _onInputFocus(event);\n    private _onInputKeyDown(event);\n    private _onMenuChange();\n    private _onResultHover();\n    private _onResultMouseDown();\n    private _openMenu();\n    private _selectIndex(index);\n    private _moveActiveIndex(operation);\n    protected onElementUpdated(element: HTMLElement, key: string): void;\n    protected renderInput(): DNode;\n    protected renderClearButton(): DNode;\n    protected renderMenuButton(): DNode;\n    protected renderMenu(results: any[]): DNode;\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/combobox/createComboBoxElement.d.ts","text":"import { CustomElementDescriptor } from '@dojo/widget-core/customElements';\n/**\n * Configures a ComboBox web component\n */\nexport default function createComboBoxElement(): CustomElementDescriptor;\n","type":2},{"name":"node_modules/@dojo/widgets/combobox/styles/comboBox.m.css.d.ts","text":"export const root: string;\nexport const controls: string;\nexport const input: string;\nexport const clearable: string;\nexport const dropdown: string;\nexport const option: string;\nexport const disabledOption: string;\nexport const selected: string;\nexport const clear: string;\nexport const trigger: string;\nexport const valid: string;\nexport const invalid: string;\nexport const open: string;\n","type":2},{"name":"node_modules/@dojo/widgets/common/styles/animations.m.css.d.ts","text":"export const fadeIn: string;\nexport const fadeOut: string;\n","type":2},{"name":"node_modules/@dojo/widgets/common/styles/base.m.css.d.ts","text":"export const visuallyHidden: string;\nexport const focusable: string;\nexport const hidden: string;\n","type":2},{"name":"node_modules/@dojo/widgets/common/styles/icons.m.css.d.ts","text":"export const icon: string;\nexport const plusIcon: string;\nexport const minusIcon: string;\nexport const checkIcon: string;\nexport const closeIcon: string;\nexport const leftIcon: string;\nexport const rightIcon: string;\nexport const upIcon: string;\nexport const downIcon: string;\nexport const upAltIcon: string;\nexport const downAltIcon: string;\nexport const searchIcon: string;\nexport const barsIcon: string;\nexport const settingsIcon: string;\nexport const alertIcon: string;\nexport const helpIcon: string;\nexport const infoIcon: string;\nexport const phoneIcon: string;\nexport const editIcon: string;\nexport const dateIcon: string;\nexport const linkIcon: string;\nexport const locationIcon: string;\nexport const secureIcon: string;\nexport const mailIcon: string;\n","type":2},{"name":"node_modules/@dojo/widgets/common/util.d.ts","text":"export declare const enum Keys {\n    Down = 40,\n    End = 35,\n    Enter = 13,\n    Escape = 27,\n    Home = 36,\n    Left = 37,\n    PageDown = 34,\n    PageUp = 33,\n    Right = 39,\n    Space = 32,\n    Tab = 9,\n    Up = 38,\n}\nexport declare function createResolvers(): {\n    resolve(): void;\n    stub(): void;\n    restore(): void;\n};\n","type":2},{"name":"node_modules/@dojo/widgets/dialog/createDialogElement.d.ts","text":"import { CustomElementDescriptor } from '@dojo/widget-core/customElements';\n/**\n * Configures a Dialog web component\n */\nexport default function createDialogElement(): CustomElementDescriptor;\n","type":2},{"name":"node_modules/@dojo/widgets/dialog/Dialog.d.ts","text":"import { DNode } from '@dojo/widget-core/interfaces';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\n/**\n * The role of this dialog, used for accessibility\n */\nexport declare type RoleType = 'dialog' | 'alertdialog';\n/**\n * @type DialogProperties\n *\n * Properties that can be set on a Dialog component\n *\n * @property closeable          Determines whether the dialog can be closed\n * @property closeText          Hidden text used by screen readers to display for the close button\n * @property enterAnimation     CSS class to apply to the dialog when opened\n * @property exitAnimation      CSS class to apply to the dialog when closed\n * @property modal              Determines whether the dialog can be closed by clicking outside its content\n * @property onOpen             Called when the dialog opens\n * @property onRequestClose     Called when the dialog is closed\n * @property open               Determines whether the dialog is open or closed\n * @property role               Role of this dialog for accessibility, either 'alert' or 'dialog'\n * @property title              Title to show in the dialog title bar\n * @property underlay           Determines whether a semi-transparent background shows behind the dialog\n */\nexport interface DialogProperties extends ThemedProperties {\n    closeable?: boolean;\n    closeText?: string;\n    enterAnimation?: string;\n    exitAnimation?: string;\n    modal?: boolean;\n    onOpen?(): void;\n    onRequestClose?(): void;\n    open?: boolean;\n    role?: RoleType;\n    title?: string;\n    underlay?: boolean;\n}\nexport declare const DialogBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class Dialog extends DialogBase<DialogProperties> {\n    private _titleId;\n    private _wasOpen;\n    private _onCloseClick();\n    private _onUnderlayClick();\n    private _onKeyUp;\n    constructor();\n    protected onDetach(): void;\n    protected getContent(): DNode;\n    protected renderCloseIcon(): DNode;\n    protected renderTitle(): DNode;\n    protected renderUnderlay(): DNode;\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/dialog/styles/dialog.m.css.d.ts","text":"export const root: string;\nexport const main: string;\nexport const underlay: string;\nexport const underlayVisible: string;\nexport const title: string;\nexport const content: string;\nexport const close: string;\n","type":2},{"name":"node_modules/@dojo/widgets/label/Label.d.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { DNode, SupportedClassName } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\n/**\n * Label settings for form label text content, position (before or after), and visibility\n */\nexport interface LabelOptions {\n    content: string;\n    before?: boolean;\n    hidden?: boolean;\n}\n/**\n * @type LabelProperties\n *\n * Properties that can be set on a Label component\n *\n * @property forId     ID to explicitly associate the label with an input element\n * @property label      Label settings for form label text, position, and visibility\n */\nexport interface LabelProperties extends ThemedProperties {\n    forId?: string;\n    label: string | LabelOptions;\n}\n/**\n * This is a helper function for using `extraClasses` with Label.\n * It can be used as follows:\n * extraClasses: { root: parseLabelClasses(this.theme([ css.class1, css.class2 ])) }\n */\nexport declare function parseLabelClasses(classes: SupportedClassName | SupportedClassName[]): string;\nexport declare const LabelBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class Label extends LabelBase<LabelProperties> {\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/label/styles/label.m.css.d.ts","text":"export const root: string;\nexport const labelText: string;\n","type":2},{"name":"node_modules/@dojo/widgets/listbox/Listbox.d.ts","text":"import { DNode } from '@dojo/widget-core/interfaces';\nimport MetaBase from '@dojo/widget-core/meta/Base';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\nexport declare class ScrollMeta extends MetaBase {\n    scroll(key: string | number, amount: number): void;\n}\n/**\n * @type ListboxProperties\n *\n * Properties that can be set on a Listbox component\n *\n * @property activeIndex          Index of the currently active listbox option\n * @property describedBy          ID of an element that provides more descriptive text\n * @property getOptionLabel       Function to return string label based on option data\n * @property getOptionDisabled    Function that accepts option data and returns a boolean for disabled/not disabled\n * @property getOptionId          Function that accepts option data and returns a string ID\n * @property getOptionSelected    Function that accepts option data and returns a boolean for selected/unselected\n * @property id                   Optional custom id for the listbox\n * @property multiselect          Adds currect semantics for a multiselect listbox\n * @property optionData           Array of data for listbox options\n * @property tabIndex             Listbox is in the focus order by default, but setting tabIndex: -1 will remove it\n * @property visualFocus          When controlling Listbox through an outside widget, e.g. in ComboBox, visualFocus mimics visual focus styling when true\n * @property onActiveIndexChange  Called with the index of the new requested active descendant\n * @property onOptionSelect       Called with the option data of the new requested selected item\n */\nexport interface ListboxProperties extends ThemedProperties {\n    activeIndex?: number;\n    describedBy?: string;\n    getOptionDisabled?(option: any, index: number): boolean;\n    getOptionId?(option: any, index: number): string;\n    getOptionLabel?(option: any, index: number): DNode;\n    getOptionSelected?(option: any, index: number): boolean;\n    id?: string;\n    multiselect?: boolean;\n    optionData?: any[];\n    tabIndex?: number;\n    visualFocus?: boolean;\n    onActiveIndexChange?(index: number, key?: string | number): void;\n    onKeyDown?(event: KeyboardEvent, key?: string | number): void;\n    onOptionSelect?(option: any, index: number, key?: string | number): void;\n}\nexport declare const ThemedBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class Listbox extends ThemedBase<ListboxProperties> {\n    private _boundRenderOption;\n    private _idBase;\n    private _getOptionDisabled(option, index);\n    private _getOptionId(index);\n    private _onKeyDown(event);\n    private _onOptionClick(option, index, key?);\n    protected animateScroll(scrollValue: number): void;\n    protected calculateScroll(previousProperties: ListboxProperties, {activeIndex}: ListboxProperties): void;\n    protected getModifierClasses(): (string | null)[];\n    protected getOptionClasses(active: boolean, disabled: boolean, selected: boolean): (string | null)[];\n    protected renderOptionLabel(option: any, index: number): DNode;\n    protected renderOption(option: any, index: number): DNode;\n    protected renderOptions(): DNode[];\n    protected render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/listbox/ListboxOption.d.ts","text":"import { DNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\nexport interface ListboxOptionProperties extends ThemedProperties {\n    active?: boolean;\n    classes?: (string | null)[];\n    disabled?: boolean;\n    id: string;\n    index: number;\n    label: DNode;\n    option: any;\n    selected?: boolean;\n    onClick?(option: any, index: number, key?: string | number): void;\n}\nexport declare const ThemedBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class ListboxOption extends ThemedBase<ListboxOptionProperties> {\n    private _onClick(event);\n    protected render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/listbox/styles/listbox.m.css.d.ts","text":"export const root: string;\nexport const option: string;\nexport const focused: string;\nexport const activeOption: string;\nexport const disabledOption: string;\nexport const selectedOption: string;\n","type":2},{"name":"node_modules/@dojo/widgets/radio/Radio.d.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { DNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { LabelOptions } from '../label/Label';\n/**\n * @type RadioProperties\n *\n * Properties that can be set on a Radio component\n *\n * @property checked          Checked/unchecked property of the radio\n * @property describedBy      ID of an element that provides more descriptive text\n * @property disabled         Prevents the user from interacting with the form field\n * @property invalid          Indicates the valid is invalid, or required and not filled in\n * @property label            Label settings for form label text, position, and visibility\n * @property name             The form widget's name\n * @property readOnly         Allows or prevents user interaction\n * @property required         Whether or not a value is required\n * @property value            The current value\n * @property onBlur           Called when the input loses focus\n * @property onChange         Called when the node's 'change' event is fired\n * @property onClick          Called when the input is clicked\n * @property onFocus          Called when the input is focused\n * @property onMouseDown      Called on the input's mousedown event\n * @property onMouseUp        Called on the input's mouseup event\n * @property onTouchStart     Called on the input's touchstart event\n * @property onTouchEnd       Called on the input's touchend event\n * @property onTouchCancel    Called on the input's touchcancel event\n */\nexport interface RadioProperties extends ThemedProperties {\n    checked?: boolean;\n    describedBy?: string;\n    disabled?: boolean;\n    invalid?: boolean;\n    label?: string | LabelOptions;\n    name?: string;\n    readOnly?: boolean;\n    required?: boolean;\n    value?: string;\n    onBlur?(event: FocusEvent): void;\n    onChange?(event: Event): void;\n    onClick?(event: MouseEvent): void;\n    onFocus?(event: FocusEvent): void;\n    onMouseDown?(event: MouseEvent): void;\n    onMouseUp?(event: MouseEvent): void;\n    onTouchStart?(event: TouchEvent): void;\n    onTouchEnd?(event: TouchEvent): void;\n    onTouchCancel?(event: TouchEvent): void;\n}\nexport declare const RadioBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class Radio extends RadioBase<RadioProperties> {\n    private _focused;\n    private _onBlur(event);\n    private _onChange(event);\n    private _onClick(event);\n    private _onFocus(event);\n    private _onMouseDown(event);\n    private _onMouseUp(event);\n    private _onTouchStart(event);\n    private _onTouchEnd(event);\n    private _onTouchCancel(event);\n    protected getModifierClasses(): (string | null)[];\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/radio/styles/radio.m.css.d.ts","text":"export const root: string;\nexport const input: string;\nexport const inputWrapper: string;\nexport const checked: string;\nexport const focused: string;\nexport const disabled: string;\nexport const readonly: string;\nexport const required: string;\nexport const invalid: string;\nexport const valid: string;\n","type":2},{"name":"node_modules/@dojo/widgets/select/Select.d.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { DNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { LabelOptions } from '../label/Label';\n/**\n * @type SelectProperties\n *\n * Properties that can be set on a Select component\n *\n * @property describedBy       ID of an element that provides more descriptive text\n * @property disabled          Prevents the user from interacting with the form field\n * @property invalid           Indicates the value entered in the form field is invalid\n * @property getOptionDisabled Function that accepts an option's data and index and returns a boolean\n * @property getOptionId       Function that accepts an option's data and index and returns a string id\n * @property getOptionLabel    Function that accepts an option's data and index and returns a DNode label\n * @property getOptionSelected Function that accepts an option's data and index and returns a boolean\n * @property getOptionValue    Function that accepts an option's data and index and returns a string value\n * @property label             Label settings for form label text, position, and visibility\n * @property name              The form widget's name\n * @property options           Array of any type of data for the options\n * @property placeholder       Optional placeholder text, only valid for custom select widgets (useNativeElement must be false or undefined)\n * @property readOnly          Allows or prevents user interaction\n * @property required          Whether or not a value is required\n * @property useNativeElement  Use the native <select> element if true\n * @property value             The current value\n * @property onBlur            Called when the input loses focus\n * @property onChange          Called when the node's 'change' event is fired\n * @property onFocus           Called when the input is focused\n */\nexport interface SelectProperties extends ThemedProperties {\n    describedBy?: string;\n    disabled?: boolean;\n    invalid?: boolean;\n    getOptionDisabled?(option: any, index: number): boolean;\n    getOptionId?(option: any, index: number): string;\n    getOptionLabel?(option: any): DNode;\n    getOptionSelected?(option: any, index: number): boolean;\n    getOptionValue?(option: any, index: number): string;\n    label?: string | LabelOptions;\n    name?: string;\n    options?: any[];\n    placeholder?: string;\n    readOnly?: boolean;\n    required?: boolean;\n    useNativeElement?: boolean;\n    value?: string;\n    onBlur?(key?: string | number): void;\n    onChange?(option: any, key?: string | number): void;\n    onFocus?(key?: string | number): void;\n}\nexport declare const ThemedBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class Select extends ThemedBase<SelectProperties> {\n    private _callTriggerFocus;\n    private _callListboxFocus;\n    private _focusedIndex;\n    private _ignoreBlur;\n    private _open;\n    private _baseId;\n    private _getOptionLabel(option);\n    private _onBlur(event);\n    private _onFocus(event);\n    private _onNativeChange(event);\n    private _openSelect();\n    private _closeSelect();\n    private _onDropdownKeyDown(event);\n    private _onTriggerClick(event);\n    private _onTriggerBlur(event);\n    private _onTriggerKeyDown(event);\n    private _onTriggerMouseDown();\n    private _onListboxBlur(event);\n    protected getModifierClasses(): (string | null)[];\n    protected onElementUpdated(element: HTMLElement, key: string): void;\n    protected renderExpandIcon(): DNode;\n    protected renderNativeSelect(): DNode;\n    protected renderCustomSelect(): DNode;\n    protected renderCustomTrigger(): DNode[];\n    protected render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/select/styles/select.m.css.d.ts","text":"export const root: string;\nexport const inputWrapper: string;\nexport const trigger: string;\nexport const placeholder: string;\nexport const dropdown: string;\nexport const open: string;\nexport const input: string;\nexport const arrow: string;\nexport const disabled: string;\nexport const readonly: string;\nexport const invalid: string;\nexport const valid: string;\nexport const required: string;\n","type":2},{"name":"node_modules/@dojo/widgets/slidepane/createSlidePaneElement.d.ts","text":"import { CustomElementDescriptor } from '@dojo/widget-core/customElements';\n/**\n * Configures a SlidePane web component\n */\nexport default function createSlidePaneElement(): CustomElementDescriptor;\n","type":2},{"name":"node_modules/@dojo/widgets/slidepane/SlidePane.d.ts","text":"import { DNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\n/**\n * Enum for left / right alignment\n */\nexport declare const enum Align {\n    bottom = \"bottom\",\n    left = \"left\",\n    right = \"right\",\n    top = \"top\",\n}\n/**\n * @type SlidePaneProperties\n *\n * Properties that can be set on a SlidePane component\n *\n * @property align            The position of the pane on the screen\n * @property closeText        Hidden text used by screen readers to display for the close button\n * @property onOpen           Called when the pane opens\n * @property onRequestClose   Called when the pane is swiped closed or the underlay is clicked or tapped\n * @property open             Determines whether the pane is open or closed\n * @property title            Title to display in the pane\n * @property underlay         Determines whether a semi-transparent background shows behind the pane\n * @property width            Width of the pane in pixels\n */\nexport interface SlidePaneProperties extends ThemedProperties {\n    align?: Align;\n    closeText?: string;\n    onOpen?(): void;\n    onRequestClose?(): void;\n    open?: boolean;\n    title?: string;\n    underlay?: boolean;\n    width?: number;\n}\nexport declare const SlidePaneBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class SlidePane extends SlidePaneBase<SlidePaneProperties> {\n    private _content;\n    private _initialPosition;\n    private _slideIn;\n    private _swiping;\n    private _titleId;\n    private _transform;\n    private _wasOpen;\n    private readonly plane;\n    private _getDelta(event, eventType);\n    private _onCloseClick();\n    private _onSwipeStart(event);\n    private _onSwipeMove(event);\n    private _onSwipeEnd(event);\n    protected onElementCreated(element: HTMLElement, key: string): void;\n    protected getContent(): DNode;\n    protected getStyles(): {\n        [key: string]: string | null;\n    };\n    protected getFixedModifierClasses(): (string | null)[];\n    protected getModifierClasses(): (string | null)[];\n    protected renderCloseIcon(): DNode;\n    protected renderTitle(): DNode;\n    protected renderUnderlay(): DNode;\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/slidepane/styles/slidePane.m.css.d.ts","text":"export const root: string;\nexport const underlay: string;\nexport const underlayVisible: string;\nexport const paneFixed: string;\nexport const leftFixed: string;\nexport const rightFixed: string;\nexport const topFixed: string;\nexport const bottomFixed: string;\nexport const pane: string;\nexport const content: string;\nexport const title: string;\nexport const close: string;\nexport const slideOutFixed: string;\nexport const slideInFixed: string;\nexport const slideIn: string;\nexport const slideOut: string;\nexport const open: string;\nexport const openFixed: string;\n","type":2},{"name":"node_modules/@dojo/widgets/slider/Slider.d.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { LabelOptions } from '../label/Label';\nimport { DNode } from '@dojo/widget-core/interfaces';\n/**\n * @type SliderProperties\n *\n * Properties that can be set on a Slider component\n *\n * @property describedBy       ID of an element that provides more descriptive text\n * @property disabled          Prevents the user from interacting with the form field\n * @property invalid           Indicates the valid is invalid, or required and not filled in\n * @property label             Label settings for form label text, position, and visibility\n * @property max               The maximum value for the slider\n * @property min               The minimum value for the slider\n * @property name              The form widget's name\n * @property output            An optional function that returns a string or DNode for custom output format\n * @property readOnly          Allows or prevents user interaction\n * @property required          Whether or not a value is required\n * @property step              Size of the slider increment\n * @property value             The current value\n * @property vertical          Orients the slider vertically, false by default.\n * @property verticalHeight    Length of the vertical slider (only used if vertical is true)\n * @property onBlur            Called when the input loses focus\n * @property onChange          Called when the node's 'change' event is fired\n * @property onClick           Called when the input is clicked\n * @property onFocus           Called when the input is focused\n * @property onInput           Called when the 'input' event is fired\n * @property onKeyDown         Called on the input's keydown event\n * @property onKeyPress        Called on the input's keypress event\n * @property onKeyUp           Called on the input's keyup event\n * @property onMouseDown       Called on the input's mousedown event\n * @property onMouseUp         Called on the input's mouseup event\n * @property onTouchStart      Called on the input's touchstart event\n * @property onTouchEnd        Called on the input's touchend event\n * @property onTouchCancel     Called on the input's touchcancel event\n */\nexport interface SliderProperties extends ThemedProperties {\n    describedBy?: string;\n    disabled?: boolean;\n    invalid?: boolean;\n    label?: string | LabelOptions;\n    max?: number;\n    min?: number;\n    name?: string;\n    output?(value: number): DNode;\n    outputIsTooltip?: boolean;\n    readOnly?: boolean;\n    required?: boolean;\n    step?: number;\n    value?: number;\n    vertical?: boolean;\n    verticalHeight?: string;\n    onBlur?(event: FocusEvent): void;\n    onChange?(event: Event): void;\n    onClick?(event: MouseEvent): void;\n    onFocus?(event: FocusEvent): void;\n    onInput?(event: Event): void;\n    onKeyDown?(event: KeyboardEvent): void;\n    onKeyPress?(event: KeyboardEvent): void;\n    onKeyUp?(event: KeyboardEvent): void;\n    onMouseDown?(event: MouseEvent): void;\n    onMouseUp?(event: MouseEvent): void;\n    onTouchStart?(event: TouchEvent): void;\n    onTouchEnd?(event: TouchEvent): void;\n    onTouchCancel?(event: TouchEvent): void;\n}\nexport declare const SliderBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class Slider extends SliderBase<SliderProperties> {\n    private _inputId;\n    private _onBlur(event);\n    private _onChange(event);\n    private _onClick(event);\n    private _onFocus(event);\n    private _onInput(event);\n    private _onKeyDown(event);\n    private _onKeyPress(event);\n    private _onKeyUp(event);\n    private _onMouseDown(event);\n    private _onMouseUp(event);\n    private _onTouchStart(event);\n    private _onTouchEnd(event);\n    private _onTouchCancel(event);\n    protected getModifierClasses(): (string | null)[];\n    protected renderControls(percentValue: number): DNode;\n    protected renderOutput(value: number, percentValue: number): DNode;\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/slider/styles/slider.m.css.d.ts","text":"export const root: string;\nexport const rootFixed: string;\nexport const inputWrapper: string;\nexport const inputWrapperFixed: string;\nexport const track: string;\nexport const trackFixed: string;\nexport const fill: string;\nexport const fillFixed: string;\nexport const thumb: string;\nexport const thumbFixed: string;\nexport const input: string;\nexport const output: string;\nexport const outputTooltip: string;\nexport const vertical: string;\nexport const disabled: string;\nexport const readonly: string;\nexport const required: string;\nexport const invalid: string;\nexport const valid: string;\nexport const nativeInput: string;\n","type":2},{"name":"node_modules/@dojo/widgets/splitpane/createSplitPaneElement.d.ts","text":"import { CustomElementDescriptor } from '@dojo/widget-core/customElements';\n/**\n * Configures a SplitPane web component\n */\nexport default function createSplitPaneElement(): CustomElementDescriptor;\n","type":2},{"name":"node_modules/@dojo/widgets/splitpane/SplitPane.d.ts","text":"import { DNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\n/**\n * Direction of this SplitPane\n */\nexport declare const enum Direction {\n    column = 0,\n    row = 1,\n}\n/**\n * @type SplitPaneProperties\n *\n * Properties that can be set on a SplitPane component\n *\n * @property direction      Orientation of this SplitPane, can be `row` or `column`\n * @property leading        Content to show in the primary pane\n * @property onResize       Called when the divider is dragged; should be used to update `size`\n * @property size           Size of the primary pane\n * @property trailing       Content to show in the secondary pane\n */\nexport interface SplitPaneProperties extends ThemedProperties {\n    direction?: Direction;\n    leading?: DNode;\n    onResize?(size: number): void;\n    size?: number;\n    trailing?: DNode;\n}\nexport declare const SplitPaneBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class SplitPane extends SplitPaneBase<SplitPaneProperties> {\n    private _divider;\n    private _dragging;\n    private _lastSize?;\n    private _position;\n    private _root;\n    private _boundHandlers;\n    constructor();\n    protected onDetach(): void;\n    private _deselect();\n    private _getPosition(event);\n    private _onDragStart(event);\n    private _onDragMove(event);\n    private _onDragEnd(event);\n    protected getPaneContent(content: DNode): DNode[];\n    protected getPaneStyles(): {\n        [key: string]: string;\n    };\n    protected onElementCreated(element: HTMLElement, key: string): void;\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/splitpane/styles/splitPane.m.css.d.ts","text":"export const rootFixed: string;\nexport const root: string;\nexport const columnFixed: string;\nexport const column: string;\nexport const dividerFixed: string;\nexport const divider: string;\nexport const leadingFixed: string;\nexport const leading: string;\nexport const rowFixed: string;\nexport const row: string;\nexport const trailingFixed: string;\nexport const trailing: string;\n","type":2},{"name":"node_modules/@dojo/widgets/tabcontroller/createTabControllerElement.d.ts","text":"import { CustomElementDescriptor } from '@dojo/widget-core/customElements';\n/**\n * Configures a TabController web component\n */\nexport default function createTabControllerElement(): CustomElementDescriptor;\n","type":2},{"name":"node_modules/@dojo/widgets/tabcontroller/styles/tabController.m.css.d.ts","text":"export const root: string;\nexport const tabButton: string;\nexport const disabledTabButton: string;\nexport const activeTabButton: string;\nexport const close: string;\nexport const tab: string;\nexport const alignLeft: string;\nexport const tabs: string;\nexport const tabButtons: string;\nexport const alignBottom: string;\nexport const alignRight: string;\n","type":2},{"name":"node_modules/@dojo/widgets/tabcontroller/createTabElement.d.ts","text":"import { CustomElementDescriptor } from '@dojo/widget-core/customElements';\n/**\n * Configures a Tab web component\n */\nexport default function createTabElement(): CustomElementDescriptor;\n","type":2},{"name":"node_modules/@dojo/widgets/tabcontroller/Tab.d.ts","text":"import { DNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\n/**\n * @type TabProperties\n *\n * Properties that can be set on a Tab component\n *\n * @property closeable    Determines whether this tab can be closed\n * @property disabled     Determines whether this tab can become active\n * @property id           ID of this underlying DOM element\n * @property key          A unique identifier for this Tab within the TabController\n * @property label        Content to show in the TabController control bar for this tab\n * @property labelledBy   ID of DOM element that serves as a label for this tab\n */\nexport interface TabProperties extends ThemedProperties {\n    closeable?: boolean;\n    disabled?: boolean;\n    id?: string;\n    key: string;\n    label?: DNode;\n    labelledBy?: string;\n}\nexport declare const TabBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class Tab extends TabBase<TabProperties> {\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/tabcontroller/TabButton.d.ts","text":"import { DNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\n/**\n * @type TabButtonProperties\n *\n * Properties that can be set on a TabButton component\n *\n * @property active             Determines whether this tab button is active\n * @property callFocus          Used to immediately call focus on the cell\n * @property closeable          Determines whether this tab can be closed\n * @property controls           ID of the DOM element this tab button controls\n * @property disabled           Determines whether this tab can become active\n * @property id                 ID of this tab button DOM element\n * @property index              The position of this tab button\n * @property onClick            Called when this tab button is clicked\n * @property onCloseClick       Called when this tab button's close icon is clicked\n * @property onDownArrowPress   Called when the down arrow button is pressed\n * @property onEndPress         Called when the end button is pressed\n * @property onFocusCalled      Callback function when the cell receives focus\n * @property onHomePress        Called when the home button is pressed\n * @property onLeftArrowPress   Called when the left arrow button is pressed\n * @property onRightArrowPress  Called when the right arrow button is pressed\n * @property onUpArrowPress     Called when the up arrow button is pressed\n */\nexport interface TabButtonProperties extends ThemedProperties {\n    active?: boolean;\n    callFocus?: boolean;\n    closeable?: boolean;\n    controls: string;\n    disabled?: boolean;\n    id: string;\n    index: number;\n    onClick?: (index: number) => void;\n    onCloseClick?: (index: number) => void;\n    onDownArrowPress?: () => void;\n    onEndPress?: () => void;\n    onFocusCalled?: () => void;\n    onHomePress?: () => void;\n    onLeftArrowPress?: () => void;\n    onRightArrowPress?: () => void;\n    onUpArrowPress?: () => void;\n}\nexport declare const TabButtonBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class TabButton extends TabButtonBase<TabButtonProperties> {\n    private _onClick();\n    private _onCloseClick(event);\n    private _onKeyDown(event);\n    private _callFocus(element);\n    protected getContent(): DNode[];\n    protected getModifierClasses(): (string | null)[];\n    protected onElementCreated(element: HTMLElement, key: string): void;\n    protected onElementUpdated(element: HTMLElement, key: string): void;\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/tabcontroller/TabController.d.ts","text":"import { DNode, WNode } from '@dojo/widget-core/interfaces';\nimport Tab from './Tab';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\n/**\n * Enum for tab button alignment\n */\nexport declare const enum Align {\n    bottom = 0,\n    left = 1,\n    right = 2,\n    top = 3,\n}\n/**\n * @type TabControllerProperties\n *\n * Properties that can be set on a TabController component\n *\n * @property activeIndex           Position of the currently active tab\n * @property alignButtons          Orientation of the tab buttons\n * @property onRequestTabChange    Called when a new tab button is clicked\n * @property onRequestTabClose     Called when a tab close button is clicked\n */\nexport interface TabControllerProperties extends ThemedProperties {\n    activeIndex: number;\n    alignButtons?: Align;\n    onRequestTabChange?(index: number, key: string): void;\n    onRequestTabClose?(index: number, key: string): void;\n}\nexport declare const TabControllerBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class TabController extends TabControllerBase<TabControllerProperties, WNode<Tab>> {\n    private _id;\n    private _callTabFocus;\n    private readonly _tabs;\n    private _onDownArrowPress();\n    private _onLeftArrowPress();\n    private _onRightArrowPress();\n    private _onUpArrowPress();\n    /**\n     * Determines if the tab at `currentIndex` is enabled. If disabled,\n     * returns the next valid index, or null if no enabled tabs exist.\n     */\n    private _validateIndex(currentIndex, backwards?);\n    protected closeIndex(index: number): void;\n    protected renderButtonContent(label?: DNode): DNode[];\n    protected renderTabButtons(): DNode[];\n    protected renderTabs(): DNode[];\n    protected selectFirstIndex(): void;\n    protected selectIndex(index: number, backwards?: boolean): void;\n    protected selectLastIndex(): void;\n    protected selectNextIndex(): void;\n    protected selectPreviousIndex(): void;\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/textarea/styles/textarea.m.css.d.ts","text":"export const root: string;\nexport const input: string;\nexport const inputWrapper: string;\nexport const disabled: string;\nexport const readonly: string;\nexport const required: string;\nexport const invalid: string;\nexport const valid: string;\n","type":2},{"name":"node_modules/@dojo/widgets/textarea/Textarea.d.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { DNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { LabelOptions } from '../label/Label';\n/**\n * @type TextareaProperties\n *\n * Properties that can be set on a TextInput component\n *\n * @property columns         Number of columns, controls the width of the textarea\n * @property describedBy     ID of an element that provides more descriptive text\n * @property disabled        Prevents the user from interacting with the form field\n * @property invalid         Indicates the value entered in the form field is invalid\n * @property label           Label settings for form label text, position, and visibility\n * @property maxLength       Maximum number of characters allowed in the input\n * @property minLength       Minimum number of characters allowed in the input\n * @property name            The form widget's name\n * @property placeholder     Placeholder text\n * @property readOnly        Allows or prevents user interaction\n * @property required        Whether or not a value is required\n * @property rows            Number of rows, controls the height of the textarea\n * @property value           The current value\n * @property wrapText        Controls text wrapping. Can be \"hard\", \"soft\", or \"off\"\n * @property onBlur          Called when the input loses focus\n * @property onChange        Called when the node's 'change' event is fired\n * @property onClick         Called when the input is clicked\n * @property onFocus         Called when the input is focused\n * @property onInput         Called when the 'input' event is fired\n * @property onKeyDown       Called on the input's keydown event\n * @property onKeyPress      Called on the input's keypress event\n * @property onKeyUp         Called on the input's keyup event\n * @property onMouseDown     Called on the input's mousedown event\n * @property onMouseUp       Called on the input's mouseup event\n * @property onTouchStart    Called on the input's touchstart event\n * @property onTouchEnd      Called on the input's touchend event\n * @property onTouchCancel   Called on the input's touchcancel event\n */\nexport interface TextareaProperties extends ThemedProperties {\n    columns?: number;\n    describedBy?: string;\n    disabled?: boolean;\n    invalid?: boolean;\n    label?: string | LabelOptions;\n    maxLength?: number | string;\n    minLength?: number | string;\n    name?: string;\n    placeholder?: string;\n    readOnly?: boolean;\n    required?: boolean;\n    rows?: number;\n    value?: string;\n    wrapText?: 'hard' | 'soft' | 'off';\n    onBlur?(event: FocusEvent): void;\n    onChange?(event: Event): void;\n    onClick?(event: MouseEvent): void;\n    onFocus?(event: FocusEvent): void;\n    onInput?(event: Event): void;\n    onKeyDown?(event: KeyboardEvent): void;\n    onKeyPress?(event: KeyboardEvent): void;\n    onKeyUp?(event: KeyboardEvent): void;\n    onMouseDown?(event: MouseEvent): void;\n    onMouseUp?(event: MouseEvent): void;\n    onTouchStart?(event: TouchEvent): void;\n    onTouchEnd?(event: TouchEvent): void;\n    onTouchCancel?(event: TouchEvent): void;\n}\nexport declare const TextareaBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class Textarea extends TextareaBase<TextareaProperties> {\n    private _onBlur(event);\n    private _onChange(event);\n    private _onClick(event);\n    private _onFocus(event);\n    private _onInput(event);\n    private _onKeyDown(event);\n    private _onKeyPress(event);\n    private _onKeyUp(event);\n    private _onMouseDown(event);\n    private _onMouseUp(event);\n    private _onTouchStart(event);\n    private _onTouchEnd(event);\n    private _onTouchCancel(event);\n    protected getModifierClasses(): (string | null)[];\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/textinput/styles/textinput.m.css.d.ts","text":"export const input: string;\nexport const inputWrapper: string;\nexport const root: string;\nexport const disabled: string;\nexport const readonly: string;\nexport const required: string;\nexport const invalid: string;\nexport const valid: string;\n","type":2},{"name":"node_modules/@dojo/widgets/textinput/TextInput.d.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { DNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { LabelOptions } from '../label/Label';\nexport declare type TextInputType = 'text' | 'email' | 'number' | 'password' | 'search' | 'tel' | 'url';\n/**\n * @type TextInputProperties\n *\n * Properties that can be set on a TextInput component\n *\n * @property controls       ID of an element that this input controls\n * @property describedBy    ID of an element that provides more descriptive text\n * @property disabled       Prevents the user from interacting with the form field\n * @property invalid        Indicates the value entered in the form field is invalid\n * @property label          Label settings for form label text, position, and visibility\n * @property maxLength      Maximum number of characters allowed in the input\n * @property minLength      Minimum number of characters allowed in the input\n * @property name           The form widget's name\n * @property placeholder    Placeholder text\n * @property readOnly       Allows or prevents user interaction\n * @property required       Whether or not a value is required\n * @property type           Input type, e.g. text, email, tel, etc.\n * @property value          The current value\n * @property onBlur         Called when the input loses focus\n * @property onChange       Called when the node's 'change' event is fired\n * @property onClick        Called when the input is clicked\n * @property onFocus        Called when the input is focused\n * @property onInput        Called when the 'input' event is fired\n * @property onKeyDown      Called on the input's keydown event\n * @property onKeyPress     Called on the input's keypress event\n * @property onKeyUp        Called on the input's keyup event\n * @property onMouseDown    Called on the input's mousedown event\n * @property onMouseUp      Called on the input's mouseup event\n * @property onTouchStart   Called on the input's touchstart event\n * @property onTouchEnd     Called on the input's touchend event\n * @property onTouchCancel  Called on the input's touchcancel event\n */\nexport interface TextInputProperties extends ThemedProperties {\n    controls?: string;\n    describedBy?: string;\n    disabled?: boolean;\n    invalid?: boolean;\n    label?: string | LabelOptions;\n    maxLength?: number | string;\n    minLength?: number | string;\n    name?: string;\n    placeholder?: string;\n    readOnly?: boolean;\n    required?: boolean;\n    type?: TextInputType;\n    value?: string;\n    onBlur?(event: FocusEvent): void;\n    onChange?(event: Event): void;\n    onClick?(event: MouseEvent): void;\n    onFocus?(event: FocusEvent): void;\n    onInput?(event: Event): void;\n    onKeyDown?(event: KeyboardEvent): void;\n    onKeyPress?(event: KeyboardEvent): void;\n    onKeyUp?(event: KeyboardEvent): void;\n    onMouseDown?(event: MouseEvent): void;\n    onMouseUp?(event: MouseEvent): void;\n    onTouchStart?(event: TouchEvent): void;\n    onTouchEnd?(event: TouchEvent): void;\n    onTouchCancel?(event: TouchEvent): void;\n}\nexport declare const TextInputBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class TextInput extends TextInputBase<TextInputProperties> {\n    private _onBlur(event);\n    private _onChange(event);\n    private _onClick(event);\n    private _onFocus(event);\n    private _onInput(event);\n    private _onKeyDown(event);\n    private _onKeyPress(event);\n    private _onKeyUp(event);\n    private _onMouseDown(event);\n    private _onMouseUp(event);\n    private _onTouchStart(event);\n    private _onTouchEnd(event);\n    private _onTouchCancel(event);\n    protected getModifierClasses(): (string | null)[];\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/accordionPane.m.css.d.ts","text":"export const root: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/button.m.css.d.ts","text":"export const root: string;\nexport const addon: string;\nexport const pressed: string;\nexport const popup: string;\nexport const disabled: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/checkbox.m.css.d.ts","text":"export const root: string;\nexport const input: string;\nexport const inputWrapper: string;\nexport const checked: string;\nexport const disabled: string;\nexport const readonly: string;\nexport const required: string;\nexport const invalid: string;\nexport const valid: string;\nexport const toggle: string;\nexport const onLabel: string;\nexport const offLabel: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/calendar.m.css.d.ts","text":"export const root: string;\nexport const dateGrid: string;\nexport const weekday: string;\nexport const date: string;\nexport const todayDate: string;\nexport const inactiveDate: string;\nexport const selectedDate: string;\nexport const topMatter: string;\nexport const monthTrigger: string;\nexport const yearTrigger: string;\nexport const previous: string;\nexport const next: string;\nexport const monthTriggerActive: string;\nexport const yearTriggerActive: string;\nexport const monthGrid: string;\nexport const yearGrid: string;\nexport const monthFields: string;\nexport const yearFields: string;\nexport const monthRadio: string;\nexport const yearRadio: string;\nexport const monthRadioLabel: string;\nexport const yearRadioLabel: string;\nexport const monthRadioChecked: string;\nexport const yearRadioChecked: string;\nexport const monthRadioInput: string;\nexport const yearRadioInput: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/comboBox.m.css.d.ts","text":"export const root: string;\nexport const trigger: string;\nexport const dropdown: string;\nexport const open: string;\nexport const option: string;\nexport const selected: string;\nexport const invalid: string;\nexport const valid: string;\nexport const clear: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/dialog.m.css.d.ts","text":"export const root: string;\nexport const main: string;\nexport const underlayVisible: string;\nexport const title: string;\nexport const content: string;\nexport const close: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/icons.m.css.d.ts","text":"export const icon: string;\nexport const plusIcon: string;\nexport const minusIcon: string;\nexport const checkIcon: string;\nexport const closeIcon: string;\nexport const leftIcon: string;\nexport const rightIcon: string;\nexport const upIcon: string;\nexport const downIcon: string;\nexport const upAltIcon: string;\nexport const downAltIcon: string;\nexport const searchIcon: string;\nexport const barsIcon: string;\nexport const settingsIcon: string;\nexport const alertIcon: string;\nexport const helpIcon: string;\nexport const infoIcon: string;\nexport const phoneIcon: string;\nexport const editIcon: string;\nexport const dateIcon: string;\nexport const linkIcon: string;\nexport const locationIcon: string;\nexport const secureIcon: string;\nexport const mailIcon: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/listbox.m.css.d.ts","text":"export const root: string;\nexport const option: string;\nexport const activeOption: string;\nexport const disabledOption: string;\nexport const selectedOption: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/radio.m.css.d.ts","text":"export const root: string;\nexport const input: string;\nexport const inputWrapper: string;\nexport const focused: string;\nexport const checked: string;\nexport const disabled: string;\nexport const readonly: string;\nexport const required: string;\nexport const invalid: string;\nexport const valid: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/select.m.css.d.ts","text":"export const root: string;\nexport const inputWrapper: string;\nexport const trigger: string;\nexport const arrow: string;\nexport const dropdown: string;\nexport const open: string;\nexport const option: string;\nexport const disabledOption: string;\nexport const focused: string;\nexport const input: string;\nexport const selected: string;\nexport const disabled: string;\nexport const readonly: string;\nexport const invalid: string;\nexport const valid: string;\nexport const required: string;\nexport const multiselect: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/slidePane.m.css.d.ts","text":"export const root: string;\nexport const underlayVisible: string;\nexport const pane: string;\nexport const content: string;\nexport const title: string;\nexport const close: string;\nexport const left: string;\nexport const right: string;\nexport const slideOut: string;\nexport const slideIn: string;\nexport const open: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/slider.m.css.d.ts","text":"export const root: string;\nexport const inputWrapper: string;\nexport const track: string;\nexport const fill: string;\nexport const thumb: string;\nexport const input: string;\nexport const outputTooltip: string;\nexport const output: string;\nexport const vertical: string;\nexport const disabled: string;\nexport const readonly: string;\nexport const required: string;\nexport const invalid: string;\nexport const valid: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/splitPane.m.css.d.ts","text":"export const root: string;\nexport const divider: string;\nexport const row: string;\nexport const column: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/tabController.m.css.d.ts","text":"export const root: string;\nexport const tabButton: string;\nexport const disabledTabButton: string;\nexport const activeTabButton: string;\nexport const close: string;\nexport const tab: string;\nexport const alignLeft: string;\nexport const tabs: string;\nexport const tabButtons: string;\nexport const alignRight: string;\nexport const alignBottom: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/textarea.m.css.d.ts","text":"export const root: string;\nexport const input: string;\nexport const inputWrapper: string;\nexport const disabled: string;\nexport const readonly: string;\nexport const required: string;\nexport const invalid: string;\nexport const valid: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/textinput.m.css.d.ts","text":"export const root: string;\nexport const input: string;\nexport const inputWrapper: string;\nexport const disabled: string;\nexport const readonly: string;\nexport const required: string;\nexport const invalid: string;\nexport const valid: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/theme.d.ts","text":"import * as accordionPane from './accordionPane.m.css';\nimport * as button from './button.m.css';\nimport * as calendar from './calendar.m.css';\nimport * as checkbox from './checkbox.m.css';\nimport * as comboBox from './comboBox.m.css';\nimport * as dialog from './dialog.m.css';\nimport * as icons from './icons.m.css';\nimport * as listbox from './listbox.m.css';\nimport * as radio from './radio.m.css';\nimport * as select from './select.m.css';\nimport * as slidePane from './slidePane.m.css';\nimport * as slider from './slider.m.css';\nimport * as splitPane from './splitPane.m.css';\nimport * as tabController from './tabController.m.css';\nimport * as textarea from './textarea.m.css';\nimport * as textinput from './textinput.m.css';\nimport * as titlePane from './titlePane.m.css';\nimport * as tooltip from './tooltip.m.css';\ndeclare const _default: {\n    'dojo-accordionPane': typeof accordionPane;\n    'dojo-button': typeof button;\n    'dojo-calendar': typeof calendar;\n    'dojo-checkbox': typeof checkbox;\n    'dojo-comboBox': typeof comboBox;\n    'dojo-dialog': typeof dialog;\n    'dojo-icons': typeof icons;\n    'dojo-listbox': typeof listbox;\n    'dojo-radio': typeof radio;\n    'dojo-select': typeof select;\n    'dojo-slidePane': typeof slidePane;\n    'dojo-slider': typeof slider;\n    'dojo-splitPane': typeof splitPane;\n    'dojo-tabController': typeof tabController;\n    'dojo-textarea': typeof textarea;\n    'dojo-textinput': typeof textinput;\n    'dojo-titlePane': typeof titlePane;\n    'dojo-tooltip': typeof tooltip;\n};\nexport default _default;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/timePicker.m.css.d.ts","text":"export const root: string;\nexport const input: string;\nexport const disabled: string;\nexport const readonly: string;\nexport const invalid: string;\nexport const arrow: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/titlePane.m.css.d.ts","text":"export const root: string;\nexport const titleButton: string;\nexport const content: string;\nexport const open: string;\nexport const arrow: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/tooltip.m.css.d.ts","text":"export const bottom: string;\nexport const content: string;\nexport const left: string;\nexport const right: string;\nexport const root: string;\nexport const top: string;\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/variables.css.d.ts","text":"export default {};\n","type":2},{"name":"node_modules/@dojo/widgets/themes/dojo/widgets.css.d.ts","text":"export default {};\n","type":2},{"name":"node_modules/@dojo/widgets/timepicker/styles/timePicker.m.css.d.ts","text":"export const root: string;\nexport const input: string;\nexport const arrow: string;\nexport const disabled: string;\nexport const invalid: string;\nexport const readonly: string;\nexport const required: string;\n","type":2},{"name":"node_modules/@dojo/widgets/timepicker/TimePicker.d.ts","text":"import { DNode } from '@dojo/widget-core/interfaces';\nimport ThemedMixin, { ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { LabelOptions } from '../label/Label';\nimport { TextInputProperties } from '../textinput/TextInput';\n/**\n * @type TimePickerProperties\n *\n * Properties that can be set on a TimePicker component\n *\n * @property autoBlur           Determines whether the input should blur after value selection\n * @property clearable          Determines whether the custom input should be able to be cleared\n * @property CustomOptionItem   Can be used to render a custom option\n * @property CustomOptionMenu   Can be used to render a custom option menu\n * @property disabled           Prevents user interaction and styles content accordingly\n * @property end                The maximum time to display in the menu (defaults to '23:59:59')\n * @property getOptionLabel     Can be used to get the text label of an option based on the underlying option object\n * @property inputProperties    TextInput properties to set on the underlying input\n * @property invalid            Determines if this input is valid\n * @property isOptionDisabled   Used to determine if an item should be disabled\n * @property label              Label settings for form label text, position, and visibility\n * @property name               The native input's name.\n * @property onBlur             Called when the input is blurred\n * @property onChange           Called when the value changes\n * @property onFocus            Called when the input is focused\n * @property onMenuChange       Called when menu visibility changes\n * @property onRequestOptions   Called when options are shown; should be used to set `options`\n * @property openOnFocus        Determines whether the result list should open when the input is focused\n * @property options            Options for the current input; should be set in response to `onRequestOptions`\n * @property readOnly           Prevents user interaction\n * @property required           Determines if this input is required, styles accordingly\n * @property start              The minimum time to display in the menu (defaults to '00:00:00')\n * @property step               The number of seconds between each option in the menu (defaults to 60)\n * @property useNativeElement   Use the native <input type=\"time\"> element if true\n * @property value              Value to set on the input\n */\nexport interface TimePickerProperties extends ThemedProperties {\n    autoBlur?: boolean;\n    clearable?: boolean;\n    disabled?: boolean;\n    end?: string;\n    getOptionLabel?(option: TimeUnits): string;\n    inputProperties?: TextInputProperties;\n    invalid?: boolean;\n    isOptionDisabled?(result: any): boolean;\n    label?: string | LabelOptions;\n    name?: string;\n    onBlur?(value: string): void;\n    onChange?(value: string): void;\n    onFocus?(value: string): void;\n    onMenuChange?(open: boolean): void;\n    onRequestOptions?(value: string, options: TimeUnits[]): void;\n    openOnFocus?: boolean;\n    options?: TimeUnits[];\n    readOnly?: boolean;\n    required?: boolean;\n    start?: string;\n    step?: number;\n    useNativeElement?: boolean;\n    value?: string;\n}\n/**\n * An object representing a dateless time (without milliseconds).\n *\n * @property hour    The number of hours.\n * @property minute  An optional number of minutes.\n * @property second  An optional number of seconds.\n */\nexport interface TimeUnits {\n    hour: number;\n    minute?: number;\n    second?: number;\n}\n/**\n * Generate an array of time unit objects from the specified start date to the specified end date.\n *\n * @param start    The start time. Defaults to midnight.\n * @param end      The end time. Defaults to 23:59:59.\n * @param step     The amount of time in seconds between each step. Defaults to 60.\n * @return         An array of time unit objects.\n */\nexport declare function getOptions(start?: string, end?: string, step?: number): TimeUnits[];\n/**\n * Convert a standard time string into an object with `hour`, `minute`, and `second` number properties.\n *\n * For example, '12:30' is converted to `{ hour: 12, minute: 30, second: 0 }`, and '19:03:27' is converted\n * to `{ hour: 19, minute: 3, second: 27 }`.\n *\n * @param value   A standard time string or an object with `hour`, `minute`, and `second` properties.\n * @return        An object containing `hour`, `second`, and `number` properties.\n */\nexport declare function parseUnits(value: string | TimeUnits): TimeUnits;\nexport declare const TimePickerBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport declare class TimePicker extends TimePickerBase<TimePickerProperties> {\n    protected options: TimeUnits[] | null;\n    private _formatUnits(units);\n    private _getOptionLabel(value);\n    private _onNativeBlur(event);\n    private _onNativeChange(event);\n    private _onNativeFocus(event);\n    private _onRequestOptions(value);\n    protected getModifierClasses(): (string | null)[];\n    protected getOptions(): TimeUnits[];\n    protected onPropertiesChanged(): void;\n    protected renderCustomInput(): DNode;\n    protected renderNativeInput(): DNode;\n    render(): DNode;\n}\nexport default TimePicker;\n","type":2},{"name":"node_modules/@dojo/widgets/titlepane/createTitlePaneElement.d.ts","text":"import { CustomElementDescriptor } from '@dojo/widget-core/customElements';\n/**\n * Configures a TitlePane web component\n */\nexport default function createTitlePaneElement(): CustomElementDescriptor;\n","type":2},{"name":"node_modules/@dojo/widgets/titlepane/styles/titlePane.m.css.d.ts","text":"export const rootFixed: string;\nexport const root: string;\nexport const open: string;\nexport const titleFixed: string;\nexport const title: string;\nexport const closeableFixed: string;\nexport const closeable: string;\nexport const content: string;\nexport const arrow: string;\nexport const titleButton: string;\n","type":2},{"name":"node_modules/@dojo/widgets/titlepane/TitlePane.d.ts","text":"import { DNode } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin, ThemedProperties } from '@dojo/widget-core/mixins/Themed';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\n/**\n * @type TitlePaneProperties\n *\n * Properties that can be set on a TitlePane component\n *\n * @property closeable          If false the pane will not collapse in response to clicking the title\n * @property headingLevel       'aria-level' for the title's DOM node\n * @property onRequestClose     Called when the title of an open pane is clicked\n * @property onRequestOpen      Called when the title of a closed pane is clicked\n * @property open               If true the pane is opened and content is visible\n * @property title              Title to display above the content\n */\nexport interface TitlePaneProperties extends ThemedProperties {\n    closeable?: boolean;\n    headingLevel?: number;\n    onRequestClose?(key: string | number | undefined): void;\n    onRequestOpen?(key: string | number | undefined): void;\n    open?: boolean;\n    title: string;\n}\nexport declare const TitlePaneBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class TitlePane extends TitlePaneBase<TitlePaneProperties> {\n    private _contentId;\n    private _titleId;\n    private _afterRender(element);\n    private _onTitleClick();\n    private _toggle();\n    protected onElementCreated(element: HTMLElement, key: string): void;\n    protected onElementUpdated(element: HTMLElement, key: string): void;\n    protected getButtonContent(): DNode;\n    protected getFixedModifierClasses(): (string | null)[];\n    protected getModifierClasses(): (string | null)[];\n    protected getPaneContent(): DNode[];\n    protected renderExpandIcon(): DNode;\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@dojo/widgets/tooltip/createTooltipElement.d.ts","text":"import { CustomElementDescriptor } from '@dojo/widget-core/customElements';\n/**\n * Configures a Tooltip web component\n */\nexport default function createTooltipElement(): CustomElementDescriptor;\n","type":2},{"name":"node_modules/@dojo/widgets/tooltip/styles/tooltip.m.css.d.ts","text":"export const rootFixed: string;\nexport const contentFixed: string;\nexport const bottomFixed: string;\nexport const leftFixed: string;\nexport const rightFixed: string;\nexport const topFixed: string;\nexport const root: string;\nexport const content: string;\nexport const top: string;\nexport const right: string;\nexport const left: string;\nexport const bottom: string;\n","type":2},{"name":"node_modules/@dojo/widgets/tooltip/Tooltip.d.ts","text":"import { DNode, WidgetProperties } from '@dojo/widget-core/interfaces';\nimport { ThemedMixin } from '@dojo/widget-core/mixins/Themed';\nimport { WidgetBase } from '@dojo/widget-core/WidgetBase';\n/**\n * @type TooltipProperties\n *\n * Properties that can be set on Tooltip components\n *\n * @property content           Information to show within the tooltip\n * @property orientation       Where this tooltip should render relative to its child\n * @property open           Determines if this tooltip is visible\n */\nexport interface TooltipProperties extends WidgetProperties {\n    content: DNode;\n    orientation?: Orientation;\n    open?: boolean;\n}\nexport declare const enum Orientation {\n    bottom = \"bottom\",\n    left = \"left\",\n    right = \"right\",\n    top = \"top\",\n}\nexport declare const ThemedBase: (new (...args: any[]) => ThemedMixin<{}>) & typeof WidgetBase;\nexport default class Tooltip extends ThemedBase<TooltipProperties> {\n    protected getFixedModifierClasses(): (string | null)[];\n    protected getModifierClasses(): (string | null)[];\n    protected renderContent(): DNode;\n    protected renderTarget(): DNode;\n    render(): DNode;\n}\n","type":2},{"name":"node_modules/@types/benchmark/index.d.ts","text":"// Type definitions for Benchmark v1.0.0\n// Project: http://benchmarkjs.com\n// Definitions by: Asana <https://asana.com>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n\ndeclare class Benchmark {\n    static deepClone<T>(value: T): T;\n    static each(obj: Object | any[], callback: Function, thisArg?: any): void;\n    static extend(destination: Object, ...sources: Object[]): Object;\n    static filter<T>(arr: T[], callback: (value: T) => any, thisArg?: any): T[];\n    static filter<T>(arr: T[], filter: string, thisArg?: any): T[];\n    static forEach<T>(arr: T[], callback: (value: T) => any, thisArg?: any): void;\n    static formatNumber(num: number): string;\n    static forOwn(obj: Object, callback: Function, thisArg?: any): void;\n    static hasKey(obj: Object, key: string): boolean;\n    static indexOf<T>(arr: T[], value: T, fromIndex?: number): number;\n    static interpolate(template: string, values: Object): string;\n    static invoke(benches: Benchmark[], name: string | Object, ...args: any[]): any[];\n    static join(obj: Object, separator1?: string, separator2?: string): string;\n    static map<T, K>(arr: T[], callback: (value: T) => K, thisArg?: any): K[];\n    static pluck<T, K>(arr: T[], key: string): K[];\n    static reduce<T, K>(arr: T[], callback: (accumulator: K, value: T) => K, thisArg?: any): K;\n\n    static options: Benchmark.Options;\n    static platform: Benchmark.Platform;\n    static support: Benchmark.Support;\n    static version: string;\n\n    constructor(fn: Function | string, options?: Benchmark.Options);\n    constructor(name: string, fn: Function | string, options?: Benchmark.Options);\n    constructor(name: string, options?: Benchmark.Options);\n    constructor(options: Benchmark.Options);\n\n    aborted: boolean;\n    compiled: Function | string;\n    count: number;\n    cycles: number;\n    error: Error;\n    fn: Function | string;\n    hz: number;\n    running: boolean;\n    setup: Function | string;\n    teardown: Function | string;\n\n    stats: Benchmark.Stats;\n    times: Benchmark.Times;\n\n    abort(): Benchmark;\n    clone(options: Benchmark.Options): Benchmark;\n    compare(benchmark: Benchmark): number;\n    emit(type: string | Object): any;\n    listeners(type: string): Function[];\n    off(type?: string, listener?: Function): Benchmark;\n    off(types: string[]): Benchmark;\n    on(type?: string, listener?: Function): Benchmark;\n    on(types: string[]): Benchmark;\n    reset(): Benchmark;\n    run(options?: Benchmark.Options): Benchmark;\n    toString(): string;\n}\n\ndeclare namespace Benchmark {\n    export interface Options {\n        async?: boolean;\n        defer?: boolean;\n        delay?: number;\n        id?: string;\n        initCount?: number;\n        maxTime?: number;\n        minSamples?: number;\n        minTime?: number;\n        name?: string;\n        onAbort?: Function;\n        onComplete?: Function;\n        onCycle?: Function;\n        onError?: Function;\n        onReset?: Function;\n        onStart?: Function;\n        setup?: Function | string;\n        teardown?: Function | string;\n        fn?: Function | string;\n        queued?: boolean;\n    }\n\n    export interface Platform {\n        description: string;\n        layout: string;\n        manufacturer: string;\n        name: string;\n        os: string;\n        prerelease: string;\n        product: string;\n        version: string;\n        toString(): string;\n    }\n\n    export interface Support {\n        air: boolean;\n        argumentsClass: boolean;\n        browser: boolean;\n        charByIndex: boolean;\n        charByOwnIndex: boolean;\n        decompilation: boolean;\n        descriptors: boolean;\n        getAllKeys: boolean;\n        iteratesOwnFirst: boolean;\n        java: boolean;\n        nodeClass: boolean;\n        timeout: boolean;\n    }\n\n    export interface Stats {\n        deviation: number;\n        mean: number;\n        moe: number;\n        rme: number;\n        sample: any[];\n        sem: number;\n        variance: number;\n    }\n\n    export interface Times {\n        cycle: number;\n        elapsed: number;\n        period: number;\n        timeStamp: number;\n    }\n\n    export class Deferred {\n        constructor(clone: Benchmark);\n\n        benchmark: Benchmark;\n        cycles: number;\n        elapsed: number;\n        timeStamp: number;\n    }\n\n    export class Event {\n        constructor(type: string | Object);\n\n        aborted: boolean;\n        cancelled: boolean;\n        currentTarget: Object;\n        result: any;\n        target: Object;\n        timeStamp: number;\n        type: string;\n    }\n\n    export class Suite {\n        static options: { name: string };\n\n        constructor(name?: string, options?: Options);\n\n        aborted: boolean;\n        length: number;\n        running: boolean;\n        abort(): Suite;\n        add(name: string, fn: Function | string, options?: Options): Suite;\n        add(fn: Function | string, options?: Options): Suite;\n        add(name: string, options?: Options): Suite;\n        add(options: Options): Suite;\n        clone(options: Options): Suite;\n        emit(type: string | Object): any;\n        filter(callback: Function | string): Suite;\n        forEach(callback: Function): Suite;\n        indexOf(value: any): number;\n        invoke(name: string, ...args: any[]): any[];\n        join(separator?: string): string;\n        listeners(type: string): Function[];\n        map(callback: Function): any[];\n        off(type?: string, callback?: Function): Suite;\n        off(types: string[]): Suite;\n        on(type?: string, callback?: Function): Suite;\n        on(types: string[]): Suite;\n        pluck(property: string): any[];\n        pop(): Function;\n        push(benchmark: Benchmark): number;\n        reduce<T>(callback: Function, accumulator: T): T;\n        reset(): Suite;\n        reverse(): any[];\n        run(options?: Options): Suite;\n        shift(): Benchmark;\n        slice(start: number, end: number): any[];\n        slice(start: number, deleteCount: number, ...values: any[]): any[];\n        unshift(benchmark: Benchmark): number;\n    }\n}\n\nexport = Benchmark;\n","type":2},{"name":"node_modules/@types/body-parser/index.d.ts","text":"// Type definitions for body-parser 1.16\r\n// Project: https://github.com/expressjs/body-parser\r\n// Definitions by: Santi Albo <https://github.com/santialbo>, Vilic Vane <https://github.com/vilic>, Jonathan Häberle <https://github.com/dreampulse>, Gevik Babakhani <https://github.com/blendsdk>, Tomasz Łaziuk <https://github.com/tlaziuk>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n// TypeScript Version: 2.2\r\n\r\n/// <reference types=\"node\" />\r\n\r\nimport { Request, RequestHandler, Response } from 'express';\r\n\r\n// for docs go to https://github.com/expressjs/body-parser/tree/1.16.0#body-parser\r\n\r\n// @deprecated\r\ndeclare function bodyParser(options?: bodyParser.OptionsJson & bodyParser.OptionsText & bodyParser.OptionsUrlencoded): RequestHandler;\r\n\r\ndeclare namespace bodyParser {\r\n    interface Options {\r\n        inflate?: boolean;\r\n        limit?: number | string;\r\n        type?: string | string[] | ((req: Request) => any);\r\n        verify?(req: Request, res: Response, buf: Buffer, encoding: string): void;\r\n    }\r\n\r\n    interface OptionsJson extends Options {\r\n        reviver?(key: string, value: any): any;\r\n        strict?: boolean;\r\n    }\r\n\r\n    interface OptionsText extends Options {\r\n        defaultCharset?: string;\r\n    }\r\n\r\n    interface OptionsUrlencoded extends Options {\r\n        extended?: boolean;\r\n        parameterLimit?: number;\r\n    }\r\n\r\n    function json(options?: OptionsJson): RequestHandler;\r\n\r\n    function raw(options?: Options): RequestHandler;\r\n\r\n    function text(options?: OptionsText): RequestHandler;\r\n\r\n    function urlencoded(options?: OptionsUrlencoded): RequestHandler;\r\n}\r\n\r\nexport = bodyParser;\r\n","type":2},{"name":"node_modules/@types/babel-types/index.d.ts","text":"// Type definitions for babel-types 7.0\n// Project: https://github.com/babel/babel/tree/master/packages/babel-types\n// Definitions by: Troy Gerwien <https://github.com/yortus>\n//                 Sam Baxter <https://github.com/baxtersa>\n//                 Marvin Hagemeister <https://github.com/marvinhagemeister>\n//                 Boris Cherny <https://github.com/bcherny>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\nexport interface Comment {\n    value: string;\n    start: number;\n    end: number;\n    loc: SourceLocation;\n}\n\nexport interface CommentBlock extends Comment {\n    type: \"CommentBlock\";\n}\n\nexport interface CommentLine extends Comment {\n    type: \"CommentLine\";\n}\n\nexport interface SourceLocation {\n    start: {\n        line: number;\n        column: number;\n    };\n\n    end: {\n        line: number;\n        column: number;\n    };\n}\n\nexport interface Node {\n    type: string;\n    leadingComments?: Comment[];\n    innerComments?: Comment[];\n    trailingComments?: Comment[];\n    start: number;\n    end: number;\n    loc: SourceLocation;\n}\n\nexport interface ArrayExpression extends Node {\n    type: \"ArrayExpression\";\n    elements: Array<Expression | SpreadElement>;\n}\n\nexport interface AssignmentExpression extends Node {\n    type: \"AssignmentExpression\";\n    operator: \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"%=\" | \"<<=\" | \">>=\" | \">>>=\" | \"|=\" | \"^=\" | \"&=\";\n    left: LVal;\n    right: Expression;\n}\n\nexport interface BinaryExpression extends Node {\n    type: \"BinaryExpression\";\n    operator: \"+\" | \"-\" | \"/\" | \"%\" | \"*\" | \"**\" | \"&\" | \"|\" | \">>\" | \">>>\" | \"<<\" | \"^\" | \"==\" | \"===\" | \"!=\" | \"!==\" | \"in\" | \"instanceof\" | \">\" | \"<\" | \">=\" | \"<=\";\n    left: Expression;\n    right: Expression;\n}\n\nexport interface Directive extends Node {\n    type: \"Directive\";\n    value: DirectiveLiteral;\n}\n\nexport interface DirectiveLiteral extends Node {\n    type: \"DirectiveLiteral\";\n    value: string;\n}\n\nexport interface BlockStatement extends Node {\n    type: \"BlockStatement\";\n    directives?: Directive[];\n    body: Statement[];\n}\n\nexport interface BreakStatement extends Node {\n    type: \"BreakStatement\";\n    label: Identifier;\n}\n\nexport interface CallExpression extends Node {\n    type: \"CallExpression\";\n    callee: Expression | Super;\n    arguments: Array<Expression | SpreadElement>;\n}\n\nexport interface CatchClause extends Node {\n    type: \"CatchClause\";\n    param: Identifier;\n    body: BlockStatement;\n}\n\nexport interface ConditionalExpression extends Node {\n    type: \"ConditionalExpression\";\n    test: Expression;\n    consequent: Expression;\n    alternate: Expression;\n}\n\nexport interface ContinueStatement extends Node {\n    type: \"ContinueStatement\";\n    label: Identifier;\n}\n\nexport interface DebuggerStatement extends Node {\n    type: \"DebuggerStatement\";\n}\n\nexport interface DoWhileStatement extends Node {\n    type: \"DoWhileStatement\";\n    test: Expression;\n    body: Statement;\n}\n\nexport interface EmptyStatement extends Node {\n    type: \"EmptyStatement\";\n}\n\nexport interface ExpressionStatement extends Node {\n    type: \"ExpressionStatement\";\n    expression: Expression;\n}\n\nexport interface File extends Node {\n    type: \"File\";\n    program: Program;\n    comments: Comment[];\n    tokens: any[];\n}\n\nexport interface ForInStatement extends Node {\n    type: \"ForInStatement\";\n    left: VariableDeclaration | LVal;\n    right: Expression;\n    body: Statement;\n}\n\nexport interface ForStatement extends Node {\n    type: \"ForStatement\";\n    init: VariableDeclaration | Expression;\n    test: Expression;\n    update: Expression;\n    body: Statement;\n}\n\nexport interface FunctionDeclaration extends Node {\n    type: \"FunctionDeclaration\";\n    id: Identifier;\n    params: LVal[];\n    body: BlockStatement;\n    generator: boolean;\n    async: boolean;\n    returnType?: TypeAnnotation;\n    typeParameters?: TypeParameterDeclaration;\n}\n\nexport interface FunctionExpression extends Node {\n    type: \"FunctionExpression\";\n    id: Identifier;\n    params: LVal[];\n    body: BlockStatement;\n    generator: boolean;\n    async: boolean;\n    returnType?: TypeAnnotation;\n    typeParameters?: TypeParameterDeclaration;\n}\n\nexport interface Identifier extends Node {\n    type: \"Identifier\";\n    name: string;\n    typeAnnotation?: TypeAnnotation;\n}\n\nexport interface IfStatement extends Node {\n    type: \"IfStatement\";\n    test: Expression;\n    consequent: Statement;\n    alternate: Statement;\n}\n\nexport interface LabeledStatement extends Node {\n    type: \"LabeledStatement\";\n    label: Identifier;\n    body: Statement;\n}\n\nexport interface StringLiteral extends Node {\n    type: \"StringLiteral\";\n    value: string;\n}\n\nexport interface NumericLiteral extends Node {\n    type: \"NumericLiteral\";\n    value: number;\n}\n\nexport interface NullLiteral extends Node {\n    type: \"NullLiteral\";\n}\n\nexport interface BooleanLiteral extends Node {\n    type: \"BooleanLiteral\";\n    value: boolean;\n}\n\nexport interface RegExpLiteral extends Node {\n    type: \"RegExpLiteral\";\n    pattern: string;\n    flags?: string;\n}\n\nexport interface LogicalExpression extends Node {\n    type: \"LogicalExpression\";\n    operator: \"||\" | \"&&\";\n    left: Expression;\n    right: Expression;\n}\n\nexport interface MemberExpression extends Node {\n    type: \"MemberExpression\";\n    object: Expression | Super;\n    property: Expression;\n    computed: boolean;\n}\n\nexport interface NewExpression extends Node {\n    type: \"NewExpression\";\n    callee: Expression | Super;\n    arguments: Array<Expression | SpreadElement>;\n}\n\nexport interface Program extends Node {\n    type: \"Program\";\n    sourceType: \"script\" | \"module\";\n    directives?: Directive[];\n    body: Array<Statement | ModuleDeclaration>;\n}\n\nexport interface ObjectExpression extends Node {\n    type: \"ObjectExpression\";\n    properties: Array<ObjectProperty | ObjectMethod | SpreadProperty>;\n}\n\nexport interface ObjectMethod extends Node {\n    type: \"ObjectMethod\";\n    key: Expression;\n    kind: \"get\" | \"set\" | \"method\";\n    shorthand: boolean;\n    computed: boolean;\n    value: Expression;\n    decorators?: Decorator[];\n    id: Identifier;\n    params: LVal[];\n    body: BlockStatement;\n    generator: boolean;\n    async: boolean;\n    returnType?: TypeAnnotation;\n    typeParameters?: TypeParameterDeclaration;\n}\n\nexport interface ObjectProperty extends Node {\n    type: \"ObjectProperty\";\n    key: Expression;\n    computed: boolean;\n    value: Expression;\n    decorators?: Decorator[];\n    shorthand: boolean;\n}\n\nexport interface RestElement extends Node {\n    type: \"RestElement\";\n    argument: LVal;\n    typeAnnotation?: TypeAnnotation;\n}\n\nexport interface ReturnStatement extends Node {\n    type: \"ReturnStatement\";\n    argument: Expression;\n}\n\nexport interface SequenceExpression extends Node {\n    type: \"SequenceExpression\";\n    expressions: Expression[];\n}\n\nexport interface SwitchCase extends Node {\n    type: \"SwitchCase\";\n    test: Expression;\n    consequent: Statement[];\n}\n\nexport interface SwitchStatement extends Node {\n    type: \"SwitchStatement\";\n    discriminant: Expression;\n    cases: SwitchCase[];\n}\n\nexport interface ThisExpression extends Node {\n    type: \"ThisExpression\";\n}\n\nexport interface ThrowStatement extends Node {\n    type: \"ThrowStatement\";\n    argument: Expression;\n}\n\nexport interface TryStatement extends Node {\n    type: \"TryStatement\";\n    block: BlockStatement;\n    handler: CatchClause;\n    finalizer: BlockStatement;\n}\n\nexport interface UnaryExpression extends Node {\n    type: \"UnaryExpression\";\n    operator: \"-\" | \"+\" | \"!\" | \"~\" | \"typeof\" | \"void\" | \"delete\";\n    prefix: boolean;\n    argument: Expression;\n}\n\nexport interface UpdateExpression extends Node {\n    type: \"UpdateExpression\";\n    operator: \"++\" | \"--\";\n    prefix: boolean;\n    argument: Expression;\n}\n\nexport interface VariableDeclaration extends Node {\n    type: \"VariableDeclaration\";\n    declarations: VariableDeclarator[];\n    kind: \"var\" | \"let\" | \"const\";\n}\n\nexport interface VariableDeclarator extends Node {\n    type: \"VariableDeclarator\";\n    id: LVal;\n    init: Expression;\n}\n\nexport interface WhileStatement extends Node {\n    type: \"WhileStatement\";\n    test: Expression;\n    body: Statement;\n}\n\nexport interface WithStatement extends Node {\n    type: \"WithStatement\";\n    object: Expression;\n    body: BlockStatement | Statement;\n}\n\nexport interface AssignmentPattern extends Node {\n    type: \"AssignmentPattern\";\n    left: Identifier;\n    right: Expression;\n}\n\nexport interface ArrayPattern extends Node {\n    type: \"ArrayPattern\";\n    elements: Expression[];\n    typeAnnotation?: TypeAnnotation;\n}\n\nexport interface ArrowFunctionExpression extends Node {\n    type: \"ArrowFunctionExpression\";\n    id: Identifier;\n    params: LVal[];\n    body: BlockStatement | Expression;\n    generator: boolean;\n    async: boolean;\n    expression: boolean;\n    returnType?: TypeAnnotation;\n    typeParameters?: TypeParameterDeclaration;\n}\n\nexport interface ClassBody extends Node {\n    type: \"ClassBody\";\n    body: Array<ClassMethod | ClassProperty>;\n}\n\nexport interface ClassDeclaration extends Node {\n    type: \"ClassDeclaration\";\n    id: Identifier;\n    superClass: Expression;\n    body: ClassBody;\n    decorators?: Decorator[];\n    implements?: ClassImplements[];\n    mixins?: any[];\n    typeParameters?: TypeParameterDeclaration;\n    superTypeParameters?: TypeParameterInstantiation;\n}\n\nexport interface ClassExpression extends Node {\n    type: \"ClassExpression\";\n    id: Identifier;\n    superClass: Expression;\n    body: ClassBody;\n    decorators?: Decorator[];\n    implements?: ClassImplements[];\n    mixins?: any[];\n    typeParameters?: TypeParameterDeclaration;\n    superTypeParameters?: TypeParameterInstantiation;\n}\n\nexport interface ExportAllDeclaration extends Node {\n    type: \"ExportAllDeclaration\";\n    source: StringLiteral;\n}\n\nexport interface ExportDefaultDeclaration extends Node {\n    type: \"ExportDefaultDeclaration\";\n    declaration: Declaration | Expression;\n}\n\nexport interface ExportNamedDeclaration extends Node {\n    type: \"ExportNamedDeclaration\";\n    declaration: Declaration;\n    specifiers: ExportSpecifier[];\n    source: StringLiteral;\n}\n\nexport interface ExportSpecifier extends Node {\n    type: \"ExportSpecifier\";\n    local: Identifier;\n    imported: Identifier;\n    exported: Identifier;\n}\n\nexport interface ForOfStatement extends Node {\n    type: \"ForOfStatement\";\n    left: VariableDeclaration | LVal;\n    right: Expression;\n    body: Statement;\n}\n\nexport interface ImportDeclaration extends Node {\n    type: \"ImportDeclaration\";\n    specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>;\n    source: StringLiteral;\n}\n\nexport interface ImportDefaultSpecifier extends Node {\n    type: \"ImportDefaultSpecifier\";\n    local: Identifier;\n}\n\nexport interface ImportNamespaceSpecifier extends Node {\n    type: \"ImportNamespaceSpecifier\";\n    local: Identifier;\n}\n\nexport interface ImportSpecifier extends Node {\n    type: \"ImportSpecifier\";\n    local: Identifier;\n    imported: Identifier;\n}\n\nexport interface MetaProperty extends Node {\n    type: \"MetaProperty\";\n    meta: Identifier;\n    property: Identifier;\n}\n\nexport interface ClassMethod extends Node {\n    type: \"ClassMethod\";\n    key: Expression;\n    value?: FunctionExpression;\n    kind: \"constructor\" | \"method\" | \"get\" | \"set\";\n    computed: boolean;\n    static: boolean;\n    decorators?: Decorator[];\n    id: Identifier;\n    params: LVal[];\n    body: BlockStatement;\n    generator: boolean;\n    async: boolean;\n    expression: boolean;\n    returnType?: TypeAnnotation;\n    typeParameters?: TypeParameterDeclaration;\n}\n\n// See: https://github.com/babel/babel/blob/master/doc/ast/spec.md#objectpattern\nexport interface AssignmentProperty extends Node {\n    type: \"ObjectProperty\";\n    key: Expression;\n    computed: boolean;\n    value: Pattern;\n    decorators?: Decorator[];\n    shorthand: boolean;\n}\n\nexport interface ObjectPattern extends Node {\n    type: \"ObjectPattern\";\n    properties: Array<AssignmentProperty | RestProperty>;\n    typeAnnotation?: TypeAnnotation;\n}\n\nexport interface SpreadElement extends Node {\n    type: \"SpreadElement\";\n    argument: Expression;\n}\n\nexport interface Super extends Node {\n    type: \"Super\";\n}\n\nexport interface TaggedTemplateExpression extends Node {\n    type: \"TaggedTemplateExpression\";\n    tag: Expression;\n    quasi: TemplateLiteral;\n}\n\nexport interface TemplateElement extends Node {\n    type: \"TemplateElement\";\n    tail: boolean;\n    value: {\n        cooked: string;\n        raw: string;\n    };\n}\n\nexport interface TemplateLiteral extends Node {\n    type: \"TemplateLiteral\";\n    quasis: TemplateElement[];\n    expressions: Expression[];\n}\n\nexport interface YieldExpression extends Node {\n    type: \"YieldExpression\";\n    argument: Expression;\n    delegate: boolean;\n}\n\nexport interface AnyTypeAnnotation extends Node {\n    type: \"AnyTypeAnnotation\";\n}\n\nexport interface ArrayTypeAnnotation extends Node {\n    type: \"ArrayTypeAnnotation\";\n    elementType: FlowTypeAnnotation;\n}\n\nexport interface BooleanTypeAnnotation extends Node {\n    type: \"BooleanTypeAnnotation\";\n}\n\nexport interface BooleanLiteralTypeAnnotation extends Node {\n    type: \"BooleanLiteralTypeAnnotation\";\n}\n\nexport interface NullLiteralTypeAnnotation extends Node {\n    type: \"NullLiteralTypeAnnotation\";\n}\n\nexport interface ClassImplements extends Node {\n    type: \"ClassImplements\";\n    id: Identifier;\n    typeParameters: TypeParameterInstantiation;\n}\n\nexport interface ClassProperty extends Node {\n    type: \"ClassProperty\";\n    key: Identifier;\n    value: Expression;\n    decorators?: Decorator[];\n    typeAnnotation?: TypeAnnotation;\n}\n\nexport interface DeclareClass extends Node {\n    type: \"DeclareClass\";\n    id: Identifier;\n    typeParameters: TypeParameterDeclaration;\n    extends: InterfaceExtends[];\n    body: ObjectTypeAnnotation;\n}\n\nexport interface DeclareFunction extends Node {\n    type: \"DeclareFunction\";\n    id: Identifier;\n}\n\nexport interface DeclareInterface extends Node {\n    type: \"DeclareInterface\";\n    id: Identifier;\n    typeParameters: TypeParameterDeclaration;\n    extends: InterfaceExtends[];\n    body: ObjectTypeAnnotation;\n}\n\nexport interface DeclareModule extends Node {\n    type: \"DeclareModule\";\n    id: StringLiteral | Identifier;\n    body: BlockStatement;\n}\n\nexport interface DeclareTypeAlias extends Node {\n    type: \"DeclareTypeAlias\";\n    id: Identifier;\n    typeParameters: TypeParameterDeclaration;\n    right: FlowTypeAnnotation;\n}\n\nexport interface DeclareVariable extends Node {\n    type: \"DeclareVariable\";\n    id: Identifier;\n}\n\nexport interface ExistentialTypeParam extends Node {\n    type: \"ExistentialTypeParam\";\n}\n\nexport interface FunctionTypeAnnotation extends Node {\n    type: \"FunctionTypeAnnotation\";\n    typeParameters: TypeParameterDeclaration;\n    params: FunctionTypeParam[];\n    rest: FunctionTypeParam;\n    returnType: FlowTypeAnnotation;\n}\n\nexport interface FunctionTypeParam extends Node {\n    type: \"FunctionTypeParam\";\n    name: Identifier;\n    typeAnnotation: FlowTypeAnnotation;\n}\n\nexport interface GenericTypeAnnotation extends Node {\n    type: \"GenericTypeAnnotation\";\n    id: Identifier;\n    typeParameters: TypeParameterInstantiation;\n}\n\nexport interface InterfaceExtends extends Node {\n    type: \"InterfaceExtends\";\n    id: Identifier;\n    typeParameters: TypeParameterInstantiation;\n}\n\nexport interface InterfaceDeclaration extends Node {\n    type: \"InterfaceDeclaration\";\n    id: Identifier;\n    typeParameters: TypeParameterDeclaration;\n    extends: InterfaceExtends[];\n    mixins?: any[];\n    body: ObjectTypeAnnotation;\n}\n\nexport interface IntersectionTypeAnnotation extends Node {\n    type: \"IntersectionTypeAnnotation\";\n    types: FlowTypeAnnotation[];\n}\n\nexport interface MixedTypeAnnotation extends Node {\n    type: \"MixedTypeAnnotation\";\n}\n\nexport interface NullableTypeAnnotation extends Node {\n    type: \"NullableTypeAnnotation\";\n    typeAnnotation: FlowTypeAnnotation;\n}\n\nexport interface NumericLiteralTypeAnnotation extends Node {\n    type: \"NumericLiteralTypeAnnotation\";\n}\n\nexport interface NumberTypeAnnotation extends Node {\n    type: \"NumberTypeAnnotation\";\n}\n\nexport interface StringLiteralTypeAnnotation extends Node {\n    type: \"StringLiteralTypeAnnotation\";\n}\n\nexport interface StringTypeAnnotation extends Node {\n    type: \"StringTypeAnnotation\";\n}\n\nexport interface ThisTypeAnnotation extends Node {\n    type: \"ThisTypeAnnotation\";\n}\n\nexport interface TupleTypeAnnotation extends Node {\n    type: \"TupleTypeAnnotation\";\n    types: FlowTypeAnnotation[];\n}\n\nexport interface TypeofTypeAnnotation extends Node {\n    type: \"TypeofTypeAnnotation\";\n    argument: FlowTypeAnnotation;\n}\n\nexport interface TypeAlias extends Node {\n    type: \"TypeAlias\";\n    id: Identifier;\n    typeParameters: TypeParameterDeclaration;\n    right: FlowTypeAnnotation;\n}\n\nexport interface TypeAnnotation extends Node {\n    type: \"TypeAnnotation\";\n    typeAnnotation: FlowTypeAnnotation;\n}\n\nexport interface TypeCastExpression extends Node {\n    type: \"TypeCastExpression\";\n    expression: Expression;\n    typeAnnotation: FlowTypeAnnotation;\n}\n\nexport interface TypeParameter extends Node {\n    type: \"TypeParameterDeclaration\";\n    bound: TypeAnnotation | null;\n    default: Flow | null;\n    name: string | null;\n}\n\nexport interface TypeParameterDeclaration extends Node {\n    type: \"TypeParameterDeclaration\";\n    params: Identifier[];\n}\n\nexport interface TypeParameterInstantiation extends Node {\n    type: \"TypeParameterInstantiation\";\n    params: FlowTypeAnnotation[];\n}\n\nexport interface ObjectTypeAnnotation extends Node {\n    type: \"ObjectTypeAnnotation\";\n    properties: ObjectTypeProperty[];\n    indexers: ObjectTypeIndexer[];\n    callProperties: ObjectTypeCallProperty[];\n}\n\nexport interface ObjectTypeCallProperty extends Node {\n    type: \"ObjectTypeCallProperty\";\n    value: FlowTypeAnnotation;\n}\n\nexport interface ObjectTypeIndexer extends Node {\n    type: \"ObjectTypeIndexer\";\n    id: Expression;\n    key: FlowTypeAnnotation;\n    value: FlowTypeAnnotation;\n}\n\nexport interface ObjectTypeProperty extends Node {\n    type: \"ObjectTypeProperty\";\n    key: Expression;\n    value: FlowTypeAnnotation;\n}\n\nexport interface QualifiedTypeIdentifier extends Node {\n    type: \"QualifiedTypeIdentifier\";\n    id: Identifier;\n    qualification: Identifier | QualifiedTypeIdentifier;\n}\n\nexport interface UnionTypeAnnotation extends Node {\n    type: \"UnionTypeAnnotation\";\n    types: FlowTypeAnnotation[];\n}\n\nexport interface VoidTypeAnnotation extends Node {\n    type: \"VoidTypeAnnotation\";\n}\n\nexport interface JSXAttribute extends Node {\n    type: \"JSXAttribute\";\n    name: JSXIdentifier | JSXNamespacedName;\n    value: JSXElement | StringLiteral | JSXExpressionContainer;\n}\n\nexport interface JSXClosingElement extends Node {\n    type: \"JSXClosingElement\";\n    name: JSXIdentifier | JSXMemberExpression;\n}\n\nexport interface JSXElement extends Node {\n    type: \"JSXElement\";\n    openingElement: JSXOpeningElement;\n    closingElement: JSXClosingElement;\n    children: Array<JSXElement | JSXExpressionContainer | JSXText>;\n    selfClosing?: boolean;\n}\n\nexport interface JSXEmptyExpression extends Node {\n    type: \"JSXEmptyExpression\";\n}\n\nexport interface JSXExpressionContainer extends Node {\n    type: \"JSXExpressionContainer\";\n    expression: Expression;\n}\n\nexport interface JSXIdentifier extends Node {\n    type: \"JSXIdentifier\";\n    name: string;\n}\n\nexport interface JSXMemberExpression extends Node {\n    type: \"JSXMemberExpression\";\n    object: JSXMemberExpression | JSXIdentifier;\n    property: JSXIdentifier;\n}\n\nexport interface JSXNamespacedName extends Node {\n    type: \"JSXNamespacedName\";\n    namespace: JSXIdentifier;\n    name: JSXIdentifier;\n}\n\nexport interface JSXOpeningElement extends Node {\n    type: \"JSXOpeningElement\";\n    name: JSXIdentifier | JSXMemberExpression;\n    selfClosing: boolean;\n    attributes: JSXAttribute[];\n}\n\nexport interface JSXSpreadAttribute extends Node {\n    type: \"JSXSpreadAttribute\";\n    argument: Expression;\n}\n\nexport interface JSXText extends Node {\n    type: \"JSXText\";\n    value: string;\n}\n\nexport interface Noop extends Node {\n    type: \"Noop\";\n}\n\nexport interface ParenthesizedExpression extends Node {\n    type: \"ParenthesizedExpression\";\n    expression: Expression;\n}\n\nexport interface AwaitExpression extends Node {\n    type: \"AwaitExpression\";\n    argument: Expression;\n}\n\nexport interface BindExpression extends Node {\n    type: \"BindExpression\";\n    object: Expression;\n    callee: Expression;\n}\n\nexport interface Decorator extends Node {\n    type: \"Decorator\";\n    expression: Expression;\n}\n\nexport interface DoExpression extends Node {\n    type: \"DoExpression\";\n    body: BlockStatement;\n}\n\nexport interface ExportDefaultSpecifier extends Node {\n    type: \"ExportDefaultSpecifier\";\n    exported: Identifier;\n}\n\nexport interface ExportNamespaceSpecifier extends Node {\n    type: \"ExportNamespaceSpecifier\";\n    exported: Identifier;\n}\n\nexport interface RestProperty extends Node {\n    type: \"RestProperty\";\n    argument: LVal;\n}\n\nexport interface SpreadProperty extends Node {\n    type: \"SpreadProperty\";\n    argument: Expression;\n}\n\nexport interface TSAnyKeyword extends Node {\n    type: \"TSAnyKeyword\";\n}\n\nexport interface TSArrayType extends Node {\n    type: \"TSArrayType\";\n    elementType: TSType;\n}\n\nexport interface TSAsExpression extends Node {\n    type: \"TSAsExpression\";\n    expression: Expression;\n    typeAnnotation: TSType;\n}\n\nexport interface TSBooleanKeyword extends Node {\n    type: \"TSBooleanKeyword\";\n}\n\nexport interface TSCallSignatureDeclaration extends Node {\n    type: \"TSCallSignatureDeclaration\";\n    typeParameters: TypeParameterDeclaration | null;\n    parameters: Array<Identifier | RestElement> | null;\n    typeAnnotation: TSTypeAnnotation | null;\n}\n\nexport interface TSConstructSignatureDeclaration extends Node {\n    type: \"TSConstructSignatureDeclaration\";\n    typeParameters: TypeParameterDeclaration | null;\n    parameters: Array<Identifier | RestElement> | null;\n    typeAnnotation: TSTypeAnnotation | null;\n}\n\nexport interface TSConstructorType extends Node {\n    type: \"TSConstructorType\";\n    typeParameters: TypeParameterDeclaration | null;\n    typeAnnotation: TSTypeAnnotation | null;\n    parameters: Array<Identifier | RestElement> | null;\n}\n\nexport interface TSDeclareFunction extends Node {\n    type: \"TSDeclareFunction\";\n    id: Identifier | null;\n    typeParameters: TypeParameterDeclaration | Noop | null;\n    params: LVal[];\n    returnType: TypeAnnotation | TSTypeAnnotation | Noop | null;\n    async: boolean;\n    declare: boolean | null;\n    generator: boolean;\n}\n\nexport interface TSDeclareMethod extends Node {\n    type: \"TSDeclareMethod\";\n    decorators: Decorator[] | null;\n    key: Expression;\n    typeParameters: TypeParameterDeclaration | Noop | null;\n    params: LVal[];\n    returnType: TypeAnnotation | TSTypeAnnotation | Noop | null;\n    abstract: boolean | null;\n    access: \"public\" | \"private\" | \"protected\" | null;\n    accessibility: \"public\" | \"private\" | \"protected\" | null;\n    async: boolean;\n    computed: boolean;\n    generator: boolean;\n    kind: \"get\" | \"set\" | \"method\" | \"constructor\";\n    optional: boolean | null;\n    static: boolean | null;\n}\n\nexport interface TSEnumDeclaration extends Node {\n    type: \"TSEnumDeclaration\";\n    id: Identifier;\n    members: TSEnumMember[];\n    const: boolean | null;\n    declare: boolean | null;\n    initializer: Expression | null;\n}\n\nexport interface TSEnumMember extends Node {\n    type: \"TSEnumMember\";\n    id: Identifier | StringLiteral;\n    initializer: Expression | null;\n}\n\nexport interface TSExportAssignment extends Node {\n    type: \"TSExportAssignment\";\n    expression: Expression;\n}\n\nexport interface TSExpressionWithTypeArguments extends Node {\n    type: \"TSExpressionWithTypeArguments\";\n    expression: TSEntityName;\n    typeParameters: TypeParameterInstantiation | null;\n}\n\nexport interface TSExternalModuleReference extends Node {\n    type: \"TSExternalModuleReference\";\n    expression: StringLiteral;\n}\n\nexport interface TSFunctionType extends Node {\n    type: \"TSFunctionType\";\n    typeParameters: TypeParameterDeclaration | null;\n    typeAnnotation: TSTypeAnnotation | null;\n    parameters: Array<Identifier | RestElement> | null;\n}\n\nexport interface TSImportEqualsDeclaration extends Node {\n    type: \"TSImportEqualsDeclaration\";\n    id: Identifier;\n    moduleReference: TSEntityName | TSExternalModuleReference;\n    isExport: boolean | null;\n}\n\nexport interface TSIndexSignature extends Node {\n    type: \"TSIndexSignature\";\n    parameters: Identifier[];\n    typeAnnotation: TSTypeAnnotation | null;\n    readonly: boolean | null;\n}\n\nexport interface TSIndexedAccessType extends Node {\n    type: \"TSIndexedAccessType\";\n    objectType: TSType;\n    indexType: TSType;\n}\n\nexport interface TSInterfaceBody extends Node {\n    type: \"TSInterfaceBody\";\n    body: TSTypeElement[];\n}\n\nexport interface TSInterfaceDeclaration extends Node {\n    type: \"TSInterfaceDeclaration\";\n    id: Identifier;\n    typeParameters: TypeParameterDeclaration | null;\n    extends: TSExpressionWithTypeArguments[] | null;\n    body: TSInterfaceBody;\n    declare: boolean | null;\n}\n\nexport interface TSIntersectionType extends Node {\n    type: \"TSIntersectionType\";\n    types: TSType[];\n}\n\nexport interface TSLiteralType extends Node {\n    type: \"TSLiteralType\";\n    literal: NumericLiteral | StringLiteral | BooleanLiteral;\n}\n\nexport interface TSMappedType extends Node {\n    type: \"TSMappedType\";\n    typeParameter: TypeParameter;\n    typeAnnotation: TSType | null;\n    optional: boolean | null;\n    readonly: boolean | null;\n}\n\nexport interface TSMethodSignature extends Node {\n    type: \"TSMethodSignature\";\n    key: Expression;\n    typeParameters: TypeParameterDeclaration | null;\n    parameters: Array<Identifier | RestElement> | null;\n    typeAnnotation: TSTypeAnnotation | null;\n    computed: boolean | null;\n    optional: boolean | null;\n}\n\nexport interface TSModuleBlock extends Node {\n    type: \"TSModuleBlock\";\n    body: Statement[];\n}\n\nexport interface TSModuleDeclaration extends Node {\n    type: \"TSModuleDeclaration\";\n    id: Identifier | StringLiteral;\n    body: TSModuleBlock | TSModuleDeclaration;\n    declare: boolean | null;\n    global: boolean | null;\n}\n\nexport interface TSNamespaceExportDeclaration extends Node {\n    type: \"TSNamespaceExportDeclaration\";\n    id: Identifier;\n}\n\nexport interface TSNeverKeyword extends Node {\n    type: \"TSNeverKeyword\";\n}\n\nexport interface TSNonNullExpression extends Node {\n    type: \"TSNonNullExpression\";\n    expression: Expression;\n}\n\nexport interface TSNullKeyword extends Node {\n    type: \"TSNullKeyword\";\n}\n\nexport interface TSNumberKeyword extends Node {\n    type: \"TSNumberKeyword\";\n}\n\nexport interface TSObjectKeyword extends Node {\n    type: \"TSObjectKeyword\";\n}\n\nexport interface TSParameterProperty extends Node {\n    type: \"TSParameterProperty\";\n    parameter: Identifier | AssignmentPattern;\n    accessibility: 'public' | 'private' | 'protected' | null;\n    readonly: boolean | null;\n}\n\nexport interface TSParenthesizedType extends Node {\n    type: \"TSParenthesizedType\";\n    typeAnnotation: TSType;\n}\n\nexport interface TSPropertySignature extends Node {\n    type: \"TSPropertySignature\";\n    key: Expression;\n    typeAnnotation: TSTypeAnnotation | null;\n    initializer: Expression | null;\n    computed: boolean | null;\n    optional: boolean | null;\n    readonly: boolean | null;\n}\n\nexport interface TSQualifiedName extends Node {\n    type: \"TSQualifiedName\";\n    left: TSEntityName;\n    right: Identifier;\n}\n\nexport interface TSStringKeyword extends Node {\n    type: \"TSStringKeyword\";\n}\n\nexport interface TSSymbolKeyword extends Node {\n    type: \"TSSymbolKeyword\";\n}\n\nexport interface TSThisType extends Node {\n    type: \"TSThisType\";\n}\n\nexport interface TSTupleType extends Node {\n    type: \"TSTupleType\";\n    elementTypes: TSType[];\n}\n\nexport interface TSTypeAliasDeclaration extends Node {\n    type: \"TSTypeAliasDeclaration\";\n    id: Identifier;\n    typeParameters: TypeParameterDeclaration | null;\n    typeAnnotation: TSType;\n    declare: boolean | null;\n}\n\nexport interface TSTypeAnnotation extends Node {\n    type: \"TSTypeAnnotation\";\n    typeAnnotation: TSType;\n}\n\nexport interface TSTypeAssertion extends Node {\n    type: \"TSTypeAssertion\";\n    typeAnnotation: TSType;\n    expression: Expression;\n}\n\nexport interface TSTypeLiteral extends Node {\n    type: \"TSTypeLiteral\";\n    members: TSTypeElement[];\n}\n\nexport interface TSTypeOperator extends Node {\n    type: \"TSTypeOperator\";\n    typeAnnotation: TSType;\n    operator: string | null;\n}\n\nexport interface TSTypeParameter extends Node {\n    type: \"TSTypeParameter\";\n    constraint: TSType | null;\n    default: TSType | null;\n    name: string | null;\n}\n\nexport interface TSTypeParameterDeclaration extends Node {\n    type: \"TSTypeParameterDeclaration\";\n    params: TSTypeParameter[];\n}\n\nexport interface TSTypeParameterInstantiation extends Node {\n    type: \"TSTypeParameterInstantiation\";\n    params: TSType[];\n}\n\nexport interface TSTypePredicate extends Node {\n    type: \"TSTypePredicate\";\n    parameterName: Identifier | TSThisType;\n    typeAnnotation: TSTypeAnnotation;\n}\n\nexport interface TSTypeQuery extends Node {\n    type: \"TSTypeQuery\";\n    exprName: TSEntityName;\n}\n\nexport interface TSTypeReference extends Node {\n    type: \"TSTypeReference\";\n    typeName: TSEntityName;\n    typeParameters: TypeParameterInstantiation | null;\n}\n\nexport interface TSUndefinedKeyword extends Node {\n    type: \"TSUndefinedKeyword\";\n}\n\nexport interface TSUnionType extends Node {\n    type: \"TSUnionType\";\n    types: TSType[];\n}\n\nexport interface TSVoidKeyword extends Node {\n    type: \"TSVoidKeyword\";\n}\n\nexport type Expression = ArrayExpression | AssignmentExpression | BinaryExpression | CallExpression\n    | ConditionalExpression | FunctionExpression | Identifier | StringLiteral | NumericLiteral | BooleanLiteral\n    | NullLiteral | RegExpLiteral | LogicalExpression | MemberExpression | NewExpression | ObjectExpression\n    | SequenceExpression | ThisExpression | UnaryExpression | UpdateExpression | ArrowFunctionExpression\n    | ClassExpression | MetaProperty | Super | TaggedTemplateExpression | TemplateLiteral | YieldExpression\n    | TypeCastExpression | JSXElement | JSXEmptyExpression | JSXIdentifier | JSXMemberExpression\n    | ParenthesizedExpression | AwaitExpression | BindExpression | DoExpression | TSAsExpression\n    | TSNonNullExpression | TSTypeAssertion;\n\nexport type Binary = BinaryExpression | LogicalExpression;\n\nexport type Scopable = BlockStatement | CatchClause | DoWhileStatement | ForInStatement | ForStatement\n    | FunctionDeclaration | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement\n    | ArrowFunctionExpression | ClassDeclaration | ClassExpression | ForOfStatement | ClassMethod;\n\nexport type BlockParent = BlockStatement | DoWhileStatement | ForInStatement | ForStatement | FunctionDeclaration\n    | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement | ArrowFunctionExpression\n    | ForOfStatement | ClassMethod;\n\nexport type Block = BlockStatement | Program;\n\nexport type Statement = BlockStatement | BreakStatement | ContinueStatement | DebuggerStatement | DoWhileStatement\n    | EmptyStatement | ExpressionStatement | ForInStatement | ForStatement | FunctionDeclaration | IfStatement\n    | LabeledStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | VariableDeclaration\n    | WhileStatement | WithStatement | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration\n    | ExportNamedDeclaration | ForOfStatement | ImportDeclaration | DeclareClass | DeclareFunction | DeclareInterface\n    | DeclareModule | DeclareTypeAlias | DeclareVariable | InterfaceDeclaration | TypeAlias | TSDeclareFunction\n    | TSEnumDeclaration | TSExportAssignment | TSImportEqualsDeclaration | TSInterfaceDeclaration\n    | TSModuleDeclaration | TSNamespaceExportDeclaration | TSTypeAliasDeclaration;\n\nexport type Terminatorless = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement | YieldExpression | AwaitExpression;\nexport type CompletionStatement = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement;\nexport type Conditional = ConditionalExpression | IfStatement;\nexport type Loop = DoWhileStatement | ForInStatement | ForStatement | WhileStatement | ForOfStatement;\nexport type While = DoWhileStatement | WhileStatement;\nexport type ExpressionWrapper = ExpressionStatement | TypeCastExpression | ParenthesizedExpression;\nexport type For = ForInStatement | ForStatement | ForOfStatement;\nexport type ForXStatement = ForInStatement | ForOfStatement;\nexport type Function = FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod;\nexport type FunctionParent = FunctionDeclaration | FunctionExpression | Program | ObjectMethod | ArrowFunctionExpression | ClassMethod;\nexport type Pureish = FunctionDeclaration | FunctionExpression | StringLiteral | NumericLiteral | BooleanLiteral | NullLiteral | ArrowFunctionExpression | ClassDeclaration | ClassExpression;\n\nexport type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration | ExportAllDeclaration\n    | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration | DeclareClass | DeclareFunction\n    | DeclareInterface | DeclareModule | DeclareTypeAlias | DeclareVariable | InterfaceDeclaration | TypeAlias\n    | TSDeclareFunction | TSEnumDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSTypeAliasDeclaration;\n\nexport type LVal = Identifier | MemberExpression | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern\n    | TSParameterProperty;\nexport type Literal = StringLiteral | NumericLiteral | BooleanLiteral | NullLiteral | RegExpLiteral | TemplateLiteral;\nexport type Immutable = StringLiteral | NumericLiteral | BooleanLiteral | NullLiteral | JSXAttribute | JSXClosingElement | JSXElement | JSXExpressionContainer | JSXOpeningElement;\nexport type UserWhitespacable = ObjectMethod | ObjectProperty | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeProperty;\nexport type Method = ObjectMethod | ClassMethod;\nexport type ObjectMember = ObjectMethod | ObjectProperty;\nexport type Property = ObjectProperty | ClassProperty;\nexport type UnaryLike = UnaryExpression | SpreadElement | RestProperty | SpreadProperty;\nexport type Pattern = AssignmentPattern | ArrayPattern | ObjectPattern;\nexport type Class = ClassDeclaration | ClassExpression;\nexport type ModuleDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration;\nexport type ExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration;\nexport type ModuleSpecifier = ExportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier;\n\nexport type Flow = AnyTypeAnnotation | ArrayTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation\n    | ClassImplements | ClassProperty | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule\n    | DeclareTypeAlias | DeclareVariable | ExistentialTypeParam | FunctionTypeAnnotation | FunctionTypeParam\n    | GenericTypeAnnotation | InterfaceExtends | InterfaceDeclaration | IntersectionTypeAnnotation\n    | MixedTypeAnnotation | NullableTypeAnnotation | NumericLiteralTypeAnnotation | NumberTypeAnnotation\n    | StringLiteralTypeAnnotation | StringTypeAnnotation | ThisTypeAnnotation | TupleTypeAnnotation\n    | TypeofTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameterDeclaration\n    | TypeParameterInstantiation | ObjectTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer\n    | ObjectTypeProperty | QualifiedTypeIdentifier | UnionTypeAnnotation | VoidTypeAnnotation;\n\nexport type FlowTypeAnnotation = AnyTypeAnnotation | ArrayTypeAnnotation | BooleanTypeAnnotation\n    | BooleanLiteralTypeAnnotation | FunctionTypeAnnotation | GenericTypeAnnotation | IntersectionTypeAnnotation\n    | MixedTypeAnnotation | NullableTypeAnnotation | NumericLiteralTypeAnnotation | NumberTypeAnnotation\n    | StringLiteralTypeAnnotation | StringTypeAnnotation | ThisTypeAnnotation | TupleTypeAnnotation\n    | TypeofTypeAnnotation | TypeAnnotation | ObjectTypeAnnotation | UnionTypeAnnotation | VoidTypeAnnotation;\n\nexport type FlowBaseAnnotation = AnyTypeAnnotation | BooleanTypeAnnotation | MixedTypeAnnotation | NumberTypeAnnotation | StringTypeAnnotation | ThisTypeAnnotation | VoidTypeAnnotation;\nexport type FlowDeclaration = DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareTypeAlias | DeclareVariable | InterfaceDeclaration | TypeAlias;\n\nexport type JSX = JSXAttribute | JSXClosingElement | JSXElement | JSXEmptyExpression | JSXExpressionContainer\n    | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXSpreadAttribute | JSXText;\n\nexport type TSType = TSAnyKeyword | TSArrayType | TSBooleanKeyword | TSConstructorType | TSExpressionWithTypeArguments\n    | TSFunctionType | TSIndexedAccessType | TSIntersectionType | TSLiteralType | TSMappedType | TSNeverKeyword\n    | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSParenthesizedType | TSStringKeyword | TSSymbolKeyword\n    | TSThisType | TSTupleType | TSTypeLiteral | TSTypeOperator | TSTypePredicate | TSTypeQuery | TSTypeReference\n    | TSUndefinedKeyword | TSUnionType | TSVoidKeyword;\n\nexport type TSEntityName = Identifier | TSQualifiedName;\n\nexport type TSTypeElement = TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSIndexSignature\n    | TSMethodSignature | TSPropertySignature;\n\nexport function arrayExpression(elements?: Array<Expression | SpreadElement>): ArrayExpression;\nexport function assignmentExpression(operator?: string, left?: LVal, right?: Expression): AssignmentExpression;\nexport function binaryExpression(\n    operator?: \"+\" | \"-\" | \"/\" | \"%\" | \"*\" | \"**\" | \"&\" | \"|\" | \">>\" | \">>>\" | \"<<\" | \"^\" | \"==\" | \"===\" | \"!=\" | \"!==\" | \"in\" | \"instanceof\" | \">\" | \"<\" | \">=\" | \"<=\",\n    left?: Expression,\n    right?: Expression\n): BinaryExpression;\nexport function directive(value?: DirectiveLiteral): Directive;\nexport function directiveLiteral(value?: string): DirectiveLiteral;\nexport function blockStatement(body?: Statement[], directives?: Directive[]): BlockStatement;\nexport function breakStatement(label?: Identifier): BreakStatement;\nexport function callExpression(callee?: Expression, _arguments?: Array<Expression | SpreadElement>): CallExpression;\nexport function catchClause(param?: Identifier, body?: BlockStatement): CatchClause;\nexport function conditionalExpression(test?: Expression, consequent?: Expression, alternate?: Expression): ConditionalExpression;\nexport function continueStatement(label?: Identifier): ContinueStatement;\nexport function debuggerStatement(): DebuggerStatement;\nexport function doWhileStatement(test?: Expression, body?: Statement): DoWhileStatement;\nexport function emptyStatement(): EmptyStatement;\nexport function expressionStatement(expression?: Expression): ExpressionStatement;\nexport function file(program?: Program, comments?: Comment[], tokens?: any[]): File;\nexport function forInStatement(left?: VariableDeclaration | LVal, right?: Expression, body?: Statement): ForInStatement;\nexport function forStatement(init?: VariableDeclaration | Expression, test?: Expression, update?: Expression, body?: Statement): ForStatement;\nexport function functionDeclaration(id?: Identifier, params?: LVal[], body?: BlockStatement, generator?: boolean, async?: boolean): FunctionDeclaration;\nexport function functionExpression(id?: Identifier, params?: LVal[], body?: BlockStatement, generator?: boolean, async?: boolean): FunctionExpression;\nexport function identifier(name?: string): Identifier;\nexport function ifStatement(test?: Expression, consequent?: Statement, alternate?: Statement): IfStatement;\nexport function labeledStatement(label?: Identifier, body?: Statement): LabeledStatement;\nexport function stringLiteral(value?: string): StringLiteral;\nexport function numericLiteral(value?: number): NumericLiteral;\nexport function nullLiteral(): NullLiteral;\nexport function booleanLiteral(value?: boolean): BooleanLiteral;\nexport function regExpLiteral(pattern?: string, flags?: string): RegExpLiteral;\nexport function logicalExpression(operator?: \"||\" | \"&&\", left?: Expression, right?: Expression): LogicalExpression;\nexport function memberExpression(object?: Expression | Super, property?: Expression, computed?: boolean): MemberExpression;\nexport function newExpression(callee?: Expression | Super, _arguments?: Array<Expression | SpreadElement>): NewExpression;\nexport function program(body?: Array<Statement | ModuleDeclaration>, directives?: Directive[]): Program;\nexport function objectExpression(properties?: Array<ObjectProperty | ObjectMethod | SpreadProperty>): ObjectExpression;\nexport function objectMethod(kind?: \"get\" | \"set\" | \"method\", key?: Expression, params?: LVal[], body?: BlockStatement, computed?: boolean): ObjectMethod;\nexport function objectProperty(key?: Expression, value?: Expression, computed?: boolean, shorthand?: boolean, decorators?: Decorator[]): ObjectProperty;\nexport function restElement(argument?: LVal, typeAnnotation?: TypeAnnotation): RestElement;\nexport function returnStatement(argument?: Expression): ReturnStatement;\nexport function sequenceExpression(expressions?: Expression[]): SequenceExpression;\nexport function switchCase(test?: Expression, consequent?: Statement[]): SwitchCase;\nexport function switchStatement(discriminant?: Expression, cases?: SwitchCase[]): SwitchStatement;\nexport function thisExpression(): ThisExpression;\nexport function throwStatement(argument?: Expression): ThrowStatement;\nexport function tryStatement(block?: BlockStatement, handler?: CatchClause, finalizer?: BlockStatement): TryStatement;\nexport function unaryExpression(operator?: \"void\" | \"delete\" | \"!\" | \"+\" | \"-\" | \"++\" | \"--\" | \"~\" | \"typeof\", argument?: Expression, prefix?: boolean): UnaryExpression;\nexport function updateExpression(operator?: \"++\" | \"--\", argument?: Expression, prefix?: boolean): UpdateExpression;\nexport function variableDeclaration(kind?: \"var\" | \"let\" | \"const\", declarations?: VariableDeclarator[]): VariableDeclaration;\nexport function variableDeclarator(id?: LVal, init?: Expression): VariableDeclarator;\nexport function whileStatement(test?: Expression, body?: BlockStatement | Statement): WhileStatement;\nexport function withStatement(object?: Expression, body?: BlockStatement | Statement): WithStatement;\nexport function assignmentPattern(left?: Identifier, right?: Expression): AssignmentPattern;\nexport function arrayPattern(elements?: Expression[], typeAnnotation?: TypeAnnotation): ArrayPattern;\nexport function arrowFunctionExpression(params?: LVal[], body?: BlockStatement | Expression, async?: boolean): ArrowFunctionExpression;\nexport function classBody(body?: Array<ClassMethod | ClassProperty>): ClassBody;\nexport function classDeclaration(id?: Identifier, superClass?: Expression, body?: ClassBody, decorators?: Decorator[]): ClassDeclaration;\nexport function classExpression(id?: Identifier, superClass?: Expression, body?: ClassBody, decorators?: Decorator[]): ClassExpression;\nexport function exportAllDeclaration(source?: StringLiteral): ExportAllDeclaration;\nexport function exportDefaultDeclaration(declaration?: FunctionDeclaration | ClassDeclaration | Expression): ExportDefaultDeclaration;\nexport function exportNamedDeclaration(declaration?: Declaration, specifiers?: ExportSpecifier[], source?: StringLiteral): ExportNamedDeclaration;\nexport function exportSpecifier(local?: Identifier, exported?: Identifier): ExportSpecifier;\nexport function forOfStatement(left?: VariableDeclaration | LVal, right?: Expression, body?: Statement): ForOfStatement;\nexport function importDeclaration(specifiers?: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>, source?: StringLiteral): ImportDeclaration;\nexport function importDefaultSpecifier(local?: Identifier): ImportDefaultSpecifier;\nexport function importNamespaceSpecifier(local?: Identifier): ImportNamespaceSpecifier;\nexport function importSpecifier(local?: Identifier, imported?: Identifier): ImportSpecifier;\nexport function metaProperty(meta?: string, property?: string): MetaProperty;\nexport function classMethod(kind?: \"constructor\" | \"method\" | \"get\" | \"set\", key?: Expression, params?: LVal[], body?: BlockStatement, computed?: boolean, _static?: boolean): ClassMethod;\nexport function objectPattern(properties?: Array<AssignmentProperty | RestProperty>, typeAnnotation?: TypeAnnotation): ObjectPattern;\nexport function spreadElement(argument?: Expression): SpreadElement;\nexport function taggedTemplateExpression(tag?: Expression, quasi?: TemplateLiteral): TaggedTemplateExpression;\nexport function templateElement(value?: { cooked?: string; raw?: string; }, tail?: boolean): TemplateElement;\nexport function templateLiteral(quasis?: TemplateElement[], expressions?: Expression[]): TemplateLiteral;\nexport function yieldExpression(argument?: Expression, delegate?: boolean): YieldExpression;\nexport function anyTypeAnnotation(): AnyTypeAnnotation;\nexport function arrayTypeAnnotation(elementType?: FlowTypeAnnotation): ArrayTypeAnnotation;\nexport function booleanTypeAnnotation(): BooleanTypeAnnotation;\nexport function booleanLiteralTypeAnnotation(): BooleanLiteralTypeAnnotation;\nexport function nullLiteralTypeAnnotation(): NullLiteralTypeAnnotation;\nexport function classImplements(id?: Identifier, typeParameters?: TypeParameterInstantiation): ClassImplements;\nexport function classProperty(key?: Identifier, value?: Expression, typeAnnotation?: TypeAnnotation, decorators?: Decorator[]): ClassProperty;\nexport function declareClass(id?: Identifier, typeParameters?: TypeParameterDeclaration, _extends?: InterfaceExtends[], body?: ObjectTypeAnnotation): DeclareClass;\nexport function declareFunction(id?: Identifier): DeclareFunction;\nexport function declareInterface(id?: Identifier, typeParameters?: TypeParameterDeclaration, _extends?: InterfaceExtends[], body?: ObjectTypeAnnotation): DeclareInterface;\nexport function declareModule(id?: StringLiteral | Identifier, body?: BlockStatement): DeclareModule;\nexport function declareTypeAlias(id?: Identifier, typeParameters?: TypeParameterDeclaration, right?: FlowTypeAnnotation): DeclareTypeAlias;\nexport function declareVariable(id?: Identifier): DeclareVariable;\nexport function existentialTypeParam(): ExistentialTypeParam;\nexport function functionTypeAnnotation(typeParameters?: TypeParameterDeclaration, params?: FunctionTypeParam[], rest?: FunctionTypeParam, returnType?: FlowTypeAnnotation): FunctionTypeAnnotation;\nexport function functionTypeParam(name?: Identifier, typeAnnotation?: FlowTypeAnnotation): FunctionTypeParam;\nexport function genericTypeAnnotation(id?: Identifier, typeParameters?: TypeParameterInstantiation): GenericTypeAnnotation;\nexport function interfaceExtends(id?: Identifier, typeParameters?: TypeParameterInstantiation): InterfaceExtends;\nexport function interfaceDeclaration(id?: Identifier, typeParameters?: TypeParameterDeclaration, _extends?: InterfaceExtends[], body?: ObjectTypeAnnotation): InterfaceDeclaration;\nexport function intersectionTypeAnnotation(types?: FlowTypeAnnotation[]): IntersectionTypeAnnotation;\nexport function mixedTypeAnnotation(): MixedTypeAnnotation;\nexport function nullableTypeAnnotation(typeAnnotation?: FlowTypeAnnotation): NullableTypeAnnotation;\nexport function numericLiteralTypeAnnotation(): NumericLiteralTypeAnnotation;\nexport function numberTypeAnnotation(): NumberTypeAnnotation;\nexport function stringLiteralTypeAnnotation(): StringLiteralTypeAnnotation;\nexport function stringTypeAnnotation(): StringTypeAnnotation;\nexport function thisTypeAnnotation(): ThisTypeAnnotation;\nexport function tupleTypeAnnotation(types?: FlowTypeAnnotation[]): TupleTypeAnnotation;\nexport function typeofTypeAnnotation(argument?: FlowTypeAnnotation): TypeofTypeAnnotation;\nexport function typeAlias(id?: Identifier, typeParameters?: TypeParameterDeclaration, right?: FlowTypeAnnotation): TypeAlias;\nexport function typeAnnotation(typeAnnotation?: FlowTypeAnnotation): TypeAnnotation;\nexport function typeCastExpression(expression?: Expression, typeAnnotation?: FlowTypeAnnotation): TypeCastExpression;\nexport function typeParameter(bound?: TypeAnnotation, default_?: Flow): TypeParameter;\nexport function typeParameterDeclaration(params?: Identifier[]): TypeParameterDeclaration;\nexport function typeParameterInstantiation(params?: FlowTypeAnnotation[]): TypeParameterInstantiation;\nexport function objectTypeAnnotation(properties?: ObjectTypeProperty[], indexers?: ObjectTypeIndexer[], callProperties?: ObjectTypeCallProperty[]): ObjectTypeAnnotation;\nexport function objectTypeCallProperty(value?: FlowTypeAnnotation): ObjectTypeCallProperty;\nexport function objectTypeIndexer(id?: Expression, key?: FlowTypeAnnotation, value?: FlowTypeAnnotation): ObjectTypeIndexer;\nexport function objectTypeProperty(key?: Expression, value?: FlowTypeAnnotation): ObjectTypeProperty;\nexport function qualifiedTypeIdentifier(id?: Identifier, qualification?: Identifier | QualifiedTypeIdentifier): QualifiedTypeIdentifier;\nexport function unionTypeAnnotation(types?: FlowTypeAnnotation[]): UnionTypeAnnotation;\nexport function voidTypeAnnotation(): VoidTypeAnnotation;\nexport function jSXAttribute(name?: JSXIdentifier | JSXNamespacedName, value?: JSXElement | StringLiteral | JSXExpressionContainer): JSXAttribute;\nexport function jSXClosingElement(name?: JSXIdentifier | JSXMemberExpression): JSXClosingElement;\nexport function jSXElement(openingElement?: JSXOpeningElement, closingElement?: JSXClosingElement, children?: Array<JSXElement | JSXExpressionContainer | JSXText>, selfClosing?: boolean): JSXElement;\nexport function jSXEmptyExpression(): JSXEmptyExpression;\nexport function jSXExpressionContainer(expression?: Expression): JSXExpressionContainer;\nexport function jSXIdentifier(name?: string): JSXIdentifier;\nexport function jSXMemberExpression(object?: JSXMemberExpression | JSXIdentifier, property?: JSXIdentifier): JSXMemberExpression;\nexport function jSXNamespacedName(namespace?: JSXIdentifier, name?: JSXIdentifier): JSXNamespacedName;\nexport function jSXOpeningElement(name?: JSXIdentifier | JSXMemberExpression, attributes?: JSXAttribute[], selfClosing?: boolean): JSXOpeningElement;\nexport function jSXSpreadAttribute(argument?: Expression): JSXSpreadAttribute;\nexport function jSXText(value?: string): JSXText;\nexport function noop(): Noop;\nexport function parenthesizedExpression(expression?: Expression): ParenthesizedExpression;\nexport function awaitExpression(argument?: Expression): AwaitExpression;\nexport function bindExpression(object?: Expression, callee?: Expression): BindExpression;\nexport function decorator(expression?: Expression): Decorator;\nexport function doExpression(body?: BlockStatement): DoExpression;\nexport function exportDefaultSpecifier(exported?: Identifier): ExportDefaultSpecifier;\nexport function exportNamespaceSpecifier(exported?: Identifier): ExportNamespaceSpecifier;\nexport function restProperty(argument?: LVal): RestProperty;\nexport function spreadProperty(argument?: Expression): SpreadProperty;\n\nexport function TSAnyKeyword(): TSAnyKeyword;\nexport function TSArrayType(elementType: TSType): TSArrayType;\nexport function TSAsExpression(expression: Expression, typeAnnotation: TSType): TSAsExpression;\nexport function TSBooleanKeyword(): TSBooleanKeyword;\nexport function TSCallSignatureDeclaration(typeParameters?: TypeParameterDeclaration, parameters?: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation): TSCallSignatureDeclaration;\nexport function TSConstructSignatureDeclaration(typeParameters?: TypeParameterDeclaration, parameters?: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation): TSTypeElement;\nexport function TSConstructorType(typeParameters?: TypeParameterDeclaration, typeAnnotation?: TSTypeAnnotation): TSConstructorType;\nexport function TSDeclareFunction(\n    id: Identifier | undefined | null,\n    typeParameters: TypeParameterDeclaration | Noop | undefined | null,\n    params: LVal[],\n    returnType: TypeAnnotation | TSTypeAnnotation | Noop | undefined | null): TSDeclareFunction;\nexport function TSDeclareMethod(\n    decorators: Decorator[] | undefined | null,\n    key: Expression,\n    typeParameters: TypeParameterDeclaration | Noop | undefined | null,\n    params: LVal[],\n    returnType?: TypeAnnotation | TSTypeAnnotation | Noop): TSDeclareMethod;\nexport function TSEnumDeclaration(id: Identifier, members: TSEnumMember[]): TSEnumDeclaration;\nexport function TSEnumMember(id: Identifier | StringLiteral, initializer?: Expression): TSEnumMember;\nexport function TSExportAssignment(expression: Expression): TSExportAssignment;\nexport function TSExpressionWithTypeArguments(expression: TSEntityName, typeParameters?: TypeParameterInstantiation): TSExpressionWithTypeArguments;\nexport function TSExternalModuleReference(expression: StringLiteral): TSExternalModuleReference;\nexport function TSFunctionType(typeParameters?: TypeParameterDeclaration, typeAnnotation?: TSTypeAnnotation): TSFunctionType;\nexport function TSImportEqualsDeclaration(id: Identifier, moduleReference: TSEntityName | TSExternalModuleReference): TSImportEqualsDeclaration;\nexport function TSIndexSignature(parameters: Identifier[], typeAnnotation?: TSTypeAnnotation): TSIndexSignature;\nexport function TSIndexedAccessType(objectType: TSType, indexType: TSType): TSIndexedAccessType;\nexport function TSInterfaceBody(body: TSTypeElement[]): TSInterfaceBody;\nexport function TSInterfaceDeclaration(\n    id: Identifier,\n    typeParameters: TypeParameterDeclaration | undefined | null,\n    extends_: TSExpressionWithTypeArguments[] | undefined | null,\n    body: TSInterfaceBody): TSInterfaceDeclaration;\nexport function TSIntersectionType(types: TSType[]): TSIntersectionType;\nexport function TSLiteralType(literal: NumericLiteral | StringLiteral | BooleanLiteral): TSLiteralType;\nexport function TSMappedType(typeParameter: TypeParameter, typeAnnotation?: TSType): TSMappedType;\nexport function TSMethodSignature(key: Expression, typeParameters?: TypeParameterDeclaration, parameters?: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation): TSMethodSignature;\nexport function TSModuleBlock(body: Statement[]): TSModuleBlock;\nexport function TSModuleDeclaration(id: Identifier | StringLiteral, body: TSModuleBlock | TSModuleDeclaration): TSModuleDeclaration;\nexport function TSNamespaceExportDeclaration(id: Identifier): TSNamespaceExportDeclaration;\nexport function TSNeverKeyword(): TSNeverKeyword;\nexport function TSNonNullExpression(expression: Expression): TSNonNullExpression;\nexport function TSNullKeyword(): TSNullKeyword;\nexport function TSNumberKeyword(): TSNumberKeyword;\nexport function TSObjectKeyword(): TSObjectKeyword;\nexport function TSParameterProperty(parameter: Identifier | AssignmentPattern): TSParameterProperty;\nexport function TSParenthesizedType(typeAnnotation: TSType): TSParenthesizedType;\nexport function TSPropertySignature(key: Expression, typeAnnotation?: TSTypeAnnotation, initializer?: Expression): TSPropertySignature;\nexport function TSQualifiedName(left: TSEntityName, right: Identifier): TSQualifiedName;\nexport function TSStringKeyword(): TSStringKeyword;\nexport function TSSymbolKeyword(): TSSymbolKeyword;\nexport function TSThisType(): TSThisType;\nexport function TSTupleType(elementTypes: TSType[]): TSTupleType;\nexport function TSTypeAliasDeclaration(id: Identifier, typeParameters: TypeParameterDeclaration | undefined | null, typeAnnotation: TSType): TSTypeAliasDeclaration;\nexport function TSTypeAnnotation(typeAnnotation: TSType): TSTypeAnnotation;\nexport function TSTypeAssertion(typeAnnotation: TSType, expression: Expression): TSTypeAssertion;\nexport function TSTypeLiteral(members: TSTypeElement[]): TSTypeLiteral;\nexport function TSTypeOperator(typeAnnotation: TSType): TSTypeOperator;\nexport function TSTypeParameter(constraint?: TSType, default_?: TSType): TSTypeParameter;\nexport function TSTypeParameterDeclaration(params: TSTypeParameter[]): TSTypeParameterDeclaration;\nexport function TSTypeParameterInstantiation(params: TSType[]): TSTypeParameterInstantiation;\nexport function TSTypePredicate(parameterName: Identifier | TSThisType, typeAnnotation: TSTypeAnnotation): TSTypePredicate;\nexport function TSTypeQuery(exprName: TSEntityName): TSTypeQuery;\nexport function TSTypeReference(typeName: TSEntityName, typeParameters?: TypeParameterInstantiation): TSTypeReference;\nexport function TSUndefinedKeyword(): TSUndefinedKeyword;\nexport function TSUnionType(types: TSType[]): TSUnionType;\nexport function TSVoidKeyword(): TSVoidKeyword;\n\nexport function isArrayExpression(node: object, opts?: object): node is ArrayExpression;\nexport function isAssignmentExpression(node: object, opts?: object): node is AssignmentExpression;\nexport function isBinaryExpression(node: object, opts?: object): node is BinaryExpression;\nexport function isDirective(node: object, opts?: object): node is Directive;\nexport function isDirectiveLiteral(node: object, opts?: object): node is DirectiveLiteral;\nexport function isBlockStatement(node: object, opts?: object): node is BlockStatement;\nexport function isBreakStatement(node: object, opts?: object): node is BreakStatement;\nexport function isCallExpression(node: object, opts?: object): node is CallExpression;\nexport function isCatchClause(node: object, opts?: object): node is CatchClause;\nexport function isConditionalExpression(node: object, opts?: object): node is ConditionalExpression;\nexport function isContinueStatement(node: object, opts?: object): node is ContinueStatement;\nexport function isDebuggerStatement(node: object, opts?: object): node is DebuggerStatement;\nexport function isDoWhileStatement(node: object, opts?: object): node is DoWhileStatement;\nexport function isEmptyStatement(node: object, opts?: object): node is EmptyStatement;\nexport function isExpressionStatement(node: object, opts?: object): node is ExpressionStatement;\nexport function isFile(node: object, opts?: object): node is File;\nexport function isForInStatement(node: object, opts?: object): node is ForInStatement;\nexport function isForStatement(node: object, opts?: object): node is ForStatement;\nexport function isFunctionDeclaration(node: object, opts?: object): node is FunctionDeclaration;\nexport function isFunctionExpression(node: object, opts?: object): node is FunctionExpression;\nexport function isIdentifier(node: object, opts?: object): node is Identifier;\nexport function isIfStatement(node: object, opts?: object): node is IfStatement;\nexport function isLabeledStatement(node: object, opts?: object): node is LabeledStatement;\nexport function isStringLiteral(node: object, opts?: object): node is StringLiteral;\nexport function isNumericLiteral(node: object, opts?: object): node is NumericLiteral;\nexport function isNullLiteral(node: object, opts?: object): node is NullLiteral;\nexport function isBooleanLiteral(node: object, opts?: object): node is BooleanLiteral;\nexport function isRegExpLiteral(node: object, opts?: object): node is RegExpLiteral;\nexport function isLogicalExpression(node: object, opts?: object): node is LogicalExpression;\nexport function isMemberExpression(node: object, opts?: object): node is MemberExpression;\nexport function isNewExpression(node: object, opts?: object): node is NewExpression;\nexport function isProgram(node: object, opts?: object): node is Program;\nexport function isObjectExpression(node: object, opts?: object): node is ObjectExpression;\nexport function isObjectMethod(node: object, opts?: object): node is ObjectMethod;\nexport function isObjectProperty(node: object, opts?: object): node is ObjectProperty;\nexport function isRestElement(node: object, opts?: object): node is RestElement;\nexport function isReturnStatement(node: object, opts?: object): node is ReturnStatement;\nexport function isSequenceExpression(node: object, opts?: object): node is SequenceExpression;\nexport function isSwitchCase(node: object, opts?: object): node is SwitchCase;\nexport function isSwitchStatement(node: object, opts?: object): node is SwitchStatement;\nexport function isThisExpression(node: object, opts?: object): node is ThisExpression;\nexport function isThrowStatement(node: object, opts?: object): node is ThrowStatement;\nexport function isTryStatement(node: object, opts?: object): node is TryStatement;\nexport function isUnaryExpression(node: object, opts?: object): node is UnaryExpression;\nexport function isUpdateExpression(node: object, opts?: object): node is UpdateExpression;\nexport function isVariableDeclaration(node: object, opts?: object): node is VariableDeclaration;\nexport function isVariableDeclarator(node: object, opts?: object): node is VariableDeclarator;\nexport function isWhileStatement(node: object, opts?: object): node is WhileStatement;\nexport function isWithStatement(node: object, opts?: object): node is WithStatement;\nexport function isAssignmentPattern(node: object, opts?: object): node is AssignmentPattern;\nexport function isArrayPattern(node: object, opts?: object): node is ArrayPattern;\nexport function isArrowFunctionExpression(node: object, opts?: object): node is ArrowFunctionExpression;\nexport function isClassBody(node: object, opts?: object): node is ClassBody;\nexport function isClassDeclaration(node: object, opts?: object): node is ClassDeclaration;\nexport function isClassExpression(node: object, opts?: object): node is ClassExpression;\nexport function isExportAllDeclaration(node: object, opts?: object): node is ExportAllDeclaration;\nexport function isExportDefaultDeclaration(node: object, opts?: object): node is ExportDefaultDeclaration;\nexport function isExportNamedDeclaration(node: object, opts?: object): node is ExportNamedDeclaration;\nexport function isExportSpecifier(node: object, opts?: object): node is ExportSpecifier;\nexport function isForOfStatement(node: object, opts?: object): node is ForOfStatement;\nexport function isImportDeclaration(node: object, opts?: object): node is ImportDeclaration;\nexport function isImportDefaultSpecifier(node: object, opts?: object): node is ImportDefaultSpecifier;\nexport function isImportNamespaceSpecifier(node: object, opts?: object): node is ImportNamespaceSpecifier;\nexport function isImportSpecifier(node: object, opts?: object): node is ImportSpecifier;\nexport function isMetaProperty(node: object, opts?: object): node is MetaProperty;\nexport function isClassMethod(node: object, opts?: object): node is ClassMethod;\nexport function isObjectPattern(node: object, opts?: object): node is ObjectPattern;\nexport function isSpreadElement(node: object, opts?: object): node is SpreadElement;\nexport function isSuper(node: object, opts?: object): node is Super;\nexport function isTaggedTemplateExpression(node: object, opts?: object): node is TaggedTemplateExpression;\nexport function isTemplateElement(node: object, opts?: object): node is TemplateElement;\nexport function isTemplateLiteral(node: object, opts?: object): node is TemplateLiteral;\nexport function isYieldExpression(node: object, opts?: object): node is YieldExpression;\nexport function isAnyTypeAnnotation(node: object, opts?: object): node is AnyTypeAnnotation;\nexport function isArrayTypeAnnotation(node: object, opts?: object): node is ArrayTypeAnnotation;\nexport function isBooleanTypeAnnotation(node: object, opts?: object): node is BooleanTypeAnnotation;\nexport function isBooleanLiteralTypeAnnotation(node: object, opts?: object): node is BooleanLiteralTypeAnnotation;\nexport function isNullLiteralTypeAnnotation(node: object, opts?: object): node is NullLiteralTypeAnnotation;\nexport function isClassImplements(node: object, opts?: object): node is ClassImplements;\nexport function isClassProperty(node: object, opts?: object): node is ClassProperty;\nexport function isDeclareClass(node: object, opts?: object): node is DeclareClass;\nexport function isDeclareFunction(node: object, opts?: object): node is DeclareFunction;\nexport function isDeclareInterface(node: object, opts?: object): node is DeclareInterface;\nexport function isDeclareModule(node: object, opts?: object): node is DeclareModule;\nexport function isDeclareTypeAlias(node: object, opts?: object): node is DeclareTypeAlias;\nexport function isDeclareVariable(node: object, opts?: object): node is DeclareVariable;\nexport function isExistentialTypeParam(node: object, opts?: object): node is ExistentialTypeParam;\nexport function isFunctionTypeAnnotation(node: object, opts?: object): node is FunctionTypeAnnotation;\nexport function isFunctionTypeParam(node: object, opts?: object): node is FunctionTypeParam;\nexport function isGenericTypeAnnotation(node: object, opts?: object): node is GenericTypeAnnotation;\nexport function isInterfaceExtends(node: object, opts?: object): node is InterfaceExtends;\nexport function isInterfaceDeclaration(node: object, opts?: object): node is InterfaceDeclaration;\nexport function isIntersectionTypeAnnotation(node: object, opts?: object): node is IntersectionTypeAnnotation;\nexport function isMixedTypeAnnotation(node: object, opts?: object): node is MixedTypeAnnotation;\nexport function isNullableTypeAnnotation(node: object, opts?: object): node is NullableTypeAnnotation;\nexport function isNumericLiteralTypeAnnotation(node: object, opts?: object): node is NumericLiteralTypeAnnotation;\nexport function isNumberTypeAnnotation(node: object, opts?: object): node is NumberTypeAnnotation;\nexport function isStringLiteralTypeAnnotation(node: object, opts?: object): node is StringLiteralTypeAnnotation;\nexport function isStringTypeAnnotation(node: object, opts?: object): node is StringTypeAnnotation;\nexport function isThisTypeAnnotation(node: object, opts?: object): node is ThisTypeAnnotation;\nexport function isTupleTypeAnnotation(node: object, opts?: object): node is TupleTypeAnnotation;\nexport function isTypeofTypeAnnotation(node: object, opts?: object): node is TypeofTypeAnnotation;\nexport function isTypeAlias(node: object, opts?: object): node is TypeAlias;\nexport function isTypeAnnotation(node: object, opts?: object): node is TypeAnnotation;\nexport function isTypeCastExpression(node: object, opts?: object): node is TypeCastExpression;\nexport function isTypeParameter(node: object, opts?: object): node is TypeParameter;\nexport function isTypeParameterDeclaration(node: object, opts?: object): node is TypeParameterDeclaration;\nexport function isTypeParameterInstantiation(node: object, opts?: object): node is TypeParameterInstantiation;\nexport function isObjectTypeAnnotation(node: object, opts?: object): node is ObjectTypeAnnotation;\nexport function isObjectTypeCallProperty(node: object, opts?: object): node is ObjectTypeCallProperty;\nexport function isObjectTypeIndexer(node: object, opts?: object): node is ObjectTypeIndexer;\nexport function isObjectTypeProperty(node: object, opts?: object): node is ObjectTypeProperty;\nexport function isQualifiedTypeIdentifier(node: object, opts?: object): node is QualifiedTypeIdentifier;\nexport function isUnionTypeAnnotation(node: object, opts?: object): node is UnionTypeAnnotation;\nexport function isVoidTypeAnnotation(node: object, opts?: object): node is VoidTypeAnnotation;\nexport function isJSXAttribute(node: object, opts?: object): node is JSXAttribute;\nexport function isJSXClosingElement(node: object, opts?: object): node is JSXClosingElement;\nexport function isJSXElement(node: object, opts?: object): node is JSXElement;\nexport function isJSXEmptyExpression(node: object, opts?: object): node is JSXEmptyExpression;\nexport function isJSXExpressionContainer(node: object, opts?: object): node is JSXExpressionContainer;\nexport function isJSXIdentifier(node: object, opts?: object): node is JSXIdentifier;\nexport function isJSXMemberExpression(node: object, opts?: object): node is JSXMemberExpression;\nexport function isJSXNamespacedName(node: object, opts?: object): node is JSXNamespacedName;\nexport function isJSXOpeningElement(node: object, opts?: object): node is JSXOpeningElement;\nexport function isJSXSpreadAttribute(node: object, opts?: object): node is JSXSpreadAttribute;\nexport function isJSXText(node: object, opts?: object): node is JSXText;\nexport function isNoop(node: object, opts?: object): node is Noop;\nexport function isParenthesizedExpression(node: object, opts?: object): node is ParenthesizedExpression;\nexport function isAwaitExpression(node: object, opts?: object): node is AwaitExpression;\nexport function isBindExpression(node: object, opts?: object): node is BindExpression;\nexport function isDecorator(node: object, opts?: object): node is Decorator;\nexport function isDoExpression(node: object, opts?: object): node is DoExpression;\nexport function isExportDefaultSpecifier(node: object, opts?: object): node is ExportDefaultSpecifier;\nexport function isExportNamespaceSpecifier(node: object, opts?: object): node is ExportNamespaceSpecifier;\nexport function isRestProperty(node: object, opts?: object): node is RestProperty;\nexport function isSpreadProperty(node: object, opts?: object): node is SpreadProperty;\nexport function isExpression(node: object, opts?: object): node is Expression;\nexport function isBinary(node: object, opts?: object): node is Binary;\nexport function isScopable(node: object, opts?: object): node is Scopable;\nexport function isBlockParent(node: object, opts?: object): node is BlockParent;\nexport function isBlock(node: object, opts?: object): node is Block;\nexport function isStatement(node: object, opts?: object): node is Statement;\nexport function isTerminatorless(node: object, opts?: object): node is Terminatorless;\nexport function isCompletionStatement(node: object, opts?: object): node is CompletionStatement;\nexport function isConditional(node: object, opts?: object): node is Conditional;\nexport function isLoop(node: object, opts?: object): node is Loop;\nexport function isWhile(node: object, opts?: object): node is While;\nexport function isExpressionWrapper(node: object, opts?: object): node is ExpressionWrapper;\nexport function isFor(node: object, opts?: object): node is For;\nexport function isForXStatement(node: object, opts?: object): node is ForXStatement;\n// tslint:disable-next-line ban-types\nexport function isFunction(node: object, opts?: object): node is Function;\nexport function isFunctionParent(node: object, opts?: object): node is FunctionParent;\nexport function isPureish(node: object, opts?: object): node is Pureish;\nexport function isDeclaration(node: object, opts?: object): node is Declaration;\nexport function isLVal(node: object, opts?: object): node is LVal;\nexport function isLiteral(node: object, opts?: object): node is Literal;\nexport function isImmutable(node: object, opts?: object): node is Immutable;\nexport function isUserWhitespacable(node: object, opts?: object): node is UserWhitespacable;\nexport function isMethod(node: object, opts?: object): node is Method;\nexport function isObjectMember(node: object, opts?: object): node is ObjectMember;\nexport function isProperty(node: object, opts?: object): node is Property;\nexport function isUnaryLike(node: object, opts?: object): node is UnaryLike;\nexport function isPattern(node: object, opts?: object): node is Pattern;\nexport function isClass(node: object, opts?: object): node is Class;\nexport function isModuleDeclaration(node: object, opts?: object): node is ModuleDeclaration;\nexport function isExportDeclaration(node: object, opts?: object): node is ExportDeclaration;\nexport function isModuleSpecifier(node: object, opts?: object): node is ModuleSpecifier;\nexport function isFlow(node: object, opts?: object): node is Flow;\nexport function isFlowBaseAnnotation(node: object, opts?: object): node is FlowBaseAnnotation;\nexport function isFlowDeclaration(node: object, opts?: object): node is FlowDeclaration;\nexport function isJSX(node: object, opts?: object): node is JSX;\nexport function isNumberLiteral(node: object, opts?: object): node is NumericLiteral;\nexport function isRegexLiteral(node: object, opts?: object): node is RegExpLiteral;\n\nexport function isReferencedIdentifier(node: object, opts?: object): node is Identifier | JSXIdentifier;\nexport function isReferencedMemberExpression(node: object, opts?: object): node is MemberExpression;\nexport function isBindingIdentifier(node: object, opts?: object): node is Identifier;\nexport function isScope(node: object, opts?: object): node is Scopable;\nexport function isReferenced(node: object, opts?: object): boolean;\nexport function isBlockScoped(node: object, opts?: object): node is FunctionDeclaration | ClassDeclaration | VariableDeclaration;\nexport function isVar(node: object, opts?: object): node is VariableDeclaration;\nexport function isUser(node: object, opts?: object): boolean;\nexport function isGenerated(node: object, opts?: object): boolean;\nexport function isPure(node: object, opts?: object): boolean;\n\nexport function isTSAnyKeyword(node: object, opts?: object): node is TSAnyKeyword;\nexport function isTSArrayType(node: object, opts?: object): node is TSArrayType;\nexport function isTSAsExpression(node: object, opts?: object): node is TSAsExpression;\nexport function isTSBooleanKeyword(node: object, opts?: object): node is TSBooleanKeyword;\nexport function isTSCallSignatureDeclaration(node: object, opts?: object): node is TSCallSignatureDeclaration;\nexport function isTSConstructSignatureDeclaration(node: object, opts?: object): node is TSTypeElement;\nexport function isTSConstructorType(node: object, opts?: object): node is TSConstructorType;\nexport function isTSDeclareFunction(node: object, opts?: object): node is TSDeclareFunction;\nexport function isTSDeclareMethod(node: object, opts?: object): node is TSDeclareMethod;\nexport function isTSEnumDeclaration(node: object, opts?: object): node is TSEnumDeclaration;\nexport function isTSEnumMember(node: object, opts?: object): node is TSEnumMember;\nexport function isTSExportAssignment(node: object, opts?: object): node is TSExportAssignment;\nexport function isTSExpressionWithTypeArguments(node: object, opts?: object): node is TSExpressionWithTypeArguments;\nexport function isTSExternalModuleReference(node: object, opts?: object): node is TSExternalModuleReference;\nexport function isTSFunctionType(node: object, opts?: object): node is TSFunctionType;\nexport function isTSImportEqualsDeclaration(node: object, opts?: object): node is TSImportEqualsDeclaration;\nexport function isTSIndexSignature(node: object, opts?: object): node is TSIndexSignature;\nexport function isTSIndexedAccessType(node: object, opts?: object): node is TSIndexedAccessType;\nexport function isTSInterfaceBody(node: object, opts?: object): node is TSInterfaceBody;\nexport function isTSInterfaceDeclaration(node: object, opts?: object): node is TSInterfaceDeclaration;\nexport function isTSIntersectionType(node: object, opts?: object): node is TSIntersectionType;\nexport function isTSLiteralType(node: object, opts?: object): node is TSLiteralType;\nexport function isTSMappedType(node: object, opts?: object): node is TSMappedType;\nexport function isTSMethodSignature(node: object, opts?: object): node is TSMethodSignature;\nexport function isTSModuleBlock(node: object, opts?: object): node is TSModuleBlock;\nexport function isTSModuleDeclaration(node: object, opts?: object): node is TSModuleDeclaration;\nexport function isTSNamespaceExportDeclaration(node: object, opts?: object): node is TSNamespaceExportDeclaration;\nexport function isTSNeverKeyword(node: object, opts?: object): node is TSNeverKeyword;\nexport function isTSNonNullExpression(node: object, opts?: object): node is TSNonNullExpression;\nexport function isTSNullKeyword(node: object, opts?: object): node is TSNullKeyword;\nexport function isTSNumberKeyword(node: object, opts?: object): node is TSNumberKeyword;\nexport function isTSObjectKeyword(node: object, opts?: object): node is TSObjectKeyword;\nexport function isTSParameterProperty(node: object, opts?: object): node is TSParameterProperty;\nexport function isTSParenthesizedType(node: object, opts?: object): node is TSParenthesizedType;\nexport function isTSPropertySignature(node: object, opts?: object): node is TSPropertySignature;\nexport function isTSQualifiedName(node: object, opts?: object): node is TSQualifiedName;\nexport function isTSStringKeyword(node: object, opts?: object): node is TSStringKeyword;\nexport function isTSSymbolKeyword(node: object, opts?: object): node is TSSymbolKeyword;\nexport function isTSThisType(node: object, opts?: object): node is TSThisType;\nexport function isTSTupleType(node: object, opts?: object): node is TSTupleType;\nexport function isTSTypeAliasDeclaration(node: object, opts?: object): node is TSTypeAliasDeclaration;\nexport function isTSTypeAnnotation(node: object, opts?: object): node is TSTypeAnnotation;\nexport function isTSTypeAssertion(node: object, opts?: object): node is TSTypeAssertion;\nexport function isTSTypeLiteral(node: object, opts?: object): node is TSTypeLiteral;\nexport function isTSTypeOperator(node: object, opts?: object): node is TSTypeOperator;\nexport function isTSTypeParameter(node: object, opts?: object): node is TSTypeParameter;\nexport function isTSTypeParameterDeclaration(node: object, opts?: object): node is TSTypeParameterDeclaration;\nexport function isTSTypeParameterInstantiation(node: object, opts?: object): node is TSTypeParameterInstantiation;\nexport function isTSTypePredicate(node: object, opts?: object): node is TSTypePredicate;\nexport function isTSTypeQuery(node: object, opts?: object): node is TSTypeQuery;\nexport function isTSTypeReference(node: object, opts?: object): node is TSTypeReference;\nexport function isTSUndefinedKeyword(node: object, opts?: object): node is TSUndefinedKeyword;\nexport function isTSUnionType(node: object, opts?: object): node is TSUnionType;\nexport function isTSVoidKeyword(node: object, opts?: object): node is TSVoidKeyword;\n\n// React specific\nexport interface ReactHelpers {\n    isCompatTag(tagName?: string): boolean;\n    buildChildren(node: object): Node[];\n}\nexport const react: ReactHelpers;\n\nexport function assertArrayExpression(node: object, opts?: object): void;\nexport function assertAssignmentExpression(node: object, opts?: object): void;\nexport function assertBinaryExpression(node: object, opts?: object): void;\nexport function assertDirective(node: object, opts?: object): void;\nexport function assertDirectiveLiteral(node: object, opts?: object): void;\nexport function assertBlockStatement(node: object, opts?: object): void;\nexport function assertBreakStatement(node: object, opts?: object): void;\nexport function assertCallExpression(node: object, opts?: object): void;\nexport function assertCatchClause(node: object, opts?: object): void;\nexport function assertConditionalExpression(node: object, opts?: object): void;\nexport function assertContinueStatement(node: object, opts?: object): void;\nexport function assertDebuggerStatement(node: object, opts?: object): void;\nexport function assertDoWhileStatement(node: object, opts?: object): void;\nexport function assertEmptyStatement(node: object, opts?: object): void;\nexport function assertExpressionStatement(node: object, opts?: object): void;\nexport function assertFile(node: object, opts?: object): void;\nexport function assertForInStatement(node: object, opts?: object): void;\nexport function assertForStatement(node: object, opts?: object): void;\nexport function assertFunctionDeclaration(node: object, opts?: object): void;\nexport function assertFunctionExpression(node: object, opts?: object): void;\nexport function assertIdentifier(node: object, opts?: object): void;\nexport function assertIfStatement(node: object, opts?: object): void;\nexport function assertLabeledStatement(node: object, opts?: object): void;\nexport function assertStringLiteral(node: object, opts?: object): void;\nexport function assertNumericLiteral(node: object, opts?: object): void;\nexport function assertNullLiteral(node: object, opts?: object): void;\nexport function assertBooleanLiteral(node: object, opts?: object): void;\nexport function assertRegExpLiteral(node: object, opts?: object): void;\nexport function assertLogicalExpression(node: object, opts?: object): void;\nexport function assertMemberExpression(node: object, opts?: object): void;\nexport function assertNewExpression(node: object, opts?: object): void;\nexport function assertProgram(node: object, opts?: object): void;\nexport function assertObjectExpression(node: object, opts?: object): void;\nexport function assertObjectMethod(node: object, opts?: object): void;\nexport function assertObjectProperty(node: object, opts?: object): void;\nexport function assertRestElement(node: object, opts?: object): void;\nexport function assertReturnStatement(node: object, opts?: object): void;\nexport function assertSequenceExpression(node: object, opts?: object): void;\nexport function assertSwitchCase(node: object, opts?: object): void;\nexport function assertSwitchStatement(node: object, opts?: object): void;\nexport function assertThisExpression(node: object, opts?: object): void;\nexport function assertThrowStatement(node: object, opts?: object): void;\nexport function assertTryStatement(node: object, opts?: object): void;\nexport function assertUnaryExpression(node: object, opts?: object): void;\nexport function assertUpdateExpression(node: object, opts?: object): void;\nexport function assertVariableDeclaration(node: object, opts?: object): void;\nexport function assertVariableDeclarator(node: object, opts?: object): void;\nexport function assertWhileStatement(node: object, opts?: object): void;\nexport function assertWithStatement(node: object, opts?: object): void;\nexport function assertAssignmentPattern(node: object, opts?: object): void;\nexport function assertArrayPattern(node: object, opts?: object): void;\nexport function assertArrowFunctionExpression(node: object, opts?: object): void;\nexport function assertClassBody(node: object, opts?: object): void;\nexport function assertClassDeclaration(node: object, opts?: object): void;\nexport function assertClassExpression(node: object, opts?: object): void;\nexport function assertExportAllDeclaration(node: object, opts?: object): void;\nexport function assertExportDefaultDeclaration(node: object, opts?: object): void;\nexport function assertExportNamedDeclaration(node: object, opts?: object): void;\nexport function assertExportSpecifier(node: object, opts?: object): void;\nexport function assertForOfStatement(node: object, opts?: object): void;\nexport function assertImportDeclaration(node: object, opts?: object): void;\nexport function assertImportDefaultSpecifier(node: object, opts?: object): void;\nexport function assertImportNamespaceSpecifier(node: object, opts?: object): void;\nexport function assertImportSpecifier(node: object, opts?: object): void;\nexport function assertMetaProperty(node: object, opts?: object): void;\nexport function assertClassMethod(node: object, opts?: object): void;\nexport function assertObjectPattern(node: object, opts?: object): void;\nexport function assertSpreadElement(node: object, opts?: object): void;\nexport function assertSuper(node: object, opts?: object): void;\nexport function assertTaggedTemplateExpression(node: object, opts?: object): void;\nexport function assertTemplateElement(node: object, opts?: object): void;\nexport function assertTemplateLiteral(node: object, opts?: object): void;\nexport function assertYieldExpression(node: object, opts?: object): void;\nexport function assertAnyTypeAnnotation(node: object, opts?: object): void;\nexport function assertArrayTypeAnnotation(node: object, opts?: object): void;\nexport function assertBooleanTypeAnnotation(node: object, opts?: object): void;\nexport function assertBooleanLiteralTypeAnnotation(node: object, opts?: object): void;\nexport function assertNullLiteralTypeAnnotation(node: object, opts?: object): void;\nexport function assertClassImplements(node: object, opts?: object): void;\nexport function assertClassProperty(node: object, opts?: object): void;\nexport function assertDeclareClass(node: object, opts?: object): void;\nexport function assertDeclareFunction(node: object, opts?: object): void;\nexport function assertDeclareInterface(node: object, opts?: object): void;\nexport function assertDeclareModule(node: object, opts?: object): void;\nexport function assertDeclareTypeAlias(node: object, opts?: object): void;\nexport function assertDeclareVariable(node: object, opts?: object): void;\nexport function assertExistentialTypeParam(node: object, opts?: object): void;\nexport function assertFunctionTypeAnnotation(node: object, opts?: object): void;\nexport function assertFunctionTypeParam(node: object, opts?: object): void;\nexport function assertGenericTypeAnnotation(node: object, opts?: object): void;\nexport function assertInterfaceExtends(node: object, opts?: object): void;\nexport function assertInterfaceDeclaration(node: object, opts?: object): void;\nexport function assertIntersectionTypeAnnotation(node: object, opts?: object): void;\nexport function assertMixedTypeAnnotation(node: object, opts?: object): void;\nexport function assertNullableTypeAnnotation(node: object, opts?: object): void;\nexport function assertNumericLiteralTypeAnnotation(node: object, opts?: object): void;\nexport function assertNumberTypeAnnotation(node: object, opts?: object): void;\nexport function assertStringLiteralTypeAnnotation(node: object, opts?: object): void;\nexport function assertStringTypeAnnotation(node: object, opts?: object): void;\nexport function assertThisTypeAnnotation(node: object, opts?: object): void;\nexport function assertTupleTypeAnnotation(node: object, opts?: object): void;\nexport function assertTypeofTypeAnnotation(node: object, opts?: object): void;\nexport function assertTypeAlias(node: object, opts?: object): void;\nexport function assertTypeAnnotation(node: object, opts?: object): void;\nexport function assertTypeCastExpression(node: object, opts?: object): void;\nexport function assertTypeParameter(node: object, opts?: object): void;\nexport function assertTypeParameterDeclaration(node: object, opts?: object): void;\nexport function assertTypeParameterInstantiation(node: object, opts?: object): void;\nexport function assertObjectTypeAnnotation(node: object, opts?: object): void;\nexport function assertObjectTypeCallProperty(node: object, opts?: object): void;\nexport function assertObjectTypeIndexer(node: object, opts?: object): void;\nexport function assertObjectTypeProperty(node: object, opts?: object): void;\nexport function assertQualifiedTypeIdentifier(node: object, opts?: object): void;\nexport function assertUnionTypeAnnotation(node: object, opts?: object): void;\nexport function assertVoidTypeAnnotation(node: object, opts?: object): void;\nexport function assertJSXAttribute(node: object, opts?: object): void;\nexport function assertJSXClosingElement(node: object, opts?: object): void;\nexport function assertJSXElement(node: object, opts?: object): void;\nexport function assertJSXEmptyExpression(node: object, opts?: object): void;\nexport function assertJSXExpressionContainer(node: object, opts?: object): void;\nexport function assertJSXIdentifier(node: object, opts?: object): void;\nexport function assertJSXMemberExpression(node: object, opts?: object): void;\nexport function assertJSXNamespacedName(node: object, opts?: object): void;\nexport function assertJSXOpeningElement(node: object, opts?: object): void;\nexport function assertJSXSpreadAttribute(node: object, opts?: object): void;\nexport function assertJSXText(node: object, opts?: object): void;\nexport function assertNoop(node: object, opts?: object): void;\nexport function assertParenthesizedExpression(node: object, opts?: object): void;\nexport function assertAwaitExpression(node: object, opts?: object): void;\nexport function assertBindExpression(node: object, opts?: object): void;\nexport function assertDecorator(node: object, opts?: object): void;\nexport function assertDoExpression(node: object, opts?: object): void;\nexport function assertExportDefaultSpecifier(node: object, opts?: object): void;\nexport function assertExportNamespaceSpecifier(node: object, opts?: object): void;\nexport function assertRestProperty(node: object, opts?: object): void;\nexport function assertSpreadProperty(node: object, opts?: object): void;\nexport function assertExpression(node: object, opts?: object): void;\nexport function assertBinary(node: object, opts?: object): void;\nexport function assertScopable(node: object, opts?: object): void;\nexport function assertBlockParent(node: object, opts?: object): void;\nexport function assertBlock(node: object, opts?: object): void;\nexport function assertStatement(node: object, opts?: object): void;\nexport function assertTerminatorless(node: object, opts?: object): void;\nexport function assertCompletionStatement(node: object, opts?: object): void;\nexport function assertConditional(node: object, opts?: object): void;\nexport function assertLoop(node: object, opts?: object): void;\nexport function assertWhile(node: object, opts?: object): void;\nexport function assertExpressionWrapper(node: object, opts?: object): void;\nexport function assertFor(node: object, opts?: object): void;\nexport function assertForXStatement(node: object, opts?: object): void;\nexport function assertFunction(node: object, opts?: object): void;\nexport function assertFunctionParent(node: object, opts?: object): void;\nexport function assertPureish(node: object, opts?: object): void;\nexport function assertDeclaration(node: object, opts?: object): void;\nexport function assertLVal(node: object, opts?: object): void;\nexport function assertLiteral(node: object, opts?: object): void;\nexport function assertImmutable(node: object, opts?: object): void;\nexport function assertUserWhitespacable(node: object, opts?: object): void;\nexport function assertMethod(node: object, opts?: object): void;\nexport function assertObjectMember(node: object, opts?: object): void;\nexport function assertProperty(node: object, opts?: object): void;\nexport function assertUnaryLike(node: object, opts?: object): void;\nexport function assertPattern(node: object, opts?: object): void;\nexport function assertClass(node: object, opts?: object): void;\nexport function assertModuleDeclaration(node: object, opts?: object): void;\nexport function assertExportDeclaration(node: object, opts?: object): void;\nexport function assertModuleSpecifier(node: object, opts?: object): void;\nexport function assertFlow(node: object, opts?: object): void;\nexport function assertFlowBaseAnnotation(node: object, opts?: object): void;\nexport function assertFlowDeclaration(node: object, opts?: object): void;\nexport function assertJSX(node: object, opts?: object): void;\nexport function assertNumberLiteral(node: object, opts?: object): void;\nexport function assertRegexLiteral(node: object, opts?: object): void;\n\nexport function assertTSAnyKeyword(node: object, opts?: object): void;\nexport function assertTSArrayType(node: object, opts?: object): void;\nexport function assertTSAsExpression(node: object, opts?: object): void;\nexport function assertTSBooleanKeyword(node: object, opts?: object): void;\nexport function assertTSCallSignatureDeclaration(node: object, opts?: object): void;\nexport function assertTSConstructSignatureDeclaration(node: object, opts?: object): void;\nexport function assertTSConstructorType(node: object, opts?: object): void;\nexport function assertTSDeclareFunction(node: object, opts?: object): void;\nexport function assertTSDeclareMethod(node: object, opts?: object): void;\nexport function assertTSEnumDeclaration(node: object, opts?: object): void;\nexport function assertTSEnumMember(node: object, opts?: object): void;\nexport function assertTSExportAssignment(node: object, opts?: object): void;\nexport function assertTSExpressionWithTypeArguments(node: object, opts?: object): void;\nexport function assertTSExternalModuleReference(node: object, opts?: object): void;\nexport function assertTSFunctionType(node: object, opts?: object): void;\nexport function assertTSImportEqualsDeclaration(node: object, opts?: object): void;\nexport function assertTSIndexSignature(node: object, opts?: object): void;\nexport function assertTSIndexedAccessType(node: object, opts?: object): void;\nexport function assertTSInterfaceBody(node: object, opts?: object): void;\nexport function assertTSInterfaceDeclaration(node: object, opts?: object): void;\nexport function assertTSIntersectionType(node: object, opts?: object): void;\nexport function assertTSLiteralType(node: object, opts?: object): void;\nexport function assertTSMappedType(node: object, opts?: object): void;\nexport function assertTSMethodSignature(node: object, opts?: object): void;\nexport function assertTSModuleBlock(node: object, opts?: object): void;\nexport function assertTSModuleDeclaration(node: object, opts?: object): void;\nexport function assertTSNamespaceExportDeclaration(node: object, opts?: object): void;\nexport function assertTSNeverKeyword(node: object, opts?: object): void;\nexport function assertTSNonNullExpression(node: object, opts?: object): void;\nexport function assertTSNullKeyword(node: object, opts?: object): void;\nexport function assertTSNumberKeyword(node: object, opts?: object): void;\nexport function assertTSObjectKeyword(node: object, opts?: object): void;\nexport function assertTSParameterProperty(node: object, opts?: object): void;\nexport function assertTSParenthesizedType(node: object, opts?: object): void;\nexport function assertTSPropertySignature(node: object, opts?: object): void;\nexport function assertTSQualifiedName(node: object, opts?: object): void;\nexport function assertTSStringKeyword(node: object, opts?: object): void;\nexport function assertTSSymbolKeyword(node: object, opts?: object): void;\nexport function assertTSThisType(node: object, opts?: object): void;\nexport function assertTSTupleType(node: object, opts?: object): void;\nexport function assertTSTypeAliasDeclaration(node: object, opts?: object): void;\nexport function assertTSTypeAnnotation(node: object, opts?: object): void;\nexport function assertTSTypeAssertion(node: object, opts?: object): void;\nexport function assertTSTypeLiteral(node: object, opts?: object): void;\nexport function assertTSTypeOperator(node: object, opts?: object): void;\nexport function assertTSTypeParameter(node: object, opts?: object): void;\nexport function assertTSTypeParameterDeclaration(node: object, opts?: object): void;\nexport function assertTSTypeParameterInstantiation(node: object, opts?: object): void;\nexport function assertTSTypePredicate(node: object, opts?: object): void;\nexport function assertTSTypeQuery(node: object, opts?: object): void;\nexport function assertTSTypeReference(node: object, opts?: object): void;\nexport function assertTSUndefinedKeyword(node: object, opts?: object): void;\nexport function assertTSUnionType(node: object, opts?: object): void;\nexport function assertTSVoidKeyword(node: object, opts?: object): void;\n","type":2},{"name":"node_modules/@types/charm/index.d.ts","text":"// Type definitions for Charm 1.0\n// Project: https://github.com/substack/node-charm/\n// Definitions by: Jad Sarout <https://github.com/Xananax>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n/// <reference types=\"node\" />\n\ndeclare namespace charm {\n\ttype CharmColorName = \"red\" | \"yellow\" | \"green\" | \"blue\" | \"cyan\" | \"magenta\" | \"black\" | \"white\";\n\ttype CharmColorHex = number;\n\ttype CharmColor = CharmColorName | CharmColorHex;\n\ttype CharmAnyStream = NodeJS.WritableStream|NodeJS.ReadableStream|NodeJS.Process;\n\n\tinterface CharmInstance extends NodeJS.WritableStream {\n\t\t/** Reset the entire screen, like the /usr/bin/reset command. */\n\t\treset(): void;\n\n\t\t/** Emit an \"end\" event downstream. */\n\t\tdestroy(): void;\n\n\t\t/** Emit an \"end\" event downstream. */\n\t\tend(): void;\n\n\t\t/**\n\t\t * Pass along `msg` to the output stream.\n\t\t * @param cb Unused by charm, only there to comply to the WritableStream interface\n\t\t */\n\t\twrite(msg: string | Buffer, cb?: Function): boolean;\n\t\twrite(msgs: string | Buffer, encoding?: string, cb?: Function): boolean;\n\n\t\t/** Set the cursor position to the absolute coordinates `x`, `y`. */\n\t\tposition(x: number, y: number): void;\n\n\t\t/**\n\t\t * Query the absolute cursor position from the input stream through the output stream\n\t\t * (the shell does this automatically) and get the response back as `cb(x, y)`.\n\t\t */\n\t\tposition(callback: (x: number, y: number) => void): void;\n\n\t\t/** Move the cursor position by the relative coordinates `x`, `y`. */\n\t\tmove(x: number, y: number): this;\n\n\t\t/** Move the cursor up by `y` rows. */\n\t\tup(y: number): this;\n\n\t\t/** Move the cursor down by `y` rows. */\n\t\tdown(y: number): this;\n\n\t\t/** Move the cursor left by `x` columns. */\n\t\tleft(x: number): this;\n\n\t\t/** Move the cursor right by `x` columns. */\n\t\tright(x: number): this;\n\n\t\t/** Push the cursor state and optionally the attribute state. */\n\t\tpush(withAttributes?: boolean): this;\n\n\t\t/** Pop the cursor state and optionally the attribute state. */\n\t\tpop(withAttributes?: boolean): this;\n\n\t\t/**\n\t\t * Erase a region defined by the string `s`.\n\t\t *\n\t\t * `s` can be:\n\t\t *\n\t\t *  - end - erase from the cursor to the end of the line\n\t\t *  - start - erase from the cursor to the start of the line\n\t\t *  - line - erase the current line\n\t\t *  - down - erase everything below the current line\n\t\t *  - up - erase everything above the current line\n\t\t *  - screen - erase the entire screen\n\t\t */\n\t\terase(s: \"end\"|\"start\"|\"line\"|\"down\"|\"up\"|\"screen\"): this;\n\n\t\t/**\n\t\t * Delete `'line'` or `'char'`s. delete differs from erase because it does not write over\n\t\t * the deleted characters with whitesapce, but instead removes the deleted space.\n\t\t *\n\t\t * mode can be `'line'` or `'char'`. `n` is the number of items to be deleted.\n\t\t * `n` must be a positive integer.\n\t\t *\n\t\t * The cursor position is not updated.\n\t\t */\n\t\tdelete(mode: \"line\"|\"char\", n?: number): this;\n\n\t\t/**\n\t\t * Insert space into the terminal. `insert` is the opposite of `delete`,\n\t\t *\n\t\t * mode can be `'line'` or `'char'`. `n` is the number of items to be deleted.\n\t\t * `n` must be a positive integer.\n\t\t */\n\t\tinsert(mode: \"line\"|\"char\", n: number): this;\n\t\t/**\n\t\t * Set the display mode with the string `attr.`\n\t\t *\n\t\t * `attr` can be:\n\t\t *\n\t\t *  - reset\n\t\t *  - bright\n\t\t *  - dim\n\t\t *  - underscore\n\t\t *  - blink\n\t\t *  - reverse\n\t\t *  - hidden\n\t\t */\n\t\tdisplay(attr: \"reset\" | \"bright\" | \"dim\" | \"underscore\" | \"blink\" | \"reverse\" | \"hidden\"): this;\n\n\t\t/**\n\t\t * Set the foreground color with the string `color`, which can be:\n\t\t *\n\t\t *  - red\n\t\t *  - yellow\n\t\t *  - green\n\t\t *  - blue\n\t\t *  - cyan\n\t\t *  - magenta\n\t\t *  - black\n\t\t *  - white\n\t\t *  - or `color` can be an integer from 0 to 255, inclusive.\n\t\t */\n\t\tforeground(color: CharmColor): this;\n\t\t/**\n\t\t * Set the background color with the string `color`, which can be:\n\t\t *\n\t\t *  - red\n\t\t *  - yellow\n\t\t *  - green\n\t\t *  - blue\n\t\t *  - cyan\n\t\t *  - magenta\n\t\t *  - black\n\t\t *  - white\n\t\t *  - or `color` can be an integer from 0 to 255, inclusive.\n\t\t */\n\t\tbackground(color: CharmColor): this;\n\n\t\t/** Set the cursor visibility with a boolean `visible`. */\n\t\tcursor(visible: boolean): any;\n\n\t\t/** Pipes the output of Charm to a writeable stream `stream` */\n\t\tpipe(stream: NodeJS.WritableStream): void;\n\t}\n}\n\n/**\n * Create a new readable/writable charm stream.\n *\n * You can pass in readable or writable streams as parameters\n * and they will be piped to or from accordingly.\n * You can also pass `process` in which case\n * `process.stdin` and `process.stdout` will be used.\n */\ndeclare function charm(param?: charm.CharmAnyStream): charm.CharmInstance;\nexport = charm;\n","type":2},{"name":"node_modules/@types/chai/index.d.ts","text":"// Type definitions for chai 4.0\n// Project: http://chaijs.com/\n// Definitions by: Jed Mao <https://github.com/jedmao>,\n//                 Bart van der Schoor <https://github.com/Bartvds>,\n//                 Andrew Brown <https://github.com/AGBrown>,\n//                 Olivier Chevet <https://github.com/olivr70>,\n//                 Matt Wistrand <https://github.com/mwistrand>,\n//                 Josh Goldberg <https://github.com/joshuakgoldberg>\n//                 Shaun Luttin <https://github.com/shaunluttin>\n//                 Gintautas Miselis <https://github.com/Naktibalda>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n// <reference types=\"assertion-error\"/>\n\ndeclare namespace Chai {\n    interface ChaiStatic {\n        expect: ExpectStatic;\n        should(): Should;\n        /**\n         * Provides a way to extend the internals of Chai\n         */\n        use(fn: (chai: any, utils: any) => void): ChaiStatic;\n        assert: AssertStatic;\n        config: Config;\n        AssertionError: typeof AssertionError;\n        version: string;\n    }\n\n    export interface ExpectStatic extends AssertionStatic {\n        fail(actual?: any, expected?: any, message?: string, operator?: Operator): void;\n    }\n\n    export interface AssertStatic extends Assert {\n    }\n\n    export interface AssertionStatic {\n        (target: any, message?: string): Assertion;\n    }\n\n    export type Operator = string; // \"==\" | \"===\" | \">\" | \">=\" | \"<\" | \"<=\" | \"!=\" | \"!==\";\n\n    export type OperatorComparable = boolean | null | number | string | undefined | Date;\n\n    interface ShouldAssertion {\n        equal(value1: any, value2: any, message?: string): void;\n        Throw: ShouldThrow;\n        throw: ShouldThrow;\n        exist(value: any, message?: string): void;\n    }\n\n    interface Should extends ShouldAssertion {\n        not: ShouldAssertion;\n        fail(actual: any, expected: any, message?: string, operator?: Operator): void;\n    }\n\n    interface ShouldThrow {\n        (actual: Function, expected?: string|RegExp, message?: string): void;\n        (actual: Function, constructor: Error|Function, expected?: string|RegExp, message?: string): void;\n    }\n\n    interface Assertion extends LanguageChains, NumericComparison, TypeComparison {\n        not: Assertion;\n        deep: Deep;\n        ordered: Ordered;\n        nested: Nested;\n        any: KeyFilter;\n        all: KeyFilter;\n        a: TypeComparison;\n        an: TypeComparison;\n        include: Include;\n        includes: Include;\n        contain: Include;\n        contains: Include;\n        ok: Assertion;\n        true: Assertion;\n        false: Assertion;\n        null: Assertion;\n        undefined: Assertion;\n        NaN: Assertion;\n        exist: Assertion;\n        empty: Assertion;\n        arguments: Assertion;\n        Arguments: Assertion;\n        equal: Equal;\n        equals: Equal;\n        eq: Equal;\n        eql: Equal;\n        eqls: Equal;\n        property: Property;\n        ownProperty: OwnProperty;\n        haveOwnProperty: OwnProperty;\n        ownPropertyDescriptor: OwnPropertyDescriptor;\n        haveOwnPropertyDescriptor: OwnPropertyDescriptor;\n        length: Length;\n        lengthOf: Length;\n        match: Match;\n        matches: Match;\n        string(string: string, message?: string): Assertion;\n        keys: Keys;\n        key(string: string): Assertion;\n        throw: Throw;\n        throws: Throw;\n        Throw: Throw;\n        respondTo: RespondTo;\n        respondsTo: RespondTo;\n        itself: Assertion;\n        satisfy: Satisfy;\n        satisfies: Satisfy;\n        closeTo: CloseTo;\n        approximately: CloseTo;\n        members: Members;\n        increase: PropertyChange;\n        increases: PropertyChange;\n        decrease: PropertyChange;\n        decreases: PropertyChange;\n        change: PropertyChange;\n        changes: PropertyChange;\n        extensible: Assertion;\n        sealed: Assertion;\n        frozen: Assertion;\n        oneOf(list: any[], message?: string): Assertion;\n    }\n\n    interface LanguageChains {\n        to: Assertion;\n        be: Assertion;\n        been: Assertion;\n        is: Assertion;\n        that: Assertion;\n        which: Assertion;\n        and: Assertion;\n        has: Assertion;\n        have: Assertion;\n        with: Assertion;\n        at: Assertion;\n        of: Assertion;\n        same: Assertion;\n        but: Assertion;\n        does: Assertion;\n    }\n\n    interface NumericComparison {\n        above: NumberComparer;\n        gt: NumberComparer;\n        greaterThan: NumberComparer;\n        least: NumberComparer;\n        gte: NumberComparer;\n        below: NumberComparer;\n        lt: NumberComparer;\n        lessThan: NumberComparer;\n        most: NumberComparer;\n        lte: NumberComparer;\n        within(start: number, finish: number, message?: string): Assertion;\n    }\n\n    interface NumberComparer {\n        (value: number, message?: string): Assertion;\n    }\n\n    interface TypeComparison {\n        (type: string, message?: string): Assertion;\n        instanceof: InstanceOf;\n        instanceOf: InstanceOf;\n    }\n\n    interface InstanceOf {\n        (constructor: Object, message?: string): Assertion;\n    }\n\n    interface CloseTo {\n        (expected: number, delta: number, message?: string): Assertion;\n    }\n\n    interface Nested {\n      include: Include;\n      property: Property;\n      members: Members;\n    }\n\n    interface Deep {\n        equal: Equal;\n        equals: Equal;\n        eq: Equal;\n        include: Include;\n        property: Property;\n        members: Members;\n        ordered: Ordered;\n    }\n\n    interface Ordered {\n        members: Members;\n    }\n\n    interface KeyFilter {\n        keys: Keys;\n    }\n\n    interface Equal {\n        (value: any, message?: string): Assertion;\n    }\n\n    interface Property {\n        (name: string, value?: any, message?: string): Assertion;\n    }\n\n    interface OwnProperty {\n        (name: string, message?: string): Assertion;\n    }\n\n    interface OwnPropertyDescriptor {\n        (name: string, descriptor: PropertyDescriptor, message?: string): Assertion;\n        (name: string, message?: string): Assertion;\n    }\n\n    interface Length extends LanguageChains, NumericComparison {\n        (length: number, message?: string): Assertion;\n    }\n\n    interface Include {\n        (value: Object | string | number, message?: string): Assertion;\n        keys: Keys;\n        deep: Deep;\n        ordered: Ordered;\n        members: Members;\n        any: KeyFilter;\n        all: KeyFilter;\n    }\n\n    interface Match {\n        (regexp: RegExp|string, message?: string): Assertion;\n    }\n\n    interface Keys {\n        (...keys: string[]): Assertion;\n        (keys: any[]|Object): Assertion;\n    }\n\n    interface Throw {\n        (expected?: string|RegExp, message?: string): Assertion;\n        (constructor: Error|Function, expected?: string|RegExp, message?: string): Assertion;\n    }\n\n    interface RespondTo {\n        (method: string, message?: string): Assertion;\n    }\n\n    interface Satisfy {\n        (matcher: Function, message?: string): Assertion;\n    }\n\n    interface Members {\n        (set: any[], message?: string): Assertion;\n    }\n\n    interface PropertyChange {\n        (object: Object, property: string, message?: string): Assertion;\n    }\n\n    export interface Assert {\n        /**\n         * @param expression    Expression to test for truthiness.\n         * @param message    Message to display on error.\n         */\n        (expression: any, message?: string): void;\n\n        /**\n         * Throws a failure.\n         *\n         * @type T   Type of the objects.\n         * @param actual   Actual value.\n         * @param expected   Potential expected value.\n         * @param message    Message to display on error.\n         * @param operator   Comparison operator, if not strict equality.\n         * @remarks Node.js assert module-compatible.\n         */\n        fail<T>(actual?: T, expected?: T, message?: string, operator?: Operator): void;\n\n        /**\n         * Asserts that object is truthy.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param message    Message to display on error.\n         */\n        isOk<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that object is truthy.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param message    Message to display on error.\n         */\n        ok<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that object is falsy.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param message    Message to display on error.\n         */\n        isNotOk<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that object is falsy.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param message    Message to display on error.\n         */\n        notOk<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts non-strict equality (==) of actual and expected.\n         *\n         * @type T   Type of the objects.\n         * @param actual   Actual value.\n         * @param expected   Potential expected value.\n         * @param message   Message to display on error.\n         */\n        equal<T>(actual: T, expected: T, message?: string): void;\n\n        /**\n         * Asserts non-strict inequality (==) of actual and expected.\n         *\n         * @type T   Type of the objects.\n         * @param actual   Actual value.\n         * @param expected   Potential expected value.\n         * @param message   Message to display on error.\n         */\n        notEqual<T>(actual: T, expected: T, message?: string): void;\n\n        /**\n         * Asserts strict equality (===) of actual and expected.\n         *\n         * @type T   Type of the objects.\n         * @param actual   Actual value.\n         * @param expected   Potential expected value.\n         * @param message   Message to display on error.\n         */\n        strictEqual<T>(actual: T, expected: T, message?: string): void;\n\n        /**\n         * Asserts strict inequality (==) of actual and expected.\n         *\n         * @type T   Type of the objects.\n         * @param actual   Actual value.\n         * @param expected   Potential expected value.\n         * @param message   Message to display on error.\n         */\n        notStrictEqual<T>(actual: T, expected: T, message?: string): void;\n\n        /**\n         * Asserts that actual is deeply equal to expected.\n         *\n         * @type T   Type of the objects.\n         * @param actual   Actual value.\n         * @param expected   Potential expected value.\n         * @param message   Message to display on error.\n         */\n        deepEqual<T>(actual: T, expected: T, message?: string): void;\n\n        /**\n         * Asserts that actual is not deeply equal to expected.\n         *\n         * @type T   Type of the objects.\n         * @param actual   Actual value.\n         * @param expected   Potential expected value.\n         * @param message   Message to display on error.\n         */\n        notDeepEqual<T>(actual: T, expected: T, message?: string): void;\n\n        /**\n         * Asserts valueToCheck is strictly greater than (>) valueToBeAbove.\n         *\n         * @param valueToCheck   Actual value.\n         * @param valueToBeAbove   Minimum Potential expected value.\n         * @param message   Message to display on error.\n         */\n        isAbove(valueToCheck: number, valueToBeAbove: number, message?: string): void;\n\n        /**\n         * Asserts valueToCheck is greater than or equal to (>=) valueToBeAtLeast.\n         *\n         * @param valueToCheck   Actual value.\n         * @param valueToBeAtLeast   Minimum Potential expected value.\n         * @param message   Message to display on error.\n         */\n        isAtLeast(valueToCheck: number, valueToBeAtLeast: number, message?: string): void;\n\n        /**\n         * Asserts valueToCheck is strictly less than (<) valueToBeBelow.\n         *\n         * @param valueToCheck   Actual value.\n         * @param valueToBeBelow   Minimum Potential expected value.\n         * @param message   Message to display on error.\n         */\n        isBelow(valueToCheck: number, valueToBeBelow: number, message?: string): void;\n\n        /**\n         * Asserts valueToCheck is greater than or equal to (>=) valueToBeAtMost.\n         *\n         * @param valueToCheck   Actual value.\n         * @param valueToBeAtMost   Minimum Potential expected value.\n         * @param message   Message to display on error.\n         */\n        isAtMost(valueToCheck: number, valueToBeAtMost: number, message?: string): void;\n\n        /**\n         * Asserts that value is true.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isTrue<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is false.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isFalse<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is not true.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNotTrue<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is not false.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNotFalse<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is null.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNull<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is not null.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNotNull<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is not null.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNaN<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is not null.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNotNaN<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that the target is neither null nor undefined.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message    Message to display on error.\n         */\n        exists<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that the target is either null or undefined.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message    Message to display on error.\n         */\n        notExists<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is undefined.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isUndefined<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is not undefined.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isDefined<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is a function.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isFunction<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is not a function.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNotFunction<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is an object of type 'Object'\n         * (as revealed by Object.prototype.toString).\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         * @remarks The assertion does not match subclassed objects.\n         */\n        isObject<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is not an object of type 'Object'\n         * (as revealed by Object.prototype.toString).\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNotObject<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is an array.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isArray<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is not an array.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNotArray<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is a string.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isString<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is not a string.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNotString<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is a number.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNumber<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is not a number.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNotNumber<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is a boolean.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isBoolean<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value is not a boolean.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNotBoolean<T>(value: T, message?: string): void;\n\n        /**\n         * Asserts that value's type is name, as determined by Object.prototype.toString.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param name   Potential expected type name of value.\n         * @param message   Message to display on error.\n         */\n        typeOf<T>(value: T, name: string, message?: string): void;\n\n        /**\n         * Asserts that value's type is not name, as determined by Object.prototype.toString.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param name   Potential expected type name of value.\n         * @param message   Message to display on error.\n         */\n        notTypeOf<T>(value: T, name: string, message?: string): void;\n\n        /**\n         * Asserts that value is an instance of constructor.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param constructor   Potential expected contructor of value.\n         * @param message   Message to display on error.\n         */\n        instanceOf<T>(value: T, constructor: Function, message?: string): void;\n\n        /**\n         * Asserts that value is not an instance of constructor.\n         *\n         * @type T   Type of value.\n         * @param value   Actual value.\n         * @param constructor   Potential expected contructor of value.\n         * @param message   Message to display on error.\n         */\n        notInstanceOf<T>(value: T, type: Function, message?: string): void;\n\n        /**\n         * Asserts that haystack includes needle.\n         *\n         * @param haystack   Container string.\n         * @param needle   Potential expected substring of haystack.\n         * @param message   Message to display on error.\n         */\n        include(haystack: string, needle: string, message?: string): void;\n\n        /**\n         * Asserts that haystack includes needle.\n         *\n         * @type T   Type of values in haystack.\n         * @param haystack   Container array.\n         * @param needle   Potential value contained in haystack.\n         * @param message   Message to display on error.\n         */\n        include<T>(haystack: T[], needle: T, message?: string): void;\n\n        /**\n         * Asserts that haystack does not include needle.\n         *\n         * @param haystack   Container string or array.\n         * @param needle   Potential expected substring of haystack.\n         * @param message   Message to display on error.\n         */\n        notInclude(haystack: string | any[], needle: any, message?: string): void;\n\n        /**\n         * Asserts that haystack includes needle. Can be used to assert the inclusion of a value in an array or a subset of properties in an object. Deep equality is used.\n         *\n         * @param haystack   Container string.\n         * @param needle   Potential expected substring of haystack.\n         * @param message   Message to display on error.\n         */\n        deepInclude(haystack: string, needle: string, message?: string): void;\n\n        /**\n         * Asserts that haystack includes needle. Can be used to assert the inclusion of a value in an array or a subset of properties in an object. Deep equality is used.\n         *\n         * @param haystack\n         * @param needle\n         * @param message   Message to display on error.\n         */\n        deepInclude<T>(haystack: any, needle: any, message?: string): void;\n\n        /**\n         * Asserts that haystack does not include needle. Can be used to assert the absence of a value in an array or a subset of properties in an object. Deep equality is used.\n         *\n         * @param haystack   Container string or array.\n         * @param needle   Potential expected substring of haystack.\n         * @param message   Message to display on error.\n         */\n        notDeepInclude(haystack: string | any[], needle: any, message?: string): void;\n\n        /**\n         * Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object.\n         *\n         * Enables the use of dot- and bracket-notation for referencing nested properties.\n         * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.Asserts that ‘haystack’ includes ‘needle’.\n         * Can be used to assert the inclusion of a subset of properties in an object.\n         * Enables the use of dot- and bracket-notation for referencing nested properties.\n         * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.\n         *\n         * @param haystack\n         * @param needle\n         * @param message   Message to display on error.\n         */\n        nestedInclude(haystack: any, needle: any, message?: string): void;\n\n        /**\n         * Asserts that ‘haystack’ does not include ‘needle’. Can be used to assert the absence of a subset of properties in an object.\n         *\n         * Enables the use of dot- and bracket-notation for referencing nested properties.\n         * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.Asserts that ‘haystack’ includes ‘needle’.\n         * Can be used to assert the inclusion of a subset of properties in an object.\n         * Enables the use of dot- and bracket-notation for referencing nested properties.\n         * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.\n         *\n         * @param haystack\n         * @param needle\n         * @param message   Message to display on error.\n         */\n        notNestedInclude(haystack: any, needle: any, message?: string): void;\n\n        /**\n         * Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while checking for deep equality\n         *\n         * Enables the use of dot- and bracket-notation for referencing nested properties.\n         * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.Asserts that ‘haystack’ includes ‘needle’.\n         * Can be used to assert the inclusion of a subset of properties in an object.\n         * Enables the use of dot- and bracket-notation for referencing nested properties.\n         * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.\n         *\n         * @param haystack\n         * @param needle\n         * @param message   Message to display on error.\n         */\n        deepNestedInclude(haystack: any, needle: any, message?: string): void;\n\n        /**\n         * Asserts that ‘haystack’ does not include ‘needle’. Can be used to assert the absence of a subset of properties in an object while checking for deep equality.\n         *\n         * Enables the use of dot- and bracket-notation for referencing nested properties.\n         * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.Asserts that ‘haystack’ includes ‘needle’.\n         * Can be used to assert the inclusion of a subset of properties in an object.\n         * Enables the use of dot- and bracket-notation for referencing nested properties.\n         * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.\n         *\n         * @param haystack\n         * @param needle\n         * @param message   Message to display on error.\n         */\n        notDeepNestedInclude(haystack: any, needle: any, message?: string): void;\n\n        /**\n         * Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties.\n         *\n         * @param haystack\n         * @param needle\n         * @param message   Message to display on error.\n         */\n        ownInclude(haystack: any, needle: any, message?: string): void;\n\n        /**\n         * Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties.\n         *\n         * @param haystack\n         * @param needle\n         * @param message   Message to display on error.\n         */\n        notOwnInclude(haystack: any, needle: any, message?: string): void;\n\n        /**\n         * Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties and checking for deep\n         *\n         * @param haystack\n         * @param needle\n         * @param message   Message to display on error.\n         */\n        deepOwnInclude(haystack: any, needle: any, message?: string): void;\n\n        /**\n         * Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties and checking for deep equality.\n         *\n         * @param haystack\n         * @param needle\n         * @param message   Message to display on error.\n         */\n        notDeepOwnInclude(haystack: any, needle: any, message?: string): void;\n\n        /**\n         * Asserts that value matches the regular expression regexp.\n         *\n         * @param value   Actual value.\n         * @param regexp   Potential match of value.\n         * @param message   Message to display on error.\n         */\n        match(value: string, regexp: RegExp, message?: string): void;\n\n        /**\n         * Asserts that value does not match the regular expression regexp.\n         *\n         * @param value   Actual value.\n         * @param regexp   Potential match of value.\n         * @param message   Message to display on error.\n         */\n        notMatch(expected: any, regexp: RegExp, message?: string): void;\n\n        /**\n         * Asserts that object has a property named by property.\n         *\n         * @type T   Type of object.\n         * @param object   Container object.\n         * @param property   Potential contained property of object.\n         * @param message   Message to display on error.\n         */\n        property<T>(object: T, property: string /* keyof T */, message?: string): void;\n\n        /**\n         * Asserts that object has a property named by property.\n         *\n         * @type T   Type of object.\n         * @param object   Container object.\n         * @param property   Potential contained property of object.\n         * @param message   Message to display on error.\n         */\n        notProperty<T>(object: T, property: string /* keyof T */, message?: string): void;\n\n        /**\n         * Asserts that object has a property named by property, which can be a string\n         * using dot- and bracket-notation for deep reference.\n         *\n         * @type T   Type of object.\n         * @param object   Container object.\n         * @param property   Potential contained property of object.\n         * @param message   Message to display on error.\n         */\n        deepProperty<T>(object: T, property: string, message?: string): void;\n\n        /**\n         * Asserts that object does not have a property named by property, which can be a\n         * string using dot- and bracket-notation for deep reference.\n         *\n         * @type T   Type of object.\n         * @param object   Container object.\n         * @param property   Potential contained property of object.\n         * @param message   Message to display on error.\n         */\n        notDeepProperty<T>(object: T, property: string, message?: string): void;\n\n        /**\n         * Asserts that object has a property named by property with value given by value.\n         *\n         * @type T   Type of object.\n         * @type V   Type of value.\n         * @param object   Container object.\n         * @param property   Potential contained property of object.\n         * @param value   Potential expected property value.\n         * @param message   Message to display on error.\n         */\n        propertyVal<T, V>(object: T, property: string /* keyof T */, value: V, message?: string): void;\n\n        /**\n         * Asserts that object has a property named by property with value given by value.\n         *\n         * @type T   Type of object.\n         * @type V   Type of value.\n         * @param object   Container object.\n         * @param property   Potential contained property of object.\n         * @param value   Potential expected property value.\n         * @param message   Message to display on error.\n         */\n        propertyNotVal<T, V>(object: T, property: string /* keyof T */, value: V, message?: string): void;\n\n        /**\n         * Asserts that object has a property named by property, which can be a string\n         * using dot- and bracket-notation for deep reference.\n         *\n         * @type T   Type of object.\n         * @type V   Type of value.\n         * @param object   Container object.\n         * @param property   Potential contained property of object.\n         * @param value   Potential expected property value.\n         * @param message   Message to display on error.\n         */\n        deepPropertyVal<T, V>(object: T, property: string, value: V, message?: string): void;\n\n        /**\n         * Asserts that object does not have a property named by property, which can be a\n         * string using dot- and bracket-notation for deep reference.\n         *\n         * @type T   Type of object.\n         * @type V   Type of value.\n         * @param object   Container object.\n         * @param property   Potential contained property of object.\n         * @param value   Potential expected property value.\n         * @param message   Message to display on error.\n         */\n        deepPropertyNotVal<T, V>(object: T, property: string, value: V, message?: string): void;\n\n        /**\n         * Asserts that object has a length property with the expected value.\n         *\n         * @type T   Type of object.\n         * @param object   Container object.\n         * @param length   Potential expected length of object.\n         * @param message   Message to display on error.\n         */\n        lengthOf<T extends { readonly length?: number }>(object: T, length: number, message?: string): void;\n\n        /**\n         * Asserts that fn will throw an error.\n         *\n         * @param fn   Function that may throw.\n         * @param message   Message to display on error.\n         */\n        throw(fn: Function, message?: string): void;\n\n        /**\n         * Asserts that function will throw an error with message matching regexp.\n         *\n         * @param fn   Function that may throw.\n         * @param regExp   Potential expected message match.\n         * @param message   Message to display on error.\n         */\n        throw(fn: Function, regExp: RegExp): void;\n\n        /**\n         * Asserts that function will throw an error that is an instance of constructor.\n         *\n         * @param fn   Function that may throw.\n         * @param constructor   Potential expected error constructor.\n         * @param message   Message to display on error.\n         */\n        throw(fn: Function, constructor: Function, message?: string): void;\n\n        /**\n         * Asserts that function will throw an error that is an instance of constructor\n         * and an error with message matching regexp.\n         *\n         * @param fn   Function that may throw.\n         * @param constructor   Potential expected error constructor.\n         * @param message   Message to display on error.\n         */\n        throw(fn: Function, constructor: Function, regExp: RegExp): void;\n\n        /**\n         * Asserts that fn will throw an error.\n         *\n         * @param fn   Function that may throw.\n         * @param message   Message to display on error.\n         */\n        throws(fn: Function, message?: string): void;\n\n        /**\n         * Asserts that function will throw an error with message matching regexp.\n         *\n         * @param fn   Function that may throw.\n         * @param errType  Potential expected message match or error constructor.\n         * @param message   Message to display on error.\n         */\n        throws(fn: Function, errType: RegExp|Function, message?: string): void;\n\n        /**\n         * Asserts that function will throw an error that is an instance of constructor\n         * and an error with message matching regexp.\n         *\n         * @param fn   Function that may throw.\n         * @param constructor   Potential expected error constructor.\n         * @param message   Message to display on error.\n         */\n        throws(fn: Function, errType: Function, regExp: RegExp): void;\n\n        /**\n         * Asserts that fn will throw an error.\n         *\n         * @param fn   Function that may throw.\n         * @param message   Message to display on error.\n         */\n        Throw(fn: Function, message?: string): void;\n\n        /**\n         * Asserts that function will throw an error with message matching regexp.\n         *\n         * @param fn   Function that may throw.\n         * @param regExp   Potential expected message match.\n         * @param message   Message to display on error.\n         */\n        Throw(fn: Function, regExp: RegExp): void;\n\n        /**\n         * Asserts that function will throw an error that is an instance of constructor.\n         *\n         * @param fn   Function that may throw.\n         * @param constructor   Potential expected error constructor.\n         * @param message   Message to display on error.\n         */\n        Throw(fn: Function, errType: Function, message?: string): void;\n\n        /**\n         * Asserts that function will throw an error that is an instance of constructor\n         * and an error with message matching regexp.\n         *\n         * @param fn   Function that may throw.\n         * @param constructor   Potential expected error constructor.\n         * @param message   Message to display on error.\n         */\n        Throw(fn: Function, errType: Function, regExp: RegExp): void;\n\n        /**\n         * Asserts that fn will not throw an error.\n         *\n         * @param fn   Function that may throw.\n         * @param message   Message to display on error.\n         */\n        doesNotThrow(fn: Function, message?: string): void;\n\n        /**\n         * Asserts that function will throw an error with message matching regexp.\n         *\n         * @param fn   Function that may throw.\n         * @param regExp   Potential expected message match.\n         * @param message   Message to display on error.\n         */\n        doesNotThrow(fn: Function, regExp: RegExp): void;\n\n        /**\n         * Asserts that function will throw an error that is an instance of constructor.\n         *\n         * @param fn   Function that may throw.\n         * @param constructor   Potential expected error constructor.\n         * @param message   Message to display on error.\n         */\n        doesNotThrow(fn: Function, errType: Function, message?: string): void;\n\n        /**\n         * Asserts that function will throw an error that is an instance of constructor\n         * and an error with message matching regexp.\n         *\n         * @param fn   Function that may throw.\n         * @param constructor   Potential expected error constructor.\n         * @param message   Message to display on error.\n         */\n        doesNotThrow(fn: Function, errType: Function, regExp: RegExp): void;\n\n        /**\n         * Compares two values using operator.\n         *\n         * @param val1   Left value during comparison.\n         * @param operator   Comparison operator.\n         * @param val2   Right value during comparison.\n         * @param message   Message to display on error.\n         */\n        operator(val1: OperatorComparable, operator: Operator, val2: OperatorComparable, message?: string): void;\n\n        /**\n         * Asserts that the target is equal to expected, to within a +/- delta range.\n         *\n         * @param actual   Actual value\n         * @param expected   Potential expected value.\n         * @param delta   Maximum differenced between values.\n         * @param message   Message to display on error.\n         */\n        closeTo(actual: number, expected: number, delta: number, message?: string): void;\n\n        /**\n         * Asserts that the target is equal to expected, to within a +/- delta range.\n         *\n         * @param actual   Actual value\n         * @param expected   Potential expected value.\n         * @param delta   Maximum differenced between values.\n         * @param message   Message to display on error.\n         */\n        approximately(act: number, exp: number, delta: number, message?: string): void;\n\n        /**\n         * Asserts that set1 and set2 have the same members. Order is not take into account.\n         *\n         * @type T   Type of set values.\n         * @param set1   Actual set of values.\n         * @param set2   Potential expected set of values.\n         * @param message   Message to display on error.\n         */\n        sameMembers<T>(set1: T[], set2: T[], message?: string): void;\n\n        /**\n         * Asserts that set1 and set2 have the same members using deep equality checking.\n         * Order is not take into account.\n         *\n         * @type T   Type of set values.\n         * @param set1   Actual set of values.\n         * @param set2   Potential expected set of values.\n         * @param message   Message to display on error.\n         */\n        sameDeepMembers<T>(set1: T[], set2: T[], message?: string): void;\n\n        /**\n         * Asserts that set1 and set2 have the same members in the same order.\n         * Uses a strict equality check (===).\n         *\n         * @type T   Type of set values.\n         * @param set1   Actual set of values.\n         * @param set2   Potential expected set of values.\n         * @param message   Message to display on error.\n         */\n        sameOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;\n\n        /**\n         * Asserts that set1 and set2 don’t have the same members in the same order.\n         * Uses a strict equality check (===).\n         *\n         * @type T   Type of set values.\n         * @param set1   Actual set of values.\n         * @param set2   Potential expected set of values.\n         * @param message   Message to display on error.\n         */\n        notSameOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;\n\n        /**\n         * Asserts that set1 and set2 have the same members in the same order.\n         * Uses a deep equality check.\n         *\n         * @type T   Type of set values.\n         * @param set1   Actual set of values.\n         * @param set2   Potential expected set of values.\n         * @param message   Message to display on error.\n         */\n        sameDeepOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;\n\n        /**\n         * Asserts that set1 and set2 don’t have the same members in the same order.\n         * Uses a deep equality check.\n         *\n         * @type T   Type of set values.\n         * @param set1   Actual set of values.\n         * @param set2   Potential expected set of values.\n         * @param message   Message to display on error.\n         */\n        notSameDeepOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;\n\n        /**\n         * Asserts that subset is included in superset in the same order beginning with the first element in superset.\n         * Uses a strict equality check (===).\n         *\n         * @type T   Type of set values.\n         * @param superset   Actual set of values.\n         * @param subset   Potential contained set of values.\n         * @param message   Message to display on error.\n         */\n        includeOrderedMembers<T>(superset: T[], subset: T[], message?: string): void;\n\n        /**\n         * Asserts that subset isn’t included in superset in the same order beginning with the first element in superset.\n         * Uses a strict equality check (===).\n         *\n         * @type T   Type of set values.\n         * @param superset   Actual set of values.\n         * @param subset   Potential contained set of values.\n         * @param message   Message to display on error.\n         */\n        notIncludeOrderedMembers<T>(superset: T[], subset: T[], message?: string): void;\n\n        /**\n         * Asserts that subset is included in superset in the same order beginning with the first element in superset.\n         * Uses a deep equality check.\n         *\n         * @type T   Type of set values.\n         * @param superset   Actual set of values.\n         * @param subset   Potential contained set of values.\n         * @param message   Message to display on error.\n         */\n        includeDeepOrderedMembers<T>(superset: T[], subset: T[], message?: string): void;\n\n        /**\n         * Asserts that subset isn’t included in superset in the same order beginning with the first element in superset.\n         * Uses a deep equality check.\n         *\n         * @type T   Type of set values.\n         * @param superset   Actual set of values.\n         * @param subset   Potential contained set of values.\n         * @param message   Message to display on error.\n         */\n        notIncludeDeepOrderedMembers<T>(superset: T[], subset: T[], message?: string): void;\n\n        /**\n         * Asserts that subset is included in superset. Order is not take into account.\n         *\n         * @type T   Type of set values.\n         * @param superset   Actual set of values.\n         * @param subset   Potential contained set of values.\n         * @param message   Message to display on error.\n         */\n        includeMembers<T>(superset: T[], subset: T[], message?: string): void;\n\n        /**\n         * Asserts that subset is included in superset using deep equality checking.\n         * Order is not take into account.\n         *\n         * @type T   Type of set values.\n         * @param superset   Actual set of values.\n         * @param subset   Potential contained set of values.\n         * @param message   Message to display on error.\n         */\n        includeDeepMembers<T>(superset: T[], subset: T[], message?: string): void;\n\n        /**\n         * Asserts that non-object, non-array value inList appears in the flat array list.\n         *\n         * @type T   Type of list values.\n         * @param inList   Value expected to be in the list.\n         * @param list   List of values.\n         * @param message   Message to display on error.\n         */\n        oneOf<T>(inList: T, list: T[], message?: string): void;\n\n        /**\n         * Asserts that a function changes the value of a property.\n         *\n         * @type T   Type of object.\n         * @param modifier   Function to run.\n         * @param object   Container object.\n         * @param property   Property of object expected to be modified.\n         * @param message   Message to display on error.\n         */\n        changes<T>(modifier: Function, object: T, property: string /* keyof T */, message?: string): void;\n\n        /**\n         * Asserts that a function does not change the value of a property.\n         *\n         * @type T   Type of object.\n         * @param modifier   Function to run.\n         * @param object   Container object.\n         * @param property   Property of object expected not to be modified.\n         * @param message   Message to display on error.\n         */\n        doesNotChange<T>(modifier: Function, object: T, property: string /* keyof T */, message?: string): void;\n\n        /**\n         * Asserts that a function increases an object property.\n         *\n         * @type T   Type of object.\n         * @param modifier   Function to run.\n         * @param object   Container object.\n         * @param property   Property of object expected to be increased.\n         * @param message   Message to display on error.\n         */\n        increases<T>(modifier: Function, object: T, property: string /* keyof T */, message?: string): void;\n\n        /**\n         * Asserts that a function does not increase an object property.\n         *\n         * @type T   Type of object.\n         * @param modifier   Function to run.\n         * @param object   Container object.\n         * @param property   Property of object expected not to be increased.\n         * @param message   Message to display on error.\n         */\n        doesNotIncrease<T>(modifier: Function, object: T, property: string /* keyof T */, message?: string): void;\n\n        /**\n         * Asserts that a function decreases an object property.\n         *\n         * @type T   Type of object.\n         * @param modifier   Function to run.\n         * @param object   Container object.\n         * @param property   Property of object expected to be decreased.\n         * @param message   Message to display on error.\n         */\n        decreases<T>(modifier: Function, object: T, property: string /* keyof T */, message?: string): void;\n\n        /**\n         * Asserts that a function does not decrease an object property.\n         *\n         * @type T   Type of object.\n         * @param modifier   Function to run.\n         * @param object   Container object.\n         * @param property   Property of object expected not to be decreased.\n         * @param message   Message to display on error.\n         */\n        doesNotDecrease<T>(modifier: Function, object: T, property: string /* keyof T */, message?: string): void;\n\n        /**\n         * Asserts if value is not a false value, and throws if it is a true value.\n         *\n         * @type T   Type of object.\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         * @remarks This is added to allow for chai to be a drop-in replacement for\n         *          Node’s assert class.\n         */\n        ifError<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that object is extensible (can have new properties added to it).\n         *\n         * @type T   Type of object\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         */\n        isExtensible<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that object is extensible (can have new properties added to it).\n         *\n         * @type T   Type of object\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         */\n        extensible<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that object is not extensible.\n         *\n         * @type T   Type of object\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNotExtensible<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that object is not extensible.\n         *\n         * @type T   Type of object\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         */\n        notExtensible<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that object is sealed (can have new properties added to it\n         * and its existing properties cannot be removed).\n         *\n         * @type T   Type of object\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         */\n        isSealed<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that object is sealed (can have new properties added to it\n         * and its existing properties cannot be removed).\n         *\n         * @type T   Type of object\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         */\n        sealed<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that object is not sealed.\n         *\n         * @type T   Type of object\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNotSealed<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that object is not sealed.\n         *\n         * @type T   Type of object\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         */\n        notSealed<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that object is frozen (cannot have new properties added to it\n         * and its existing properties cannot be removed).\n         *\n         * @type T   Type of object\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         */\n        isFrozen<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that object is frozen (cannot have new properties added to it\n         * and its existing properties cannot be removed).\n         *\n         * @type T   Type of object\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         */\n        frozen<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that object is not frozen (cannot have new properties added to it\n         * and its existing properties cannot be removed).\n         *\n         * @type T   Type of object\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         */\n        isNotFrozen<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that object is not frozen (cannot have new properties added to it\n         * and its existing properties cannot be removed).\n         *\n         * @type T   Type of object\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         */\n        notFrozen<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that the target does not contain any values. For arrays and\n         * strings, it checks the length property. For Map and Set instances, it\n         * checks the size property. For non-function objects, it gets the count\n         * of own enumerable string keys.\n         *\n         * @type T   Type of object\n         * @param object   Actual value.\n         * @param message   Message to display on error.\n         */\n        isEmpty<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that the target contains values. For arrays and strings, it checks\n         * the length property. For Map and Set instances, it checks the size property.\n         * For non-function objects, it gets the count of own enumerable string keys.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param message    Message to display on error.\n         */\n        isNotEmpty<T>(object: T, message?: string): void;\n\n        /**\n         * Asserts that `object` has at least one of the `keys` provided.\n         * You can also provide a single object instead of a `keys` array and its keys\n         * will be used as the expected set of keys.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param keys   Keys to check\n         * @param message    Message to display on error.\n         */\n        hasAnyKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;\n\n        /**\n         * Asserts that `object` has all and only all of the `keys` provided.\n         * You can also provide a single object instead of a `keys` array and its keys\n         * will be used as the expected set of keys.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param keys   Keys to check\n         * @param message    Message to display on error.\n         */\n        hasAllKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;\n\n        /**\n         * Asserts that `object` has all of the `keys` provided but may have more keys not listed.\n         * You can also provide a single object instead of a `keys` array and its keys\n         * will be used as the expected set of keys.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param keys   Keys to check\n         * @param message    Message to display on error.\n         */\n        containsAllKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;\n\n        /**\n         * Asserts that `object` has none of the `keys` provided.\n         * You can also provide a single object instead of a `keys` array and its keys\n         * will be used as the expected set of keys.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param keys   Keys to check\n         * @param message    Message to display on error.\n         */\n        doesNotHaveAnyKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;\n\n        /**\n         * Asserts that `object` does not have at least one of the `keys` provided.\n         * You can also provide a single object instead of a `keys` array and its keys\n         * will be used as the expected set of keys.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param keys   Keys to check\n         * @param message    Message to display on error.\n         */\n        doesNotHaveAllKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;\n\n        /**\n         * Asserts that `object` has at least one of the `keys` provided.\n         * Since Sets and Maps can have objects as keys you can use this assertion to perform\n         * a deep comparison.\n         * You can also provide a single object instead of a `keys` array and its keys\n         * will be used as the expected set of keys.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param keys   Keys to check\n         * @param message    Message to display on error.\n         */\n        hasAnyDeepKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;\n\n        /**\n         * Asserts that `object` has all and only all of the `keys` provided.\n         * Since Sets and Maps can have objects as keys you can use this assertion to perform\n         * a deep comparison.\n         * You can also provide a single object instead of a `keys` array and its keys\n         * will be used as the expected set of keys.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param keys   Keys to check\n         * @param message    Message to display on error.\n         */\n        hasAllDeepKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;\n\n        /**\n         * Asserts that `object` contains all of the `keys` provided.\n         * Since Sets and Maps can have objects as keys you can use this assertion to perform\n         * a deep comparison.\n         * You can also provide a single object instead of a `keys` array and its keys\n         * will be used as the expected set of keys.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param keys   Keys to check\n         * @param message    Message to display on error.\n         */\n        containsAllDeepKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;\n\n        /**\n         * Asserts that `object` contains all of the `keys` provided.\n         * Since Sets and Maps can have objects as keys you can use this assertion to perform\n         * a deep comparison.\n         * You can also provide a single object instead of a `keys` array and its keys\n         * will be used as the expected set of keys.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param keys   Keys to check\n         * @param message    Message to display on error.\n         */\n        doesNotHaveAnyDeepKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;\n\n        /**\n         * Asserts that `object` contains all of the `keys` provided.\n         * Since Sets and Maps can have objects as keys you can use this assertion to perform\n         * a deep comparison.\n         * You can also provide a single object instead of a `keys` array and its keys\n         * will be used as the expected set of keys.\n         *\n         * @type T   Type of object.\n         * @param object   Object to test.\n         * @param keys   Keys to check\n         * @param message    Message to display on error.\n         */\n        doesNotHaveAllDeepKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;\n    }\n\n    export interface Config {\n        /**\n         * Default: false\n         */\n        includeStack: boolean;\n\n        /**\n         * Default: true\n         */\n        showDiff: boolean;\n\n        /**\n         * Default: 40\n         */\n        truncateThreshold: number;\n    }\n\n    export class AssertionError {\n        constructor(message: string, _props?: any, ssf?: Function);\n        name: string;\n        message: string;\n        showDiff: boolean;\n        stack: string;\n    }\n}\n\ndeclare const chai: Chai.ChaiStatic;\n\ndeclare module \"chai\" {\n    export = chai;\n}\n\ninterface Object {\n    should: Chai.Assertion;\n}\n","type":2},{"name":"node_modules/@types/diff/index.d.ts","text":"// Type definitions for diff 3.2\n// Project: https://github.com/kpdecker/jsdiff\n// Definitions by: vvakame <https://github.com/vvakame>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.2\n\nexport = JsDiff;\nexport as namespace JsDiff;\n\ndeclare namespace JsDiff {\n    interface ICaseOptions {\n        ignoreCase: boolean;\n    }\n\n    interface ILinesOptions {\n        ignoreWhitespace?: boolean;\n        newlineIsToken?: boolean;\n    }\n\n    interface IDiffResult {\n        value: string;\n        count?: number;\n        added?: boolean;\n        removed?: boolean;\n    }\n\n    interface IBestPath {\n        newPos: number;\n        componenets: IDiffResult[];\n    }\n\n    interface IHunk {\n        oldStart: number;\n        oldLines: number;\n        newStart: number;\n        newLines: number;\n        lines: string[];\n    }\n\n    interface IUniDiff {\n        oldFileName: string;\n        newFileName: string;\n        oldHeader: string;\n        newHeader: string;\n        hunks: IHunk[];\n    }\n\n    class Diff {\n        ignoreWhitespace: boolean;\n\n        constructor(ignoreWhitespace?: boolean);\n\n        diff(oldString: string, newString: string): IDiffResult[];\n\n        pushComponent(components: IDiffResult[], value: string, added: boolean, removed: boolean): void;\n\n        extractCommon(basePath: IBestPath, newString: string, oldString: string, diagonalPath: number): number;\n\n        equals(left: string, right: string): boolean;\n\n        join(left: string, right: string): string;\n\n        tokenize(value: string): any; // return types are string or string[]\n    }\n\n    function diffChars(oldStr: string, newStr: string, options?: ICaseOptions): IDiffResult[];\n\n    function diffWords(oldStr: string, newStr: string, options?: ICaseOptions): IDiffResult[];\n\n    function diffWordsWithSpace(oldStr: string, newStr: string): IDiffResult[];\n\n    function diffJson(oldObj: object, newObj: object): IDiffResult[];\n\n    function diffLines(oldStr: string, newStr: string, options?: ILinesOptions): IDiffResult[];\n\n    function diffCss(oldStr: string, newStr: string): IDiffResult[];\n\n    function createPatch(fileName: string, oldStr: string, newStr: string, oldHeader: string, newHeader: string, options?: {context: number}): string;\n\n    function createTwoFilesPatch(oldFileName: string, newFileName: string, oldStr: string, newStr: string, oldHeader: string, newHeader: string, options?: {context: number}): string;\n\n    function structuredPatch(oldFileName: string, newFileName: string, oldStr: string, newStr: string, oldHeader: string, newHeader: string, options?: {context: number}): IUniDiff;\n\n    function applyPatch(oldStr: string, uniDiff: string | IUniDiff | IUniDiff[]): string;\n\n    function applyPatches(uniDiff: IUniDiff[], options: {\n        loadFile(index: number, callback: (err: Error, data: string) => void): void,\n        patched(index: number, content: string): void,\n        complete(err?: Error): void\n    }): void;\n\n    function parsePatch(diffStr: string, options?: {strict: boolean}): IUniDiff[];\n\n    function convertChangesToXML(changes: IDiffResult[]): string;\n\n    function convertChangesToDMP(changes: IDiffResult[]): Array<{0: number; 1: string; }>;\n}\n","type":2},{"name":"node_modules/@types/events/index.d.ts","text":"// Type definitions for events 1.1\n// Project: https://github.com/Gozala/events\n// Definitions by: Yasunori Ohoka <https://github.com/yasupeke>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\nexport type Listener = (...args: any[]) => void;\n\nexport class EventEmitter {\n  static listenerCount(emitter: EventEmitter, type: string | number): number;\n  static defaultMaxListeners: number;\n\n  setMaxListeners(n: number): this;\n  emit(type: string | number, ...args: any[]): boolean;\n  addListener(type: string | number, listener: Listener): this;\n  on(type: string | number, listener: Listener): this;\n  once(type: string | number, listener: Listener): this;\n  removeListener(type: string | number, listener: Listener): this;\n  removeAllListeners(type: string | number): this;\n  listeners(type: string | number): Listener[];\n  listenerCount(type: string | number): number;\n}\n","type":2},{"name":"node_modules/@types/express/index.d.ts","text":"// Type definitions for Express 4.x\r\n// Project: http://expressjs.com\r\n// Definitions by: Boris Yankov <https://github.com/borisyankov>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n// TypeScript Version: 2.2\r\n\r\n/* =================== USAGE ===================\r\n\r\n    import * as express from \"express\";\r\n    var app = express();\r\n\r\n =============================================== */\r\n\r\n/// <reference types=\"express-serve-static-core\" />\r\n/// <reference types=\"serve-static\" />\r\n\r\nimport * as bodyParser from \"body-parser\";\r\nimport * as serveStatic from \"serve-static\";\r\nimport * as core from \"express-serve-static-core\";\r\n\r\n/**\r\n * Creates an Express application. The express() function is a top-level function exported by the express module.\r\n */\r\ndeclare function e(): core.Express;\r\n\r\ndeclare namespace e {\r\n    /**\r\n     * This is a built-in middleware function in Express. It parses incoming requests with JSON payloads and is based on body-parser.\r\n     * @since 4.16.0\r\n     */\r\n    var json: typeof bodyParser.json;\r\n\r\n    /**\r\n     * This is a built-in middleware function in Express. It serves static files and is based on serve-static.\r\n     */\r\n    var static: typeof serveStatic;\r\n\r\n    /**\r\n     * This is a built-in middleware function in Express. It parses incoming requests with urlencoded payloads and is based on body-parser.\r\n     * @since 4.16.0\r\n     */\r\n    var urlencoded: typeof bodyParser.urlencoded;\r\n\r\n    export function Router(options?: RouterOptions): core.Router;\r\n\r\n    interface RouterOptions {\r\n        /**\r\n         * Enable case sensitivity.\r\n         */\r\n        caseSensitive?: boolean;\r\n\r\n        /**\r\n         * Preserve the req.params values from the parent router.\r\n         * If the parent and the child have conflicting param names, the child’s value take precedence.\r\n         *\r\n         * @default false\r\n         * @since 4.5.0\r\n         */\r\n        mergeParams?: boolean;\r\n\r\n        /**\r\n         * Enable strict routing.\r\n         */\r\n        strict?: boolean;\r\n    }\r\n\r\n    interface Application extends core.Application { }\r\n    interface CookieOptions extends core.CookieOptions { }\r\n    interface Errback extends core.Errback { }\r\n    interface ErrorRequestHandler extends core.ErrorRequestHandler { }\r\n    interface Express extends core.Express { }\r\n    interface Handler extends core.Handler { }\r\n    interface IRoute extends core.IRoute { }\r\n    interface IRouter<T> extends core.IRouter { }\r\n    interface IRouterHandler<T> extends core.IRouterHandler<T> { }\r\n    interface IRouterMatcher<T> extends core.IRouterMatcher<T> { }\r\n    interface MediaType extends core.MediaType { }\r\n    interface NextFunction extends core.NextFunction { }\r\n    interface Request extends core.Request { }\r\n    interface RequestHandler extends core.RequestHandler { }\r\n    interface RequestParamHandler extends core.RequestParamHandler { }\r\n    export interface Response extends core.Response { }\r\n    interface Router extends core.Router { }\r\n    interface Send extends core.Send { }\r\n}\r\n\r\nexport = e;\r\n","type":2},{"name":"node_modules/@types/express-serve-static-core/index.d.ts","text":"// Type definitions for Express 4.11\r\n// Project: http://expressjs.com\r\n// Definitions by: Boris Yankov <https://github.com/borisyankov>\r\n//                 Michał Lytek <https://github.com/19majkel94>\r\n//                 Kacper Polak <https://github.com/kacepe>\r\n//                 Satana Charuwichitratana <https://github.com/micksatana>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n// TypeScript Version: 2.2\r\n\r\n// This extracts the core definitions from express to prevent a circular dependency between express and serve-static\r\n/// <reference types=\"node\" />\r\n\r\ndeclare global {\r\n    namespace Express {\r\n        // These open interfaces may be extended in an application-specific manner via declaration merging.\r\n        // See for example method-override.d.ts (https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/method-override/index.d.ts)\r\n        interface Request { }\r\n        interface Response { }\r\n        interface Application { }\r\n    }\r\n}\r\n\r\nimport * as http from \"http\";\r\n\r\nexport interface NextFunction {\r\n    // tslint:disable-next-line callable-types (In ts2.1 it thinks the type alias has no call signatures)\r\n    (err?: any): void;\r\n}\r\n\r\nexport interface RequestHandler {\r\n    // tslint:disable-next-line callable-types (This is extended from and can't extend from a type alias in ts<2.2\r\n    (req: Request, res: Response, next: NextFunction): any;\r\n}\r\n\r\nexport type ErrorRequestHandler = (err: any, req: Request, res: Response, next: NextFunction) => any;\r\n\r\nexport type PathParams = string | RegExp | Array<string | RegExp>;\r\n\r\nexport type RequestHandlerParams = RequestHandler | ErrorRequestHandler | Array<RequestHandler | ErrorRequestHandler>;\r\n\r\nexport interface IRouterMatcher<T> {\r\n    (path: PathParams, ...handlers: RequestHandler[]): T;\r\n    (path: PathParams, ...handlers: RequestHandlerParams[]): T;\r\n}\r\n\r\nexport interface IRouterHandler<T> {\r\n    (...handlers: RequestHandler[]): T;\r\n    (...handlers: RequestHandlerParams[]): T;\r\n}\r\n\r\nexport interface IRouter extends RequestHandler {\r\n    /**\r\n     * Map the given param placeholder `name`(s) to the given callback(s).\r\n     *\r\n     * Parameter mapping is used to provide pre-conditions to routes\r\n     * which use normalized placeholders. For example a _:user_id_ parameter\r\n     * could automatically load a user's information from the database without\r\n     * any additional code,\r\n     *\r\n     * The callback uses the samesignature as middleware, the only differencing\r\n     * being that the value of the placeholder is passed, in this case the _id_\r\n     * of the user. Once the `next()` function is invoked, just like middleware\r\n     * it will continue on to execute the route, or subsequent parameter functions.\r\n     *\r\n     *      app.param('user_id', function(req, res, next, id){\r\n     *        User.find(id, function(err, user){\r\n     *          if (err) {\r\n     *            next(err);\r\n     *          } else if (user) {\r\n     *            req.user = user;\r\n     *            next();\r\n     *          } else {\r\n     *            next(new Error('failed to load user'));\r\n     *          }\r\n     *        });\r\n     *      });\r\n     */\r\n    param(name: string, handler: RequestParamHandler): this;\r\n\r\n    /**\r\n     * Alternatively, you can pass only a callback, in which case you have the opportunity to alter the app.param()\r\n     *\r\n     * @deprecated since version 4.11\r\n     */\r\n    param(callback: (name: string, matcher: RegExp) => RequestParamHandler): this;\r\n\r\n    /**\r\n     * Special-cased \"all\" method, applying the given route `path`,\r\n     * middleware, and callback to _every_ HTTP method.\r\n     */\r\n    all: IRouterMatcher<this>;\r\n    get: IRouterMatcher<this>;\r\n    post: IRouterMatcher<this>;\r\n    put: IRouterMatcher<this>;\r\n    delete: IRouterMatcher<this>;\r\n    patch: IRouterMatcher<this>;\r\n    options: IRouterMatcher<this>;\r\n    head: IRouterMatcher<this>;\r\n\r\n    checkout: IRouterMatcher<this>;\r\n    connect: IRouterMatcher<this>;\r\n    copy: IRouterMatcher<this>;\r\n    lock: IRouterMatcher<this>;\r\n    merge: IRouterMatcher<this>;\r\n    mkactivity: IRouterMatcher<this>;\r\n    mkcol: IRouterMatcher<this>;\r\n    move: IRouterMatcher<this>;\r\n    \"m-search\": IRouterMatcher<this>;\r\n    notify: IRouterMatcher<this>;\r\n    propfind: IRouterMatcher<this>;\r\n    proppatch: IRouterMatcher<this>;\r\n    purge: IRouterMatcher<this>;\r\n    report: IRouterMatcher<this>;\r\n    search: IRouterMatcher<this>;\r\n    subscribe: IRouterMatcher<this>;\r\n    trace: IRouterMatcher<this>;\r\n    unlock: IRouterMatcher<this>;\r\n    unsubscribe: IRouterMatcher<this>;\r\n\r\n    use: IRouterHandler<this> & IRouterMatcher<this>;\r\n\r\n    route(prefix: PathParams): IRoute;\r\n    /**\r\n     * Stack of configured routes\r\n     */\r\n    stack: any[];\r\n}\r\n\r\nexport interface IRoute {\r\n    path: string;\r\n    stack: any;\r\n    all: IRouterHandler<this>;\r\n    get: IRouterHandler<this>;\r\n    post: IRouterHandler<this>;\r\n    put: IRouterHandler<this>;\r\n    delete: IRouterHandler<this>;\r\n    patch: IRouterHandler<this>;\r\n    options: IRouterHandler<this>;\r\n    head: IRouterHandler<this>;\r\n\r\n    checkout: IRouterHandler<this>;\r\n    copy: IRouterHandler<this>;\r\n    lock: IRouterHandler<this>;\r\n    merge: IRouterHandler<this>;\r\n    mkactivity: IRouterHandler<this>;\r\n    mkcol: IRouterHandler<this>;\r\n    move: IRouterHandler<this>;\r\n    \"m-search\": IRouterHandler<this>;\r\n    notify: IRouterHandler<this>;\r\n    purge: IRouterHandler<this>;\r\n    report: IRouterHandler<this>;\r\n    search: IRouterHandler<this>;\r\n    subscribe: IRouterHandler<this>;\r\n    trace: IRouterHandler<this>;\r\n    unlock: IRouterHandler<this>;\r\n    unsubscribe: IRouterHandler<this>;\r\n}\r\n\r\nexport interface Router extends IRouter { }\r\n\r\nexport interface CookieOptions {\r\n    maxAge?: number;\r\n    signed?: boolean;\r\n    expires?: Date | boolean;\r\n    httpOnly?: boolean;\r\n    path?: string;\r\n    domain?: string;\r\n    secure?: boolean | 'auto';\r\n    encode?: (val: string) => void;\r\n    sameSite?: boolean | string;\r\n}\r\n\r\nexport interface ByteRange { start: number; end: number; }\r\n\r\nexport interface RequestRanges extends Array<ByteRange> { type: string; }\r\n\r\nexport type Errback = (err: Error) => void;\r\n\r\nexport interface Request extends http.IncomingMessage, Express.Request {\r\n    /**\r\n     * Return request header.\r\n     *\r\n     * The `Referrer` header field is special-cased,\r\n     * both `Referrer` and `Referer` are interchangeable.\r\n     *\r\n     * Examples:\r\n     *\r\n     *     req.get('Content-Type');\r\n     *     // => \"text/plain\"\r\n     *\r\n     *     req.get('content-type');\r\n     *     // => \"text/plain\"\r\n     *\r\n     *     req.get('Something');\r\n     *     // => undefined\r\n     *\r\n     * Aliased as `req.header()`.\r\n     */\r\n    get(name: \"set-cookie\"): string[] | undefined;\r\n    get(name: string): string | undefined;\r\n\r\n    header(name: \"set-cookie\"): string[] | undefined;\r\n    header(name: string): string | undefined;\r\n\r\n    /**\r\n     * Check if the given `type(s)` is acceptable, returning\r\n     * the best match when true, otherwise `undefined`, in which\r\n     * case you should respond with 406 \"Not Acceptable\".\r\n     *\r\n     * The `type` value may be a single mime type string\r\n     * such as \"application/json\", the extension name\r\n     * such as \"json\", a comma-delimted list such as \"json, html, text/plain\",\r\n     * or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\r\n     * or array is given the _best_ match, if any is returned.\r\n     *\r\n     * Examples:\r\n     *\r\n     *     // Accept: text/html\r\n     *     req.accepts('html');\r\n     *     // => \"html\"\r\n     *\r\n     *     // Accept: text/*, application/json\r\n     *     req.accepts('html');\r\n     *     // => \"html\"\r\n     *     req.accepts('text/html');\r\n     *     // => \"text/html\"\r\n     *     req.accepts('json, text');\r\n     *     // => \"json\"\r\n     *     req.accepts('application/json');\r\n     *     // => \"application/json\"\r\n     *\r\n     *     // Accept: text/*, application/json\r\n     *     req.accepts('image/png');\r\n     *     req.accepts('png');\r\n     *     // => undefined\r\n     *\r\n     *     // Accept: text/*;q=.5, application/json\r\n     *     req.accepts(['html', 'json']);\r\n     *     req.accepts('html, json');\r\n     *     // => \"json\"\r\n     */\r\n    accepts(): string[];\r\n    accepts(type: string): string | false;\r\n    accepts(type: string[]): string | false;\r\n    accepts(...type: string[]): string | false;\r\n\r\n    /**\r\n     * Returns the first accepted charset of the specified character sets,\r\n     * based on the request's Accept-Charset HTTP header field.\r\n     * If none of the specified charsets is accepted, returns false.\r\n     *\r\n     * For more information, or if you have issues or concerns, see accepts.\r\n     */\r\n    acceptsCharsets(): string[];\r\n    acceptsCharsets(charset: string): string | false;\r\n    acceptsCharsets(charset: string[]): string | false;\r\n    acceptsCharsets(...charset: string[]): string | false;\r\n\r\n    /**\r\n     * Returns the first accepted encoding of the specified encodings,\r\n     * based on the request's Accept-Encoding HTTP header field.\r\n     * If none of the specified encodings is accepted, returns false.\r\n     *\r\n     * For more information, or if you have issues or concerns, see accepts.\r\n     */\r\n    acceptsEncodings(): string[];\r\n    acceptsEncodings(encoding: string): string | false;\r\n    acceptsEncodings(encoding: string[]): string | false;\r\n    acceptsEncodings(...encoding: string[]): string | false;\r\n\r\n    /**\r\n     * Returns the first accepted language of the specified languages,\r\n     * based on the request's Accept-Language HTTP header field.\r\n     * If none of the specified languages is accepted, returns false.\r\n     *\r\n     * For more information, or if you have issues or concerns, see accepts.\r\n     */\r\n    acceptsLanguages(): string[];\r\n    acceptsLanguages(lang: string): string | false;\r\n    acceptsLanguages(lang: string[]): string | false;\r\n    acceptsLanguages(...lang: string[]): string | false;\r\n\r\n    /**\r\n     * Parse Range header field,\r\n     * capping to the given `size`.\r\n     *\r\n     * Unspecified ranges such as \"0-\" require\r\n     * knowledge of your resource length. In\r\n     * the case of a byte range this is of course\r\n     * the total number of bytes. If the Range\r\n     * header field is not given `null` is returned,\r\n     * `-1` when unsatisfiable, `-2` when syntactically invalid.\r\n     *\r\n     * NOTE: remember that ranges are inclusive, so\r\n     * for example \"Range: users=0-3\" should respond\r\n     * with 4 users when available, not 3.\r\n     */\r\n    range(size: number): RequestRanges|null|-1|-2;\r\n\r\n    /**\r\n     * Return an array of Accepted media types\r\n     * ordered from highest quality to lowest.\r\n     */\r\n    accepted: MediaType[];\r\n\r\n    /**\r\n     * @deprecated since 4.11 Use either req.params, req.body or req.query, as applicable.\r\n     *\r\n     * Return the value of param `name` when present or `defaultValue`.\r\n     *\r\n     *  - Checks route placeholders, ex: _/user/:id_\r\n     *  - Checks body params, ex: id=12, {\"id\":12}\r\n     *  - Checks query string params, ex: ?id=12\r\n     *\r\n     * To utilize request bodies, `req.body`\r\n     * should be an object. This can be done by using\r\n     * the `connect.bodyParser()` middleware.\r\n     */\r\n    param(name: string, defaultValue?: any): string;\r\n\r\n    /**\r\n     * Check if the incoming request contains the \"Content-Type\"\r\n     * header field, and it contains the give mime `type`.\r\n     *\r\n     * Examples:\r\n     *\r\n     *      // With Content-Type: text/html; charset=utf-8\r\n     *      req.is('html');\r\n     *      req.is('text/html');\r\n     *      req.is('text/*');\r\n     *      // => true\r\n     *\r\n     *      // When Content-Type is application/json\r\n     *      req.is('json');\r\n     *      req.is('application/json');\r\n     *      req.is('application/*');\r\n     *      // => true\r\n     *\r\n     *      req.is('html');\r\n     *      // => false\r\n     */\r\n    is(type: string): string | false;\r\n\r\n    /**\r\n     * Return the protocol string \"http\" or \"https\"\r\n     * when requested with TLS. When the \"trust proxy\"\r\n     * setting is enabled the \"X-Forwarded-Proto\" header\r\n     * field will be trusted. If you're running behind\r\n     * a reverse proxy that supplies https for you this\r\n     * may be enabled.\r\n     */\r\n    protocol: string;\r\n\r\n    /**\r\n     * Short-hand for:\r\n     *\r\n     *    req.protocol == 'https'\r\n     */\r\n    secure: boolean;\r\n\r\n    /**\r\n     * Return the remote address, or when\r\n     * \"trust proxy\" is `true` return\r\n     * the upstream addr.\r\n     */\r\n    ip: string;\r\n\r\n    /**\r\n     * When \"trust proxy\" is `true`, parse\r\n     * the \"X-Forwarded-For\" ip address list.\r\n     *\r\n     * For example if the value were \"client, proxy1, proxy2\"\r\n     * you would receive the array `[\"client\", \"proxy1\", \"proxy2\"]`\r\n     * where \"proxy2\" is the furthest down-stream.\r\n     */\r\n    ips: string[];\r\n\r\n    /**\r\n     * Return subdomains as an array.\r\n     *\r\n     * Subdomains are the dot-separated parts of the host before the main domain of\r\n     * the app. By default, the domain of the app is assumed to be the last two\r\n     * parts of the host. This can be changed by setting \"subdomain offset\".\r\n     *\r\n     * For example, if the domain is \"tobi.ferrets.example.com\":\r\n     * If \"subdomain offset\" is not set, req.subdomains is `[\"ferrets\", \"tobi\"]`.\r\n     * If \"subdomain offset\" is 3, req.subdomains is `[\"tobi\"]`.\r\n     */\r\n    subdomains: string[];\r\n\r\n    /**\r\n     * Short-hand for `url.parse(req.url).pathname`.\r\n     */\r\n    path: string;\r\n\r\n    /**\r\n     * Parse the \"Host\" header field hostname.\r\n     */\r\n    hostname: string;\r\n\r\n    /**\r\n     * @deprecated Use hostname instead.\r\n     */\r\n    host: string;\r\n\r\n    /**\r\n     * Check if the request is fresh, aka\r\n     * Last-Modified and/or the ETag\r\n     * still match.\r\n     */\r\n    fresh: boolean;\r\n\r\n    /**\r\n     * Check if the request is stale, aka\r\n     * \"Last-Modified\" and / or the \"ETag\" for the\r\n     * resource has changed.\r\n     */\r\n    stale: boolean;\r\n\r\n    /**\r\n     * Check if the request was an _XMLHttpRequest_.\r\n     */\r\n    xhr: boolean;\r\n\r\n    //body: { username: string; password: string; remember: boolean; title: string; };\r\n    body: any;\r\n\r\n    //cookies: { string; remember: boolean; };\r\n    cookies: any;\r\n\r\n    method: string;\r\n\r\n    params: any;\r\n\r\n    /** Clear cookie `name`. */\r\n    clearCookie(name: string, options?: any): Response;\r\n\r\n    query: any;\r\n\r\n    route: any;\r\n\r\n    signedCookies: any;\r\n\r\n    originalUrl: string;\r\n\r\n    url: string;\r\n\r\n    baseUrl: string;\r\n\r\n    app: Application;\r\n}\r\n\r\nexport interface MediaType {\r\n    value: string;\r\n    quality: number;\r\n    type: string;\r\n    subtype: string;\r\n}\r\n\r\nexport type Send = (body?: any) => Response;\r\n\r\nexport interface Response extends http.ServerResponse, Express.Response {\r\n    /**\r\n     * Set status `code`.\r\n     */\r\n    status(code: number): Response;\r\n\r\n    /**\r\n     * Set the response HTTP status code to `statusCode` and send its string representation as the response body.\r\n     * @link http://expressjs.com/4x/api.html#res.sendStatus\r\n     *\r\n     * Examples:\r\n     *\r\n     *    res.sendStatus(200); // equivalent to res.status(200).send('OK')\r\n     *    res.sendStatus(403); // equivalent to res.status(403).send('Forbidden')\r\n     *    res.sendStatus(404); // equivalent to res.status(404).send('Not Found')\r\n     *    res.sendStatus(500); // equivalent to res.status(500).send('Internal Server Error')\r\n     */\r\n    sendStatus(code: number): Response;\r\n\r\n    /**\r\n     * Set Link header field with the given `links`.\r\n     *\r\n     * Examples:\r\n     *\r\n     *    res.links({\r\n     *      next: 'http://api.example.com/users?page=2',\r\n     *      last: 'http://api.example.com/users?page=5'\r\n     *    });\r\n     */\r\n    links(links: any): Response;\r\n\r\n    /**\r\n     * Send a response.\r\n     *\r\n     * Examples:\r\n     *\r\n     *     res.send(new Buffer('wahoo'));\r\n     *     res.send({ some: 'json' });\r\n     *     res.send('<p>some html</p>');\r\n     *     res.send(404, 'Sorry, cant find that');\r\n     *     res.send(404);\r\n     */\r\n    send: Send;\r\n\r\n    /**\r\n     * Send JSON response.\r\n     *\r\n     * Examples:\r\n     *\r\n     *     res.json(null);\r\n     *     res.json({ user: 'tj' });\r\n     *     res.json(500, 'oh noes!');\r\n     *     res.json(404, 'I dont have that');\r\n     */\r\n    json: Send;\r\n\r\n    /**\r\n     * Send JSON response with JSONP callback support.\r\n     *\r\n     * Examples:\r\n     *\r\n     *     res.jsonp(null);\r\n     *     res.jsonp({ user: 'tj' });\r\n     *     res.jsonp(500, 'oh noes!');\r\n     *     res.jsonp(404, 'I dont have that');\r\n     */\r\n    jsonp: Send;\r\n\r\n    /**\r\n     * Transfer the file at the given `path`.\r\n     *\r\n     * Automatically sets the _Content-Type_ response header field.\r\n     * The callback `fn(err)` is invoked when the transfer is complete\r\n     * or when an error occurs. Be sure to check `res.sentHeader`\r\n     * if you wish to attempt responding, as the header and some data\r\n     * may have already been transferred.\r\n     *\r\n     * Options:\r\n     *\r\n     *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)\r\n     *   - `root`     root directory for relative filenames\r\n     *   - `headers`  object of headers to serve with file\r\n     *   - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\r\n     *\r\n     * Other options are passed along to `send`.\r\n     *\r\n     * Examples:\r\n     *\r\n     *  The following example illustrates how `res.sendFile()` may\r\n     *  be used as an alternative for the `static()` middleware for\r\n     *  dynamic situations. The code backing `res.sendFile()` is actually\r\n     *  the same code, so HTTP cache support etc is identical.\r\n     *\r\n     *     app.get('/user/:uid/photos/:file', function(req, res){\r\n     *       var uid = req.params.uid\r\n     *         , file = req.params.file;\r\n     *\r\n     *       req.user.mayViewFilesFrom(uid, function(yes){\r\n     *         if (yes) {\r\n     *           res.sendFile('/uploads/' + uid + '/' + file);\r\n     *         } else {\r\n     *           res.send(403, 'Sorry! you cant see that.');\r\n     *         }\r\n     *       });\r\n     *     });\r\n     *\r\n     * @api public\r\n     */\r\n    sendFile(path: string): void;\r\n    sendFile(path: string, options: any): void;\r\n    sendFile(path: string, fn: Errback): void;\r\n    sendFile(path: string, options: any, fn: Errback): void;\r\n\r\n    /**\r\n     * @deprecated Use sendFile instead.\r\n     */\r\n    sendfile(path: string): void;\r\n    /**\r\n     * @deprecated Use sendFile instead.\r\n     */\r\n    sendfile(path: string, options: any): void;\r\n    /**\r\n     * @deprecated Use sendFile instead.\r\n     */\r\n    sendfile(path: string, fn: Errback): void;\r\n    /**\r\n     * @deprecated Use sendFile instead.\r\n     */\r\n    sendfile(path: string, options: any, fn: Errback): void;\r\n\r\n    /**\r\n     * Transfer the file at the given `path` as an attachment.\r\n     *\r\n     * Optionally providing an alternate attachment `filename`,\r\n     * and optional callback `fn(err)`. The callback is invoked\r\n     * when the data transfer is complete, or when an error has\r\n     * ocurred. Be sure to check `res.headerSent` if you plan to respond.\r\n     *\r\n     * This method uses `res.sendfile()`.\r\n     */\r\n    download(path: string): void;\r\n    download(path: string, filename: string): void;\r\n    download(path: string, fn: Errback): void;\r\n    download(path: string, filename: string, fn: Errback): void;\r\n\r\n    /**\r\n     * Set _Content-Type_ response header with `type` through `mime.lookup()`\r\n     * when it does not contain \"/\", or set the Content-Type to `type` otherwise.\r\n     *\r\n     * Examples:\r\n     *\r\n     *     res.type('.html');\r\n     *     res.type('html');\r\n     *     res.type('json');\r\n     *     res.type('application/json');\r\n     *     res.type('png');\r\n     */\r\n    contentType(type: string): Response;\r\n\r\n    /**\r\n     * Set _Content-Type_ response header with `type` through `mime.lookup()`\r\n     * when it does not contain \"/\", or set the Content-Type to `type` otherwise.\r\n     *\r\n     * Examples:\r\n     *\r\n     *     res.type('.html');\r\n     *     res.type('html');\r\n     *     res.type('json');\r\n     *     res.type('application/json');\r\n     *     res.type('png');\r\n     */\r\n    type(type: string): Response;\r\n\r\n    /**\r\n     * Respond to the Acceptable formats using an `obj`\r\n     * of mime-type callbacks.\r\n     *\r\n     * This method uses `req.accepted`, an array of\r\n     * acceptable types ordered by their quality values.\r\n     * When \"Accept\" is not present the _first_ callback\r\n     * is invoked, otherwise the first match is used. When\r\n     * no match is performed the server responds with\r\n     * 406 \"Not Acceptable\".\r\n     *\r\n     * Content-Type is set for you, however if you choose\r\n     * you may alter this within the callback using `res.type()`\r\n     * or `res.set('Content-Type', ...)`.\r\n     *\r\n     *    res.format({\r\n     *      'text/plain': function(){\r\n     *        res.send('hey');\r\n     *      },\r\n     *\r\n     *      'text/html': function(){\r\n     *        res.send('<p>hey</p>');\r\n     *      },\r\n     *\r\n     *      'appliation/json': function(){\r\n     *        res.send({ message: 'hey' });\r\n     *      }\r\n     *    });\r\n     *\r\n     * In addition to canonicalized MIME types you may\r\n     * also use extnames mapped to these types:\r\n     *\r\n     *    res.format({\r\n     *      text: function(){\r\n     *        res.send('hey');\r\n     *      },\r\n     *\r\n     *      html: function(){\r\n     *        res.send('<p>hey</p>');\r\n     *      },\r\n     *\r\n     *      json: function(){\r\n     *        res.send({ message: 'hey' });\r\n     *      }\r\n     *    });\r\n     *\r\n     * By default Express passes an `Error`\r\n     * with a `.status` of 406 to `next(err)`\r\n     * if a match is not made. If you provide\r\n     * a `.default` callback it will be invoked\r\n     * instead.\r\n     */\r\n    format(obj: any): Response;\r\n\r\n    /**\r\n     * Set _Content-Disposition_ header to _attachment_ with optional `filename`.\r\n     */\r\n    attachment(filename?: string): Response;\r\n\r\n    /**\r\n     * Set header `field` to `val`, or pass\r\n     * an object of header fields.\r\n     *\r\n     * Examples:\r\n     *\r\n     *    res.set('Foo', ['bar', 'baz']);\r\n     *    res.set('Accept', 'application/json');\r\n     *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });\r\n     *\r\n     * Aliased as `res.header()`.\r\n     */\r\n    set(field: any): Response;\r\n    set(field: string, value?: string): Response;\r\n\r\n    header(field: any): Response;\r\n    header(field: string, value?: string): Response;\r\n\r\n    // Property indicating if HTTP headers has been sent for the response.\r\n    headersSent: boolean;\r\n\r\n    /** Get value for header `field`. */\r\n    get(field: string): string;\r\n\r\n    /** Clear cookie `name`. */\r\n    clearCookie(name: string, options?: any): Response;\r\n\r\n    /**\r\n     * Set cookie `name` to `val`, with the given `options`.\r\n     *\r\n     * Options:\r\n     *\r\n     *    - `maxAge`   max-age in milliseconds, converted to `expires`\r\n     *    - `signed`   sign the cookie\r\n     *    - `path`     defaults to \"/\"\r\n     *\r\n     * Examples:\r\n     *\r\n     *    // \"Remember Me\" for 15 minutes\r\n     *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\r\n     *\r\n     *    // save as above\r\n     *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })\r\n     */\r\n    cookie(name: string, val: string, options: CookieOptions): Response;\r\n    cookie(name: string, val: any, options: CookieOptions): Response;\r\n    cookie(name: string, val: any): Response;\r\n\r\n    /**\r\n     * Set the location header to `url`.\r\n     *\r\n     * The given `url` can also be the name of a mapped url, for\r\n     * example by default express supports \"back\" which redirects\r\n     * to the _Referrer_ or _Referer_ headers or \"/\".\r\n     *\r\n     * Examples:\r\n     *\r\n     *    res.location('/foo/bar').;\r\n     *    res.location('http://example.com');\r\n     *    res.location('../login'); // /blog/post/1 -> /blog/login\r\n     *\r\n     * Mounting:\r\n     *\r\n     *   When an application is mounted and `res.location()`\r\n     *   is given a path that does _not_ lead with \"/\" it becomes\r\n     *   relative to the mount-point. For example if the application\r\n     *   is mounted at \"/blog\", the following would become \"/blog/login\".\r\n     *\r\n     *      res.location('login');\r\n     *\r\n     *   While the leading slash would result in a location of \"/login\":\r\n     *\r\n     *      res.location('/login');\r\n     */\r\n    location(url: string): Response;\r\n\r\n    /**\r\n     * Redirect to the given `url` with optional response `status`\r\n     * defaulting to 302.\r\n     *\r\n     * The resulting `url` is determined by `res.location()`, so\r\n     * it will play nicely with mounted apps, relative paths,\r\n     * `\"back\"` etc.\r\n     *\r\n     * Examples:\r\n     *\r\n     *    res.redirect('/foo/bar');\r\n     *    res.redirect('http://example.com');\r\n     *    res.redirect(301, 'http://example.com');\r\n     *    res.redirect('http://example.com', 301);\r\n     *    res.redirect('../login'); // /blog/post/1 -> /blog/login\r\n     */\r\n    redirect(url: string): void;\r\n    redirect(status: number, url: string): void;\r\n    redirect(url: string, status: number): void;\r\n\r\n    /**\r\n     * Render `view` with the given `options` and optional callback `fn`.\r\n     * When a callback function is given a response will _not_ be made\r\n     * automatically, otherwise a response of _200_ and _text/html_ is given.\r\n     *\r\n     * Options:\r\n     *\r\n     *  - `cache`     boolean hinting to the engine it should cache\r\n     *  - `filename`  filename of the view being rendered\r\n     */\r\n    render(view: string, options?: Object, callback?: (err: Error, html: string) => void): void;\r\n    render(view: string, callback?: (err: Error, html: string) => void): void;\r\n\r\n    locals: any;\r\n\r\n    charset: string;\r\n\r\n    /**\r\n     * Adds the field to the Vary response header, if it is not there already.\r\n     * Examples:\r\n     *\r\n     *     res.vary('User-Agent').render('docs');\r\n     *\r\n     */\r\n    vary(field: string): Response;\r\n\r\n    app: Application;\r\n\r\n    /**\r\n     * Appends the specified value to the HTTP response header field.\r\n     * If the header is not already set, it creates the header with the specified value.\r\n     * The value parameter can be a string or an array.\r\n     *\r\n     * Note: calling res.set() after res.append() will reset the previously-set header value.\r\n     *\r\n     * @since 4.11.0\r\n     */\r\n    append(field: string, value?: string[]|string): Response;\r\n}\r\n\r\nexport interface Handler extends RequestHandler { }\r\n\r\nexport type RequestParamHandler = (req: Request, res: Response, next: NextFunction, value: any, name: string) => any;\r\n\r\nexport type ApplicationRequestHandler<T> = IRouterHandler<T> & IRouterMatcher<T> & ((...handlers: RequestHandlerParams[]) => T);\r\n\r\nexport interface Application extends IRouter, Express.Application {\r\n    /**\r\n     * Express instance itself is a request handler, which could be invoked without\r\n     * third argument.\r\n     */\r\n    (req: Request | http.IncomingMessage, res: Response | http.ServerResponse): any;\r\n\r\n    /**\r\n     * Initialize the server.\r\n     *\r\n     *   - setup default configuration\r\n     *   - setup default middleware\r\n     *   - setup route reflection methods\r\n     */\r\n    init(): void;\r\n\r\n    /**\r\n     * Initialize application configuration.\r\n     */\r\n    defaultConfiguration(): void;\r\n\r\n    /**\r\n     * Register the given template engine callback `fn`\r\n     * as `ext`.\r\n     *\r\n     * By default will `require()` the engine based on the\r\n     * file extension. For example if you try to render\r\n     * a \"foo.jade\" file Express will invoke the following internally:\r\n     *\r\n     *     app.engine('jade', require('jade').__express);\r\n     *\r\n     * For engines that do not provide `.__express` out of the box,\r\n     * or if you wish to \"map\" a different extension to the template engine\r\n     * you may use this method. For example mapping the EJS template engine to\r\n     * \".html\" files:\r\n     *\r\n     *     app.engine('html', require('ejs').renderFile);\r\n     *\r\n     * In this case EJS provides a `.renderFile()` method with\r\n     * the same signature that Express expects: `(path, options, callback)`,\r\n     * though note that it aliases this method as `ejs.__express` internally\r\n     * so if you're using \".ejs\" extensions you dont need to do anything.\r\n     *\r\n     * Some template engines do not follow this convention, the\r\n     * [Consolidate.js](https://github.com/visionmedia/consolidate.js)\r\n     * library was created to map all of node's popular template\r\n     * engines to follow this convention, thus allowing them to\r\n     * work seamlessly within Express.\r\n     */\r\n    engine(ext: string, fn: Function): Application;\r\n\r\n    /**\r\n     * Assign `setting` to `val`, or return `setting`'s value.\r\n     *\r\n     *    app.set('foo', 'bar');\r\n     *    app.get('foo');\r\n     *    // => \"bar\"\r\n     *    app.set('foo', ['bar', 'baz']);\r\n     *    app.get('foo');\r\n     *    // => [\"bar\", \"baz\"]\r\n     *\r\n     * Mounted servers inherit their parent server's settings.\r\n     */\r\n    set(setting: string, val: any): Application;\r\n    get: ((name: string) => any) & IRouterMatcher<this>;\r\n\r\n    param(name: string | string[], handler: RequestParamHandler): this;\r\n\r\n    /**\r\n     * Alternatively, you can pass only a callback, in which case you have the opportunity to alter the app.param()\r\n     *\r\n     * @deprecated since version 4.11\r\n     */\r\n    param(callback: (name: string, matcher: RegExp) => RequestParamHandler): this;\r\n\r\n    /**\r\n     * Return the app's absolute pathname\r\n     * based on the parent(s) that have\r\n     * mounted it.\r\n     *\r\n     * For example if the application was\r\n     * mounted as \"/admin\", which itself\r\n     * was mounted as \"/blog\" then the\r\n     * return value would be \"/blog/admin\".\r\n     */\r\n    path(): string;\r\n\r\n    /**\r\n     * Check if `setting` is enabled (truthy).\r\n     *\r\n     *    app.enabled('foo')\r\n     *    // => false\r\n     *\r\n     *    app.enable('foo')\r\n     *    app.enabled('foo')\r\n     *    // => true\r\n     */\r\n    enabled(setting: string): boolean;\r\n\r\n    /**\r\n     * Check if `setting` is disabled.\r\n     *\r\n     *    app.disabled('foo')\r\n     *    // => true\r\n     *\r\n     *    app.enable('foo')\r\n     *    app.disabled('foo')\r\n     *    // => false\r\n     */\r\n    disabled(setting: string): boolean;\r\n\r\n    /** Enable `setting`. */\r\n    enable(setting: string): Application;\r\n\r\n    /** Disable `setting`. */\r\n    disable(setting: string): Application;\r\n\r\n    /**\r\n     * Configure callback for zero or more envs,\r\n     * when no `env` is specified that callback will\r\n     * be invoked for all environments. Any combination\r\n     * can be used multiple times, in any order desired.\r\n     *\r\n     * Examples:\r\n     *\r\n     *    app.configure(function(){\r\n     *      // executed for all envs\r\n     *    });\r\n     *\r\n     *    app.configure('stage', function(){\r\n     *      // executed staging env\r\n     *    });\r\n     *\r\n     *    app.configure('stage', 'production', function(){\r\n     *      // executed for stage and production\r\n     *    });\r\n     *\r\n     * Note:\r\n     *\r\n     *  These callbacks are invoked immediately, and\r\n     *  are effectively sugar for the following:\r\n     *\r\n     *     var env = process.env.NODE_ENV || 'development';\r\n     *\r\n     *      switch (env) {\r\n     *        case 'development':\r\n     *          ...\r\n     *          break;\r\n     *        case 'stage':\r\n     *          ...\r\n     *          break;\r\n     *        case 'production':\r\n     *          ...\r\n     *          break;\r\n     *      }\r\n     */\r\n    configure(fn: Function): Application;\r\n    configure(env0: string, fn: Function): Application;\r\n    configure(env0: string, env1: string, fn: Function): Application;\r\n    configure(env0: string, env1: string, env2: string, fn: Function): Application;\r\n    configure(env0: string, env1: string, env2: string, env3: string, fn: Function): Application;\r\n    configure(env0: string, env1: string, env2: string, env3: string, env4: string, fn: Function): Application;\r\n\r\n    /**\r\n     * Render the given view `name` name with `options`\r\n     * and a callback accepting an error and the\r\n     * rendered template string.\r\n     *\r\n     * Example:\r\n     *\r\n     *    app.render('email', { name: 'Tobi' }, function(err, html){\r\n     *      // ...\r\n     *    })\r\n     */\r\n    render(name: string, options?: Object, callback?: (err: Error, html: string) => void): void;\r\n    render(name: string, callback: (err: Error, html: string) => void): void;\r\n\r\n    /**\r\n     * Listen for connections.\r\n     *\r\n     * A node `http.Server` is returned, with this\r\n     * application (which is a `Function`) as its\r\n     * callback. If you wish to create both an HTTP\r\n     * and HTTPS server you may do so with the \"http\"\r\n     * and \"https\" modules as shown here:\r\n     *\r\n     *    var http = require('http')\r\n     *      , https = require('https')\r\n     *      , express = require('express')\r\n     *      , app = express();\r\n     *\r\n     *    http.createServer(app).listen(80);\r\n     *    https.createServer({ ... }, app).listen(443);\r\n     */\r\n    listen(port: number, hostname: string, backlog: number, callback?: Function): http.Server;\r\n    listen(port: number, hostname: string, callback?: Function): http.Server;\r\n    listen(port: number, callback?: Function): http.Server;\r\n    listen(path: string, callback?: Function): http.Server;\r\n    listen(handle: any, listeningListener?: Function): http.Server;\r\n\r\n    router: string;\r\n\r\n    settings: any;\r\n\r\n    resource: any;\r\n\r\n    map: any;\r\n\r\n    locals: any;\r\n\r\n    /**\r\n     * The app.routes object houses all of the routes defined mapped by the\r\n     * associated HTTP verb. This object may be used for introspection\r\n     * capabilities, for example Express uses this internally not only for\r\n     * routing but to provide default OPTIONS behaviour unless app.options()\r\n     * is used. Your application or framework may also remove routes by\r\n     * simply by removing them from this object.\r\n     */\r\n    routes: any;\r\n\r\n    /**\r\n     * Used to get all registered routes in Express Application\r\n     */\r\n    _router: any;\r\n\r\n    use: ApplicationRequestHandler<this>;\r\n}\r\n\r\nexport interface Express extends Application {\r\n    request: Request;\r\n    response: Response;\r\n}\r\n","type":2},{"name":"node_modules/@types/glob/index.d.ts","text":"// Type definitions for Glob 5.0\n// Project: https://github.com/isaacs/node-glob\n// Definitions by: vvakame <https://github.com/vvakame>\n//                 voy <https://github.com/voy>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n/// <reference types=\"node\" />\n\nimport events = require(\"events\");\nimport fs = require('fs');\nimport minimatch = require(\"minimatch\");\n\ndeclare function G(pattern: string, cb: (err: Error | null, matches: string[]) => void): void;\ndeclare function G(pattern: string, options: G.IOptions, cb: (err: Error | null, matches: string[]) => void): void;\n\ndeclare namespace G {\n    function sync(pattern: string, options?: IOptions): string[];\n\n    function hasMagic(pattern: string, options?: IOptions): boolean;\n\n    let Glob: IGlobStatic;\n    let GlobSync: IGlobSyncStatic;\n\n    interface IOptions extends minimatch.IOptions {\n        cwd?: string;\n        root?: string;\n        dot?: boolean;\n        nomount?: boolean;\n        mark?: boolean;\n        nosort?: boolean;\n        stat?: boolean;\n        silent?: boolean;\n        strict?: boolean;\n        cache?: { [path: string]: any /* boolean | string | string[] */ };\n        statCache?: { [path: string]: fs.Stats };\n        symlinks?: any;\n        sync?: boolean;\n        nounique?: boolean;\n        nonull?: boolean;\n        debug?: boolean;\n        nobrace?: boolean;\n        noglobstar?: boolean;\n        noext?: boolean;\n        nocase?: boolean;\n        matchBase?: any;\n        nodir?: boolean;\n        ignore?: any; /* string | string[] */\n        follow?: boolean;\n        realpath?: boolean;\n        nonegate?: boolean;\n        nocomment?: boolean;\n        absolute?: boolean;\n\n        /** Deprecated. */\n        globDebug?: boolean;\n    }\n\n    interface IGlobStatic extends events.EventEmitter {\n        new (pattern: string, cb?: (err: Error | null, matches: string[]) => void): IGlob;\n        new (pattern: string, options: IOptions, cb?: (err: Error | null, matches: string[]) => void): IGlob;\n        prototype: IGlob;\n    }\n\n    interface IGlobSyncStatic {\n        new (pattern: string, options?: IOptions): IGlobBase;\n        prototype: IGlobBase;\n    }\n\n    interface IGlobBase {\n        minimatch: minimatch.IMinimatch;\n        options: IOptions;\n        aborted: boolean;\n        cache: { [path: string]: any /* boolean | string | string[] */ };\n        statCache: { [path: string]: fs.Stats };\n        symlinks: { [path: string]: boolean };\n        realpathCache: { [path: string]: string };\n        found: string[];\n    }\n\n    interface IGlob extends IGlobBase, events.EventEmitter {\n        pause(): void;\n        resume(): void;\n        abort(): void;\n\n        /** Deprecated. */\n        EOF: any;\n        /** Deprecated. */\n        paused: boolean;\n        /** Deprecated. */\n        maxDepth: number;\n        /** Deprecated. */\n        maxLength: number;\n        /** Deprecated. */\n        changedCwd: boolean;\n        /** Deprecated. */\n        cwd: string;\n        /** Deprecated. */\n        root: string;\n        /** Deprecated. */\n        error: any;\n        /** Deprecated. */\n        matches: string[];\n        /** Deprecated. */\n        log(...args: any[]): void;\n        /** Deprecated. */\n        emitMatch(m: any): void;\n    }\n}\n\nexport = G;\n","type":2},{"name":"node_modules/@types/http-errors/index.d.ts","text":"// Type definitions for http-errors v1.5.0\r\n// Project: https://github.com/jshttp/http-errors\r\n// Definitions by: Tanguy Krotoff <https://github.com/tkrotoff>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n\r\ndeclare module 'http-errors' {\r\n    namespace createHttpError {\r\n\r\n        // See https://github.com/jshttp/http-errors/blob/1.3.1/index.js#L42\r\n        interface HttpError extends Error {\r\n            status: number;\r\n            statusCode: number;\r\n            expose: boolean;\r\n            headers?: {\r\n                [key: string]: string\r\n            };\r\n        }\r\n\r\n        type HttpErrorConstructor = new(msg?: string) => HttpError;\r\n\r\n        interface CreateHttpError {\r\n            // See https://github.com/Microsoft/TypeScript/issues/227#issuecomment-50092674\r\n            [code: string]: new (msg?: string) => HttpError;\r\n\r\n            (...args: Array<Error | string | number | Object>): HttpError;\r\n            \r\n            HttpError: HttpErrorConstructor;\r\n\r\n            Continue: HttpErrorConstructor;\r\n            SwitchingProtocols: HttpErrorConstructor;\r\n            Processing: HttpErrorConstructor;\r\n            OK: HttpErrorConstructor;\r\n            Created: HttpErrorConstructor;\r\n            Accepted: HttpErrorConstructor;\r\n            NonAuthoritativeInformation: HttpErrorConstructor;\r\n            NoContent: HttpErrorConstructor;\r\n            ResetContent: HttpErrorConstructor;\r\n            PartialContent: HttpErrorConstructor;\r\n            MultiStatus: HttpErrorConstructor;\r\n            AlreadyReported: HttpErrorConstructor;\r\n            IMUsed: HttpErrorConstructor;\r\n            MultipleChoices: HttpErrorConstructor;\r\n            MovedPermanently: HttpErrorConstructor;\r\n            Found: HttpErrorConstructor;\r\n            SeeOther: HttpErrorConstructor;\r\n            NotModified: HttpErrorConstructor;\r\n            UseProxy: HttpErrorConstructor;\r\n            Unused: HttpErrorConstructor;\r\n            TemporaryRedirect: HttpErrorConstructor;\r\n            PermanentRedirect: HttpErrorConstructor;\r\n            BadRequest: HttpErrorConstructor;\r\n            Unauthorized: HttpErrorConstructor;\r\n            PaymentRequired: HttpErrorConstructor;\r\n            Forbidden: HttpErrorConstructor;\r\n            NotFound: HttpErrorConstructor;\r\n            MethodNotAllowed: HttpErrorConstructor;\r\n            NotAcceptable: HttpErrorConstructor;\r\n            ProxyAuthenticationRequired: HttpErrorConstructor;\r\n            RequestTimeout: HttpErrorConstructor;\r\n            Conflict: HttpErrorConstructor;\r\n            Gone: HttpErrorConstructor;\r\n            LengthRequired: HttpErrorConstructor;\r\n            PreconditionFailed: HttpErrorConstructor;\r\n            PayloadTooLarge: HttpErrorConstructor;\r\n            URITooLong: HttpErrorConstructor;\r\n            UnsupportedMediaType: HttpErrorConstructor;\r\n            RangeNotSatisfiable: HttpErrorConstructor;\r\n            ExpectationFailed: HttpErrorConstructor;\r\n            ImATeapot: HttpErrorConstructor;\r\n            MisdirectedRequest: HttpErrorConstructor;\r\n            UnprocessableEntity: HttpErrorConstructor;\r\n            Locked: HttpErrorConstructor;\r\n            FailedDependency: HttpErrorConstructor;\r\n            UnorderedCollection: HttpErrorConstructor;\r\n            UpgradeRequired: HttpErrorConstructor;\r\n            PreconditionRequired: HttpErrorConstructor;\r\n            TooManyRequests: HttpErrorConstructor;\r\n            RequestHeaderFieldsTooLarge: HttpErrorConstructor;\r\n            UnavailableForLegalReasons: HttpErrorConstructor;\r\n            InternalServerError: HttpErrorConstructor;\r\n            NotImplemented: HttpErrorConstructor;\r\n            BadGateway: HttpErrorConstructor;\r\n            ServiceUnavailable: HttpErrorConstructor;\r\n            GatewayTimeout: HttpErrorConstructor;\r\n            HTTPVersionNotSupported: HttpErrorConstructor;\r\n            VariantAlsoNegotiates: HttpErrorConstructor;\r\n            InsufficientStorage: HttpErrorConstructor;\r\n            LoopDetected: HttpErrorConstructor;\r\n            BandwidthLimitExceeded: HttpErrorConstructor;\r\n            NotExtended: HttpErrorConstructor;\r\n            NetworkAuthenticationRequired: HttpErrorConstructor;\r\n        }\r\n    }\r\n\r\n    var createHttpError: createHttpError.CreateHttpError;\r\n    export = createHttpError;\r\n}\r\n","type":2},{"name":"node_modules/@types/grunt/index.d.ts","text":"// Type definitions for Grunt 0.4.x\n// Project: http://gruntjs.com\n// Definitions by: Jeff May <https://github.com/jeffmay>, Basarat Ali Syed <https://github.com/basarat>\n// Definitions: https://github.com/jeffmay/DefinitelyTyped\n\n/// <reference types=\"node\" />\n\n/**\n * {@link https://github.com/marak/colors.js/}\n */\ninterface String {\n    yellow: string;\n    cyan: string;\n    white: string;\n    magenta: string;\n    green: string;\n    red: string;\n    grey: string;\n    blue: string;\n}\n\ndeclare namespace node {\n\n    /**\n     * {@link http://npmjs.org/doc/json.html}\n     */\n    interface NodePackage {\n        name: string;\n        version: string;\n        description?: string;\n        keywords?: string[];\n        homepage?: string;\n    }\n}\n\n/**\n * {@link https://github.com/isaacs/minimatch}\n */\ndeclare namespace minimatch {\n\n    /**\n     * A minimal matching utility options.\n     *\n     * This is the matching library used internally by npm.\n     * Eventually, it will replace the C binding in node-glob.\n     * It works by converting glob expressions into JavaScript RegExp objects.\n     */\n    interface IMinimatchOptions {\n        /*\n         All options are false by default.\n         */\n\n        /**\n         * Dump a ton of stuff to stderr.\n         */\n        debug?: boolean;\n\n        /**\n         * Do not expand {a,b} and {1..3} brace sets.\n         */\n        nobrace?: boolean;\n\n        /**\n         * Disable ** matching against multiple folder names.\n         */\n        noglobstar?: boolean;\n\n        /**\n         * Allow patterns to match filenames starting with a period,\n         * even if the pattern does not explicitly have a period in that spot.\n         */\n        // Note that by default, a/**\\/b will not match a/.d/b, unless dot is set.\n        dot?: boolean;\n\n        /**\n         * Disable \"extglob\" style patterns like +(a|b).\n         */\n        noext?: boolean;\n\n        /**\n         * Perform a case-insensitive match.\n         */\n        nocase?: boolean;\n\n        /**\n         * When a match is not found by minimatch.match, return a list containing the pattern itself.\n         * When set, an empty list is returned if there are no matches.\n         */\n        nonull?: boolean;\n\n        /**\n         * If set, then patterns without slashes will be matched against the basename of the path if it contains slashes.\n         * For example, a?b would match the path /xyz/123/acb, but not /xyz/acb/123.\n         */\n        matchBase?: boolean;\n\n        /**\n         * Suppress the behavior of treating # at the start of a pattern as a comment.\n         */\n        nocomment?: boolean;\n\n        /**\n         * Suppress the behavior of treating a leading ! character as negation.\n         */\n        nonegate?: boolean;\n\n        /**\n         * Returns from negate expressions the same as if they were not negated. (Ie, true on a hit, false on a miss.)\n         */\n        flipNegate?: boolean;\n    }\n}\n\n/* GRUNT CONFIGURATION\n *********************/\n\ndeclare namespace grunt {\n\n    namespace config {\n\n        /**\n         * {@link http://gruntjs.com/sample-gruntfile}\n         */\n        interface IProjectConfig{\n            [plugin: string]: any;\n        }\n\n        /**\n         * {@link http://gruntjs.com/api/grunt.config}\n         */\n        interface ConfigModule {\n            /**\n             * Get or set a value from the project's Grunt configuration.\n             * This method serves as an alias to other methods;\n             * if two arguments are passed, grunt.config.set is called,\n             * otherwise grunt.config.get is called.\n             */\n            (prop: string, value: any): any;\n            (prop: string): any;\n\n            /**\n             * Initialize a configuration object for the current project.\n             * The specified configObject is used by tasks and can be accessed using the grunt.config method.\n             * Nearly every project's Gruntfile will call this method.\n             */\n            init(config: IProjectConfig): void;\n\n            /**\n             * Get a value from the project's Grunt configuration.\n             * If prop is specified, that property's value is returned, or null if that property is not defined.\n             * If prop isn't specified, a copy of the entire config object is returned.\n             * Templates strings will be recursively processed using the grunt.config.process method.\n             *\n             * @note Although this accepts a generic type, you may still get the wrong typed value.\n             */\n            get<T>(prop: string): T;\n            get(): ConfigModule;\n\n            /**\n             * Process a value, recursively expanding <% %> templates (via the grunt.template.process method)\n             * in the context of the Grunt config, as they are encountered.\n             * this method is called automatically by grunt.config.get but not by grunt.config.getRaw.\n             *\n             * If any retrieved value is entirely a single '<%= foo %>' or '<%= foo.bar %>' template string,\n             * and the specified foo or foo.bar property is a non-string (and not null or undefined) value,\n             * it will be expanded to the actual value. That, combined with grunt's task system automatically\n             * flattening arrays, can be extremely useful.\n             */\n            process<T>(value: string): T;\n\n            /**\n             * Get a raw value from the project's Grunt configuration, without processing <% %> template strings.\n             * If prop is specified, that property's value is returned, or null if that property is not defined.\n             * If prop isn't specified, a copy of the entire config object is returned.\n             */\n            getRaw<T>(prop: string): T;\n\n            /**\n             * Set a value into the project's Grunt configuration.\n             * @note any specified <% %> template strings will only be processed when config data is retrieved.\n             */\n            set<T>(prop: string, value: T): T;\n\n            /**\n             * Escape '.' dots in the given propString. This should be used for property names that contain dots.\n             */\n            escape(propString: string): string;\n\n            /**\n             * Fail the current task if one or more required config properties is missing, null or undefined.\n             * One or more string or array config properties may be specified.\n             */\n            requires(prop: string, ...andProps: string[]): void;\n            requires(prop: string[], ...andProps: string[][]): void;\n\n            /**\n             * Recursively merges properties of the specified configObject into the current project configuration.\n             * You can use this method to append configuration options, targets, etc., to already defined tasks.\n             */\n            merge<T>(configObject: T): void;\n        }\n    }\n\n    namespace event {\n        /**\n         * {@link https://github.com/hij1nx/EventEmitter2}\n         */\n        interface EventModule {\n\n            /**\n             * Adds a listener to the end of the listeners array for the specified event.\n             */\n            addListener(event: string, listener: Function): EventModule;\n            on(event: string, listener: Function): EventModule;\n\n            /**\n             * Adds a listener that will be fired when any event is emitted.\n             */\n            onAny(listener: Function): EventModule;\n\n            /**\n             * Removes the listener that will be fired when any event is emitted.\n             */\n            offAny(listener: Function): EventModule;\n\n            /**\n             * Adds a one time listener for the event.\n             * The listener is invoked only the first time the event is fired, after which it is removed.\n             */\n            once(event: string, listener: Function): EventModule;\n\n            /**\n             * Adds a listener that will execute n times for the event before being removed.\n             * The listener is invoked only the first time the event is fired, after which it is removed.\n             */\n            many(event: string, timesToListen: number, listener: Function): EventModule;\n\n            /**\n             * Remove a listener from the listener array for the specified event.\n             * Caution: changes array indices in the listener array behind the listener.\n             */\n            removeListener(event: string, listener: Function): EventModule;\n            off(event: string, listener: Function): EventModule;\n\n            /**\n             * Removes all listeners, or those of the specified event.\n             */\n            removeAllListeners(event: string): EventModule;\n\n            /**\n             * By default EventEmitters will print a warning if more than 10 listeners are added to it.\n             * This is a useful default which helps finding memory leaks. Obviously not all Emitters\n             * should be limited to 10. This function allows that to be increased.\n             *\n             * Set to zero for unlimited.\n             */\n            setMaxListener(n: number): void;\n\n            /**\n             * Returns an array of listeners for the specified event.\n             * This array can be manipulated, e.g. to remove listeners.\n             */\n            listeners(event: string): Function[];\n\n            /**\n             * Returns an array of listeners that are listening for any event that is specified.\n             * This array can be manipulated, e.g. to remove listeners.\n             */\n            listenersAny(): Function[];\n\n            /**\n             * Execute each of the listeners that may be listening for the specified event name\n             * in order with the list of arguments.\n             */\n            emit(event: string, ...args: any[]): any;\n        }\n    }\n\n    namespace fail {\n\n        enum ErrorCode {\n            NoError = 0,\n            Fatal = 1,\n            MissingGruntfile = 2,\n            Task = 3,\n            Template = 4,\n            Autocomplete = 5,\n            Warning = 6,\n        }\n\n        interface FailModule {\n\n            /**\n             * Display a warning and abort Grunt immediately.\n             * Grunt will continue processing tasks if the --force command-line option was specified.\n             */\n            warn(error: string, errorCode?: ErrorCode): void;\n            warn(error: Error, errorCode?: ErrorCode): void;\n\n            /**\n             * Display a warning and abort Grunt immediately.\n             */\n            fatal(error: string, errorCode?: ErrorCode): void;\n            fatal(error: Error, errorCode?: ErrorCode): void;\n        }\n    }\n\n    namespace file {\n\n        /**\n         * {@link http://gruntjs.com/api/grunt.file#grunt.file.defaultencoding}\n         */\n        interface IFileEncodedOption {\n            encoding: string;\n        }\n\n        /**\n         * {@link http://gruntjs.com/api/grunt.file#grunt.file.copy}\n         *\n         * @see IFileWriteBufferOption\n         * @see IFileWriteStringOption\n         */\n        interface IFileWriteOptions {\n            /**\n             * These optional globbing patterns will be matched against the filepath\n             * (not the filename) using grunt.file.isMatch. If any specified globbing\n             * pattern matches, the file won't be processed via the `process` function.\n             * If `true` is specified, processing will be prevented.\n             */\n            // noProcess?: string[]\n            // noProcess?: boolean\n            noProcess?: any;\n        }\n\n        /**\n         * @see IFileWriteOptions\n         */\n        interface IFileWriteBufferOption extends grunt.file.IFileWriteOptions {\n            /**\n             * The source file contents and file path are passed into this function,\n             * whose return value will be used as the destination file's contents. If\n             * this function returns `false`, the file copy will be aborted.\n             */\n            process?: (buffer: Buffer) => boolean;\n        }\n\n        /**\n         * @see IFileWriteOptions\n         */\n        interface IFileWriteStringOption extends grunt.file.IFileWriteOptions {\n            /**\n             * The source file contents and file path are passed into this function,\n             * whose return value will be used as the destination file's contents. If\n             * this function returns `false`, the file copy will be aborted.\n             */\n            process?: (file: string) => boolean;\n        }\n\n        /**\n         * {@link http://gruntjs.com/api/grunt.file}\n         */\n        interface FileModule {\n\n            /**\n             * Set this property to change the default encoding used by all grunt.file methods.\n             * Defaults to 'utf8'.\n             *\n             * If you do have to change this value, it's recommended that you change\n             * it as early as possible inside your Gruntfile.\n             */\n            defaultEncoding: string;\n\n            /**\n             * Read and return a file's contents.\n             * Returns a string, unless options.encoding is null in which case it returns a Buffer.\n             */\n            read(filepath: string): string;\n            read(filepath: string, options: IFileEncodedOption): Buffer;\n\n            /**\n             * Read a file's contents, parsing the data as JSON and returning the result.\n             * @see FileModule.read for a list of supported options.\n             */\n            readJSON(filepath: string): any;\n            readJSON(filepath: string, options: IFileEncodedOption): Buffer;\n\n            /**\n             * Read a file's contents, parsing the data as YAML and returning the result.\n             * @see FileModule.read for a list of supported options.\n             */\n            readYAML(filepath: string): any;\n            readYAML(filepath: string, options: IFileEncodedOption): Buffer;\n\n            /**\n             * Write the specified contents to a file, creating intermediate directories if necessary.\n             * Strings will be encoded using the specified character encoding, Buffers will be written to disk as-specified.\n             *\n             * @param contents If `contents` is a Buffer, encoding is ignored.\n             * @param options If an encoding is not specified, default to grunt.file.defaultEncoding.\n             */\n            write(filepath: string, contents: string, options?: IFileEncodedOption): void;\n            write(filepath: string, contents: Buffer): void;\n\n            /**\n             * Copy a source file to a destination path, creating intermediate directories if necessary.\n             */\n            copy(srcpath: string, destpath: string): void;\n            copy(srcpath: string, destpath: string, options: IFileWriteStringOption): void;\n            copy(srcpath: string, destpath: string, options: IFileWriteBufferOption): void;\n\n            /**\n             * Delete the specified filepath. Will delete files and folders recursively.\n             *\n             * @return true if the files could be deleted, otherwise false.\n             */\n            delete(filepath: string, options?: { force?: boolean }): boolean;\n\n            /**\n             * Works like mkdir -p. Create a directory along with any intermediate directories.\n             * If mode isn't specified, it defaults to 0777 & (~process.umask()).\n             */\n            mkdir(dirpath: string, mode?: string): void;\n\n            /**\n             * Recurse into a directory, executing callback for each file.\n             *\n             * Callback args:\n             * abspath  - The full path to the current file,\n             *            which is nothing more than the rootdir + subdir + filename arguments, joined.\n             * rootdir  - The root director, as originally specified.\n             * subdir   - The current file's directory, relative to rootdir.\n             * filename - The filename of the current file, without any directory parts.\n             */\n            recurse(\n                rootdir: string,\n                callback: (abspath: string, rootdir: string, subdir: string, filename: string) => void\n            ): void;\n\n            /**\n             * Return a unique array of all file or directory paths that match the given globbing pattern(s).\n             * This method accepts either comma separated globbing patterns or an array of globbing patterns.\n             * Paths matching patterns that begin with ! will be excluded from the returned array.\n             * Patterns are processed in order, so inclusion and exclusion order is significant.\n             *\n             * File paths are relative to the Gruntfile unless the current working directory is changed with\n             * grunt.file.setBase or the --base command-line option.\n             */\n            expand(patterns: string[]): string[];\n            expand(options: IFilesConfig, patterns: string[]): string[];\n\n            /**\n             * Returns an array of src-dest file mapping objects.\n             * For each source file matched by a specified pattern, join that file path to the specified dest.\n             * This file path may be flattened or renamed, depending on the options specified.\n             *\n             * @see FileModule.expand method documentation for an explanation of how the patterns\n             *      and options arguments may be specified.\n             */\n            expandMapping(patterns: string[], dest: string, options: IExpandedFilesConfig): Array<IFileMap>;\n\n            /**\n             * Match one or more globbing patterns against one or more file paths.\n             * Returns a uniqued array of all file paths that match any of the specified globbing patterns.\n             * Both the patterns and filepaths argument can be a single string or array of strings.\n             * Paths matching patterns that begin with ! will be excluded from the returned array.\n             * Patterns are processed in order, so inclusion and exclusion order is significant.\n             */\n            match(pattern: string, filepath: string): string[];\n            match(pattern: string, filepaths: string[]): string[];\n            match(patterns: string[], filepath: string): string[];\n            match(patterns: string[], filepaths: string[]): string[];\n            match(options: minimatch.IMinimatchOptions, pattern: string, filepath: string): string[];\n            match(options: minimatch.IMinimatchOptions, pattern: string, filepaths: string[]): string[];\n            match(options: minimatch.IMinimatchOptions, patterns: string[], filepath: string): string[];\n            match(options: minimatch.IMinimatchOptions, patterns: string[], filepaths: string[]): string[];\n\n            /**\n             * This method contains the same signature and logic as the grunt.file.match method,\n             * but simply returns true if any files were matched, otherwise false.\n             *\n             * @see FileModule.match\n             */\n            isMatch(pattern: string, filepath: string): boolean;\n            isMatch(pattern: string, filepaths: string[]): boolean;\n            isMatch(patterns: string[], filepath: string): boolean;\n            isMatch(patterns: string[], filepaths: string[]): boolean;\n            isMatch(options: minimatch.IMinimatchOptions, pattern: string, filepath: string): boolean;\n            isMatch(options: minimatch.IMinimatchOptions, pattern: string, filepaths: string[]): boolean;\n            isMatch(options: minimatch.IMinimatchOptions, patterns: string[], filepath: string): boolean;\n            isMatch(options: minimatch.IMinimatchOptions, patterns: string[], filepaths: string[]): boolean;\n\n\n            /*\n             * Like the Node.js path.join method, the methods below will\n             * join all arguments together and normalize the resulting path.\n             */\n\n            /**\n             * Does the given path exist?\n             */\n            exists(path: string, ...append: string[]): boolean;\n\n            /**\n             * Is the given path a symbolic link?\n             */\n            isLink(path: string, ...append: string[]): boolean;\n\n            /**\n             * Is the given path a symbolic link?\n             */\n            isDir(path: string, ...append: string[]): boolean;\n\n            /**\n             * Is the given path a file?\n             */\n            isFile(path: string, ...append: string[]): boolean;\n\n            /**\n             * Is a given file path absolute?\n             */\n            isPathAbsolute(path: string, ...append: string[]): boolean;\n\n            /**\n             * Do all the specified paths refer to the same path?\n             */\n            arePathsEquivalent(path: string, ...append: string[]): boolean;\n\n            /**\n             * Are all descendant path(s) contained within the specified ancestor path?\n             */\n            doesPathContain(ancestorPath: string, decendantPaths: string[]): boolean;\n\n            /**\n             * Is a given file path the current working directory (CWD)?\n             */\n            isPathCwd(path: string, ...append: string[]): boolean;\n\n            /**\n             * Change grunt's current working directory (CWD).\n             * By default, all file paths are relative to the Gruntfile.\n             * This works just like the --base command-line option.\n             */\n            setBase(path: string, ...append: string[]): void;\n\n            // External libraries\n            // TODO: Create declarations\n            glob: any;\n            minimatch: any;\n            findup: any;\n        }\n\n        /**\n         * A convenience type.\n         *\n         * {@link http://gruntjs.com/configuring-tasks#files}\n         */\n        interface IFilesArray extends Array<IFilesConfig> {}\n\n        /**\n         * {@link http://gruntjs.com/configuring-tasks#files}\n         */\n        interface IFilesConfig extends minimatch.IMinimatchOptions {\n\n            /**\n             * Pattern(s) to match, relative to the {@link IExpandedFilesConfig.cwd}.\n             */\n            src?: string[];\n\n            /**\n             * Destination path prefix.\n             */\n            dest?: string;\n\n            /**\n             * Process a dynamic src-dest file mapping,\n             * @see {@link http://gruntjs.com/configuring-tasks#building-the-files-object-dynamically for more information.\n            */\n            expand?: boolean; // = false\n\n            /**\n             * Either a valid fs.Stats method name:\n             * - isFile\n             * - isDirectory\n             * - isBlockDevice\n             * - isCharacterDevice\n             * - isSymbolicLink\n             * - isFIFO\n             * - isSocket\n             *\n             * or a function that is passed the matched src filepath and returns true or false.\n             *\n             * string\n             * (src: string) => boolean\n             */\n            // filter?: string\n            // filter?: (src: string) => boolean\n            filter?: any;\n        }\n\n        /**\n         * These are valid for compact-format\n         */\n        interface IExpandedFilesConfig extends IFilesConfig {\n\n            /**\n             * Enables the following options\n             */\n            expand?: boolean; // = true\n\n            /**\n             * All {@link IExpandedFilesConfig.src} matches are relative to (but don't include) this path.\n             */\n            cwd?: string;\n\n            /**\n             * Replace any existing extension with this value in generated {@link IExpandedFilesConfig.dest} paths.\n             */\n            ext?: string;\n\n            /**\n             * Remove all path parts from generated {@link IExpandedFilesConfig.dest} paths.\n             */\n            flatten?: boolean;\n\n            /**\n             * This function is called for each matched src file, (after extension renaming and flattening).\n             * The {@link IExpandedFilesConfig.dest} and matched {@link IExpandedFilesConfig.src} path are passed in,\n             * and this function must return a new dest value.\n             * If the same dest is returned more than once, each src which used it will be added to an array of sources for it.\n             */\n            rename?: Function;\n        }\n\n        /**\n         * @see {@link http://gruntjs.com/configuring-tasks#files-array-format}\n         */\n        interface IFileMap {\n            /**\n             * source filenames.\n             */\n            src: string[];\n            /**\n             * destination filename.\n             */\n            dest: string;\n        }\n    }\n\n    namespace log {\n\n        /**\n         * Grunt output should look consistent, and maybe even pretty.\n         * As such, there is a plethora of logging methods, and a few useful patterns.\n         * All of the methods that actually log something are chainable.\n         */\n        interface CommonLogging<T> {\n\n            /**\n             * Log the specified msg string, with no trailing newline.\n             */\n            write(msg: string): T;\n\n            /**\n             * Log the specified msg string, with trailing newline.\n             */\n            writeln(msg: string): T;\n\n            /**\n             * If msg string is omitted, logs ERROR in red,\n             * otherwise logs >> msg, with trailing newline.\n             */\n            error(msg: string): T;\n\n            /**\n             * Log an error with grunt.log.error, wrapping text to 80 columns using grunt.log.wraptext.\n             */\n            errorlns(msg: string): T;\n\n            /**\n             * If msg string is omitted, logs OK in green, otherwise logs >> msg, with trailing newline.\n             */\n            ok(msg: string): T;\n\n            /**\n             * Log an ok message with grunt.log.ok, wrapping text to 80 columns using grunt.log.wraptext.\n             */\n            oklns(msg: string): T;\n\n            /**\n             * Log the specified msg string in bold, with trailing newline.\n             */\n            subhead(msg: string): T;\n\n            /**\n             * Log a list of obj properties (good for debugging flags).\n             */\n            writeflags(obj: any): T;\n\n            /**\n             * Log an warning with grunt.log.warn\n             */\n            warn(msg: string): T;\n        }\n\n        /**\n         * @note all methods available under grunt.verbose work exactly like grunt.log methods,\n         *       but only log if the --verbose command-line option was specified.\n         */\n        interface VerboseLogModule extends CommonLogging<VerboseLogModule> {\n            or: NotVerboseLogModule;\n        }\n\n        /**\n         * @note all methods available under grunt.verbose work exactly like grunt.log methods,\n         *       but only log if the --verbose command-line option was not specified.\n         */\n        interface NotVerboseLogModule extends CommonLogging<NotVerboseLogModule> {\n            or: VerboseLogModule;\n        }\n\n        /**\n         * {@link http://gruntjs.com/api/grunt.log}\n         */\n        interface LogModule extends CommonLogging<LogModule> {\n            verbose: VerboseLogModule;\n            notverbose: NotVerboseLogModule;\n        }\n    }\n\n    namespace option {\n\n        /**\n         * {@link http://gruntjs.com/api/grunt.option}\n         */\n        interface OptionModule {\n\n            /**\n             * Gets or sets an option.\n             * Boolean options can be negated by prepending no- onto the key. For example:\n             *\n             * grunt.option('staging', false);\n             * var isDev = grunt.option('no-staging');\n             * assert(isDev === true)\n             */\n            <T>(key: string, value: T): void;\n            <T>(key: string): T;\n\n            /**\n             * Initialize grunt.option.\n             * If initObject is omitted option will be initialized to an empty object\n             * otherwise will be set to initObject.\n             */\n            init(initObject?: any): void;\n\n            /**\n             * Returns the options as an array of command line parameters.\n             */\n            flags: grunt.IFlag[];\n        }\n\n    }\n\n    namespace task {\n\n        /**\n         * {@link http://gruntjs.com/api/grunt.task}\n         */\n        interface CommonTaskModule {\n\n            /**\n             * If a task list is specified, the new task will be an alias for one or more other tasks.\n             * Whenever this \"alias task\" is run, every specified task in taskList will be run, in the order specified.\n             * The taskList argument must be an array of tasks.\n             */\n            registerTask(taskName: string, taskList: string[]): void;\n            registerTask(taskName: string, description: string, taskList: string[]): void;\n\n            /**\n             * If a description and taskFunction are passed, the specified function will be executed\n             * whenever the task is run.\n             *\n             * In addition, the specified description will be shown when grunt --help is run.\n             * Task-specific properties and methods are available inside the task function as properties\n             * of the this object. The task function can return false to indicate that the task has failed.\n             *\n             * @note taskFunction.apply(scope: grunt.task.ITask, args: any[])\n             */\n            registerTask(taskName: string, taskFunction: (this: ITask, ...args: any[]) => void): void;\n            registerTask(taskName: string, description: string, taskFunction: (this: ITask, ...args: any[]) => void): void;\n\n            /**\n             * Register a \"multi task.\" A multi task is a task that implicitly iterates over all of its\n             * named sub-properties (AKA targets) if no target was specified.\n             * In addition to the default properties and methods, extra multi task-specific properties\n             * are available inside the task function as properties of the this object.\n             *\n             * @note taskFunction.apply(scope: grunt.task.IMultiTask<any>, args: any[])\n             */\n            registerMultiTask(taskName: string, taskFunction: (this: IMultiTask<any>, ...args: any[]) => void): void;\n            registerMultiTask(taskName: string, taskDescription: string, taskFunction: (this: IMultiTask<any>, ...args: any[]) => void): void;\n\n            /**\n             * Check with the name, if a task exists in the registered tasks.\n             * @param name The task name to check.\n             * @since 0.4.5\n             */\n            exists(name: string): boolean;\n\n            /**\n             * Rename a task. This might be useful if you want to override the default behavior of a task, while retaining the old name.\n             * Note that if a task has been renamed, the this.name and this.nameArgs properties will change accordingly.\n             * @see ITask\n             * @param oldname The previous name of the task.\n             * @param newname The new name for the task.\n             */\n            renameTask(oldname: string, newname: string): void;\n        }\n\n        /**\n         * {@link http://gruntjs.com/api/grunt.task#queueing-tasks}\n         */\n        interface TaskModule extends CommonTaskModule {\n            /**\n             * Enqueue one or more tasks.\n             * Every specified task in taskList will be run immediately after the current task completes,\n             * in the order specified. The task list can be an array of tasks or individual task arguments.\n             */\n            run(tasks: string[]): void;\n            run(task: string, ...thenTasks: string[]): void;\n\n            /**\n             * Empty the task queue completely. Unless additional tasks are enqueued, no more tasks will be run.\n             */\n            clearQueue(): void;\n\n            /**\n             * Normalizes a task target configuration object into an array of src-dest file mappings.\n             * This method is used internally by the multi task system this.files / grunt.task.current.files property.\n             */\n            normalizeMultiTaskFiles(data: grunt.config.IProjectConfig, targetname?: string): Array<grunt.file.IFileMap>;\n\n            /**\n             * The currently running task or multitask.\n             * @see http://gruntjs.com/api/inside-tasks\n             */\n            current: grunt.task.IMultiTask<any>;\n        }\n\n        interface AsyncResultCatcher {\n            /**\n             * Either false or an Error object may be passed to the done function\n             * to instruct Grunt that the task has failed.\n             */\n            (success: boolean): void;\n            (error: Error): void;\n            (result: any): void;\n            (): void;\n        }\n\n        /**\n         * @link http://gruntjs.com/inside-tasks\n         *\n         * Grunt version 0.4.x\n         */\n        interface ITask {\n\n            /**\n             * If a task is asynchronous, this method must be invoked to instruct Grunt to wait.\n             * It returns a handle to a \"done\" function that should be called when the task has completed.\n             *\n             *   // Tell Grunt this task is asynchronous.\n             *   var done = this.async();\n             *   // Your async code.\n             *   setTimeout(function() {\n             *     // Let's simulate an error, sometimes.\n             *     var success = Math.random() > 0.5;\n             *     // All done!\n             *     done(success);\n             *   }, 1000);\n             */\n            async(): AsyncResultCatcher;\n\n            /**\n             * If one task depends on the successful completion of another task (or tasks),\n             * this method can be used to force Grunt to abort if the other task didn't run,\n             * or if the other task failed.\n             *\n             * @param tasks an array of task names or individual task names, as arguments.\n             * @note that this won't actually run the specified task(s),\n             * it will just fail the current task if they haven't already run successfully.\n             */\n            requires(tasks: string[]): void\n            requires(tasks: string, ...otherTasks: string[]): void\n            requires(tasks: string[], ...otherTasks: string[][]): void\n\n            /**\n             * Fail the current task if one or more required config properties is missing.\n             * One or more string or array config properties may be specified.\n             * this.requiresConfig(prop [, prop [, ...]])\n             */\n            requiresConfig(prop: string, ...andProps: string[]): void;\n\n            /**\n             * The name of the task, as defined in grunt.registerTask.\n             * For example, if a \"sample\" task was run as grunt sample or grunt sample:foo,\n             * inside the task function, this.name would be \"sample\".\n             */\n            name: string;\n\n            /**\n             * The name of the task, including any colon-separated arguments or flags specified on the command-line.\n             * For example, if a \"sample\" task was run as grunt sample:foo,\n             * inside the task function, this.nameArgs would be \"sample:foo\".\n             */\n            nameArgs: string;\n\n            /**\n             * An array of arguments passed to the task.\n             * For example, if a \"sample\" task was run as grunt sample:foo:bar,\n             * inside the task function, this.args would be [\"foo\", \"bar\"].\n             */\n            args: string[];\n\n            /**\n             * An object generated from the arguments passed to the task.\n             * For example, if a \"sample\" task was run as grunt sample:foo:bar,\n             * inside the task function, this.flags would be {foo: true, bar: true}.\n             */\n            flags: grunt.IFlag[];\n\n            /**\n             * The number of grunt.log.error calls that occurred during this task.\n             * This can be used to fail a task if errors were logged during the task.\n             */\n            errorCount: number;\n\n            /**\n             * Returns an options object.\n             * Properties of the optional defaultsObj argument will be overridden by any task-level options\n             * object properties, which will be further overridden in multi tasks by any target-level\n             * options object properties.\n             */\n            options<T>(defaultsObj: T): T;\n            options(defaultsObj: any): ITaskOptions;\n        }\n\n        /**\n         * {@link http://gruntjs.com/inside-tasks#inside-multi-tasks}\n         */\n        interface IMultiTask<T> extends ITask {\n            /**\n             * In a multi task, this property contains the name of the target currently being iterated over.\n             * For example, if a \"sample\" multi task was run as grunt sample:foo with the config data\n             * {sample: {foo: \"bar\"}}, inside the task function, this.target would be \"foo\".\n             */\n            target: string;\n\n            /**\n             * In a multi task, all files specified using any Grunt-supported file formats and options,\n             * globbing patterns or dynamic mappings will automatically be normalized into a single format:\n             * the Files Array file format.\n             *\n             * What this means is that tasks don't need to contain a ton of boilerplate for explicitly\n             * handling custom file formats, globbing patterns, mapping source files to destination files\n             * or filtering out files or directories. A task user can just specify files per the Configuring\n             * tasks guide, and Grunt will handle all the details.\n             *\n             * Your task should iterate over the this.files array, utilizing the src and dest properties of\n             * each object in that array. The this.files property will always be an array.\n             * The src property will also always be an array, in case your task cares about multiple source\n             * files per destination file.\n             *\n             * @note it's possible that nonexistent files might be included in src values,\n             *       so you may want to explicitly test that source files exist before using them.\n             */\n            files: grunt.file.IFilesArray;\n\n            /**\n             * In a multi task, all src files files specified via any file format are reduced to a single array.\n             * If your task is \"read only\" and doesn't care about destination filepaths,\n             * use this array instead of this.files.\n             */\n            filesSrc: string[];\n\n            /**\n             * In a multi task, this is the actual data stored in the Grunt config object for the given target.\n             * For example, if a \"sample\" multi task was run as grunt sample:foo with the config data\n             * {sample: {foo: \"bar\"}}, inside the task function, this.data would be \"bar\".\n             *\n             * @note It is recommended that this.options this.files and this.filesSrc are used instead of this.data,\n             *       as their values are normalized.\n             */\n            data: T;\n        }\n\n        /**\n         * {@link http://gruntjs.com/configuring-tasks}\n         *\n         * A TaskConfig can be either be a full config or a compacted files config.\n         * @see ITaskCompactOptions\n         */\n        interface ITaskOptions {\n\n            options?: any;\n\n            // files?: grunt.file.IFilesArray\n            // files?: grunt.file.IFilesMap\n            files?: any;\n        }\n\n        /**\n         * @see ITaskOptions\n         */\n        interface ITaskCompactOptions extends grunt.task.ITaskOptions, grunt.file.IFilesConfig {}\n    }\n\n    namespace template {\n\n        interface TemplateModule {\n\n            /**\n             * Process a Lo-Dash template string.\n             *\n             * The template argument will be processed recursively until there are no more templates to process.\n             *\n             * The default data object is the entire config object, but if options.data is set, that object will\n             * be used instead. The default template delimiters are <% %> but if options.delimiters is set to a\n             * custom delimiter name, those template delimiters will be used instead.\n             *\n             * Inside templates, the grunt object is exposed so that you can do things like:\n             *     <%= grunt.template.today('yyyy') %>\n             *\n             * @note if the data object already has a grunt property, the grunt API will not be accessible in templates.\n             */\n            process(template: string): (options: any) => string;\n            process(template: string, options: any): string;\n\n            /**\n             * Set the Lo-Dash template delimiters to a predefined set in case you grunt.util._.template\n             * needs to be called manually.\n             *\n             * The config delimiters <% %> are included by default.\n             */\n            setDelimiters(name: string): void;\n\n            /**\n             * Add a named set of Lo-Dash template delimiters.\n             *\n             * You probably won't need to use this method, because the built-in delimiters should be sufficient,\n             * but you could always add {% %} or [% %] style delimiters.\n             */\n            addDelimiters(name: string, opener: string, closer: string): void;\n\n            /**\n             * Format a date using the dateformat library.\n             * {@link https://github.com/felixge/node-dateformat}\n             *\n             * @note if you don't include the mask argument, dateFormat.masks.default is used\n             */\n            date(date?: Date, format?: string): string;\n            date(date?: number, format?: string): string;\n            date(date?: string, format?: string): string;\n\n            /**\n             * Format today's date using the dateformat library using the current date and time.\n             * {@link https://github.com/felixge/node-dateformat}\n             *\n             * @note if you don't include the mask argument, dateFormat.masks.default is used\n             */\n            today(format?: string): string;\n        }\n    }\n\n    namespace util {\n\n        /**\n         * {@link http://gruntjs.com/api/grunt.util}\n         */\n        interface UtilModule {\n\n            /**\n             * Return the \"kind\" of a value. Like typeof but returns the internal [Class](Class/) value.\n             * Possible results are \"number\", \"string\", \"boolean\", \"function\", \"regexp\", \"array\", \"date\",\n             * \"error\", \"null\", \"undefined\" and the catch-all \"object\".\n             */\n            kindOf(value: any): string;\n\n            /**\n             * Return a new Error instance (that can be thrown) with the appropriate message.\n             * If an Error object is specified instead of message that object will be returned.\n             * Also, if an Error object is specified for origError and Grunt was run with the --debug 9 option,\n             * the original Error stack will be dumped.\n             */\n            error(message: string, origError?: Error): Error;\n            error(error: Error, origError?: Error): Error;\n            error(error: any, origError?: Error): Error;\n\n            /**\n             * The linefeed character, normalized for the current operating system.\n             * (\\r\\n on Windows, \\n otherwise)\n             */\n            linefeed: string;\n\n            /**\n             * Given a string, return a new string with all the linefeeds normalized for the current operating system.\n             * (\\r\\n on Windows, \\n otherwise)\n             */\n            normalizelf(str: string): string;\n\n            /**\n             * Recurse through nested objects and arrays, executing callbackFunction for each non-object value.\n             * If continueFunction returns false, a given object or value will be skipped.\n             */\n            recurse(object: any, callbackFunction: (value: any) => void, continueFunction: (objOrValue: any) => boolean): void;\n\n            /**\n             * Return string str repeated n times.\n             */\n            repeat(n: number, str: string): string;\n\n            /**\n             * Given str of \"a/b\", If n is 1, return \"a\" otherwise \"b\".\n             * You can specify a custom separator if '/' doesn't work for you.\n             */\n            pluralize(n: number, str: string, separator?: string): string;\n\n            /**\n             * Spawn a child process, keeping track of its stdout, stderr and exit code.\n             * The method returns a reference to the spawned child.\n             * When the child exits, the done function is called.\n             *\n             * @param done a function with arguments:\n             *        error  - If the exit code was non-zero and a fallback wasn't specified,\n             *                 an Error object, otherwise null.\n             *        result - The result object is an\n             *        code   - The numeric exit code.\n             */\n            spawn(options: ISpawnOptions, done: (error: Error, result: ISpawnResult, code: number) => void): ISpawnedChild;\n\n            /**\n             * Given an array or array-like object, return an array.\n             * Great for converting arguments objects into arrays.\n             */\n            toArray<T>(arrayLikeObject: any): T[];\n\n            /**\n             * Normalizes both \"returns a value\" and \"passes result to a callback\" functions to always\n             * pass a result to the specified callback. If the original function returns a value,\n             * that value will now be passed to the callback, which is specified as the last argument,\n             * after all other predefined arguments. If the original function passed a value to a callback,\n             * it will continue to do so.\n             */\n            callbackify<R>(syncOrAsyncFunction: () => R):\n                (callback: (result: R) => void) => void;\n            callbackify<A, R>(syncOrAsyncFunction: (a: A) => R):\n                (a: A, callback: (result: R) => void) => void;\n            callbackify<A, B, R>(syncOrAsyncFunction: (a: A, b: B) => R):\n                (a: A, b: B, callback: (result: R) => void) => void;\n            callbackify<A, B, C, R>(syncOrAsyncFunction: (a: A, b: B, c: C) => R):\n                (a: A, b: B, c: C, callback: (result: R) => void) => void;\n            callbackify<A, B, C, D, R>(syncOrAsyncFunction: (a: A, b: B, c: C, d: D) => R):\n                (a: A, b: B, c: C, d: D, callback: (result: R) => void) => void;\n\n            // Internal libraries\n            namespace: any\n            task: any\n        }\n\n        /**\n         * {@link http://gruntjs.com/api/grunt.util#grunt.util.spawn}\n         */\n        interface ISpawnOptions {\n\n            /**\n             * The command to execute. It should be in the system path.\n             */\n            cmd?: string;\n\n            /**\n             * If specified, the same grunt bin that is currently running will be\n             * spawned as the child command, instead of the \"cmd\" option.\n             * Defaults to false.\n             */\n            grunt?: boolean;\n\n            /**\n             * An array of arguments to pass to the command.\n             */\n            args?: string[];\n\n            /**\n             * Additional options for the Node.js child_process spawn method.\n             */\n            opts?: {\n                cwd?: string;\n                stdio?: any;\n                custom?: any;\n                env?: any;\n                detached?: boolean;\n            }\n\n            /**\n             * If this value is set and an error occurs, it will be used as the value\n             * and null will be passed as the error value.\n             */\n            fallback?: any;\n        }\n\n        /**\n         * @note When result is coerced to a string, the value is stdout if the exit code\n         *       was zero, the fallback if the exit code was non-zero and a fallback was\n         *       specified, or stderr if the exit code was non-zero and a fallback was\n         *       not specified.\n         */\n        interface ISpawnResult {\n            stdout: string;\n            stderr: string;\n            code: number;\n        }\n\n        /**\n         * {@link https://github.com/snbartell/node-spawn}\n         */\n        interface ISpawnedChild {\n            /**\n             * Start the cmd with the options provided.\n             */\n            start(): void;\n\n            /**\n             * Convenience function. Overrides options. restarts to 0.\n             * Runs command exactly once no matter the options passed into the constructor.\n             */\n            once(): void;\n\n            /**\n             * Convenience function. Overrides options.restarts to -1.\n             * Runs command indefinitely no matter the options passed into the constructor.\n             */\n            forever(): void;\n\n            /**\n             * Shut down the child and don't let it restart.\n             */\n            kill(): void;\n        }\n    }\n\n    /*\n     * Common interfaces\n     */\n\n    interface IFlag {\n        [flag: string]: boolean;\n    }\n\n    /*\n     * Grunt module mixins.\n     */\n\n    interface IConfigComponents extends grunt.config.ConfigModule {\n        /**\n         * An alias\n         * @see grunt.config.ConfigModule.init\n         */\n        initConfig(config: grunt.config.IProjectConfig): void;\n    }\n\n    interface ITaskComponents extends grunt.task.CommonTaskModule {\n        /**\n         * Load task-related files from the specified directory, relative to the Gruntfile.\n         * This method can be used to load task-related files from a local Grunt plugin by\n         * specifying the path to that plugin's \"tasks\" subdirectory.\n         */\n        loadTasks(tasksPath: string): void;\n\n        /**\n         * Load tasks from the specified Grunt plugin.\n         * This plugin must be installed locally via npm, and must be relative to the Gruntfile.\n         * Grunt plugins can be created by using the grunt-init gruntplugin template: grunt init:gruntplugin.\n         */\n        loadNpmTasks(pluginName: string): void;\n    }\n}\n\n/* GRUNT MODULE\n **************/\n\n/**\n * The main Grunt module.\n *\n * {@link http://gruntjs.com/api/grunt}\n */\ninterface IGrunt extends grunt.IConfigComponents, grunt.fail.FailModule, grunt.ITaskComponents {\n\n    config: grunt.config.ConfigModule;\n\n    event: grunt.event.EventModule;\n\n    fail: grunt.fail.FailModule;\n\n    file: grunt.file.FileModule;\n\n    log: grunt.log.LogModule;\n\n    option: grunt.option.OptionModule;\n\n    task: grunt.task.TaskModule;\n\n    template: grunt.template.TemplateModule;\n\n    util: grunt.util.UtilModule;\n\n    /**\n     * The current Grunt package.json metadata, as an object.\n     */\n    package: node.NodePackage;\n\n    /**\n     * The current Grunt version, as a string. This is just a shortcut to the grunt.package.version property.\n     */\n    version: string\n}\n\n// NodeJS Support\ndeclare module 'grunt' {\n    var grunt: IGrunt;\n    export = grunt;\n}\n","type":2},{"name":"node_modules/@types/istanbul-lib-coverage/index.d.ts","text":"// Type definitions for istanbul-lib-coverage 1.1\r\n// Project: https://github.com/istanbuljs/istanbuljs\r\n// Definitions by: Jason Cheatham <https://github.com/jason0x43>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n// TypeScript Version: 2.4\r\n\r\nexport interface CoverageSummary {\r\n\tlines: Totals;\r\n\tstatements: Totals;\r\n\tbranches: Totals;\r\n\tfunctions: Totals;\r\n}\r\n\r\nexport interface CoverageMapData {\r\n\t[key: string]: FileCoverage;\r\n}\r\n\r\nexport class CoverageMap {\r\n\tconstructor(data: CoverageMapData);\r\n\taddFileCoverage(pathOrObject: string | FileCoverageData): void;\r\n\tfiles(): string[];\r\n\tfileCoverageFor(filename: string): FileCoverage;\r\n\tfilter(callback: (key: string) => boolean): void;\r\n\tmerge(data: CoverageMapData | CoverageMap): void;\r\n\ttoJSON(): object;\r\n\tdata: CoverageMapData;\r\n}\r\n\r\nexport interface Location {\r\n\tline: number;\r\n\tcolumn: number;\r\n}\r\n\r\nexport interface Range {\r\n\tstart: Location;\r\n\tend: Location;\r\n}\r\n\r\nexport interface BranchMapping {\r\n\tloc: Range;\r\n\ttype: string;\r\n\tlocations: Range[];\r\n\tline: number;\r\n}\r\n\r\nexport interface FunctionMapping {\r\n\tname: string;\r\n\tdecl: Range;\r\n\tloc: Range;\r\n\tline: number;\r\n}\r\n\r\nexport interface FileCoverageData {\r\n\tpath: string;\r\n\tstatementMap: { [key: string]: Range };\r\n\tfnMap: { [key: string]: FunctionMapping };\r\n\tbranchMap: { [key: string]: BranchMapping };\r\n\ts: { [key: string]: number };\r\n\tf: { [key: string]: number };\r\n\tb: { [key: string]: number[] };\r\n}\r\n\r\nexport interface Totals {\r\n\ttotal: number;\r\n\tcovered: number;\r\n\tskipped: number;\r\n\tpct: number;\r\n}\r\n\r\nexport interface Coverage {\r\n\tcovered: number;\r\n\ttotal: number;\r\n\tcoverage: number;\r\n}\r\n\r\nexport class FileCoverage implements FileCoverageData {\r\n\tconstructor(data: string | FileCoverageData);\r\n\tmerge(other: FileCoverageData): void;\r\n\tgetBranchCoverageByLine(): { [line: number]: Coverage };\r\n\tgetLineCoverage(): { [line: number]: number };\r\n\tgetUncoveredLines(): number[];\r\n\tresetHits(): void;\r\n\tcomputeBranchTotals(): Totals;\r\n\tcomputeSimpleTotals(): Totals;\r\n\ttoSummary(): CoverageSummary;\r\n\ttoJSON(): object;\r\n\r\n\tdata: FileCoverageData;\r\n\tpath: string;\r\n\tstatementMap: { [key: string]: Range };\r\n\tfnMap: { [key: string]: FunctionMapping };\r\n\tbranchMap: { [key: string]: BranchMapping };\r\n\ts: { [key: string]: number };\r\n\tf: { [key: string]: number };\r\n\tb: { [key: string]: number[] };\r\n}\r\n\r\nexport const classes: {\r\n\tFileCoverage: FileCoverage;\r\n};\r\n\r\nexport function createCoverageMap(data?: CoverageMap | CoverageMapData): CoverageMap;\r\nexport function createCoverageSummary(obj?: CoverageSummary): CoverageSummary;\r\nexport function createFileCoverage(pathOrObject: string | FileCoverageData): FileCoverage;\r\n","type":2},{"name":"node_modules/@types/istanbul-lib-hook/index.d.ts","text":"// Type definitions for istanbul-lib-hook 1.0\r\n// Project: https://github.com/istanbuljs/istanbuljs\r\n// Definitions by: Jason Cheatham <https://github.com/jason0x43>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n// TypeScript Version: 2.4\r\n\r\nexport interface Options {\r\n\tverbose: boolean;\r\n}\r\n\r\nexport interface HookRequireOptions extends Options {\r\n\textensions: string[];\r\n\tpostLoadHook(filename: string): void;\r\n}\r\n\r\nexport function hookRequire(\r\n\tmatcher: Matcher,\r\n\ttransformer: Transformer,\r\n\toptions?: Partial<HookRequireOptions>\r\n): () => void;\r\n\r\nexport function hookCreateScript(\r\n\tmatcher: Matcher,\r\n\ttransformer: Transformer,\r\n\toptions?: Partial<Options>\r\n): void;\r\n\r\nexport function unhookCreateScript(): void;\r\n\r\nexport function hookRunInThisContext(\r\n\tmatcher: Matcher,\r\n\ttransformer: Transformer,\r\n\toptions?: Partial<Options>\r\n): void;\r\n\r\nexport function unhookRunInThisContext(): void;\r\n\r\nexport function unloadRequireCache(matcher: Matcher): void;\r\n\r\nexport type Matcher = (filename: string) => boolean;\r\nexport type Transformer = (code: string, filepath: string) => string;\r\n","type":2},{"name":"node_modules/@types/istanbul-lib-instrument/index.d.ts","text":"// Type definitions for istanbul-lib-instrument 1.7\n// Project: https://github.com/istanbuljs/istanbuljs\n// Definitions by: Jason Cheatham <https://github.com/jason0x43>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.4\n\nimport { FileCoverage, FileCoverageData, Range } from 'istanbul-lib-coverage';\nimport { RawSourceMap } from 'source-map';\nimport * as babelTypes from 'babel-types';\n\nexport interface InstrumenterOptions {\n\tcoverageVariable: string;\n\tpreserveComments: boolean;\n\tcompact: boolean;\n\tesModules: boolean;\n\tautoWrap: boolean;\n\tproduceSourceMap: boolean;\n\tsourceMapUrlCallback(filename: string, url: string): void;\n\tdebug: boolean;\n}\n\nexport type InstrumenterCallback = (error: Error | null, code: string) => void;\n\nexport class Instrumenter {\n\tfileCoverage: FileCoverage;\n\tsourceMap: RawSourceMap | null;\n\topts: InstrumenterOptions;\n\n\tconstructor(options?: Partial<InstrumenterOptions>);\n\n\tnormalizeOpts(options?: Partial<InstrumenterOptions>): InstrumenterOptions;\n\n\tinstrumentSync(\n\t\tcode: string,\n\t\tfilename: string,\n\t\tinputSourceMap?: RawSourceMap\n\t): string;\n\n\tinstrument(\n\t\tcode: string,\n\t\tfilenameOrCallback: string | InstrumenterCallback,\n\t\tcallback?: InstrumenterCallback,\n\t\tinputSourceMap?: RawSourceMap\n\t): void;\n\n\tlastFileCoverage(): FileCoverageData;\n\tlastSourceMap(): RawSourceMap;\n}\n\nexport function createInstrumenter(\n\toptions?: Partial<InstrumenterOptions>\n): Instrumenter;\n\nexport interface InitialCoverage {\n\tpath: string;\n\thash: string;\n\tgcv: any;\n\tcoverageData: any;\n}\n\nexport function readInitialCoverage(code: string): InitialCoverage;\n\nexport interface Visitor {\n\tenter(path: string): void;\n\texit(path: string): { fileCoverage: FileCoverage; sourceMappingURL: string };\n}\n\nexport interface VisitorOptions {\n\tcoverageVariable: string;\n\tinputSourceMap: RawSourceMap;\n}\n\nexport function programVisitor(\n\ttypes: typeof babelTypes,\n\tsourceFilePath?: string,\n\topts?: Partial<VisitorOptions>\n): Visitor;\n","type":2},{"name":"node_modules/@types/istanbul-lib-report/index.d.ts","text":"// Type definitions for istanbul-lib-report 1.1\r\n// Project: https://github.com/istanbuljs/istanbuljs\r\n// Definitions by: Jason Cheatham <https://github.com/jason0x43>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n// TypeScript Version: 2.4\r\n\r\nimport { CoverageMap, FileCoverage, CoverageSummary } from 'istanbul-lib-coverage';\r\n\r\nexport function createContext(options?: Partial<ContextOptions>): Context;\r\nexport function getDefaultWatermarks(): Watermarks;\r\n\r\nexport const summarizers: {\r\n\tflat(coverageMap: CoverageMap): Tree;\r\n\tnested(coverageMap: CoverageMap): Tree;\r\n\tpkg(coverageMap: CoverageMap): Tree;\r\n};\r\n\r\nexport interface ContextOptions {\r\n\tdir: string;\r\n\twatermarks: Watermarks;\r\n\tsourceFinder(filepath: string): string;\r\n}\r\n\r\nexport interface Context extends ContextOptions {\r\n\tdata: any;\r\n\twriter: FileWriter;\r\n}\r\n\r\nexport interface ContentWriter {\r\n\twrite(str: string): void;\r\n\tcolorize(str: string, cls?: string): string;\r\n\tprintln(str: string): void;\r\n\tclose(): void;\r\n}\r\n\r\nexport interface FileWriter {\r\n\twriteForDir(subdir: string): FileWriter;\r\n\tcopyFile(source: string, dest: string): void;\r\n\twriteFile(file: string | null): ContentWriter;\r\n}\r\n\r\nexport interface Watermarks {\r\n\tstatements: number[];\r\n\tfunctions: number[];\r\n\tbranches: number[];\r\n\tlines: number[];\r\n}\r\n\r\nexport interface Node {\r\n\tgetQualifiedName(): string;\r\n\tgetRelativeName(): string;\r\n\tisRoot(): boolean;\r\n\tgetParent(): Node;\r\n\tgetChildren(): Node[];\r\n\tisSummary(): boolean;\r\n\tgetCoverageSummary(filesOnly: boolean): CoverageSummary;\r\n\tgetFileCoverage(): FileCoverage;\r\n\tvisit(visitor: Visitor, state: any): void;\r\n}\r\n\r\nexport interface ReportNode extends Node {\r\n\tpath: string;\r\n\tparent: ReportNode | null;\r\n\tfileCoverage: FileCoverage;\r\n\tchildren: ReportNode[];\r\n\taddChild(child: ReportNode): void;\r\n\tasRelative(p: string): string;\r\n\tvisit(visitor: Visitor<ReportNode>, state: any): void;\r\n}\r\n\r\nexport interface Visitor<N extends Node = Node> {\r\n\tonStart(root: N, state: any): void;\r\n\tonSummary(root: N, state: any): void;\r\n\tonDetail(root: N, state: any): void;\r\n\tonSummaryEnd(root: N, state: any): void;\r\n\tonEnd(root: N, state: any): void;\r\n}\r\n\r\nexport interface Tree<N extends Node = Node> {\r\n\tgetRoot(): N;\r\n\tvisit(visitor: Partial<Visitor<N>>, state: any): void;\r\n}\r\n","type":2},{"name":"node_modules/@types/istanbul-lib-source-maps/index.d.ts","text":"// Type definitions for istanbul-lib-source-maps 1.2\n// Project: https://github.com/istanbuljs/istanbuljs\n// Definitions by: Jason Cheatham <https://github.com/jason0x43>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.4\n\nimport { CoverageMap } from 'istanbul-lib-coverage';\nimport { RawSourceMap } from 'source-map';\n\nexport function createSourceMapStore(\n\toptions?: Partial<MapStoreOptions>\n): MapStore;\n\nexport interface MapStoreOptions {\n\tverbose: boolean;\n\tbaseDir: string;\n\tsourceStore: 'memory' | 'file';\n\ttmpdir: string;\n}\n\nexport interface MapStore {\n\tbaseDir: string | null;\n\tverbose: boolean;\n\tsourceStore: SourceStore;\n\tdata: {\n\t\t[filepath: string]: {\n\t\t\ttype: string;\n\t\t\tdata: any;\n\t\t};\n\t};\n\n\tregisterURL(transformedFilePath: string, sourceMapUrl: string): void;\n\tregisterMap(filename: string, sourceMap: RawSourceMap): void;\n\ttransformCoverage(\n\t\tcoverageMap: CoverageMap\n\t): { map: CoverageMap; sourceFinder(path: string): string };\n\tdispose(): void;\n}\n\nexport class SourceStore {\n\tgetSource(filepath: string): string | null;\n\tregisterSource(filepath: string, sourceText: string): void;\n}\n","type":2},{"name":"node_modules/@types/istanbul-reports/index.d.ts","text":"// Type definitions for istanbul-reports 1.1\r\n// Project: https://github.com/istanbuljs/istanbuljs\r\n// Definitions by: Jason Cheatham <https://github.com/jason0x43>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n// TypeScript Version: 2.4\r\n\r\nimport { Context, Node, FileWriter, Visitor } from 'istanbul-lib-report';\r\nimport { CoverageSummary } from 'istanbul-lib-coverage';\r\n\r\nexport function create<T extends keyof ReportOptions>(\r\n\tname: T,\r\n\toptions?: Partial<ReportOptions[T]>\r\n): Visitor;\r\n\r\nexport interface ReportOptions {\r\n\tclover: RootedOptions;\r\n\tcobertura: RootedOptions;\r\n\thtml: HtmlOptions;\r\n\tjson: Options;\r\n\t'json-summary': Options;\r\n\tlcov: never;\r\n\tlcovonly: Options;\r\n\tnone: RootedOptions;\r\n\tteamcity: Options & { blockName: string };\r\n\ttext: Options & { maxCols: number };\r\n\t'text-lcov': Options;\r\n\t'text-summary': Options;\r\n}\r\n\r\nexport type ReportType = keyof ReportOptions;\r\n\r\nexport interface Options {\r\n\tfile: string;\r\n}\r\n\r\nexport interface RootedOptions extends Options {\r\n\tprojectRoot: string;\r\n}\r\n\r\nexport interface HtmlOptions {\r\n\tverbose: boolean;\r\n\tlinkMapper: LinkMapper;\r\n\tsubdir: string;\r\n}\r\n\r\nexport interface LinkMapper {\r\n\tgetPath(node: string | Node): string;\r\n\trelativePath(source: string | Node, target: string | Node): string;\r\n\tassetPath(node: Node, name: string): string;\r\n}\r\n","type":2},{"name":"node_modules/@types/jszip/index.d.ts","text":"// Type definitions for JSZip\r\n// Project: http://stuk.github.com/jszip/\r\n// Definitions by: mzeiher <https://github.com/mzeiher>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n\r\ninterface JSZip {\r\n    files: {[key: string]: JSZipObject};\r\n\r\n    /**\r\n     * Get a file from the archive\r\n     *\r\n     * @param Path relative path to file\r\n     * @return File matching path, null if no file found\r\n     */\r\n    file(path: string): JSZipObject;\r\n\r\n    /**\r\n     * Get files matching a RegExp from archive\r\n     *\r\n     * @param path RegExp to match\r\n     * @return Return all matching files or an empty array\r\n     */\r\n    file(path: RegExp): JSZipObject[];\r\n\r\n    /**\r\n     * Add a file to the archive\r\n     *\r\n     * @param path Relative path to file\r\n     * @param content Content of the file\r\n     * @param options Optional information about the file\r\n     * @return JSZip object\r\n     */\r\n    file(path: string, data: any, options?: JSZipFileOptions): JSZip;\r\n\r\n    /**\r\n     * Return an new JSZip instance with the given folder as root\r\n     *\r\n     * @param name Name of the folder\r\n     * @return New JSZip object with the given folder as root or null\r\n     */\r\n    folder(name: string): JSZip;\r\n\r\n    /**\r\n     * Returns new JSZip instances with the matching folders as root\r\n     *\r\n     * @param name RegExp to match\r\n     * @return New array of JSZipFile objects which match the RegExp\r\n     */\r\n    folder(name: RegExp): JSZipObject[];\r\n\r\n    /**\r\n     * Call a callback function for each entry at this folder level.\r\n     *\r\n     * @param callback function\r\n     */\r\n    forEach(callback: (relativePath: string, file: JSZipObject) => void): void;\r\n\r\n    /**\r\n     * Get all files wchich match the given filter function\r\n     *\r\n     * @param predicate Filter function\r\n     * @return Array of matched elements\r\n     */\r\n    filter(predicate: (relativePath: string, file: JSZipObject) => boolean): JSZipObject[];\r\n\r\n    /**\r\n     * Removes the file or folder from the archive\r\n     *\r\n     * @param path Relative path of file or folder\r\n     * @return Returns the JSZip instance\r\n     */\r\n    remove(path: string): JSZip;\r\n\r\n    /**\r\n     * @deprecated since version 3.0\r\n     * @see {@link generateAsync}\r\n     * http://stuk.github.io/jszip/documentation/upgrade_guide.html\r\n     */\r\n    generate(options?: JSZipGeneratorOptions): any;\r\n\r\n    /**\r\n     * Generates a new archive asynchronously\r\n     *\r\n     * @param options Optional options for the generator\r\n     * @return The serialized archive\r\n     */\r\n    generateAsync(options?: JSZipGeneratorOptions, onUpdate?: Function): Promise<any>;\r\n\r\n    /**\r\n     * @deprecated since version 3.0\r\n     * @see {@link loadAsync}\r\n     * http://stuk.github.io/jszip/documentation/upgrade_guide.html\r\n     */\r\n    load(): void;\r\n\r\n    /**\r\n     * Deserialize zip file asynchronously\r\n     *\r\n     * @param data Serialized zip file\r\n     * @param options Options for deserializing\r\n     * @return Returns promise\r\n     */\r\n    loadAsync(data: any, options?: JSZipLoadOptions): Promise<JSZip>;\r\n}\r\n\r\ntype Serialization = (\"string\" | \"text\" | \"base64\" | \"binarystring\" | \"uint8array\" |\r\n                      \"arraybuffer\" | \"blob\" | \"nodebuffer\");\r\n\r\ninterface JSZipObject {\r\n    name: string;\r\n    dir: boolean;\r\n    date: Date;\r\n    comment: string;\r\n    options: JSZipObjectOptions;\r\n\r\n    /**\r\n     * Prepare the content in the asked type.\r\n     * @param {String} type the type of the result.\r\n     * @param {Function} onUpdate a function to call on each internal update.\r\n     * @return Promise the promise of the result.\r\n     */\r\n    async(type: Serialization, onUpdate?: Function): Promise<any>;\r\n\r\n    /**\r\n     * @deprecated since version 3.0\r\n     */\r\n    asText(): void;\r\n    /**\r\n     * @deprecated since version 3.0\r\n     */\r\n    asBinary(): void;\r\n    /**\r\n     * @deprecated since version 3.0\r\n     */\r\n    asArrayBuffer(): void;\r\n    /**\r\n     * @deprecated since version 3.0\r\n     */\r\n    asUint8Array(): void;\r\n    //asNodeBuffer(): void;\r\n}\r\n\r\ninterface JSZipFileOptions {\r\n    base64?: boolean;\r\n    binary?: boolean;\r\n    date?: Date;\r\n    compression?: string;\r\n    comment?: string;\r\n    optimizedBinaryString?: boolean;\r\n    createFolders?: boolean;\r\n    dir?: boolean;\r\n}\r\n\r\ninterface JSZipObjectOptions {\r\n    /** deprecated */\r\n    base64: boolean;\r\n    /** deprecated */\r\n    binary: boolean;\r\n    /** deprecated */\r\n    dir: boolean;\r\n    /** deprecated */\r\n    date: Date;\r\n    compression: string;\r\n}\r\n\r\ninterface JSZipGeneratorOptions {\r\n    /** deprecated */\r\n    base64?: boolean;\r\n    /** DEFLATE or STORE */\r\n    compression?: string;\r\n    /** base64 (default), string, uint8array, arraybuffer, blob */\r\n    type?: string;\r\n    comment?: string;\r\n    /**\r\n     * mime-type for the generated file.\r\n     * Useful when you need to generate a file with a different extension, ie: “.ods”.\r\n     */\r\n    mimeType?: string;\r\n    /** streaming uses less memory */\r\n    streamFiles?: boolean;\r\n    /** DOS (default) or UNIX */\r\n    platform?: string;\r\n}\r\n\r\ninterface JSZipLoadOptions {\r\n    base64?: boolean;\r\n    checkCRC32?: boolean;\r\n    optimizedBinaryString?: boolean;\r\n    createFolders?: boolean;\r\n}\r\n\r\ninterface JSZipSupport {\r\n    arraybuffer: boolean;\r\n    uint8array: boolean;\r\n    blob: boolean;\r\n    nodebuffer: boolean;\r\n}\r\n\r\ndeclare var JSZip: {\r\n    /**\r\n     * Create JSZip instance\r\n     */\r\n    (): JSZip;\r\n    /**\r\n     * Create JSZip instance\r\n     * If no parameters given an empty zip archive will be created\r\n     *\r\n     * @param data Serialized zip archive\r\n     * @param options Description of the serialized zip archive\r\n     */\r\n    (data: any, options?: JSZipLoadOptions): JSZip;\r\n\r\n    /**\r\n     * Create JSZip instance\r\n     */\r\n    new (): JSZip;\r\n    /**\r\n     * Create JSZip instance\r\n     * If no parameters given an empty zip archive will be created\r\n     *\r\n     * @param data Serialized zip archive\r\n     * @param options Description of the serialized zip archive\r\n     */\r\n    new (data: any, options?: JSZipLoadOptions): JSZip;\r\n\r\n    prototype: JSZip;\r\n    support: JSZipSupport;\r\n}\r\n\r\ndeclare module \"jszip\" {\r\n    export = JSZip;\r\n}\r\n","type":2},{"name":"node_modules/@types/lodash/add.d.ts","text":"import { add } from \"./index\";\nexport = add;\n","type":2},{"name":"node_modules/@types/lodash/after.d.ts","text":"import { after } from \"./index\";\nexport = after;\n","type":2},{"name":"node_modules/@types/lodash/ary.d.ts","text":"import { ary } from \"./index\";\nexport = ary;\n","type":2},{"name":"node_modules/@types/lodash/assign.d.ts","text":"import { assign } from \"./index\";\nexport = assign;\n","type":2},{"name":"node_modules/@types/lodash/assignIn.d.ts","text":"import { assignIn } from \"./index\";\nexport = assignIn;\n","type":2},{"name":"node_modules/@types/lodash/assignInWith.d.ts","text":"import { assignInWith } from \"./index\";\nexport = assignInWith;\n","type":2},{"name":"node_modules/@types/lodash/assignWith.d.ts","text":"import { assignWith } from \"./index\";\nexport = assignWith;\n","type":2},{"name":"node_modules/@types/lodash/at.d.ts","text":"import { at } from \"./index\";\nexport = at;\n","type":2},{"name":"node_modules/@types/lodash/attempt.d.ts","text":"import { attempt } from \"./index\";\nexport = attempt;\n","type":2},{"name":"node_modules/@types/lodash/before.d.ts","text":"import { before } from \"./index\";\nexport = before;\n","type":2},{"name":"node_modules/@types/lodash/bind.d.ts","text":"import { bind } from \"./index\";\nexport = bind;\n","type":2},{"name":"node_modules/@types/lodash/bindAll.d.ts","text":"import { bindAll } from \"./index\";\nexport = bindAll;\n","type":2},{"name":"node_modules/@types/lodash/bindKey.d.ts","text":"import { bindKey } from \"./index\";\nexport = bindKey;\n","type":2},{"name":"node_modules/@types/lodash/camelCase.d.ts","text":"import { camelCase } from \"./index\";\nexport = camelCase;\n","type":2},{"name":"node_modules/@types/lodash/capitalize.d.ts","text":"import { capitalize } from \"./index\";\nexport = capitalize;\n","type":2},{"name":"node_modules/@types/lodash/castArray.d.ts","text":"import { castArray } from \"./index\";\nexport = castArray;\n","type":2},{"name":"node_modules/@types/lodash/ceil.d.ts","text":"import { ceil } from \"./index\";\nexport = ceil;\n","type":2},{"name":"node_modules/@types/lodash/chain.d.ts","text":"import { chain } from \"./index\";\nexport = chain;\n","type":2},{"name":"node_modules/@types/lodash/chunk.d.ts","text":"import { chunk } from \"./index\";\nexport = chunk;\n","type":2},{"name":"node_modules/@types/lodash/clamp.d.ts","text":"import { clamp } from \"./index\";\nexport = clamp;\n","type":2},{"name":"node_modules/@types/lodash/clone.d.ts","text":"import { clone } from \"./index\";\nexport = clone;\n","type":2},{"name":"node_modules/@types/lodash/cloneDeep.d.ts","text":"import { cloneDeep } from \"./index\";\nexport = cloneDeep;\n","type":2},{"name":"node_modules/@types/lodash/cloneDeepWith.d.ts","text":"import { cloneDeepWith } from \"./index\";\nexport = cloneDeepWith;\n","type":2},{"name":"node_modules/@types/lodash/cloneWith.d.ts","text":"import { cloneWith } from \"./index\";\nexport = cloneWith;\n","type":2},{"name":"node_modules/@types/lodash/compact.d.ts","text":"import { compact } from \"./index\";\nexport = compact;\n","type":2},{"name":"node_modules/@types/lodash/concat.d.ts","text":"import { concat } from \"./index\";\nexport = concat;\n","type":2},{"name":"node_modules/@types/lodash/cond.d.ts","text":"import { cond } from \"./index\";\nexport = cond;\n","type":2},{"name":"node_modules/@types/lodash/conformsTo.d.ts","text":"import { conformsTo } from \"./index\";\nexport = conformsTo;\n","type":2},{"name":"node_modules/@types/lodash/constant.d.ts","text":"import { constant } from \"./index\";\nexport = constant;\n","type":2},{"name":"node_modules/@types/lodash/countBy.d.ts","text":"import { countBy } from \"./index\";\nexport = countBy;\n","type":2},{"name":"node_modules/@types/lodash/create.d.ts","text":"import { create } from \"./index\";\nexport = create;\n","type":2},{"name":"node_modules/@types/lodash/curry.d.ts","text":"import { curry } from \"./index\";\nexport = curry;\n","type":2},{"name":"node_modules/@types/lodash/curryRight.d.ts","text":"import { curryRight } from \"./index\";\nexport = curryRight;\n","type":2},{"name":"node_modules/@types/lodash/debounce.d.ts","text":"import { debounce } from \"./index\";\nexport = debounce;\n","type":2},{"name":"node_modules/@types/lodash/deburr.d.ts","text":"import { deburr } from \"./index\";\nexport = deburr;\n","type":2},{"name":"node_modules/@types/lodash/defaults.d.ts","text":"import { defaults } from \"./index\";\nexport = defaults;\n","type":2},{"name":"node_modules/@types/lodash/defaultsDeep.d.ts","text":"import { defaultsDeep } from \"./index\";\nexport = defaultsDeep;\n","type":2},{"name":"node_modules/@types/lodash/defaultTo.d.ts","text":"import { defaultTo } from \"./index\";\nexport = defaultTo;\n","type":2},{"name":"node_modules/@types/lodash/defer.d.ts","text":"import { defer } from \"./index\";\nexport = defer;\n","type":2},{"name":"node_modules/@types/lodash/delay.d.ts","text":"import { delay } from \"./index\";\nexport = delay;\n","type":2},{"name":"node_modules/@types/lodash/difference.d.ts","text":"import { difference } from \"./index\";\nexport = difference;\n","type":2},{"name":"node_modules/@types/lodash/differenceBy.d.ts","text":"import { differenceBy } from \"./index\";\nexport = differenceBy;\n","type":2},{"name":"node_modules/@types/lodash/differenceWith.d.ts","text":"import { differenceWith } from \"./index\";\nexport = differenceWith;\n","type":2},{"name":"node_modules/@types/lodash/divide.d.ts","text":"import { divide } from \"./index\";\nexport = divide;\n","type":2},{"name":"node_modules/@types/lodash/drop.d.ts","text":"import { drop } from \"./index\";\nexport = drop;\n","type":2},{"name":"node_modules/@types/lodash/dropRight.d.ts","text":"import { dropRight } from \"./index\";\nexport = dropRight;\n","type":2},{"name":"node_modules/@types/lodash/dropRightWhile.d.ts","text":"import { dropRightWhile } from \"./index\";\nexport = dropRightWhile;\n","type":2},{"name":"node_modules/@types/lodash/dropWhile.d.ts","text":"import { dropWhile } from \"./index\";\nexport = dropWhile;\n","type":2},{"name":"node_modules/@types/lodash/each.d.ts","text":"import { each } from \"./index\";\nexport = each;\n","type":2},{"name":"node_modules/@types/lodash/eachRight.d.ts","text":"import { eachRight } from \"./index\";\nexport = eachRight;\n","type":2},{"name":"node_modules/@types/lodash/endsWith.d.ts","text":"import { endsWith } from \"./index\";\nexport = endsWith;\n","type":2},{"name":"node_modules/@types/lodash/entries.d.ts","text":"import { entries } from \"./index\";\nexport = entries;\n","type":2},{"name":"node_modules/@types/lodash/entriesIn.d.ts","text":"import { entriesIn } from \"./index\";\nexport = entriesIn;\n","type":2},{"name":"node_modules/@types/lodash/eq.d.ts","text":"import { eq } from \"./index\";\nexport = eq;\n","type":2},{"name":"node_modules/@types/lodash/escape.d.ts","text":"import { escape } from \"./index\";\nexport = escape;\n","type":2},{"name":"node_modules/@types/lodash/escapeRegExp.d.ts","text":"import { escapeRegExp } from \"./index\";\nexport = escapeRegExp;\n","type":2},{"name":"node_modules/@types/lodash/every.d.ts","text":"import { every } from \"./index\";\nexport = every;\n","type":2},{"name":"node_modules/@types/lodash/extend.d.ts","text":"import { extend } from \"./index\";\nexport = extend;\n","type":2},{"name":"node_modules/@types/lodash/extendWith.d.ts","text":"import { extendWith } from \"./index\";\nexport = extendWith;\n","type":2},{"name":"node_modules/@types/lodash/fill.d.ts","text":"import { fill } from \"./index\";\nexport = fill;\n","type":2},{"name":"node_modules/@types/lodash/filter.d.ts","text":"import { filter } from \"./index\";\nexport = filter;\n","type":2},{"name":"node_modules/@types/lodash/find.d.ts","text":"import { find } from \"./index\";\nexport = find;\n","type":2},{"name":"node_modules/@types/lodash/findIndex.d.ts","text":"import { findIndex } from \"./index\";\nexport = findIndex;\n","type":2},{"name":"node_modules/@types/lodash/findKey.d.ts","text":"import { findKey } from \"./index\";\nexport = findKey;\n","type":2},{"name":"node_modules/@types/lodash/findLast.d.ts","text":"import { findLast } from \"./index\";\nexport = findLast;\n","type":2},{"name":"node_modules/@types/lodash/findLastIndex.d.ts","text":"import { findLastIndex } from \"./index\";\nexport = findLastIndex;\n","type":2},{"name":"node_modules/@types/lodash/findLastKey.d.ts","text":"import { findLastKey } from \"./index\";\nexport = findLastKey;\n","type":2},{"name":"node_modules/@types/lodash/first.d.ts","text":"import { first } from \"./index\";\nexport = first;\n","type":2},{"name":"node_modules/@types/lodash/flatMap.d.ts","text":"import { flatMap } from \"./index\";\nexport = flatMap;\n","type":2},{"name":"node_modules/@types/lodash/flatMapDeep.d.ts","text":"import { flatMapDeep } from \"./index\";\nexport = flatMapDeep;\n","type":2},{"name":"node_modules/@types/lodash/flatMapDepth.d.ts","text":"import { flatMapDepth } from \"./index\";\nexport = flatMapDepth;\n","type":2},{"name":"node_modules/@types/lodash/flatten.d.ts","text":"import { flatten } from \"./index\";\nexport = flatten;\n","type":2},{"name":"node_modules/@types/lodash/flattenDeep.d.ts","text":"import { flattenDeep } from \"./index\";\nexport = flattenDeep;\n","type":2},{"name":"node_modules/@types/lodash/flattenDepth.d.ts","text":"import { flattenDepth } from \"./index\";\nexport = flattenDepth;\n","type":2},{"name":"node_modules/@types/lodash/flip.d.ts","text":"import { flip } from \"./index\";\nexport = flip;\n","type":2},{"name":"node_modules/@types/lodash/floor.d.ts","text":"import { floor } from \"./index\";\nexport = floor;\n","type":2},{"name":"node_modules/@types/lodash/flow.d.ts","text":"import { flow } from \"./index\";\nexport = flow;\n","type":2},{"name":"node_modules/@types/lodash/flowRight.d.ts","text":"import { flowRight } from \"./index\";\nexport = flowRight;\n","type":2},{"name":"node_modules/@types/lodash/forEach.d.ts","text":"import { forEach } from \"./index\";\nexport = forEach;\n","type":2},{"name":"node_modules/@types/lodash/forEachRight.d.ts","text":"import { forEachRight } from \"./index\";\nexport = forEachRight;\n","type":2},{"name":"node_modules/@types/lodash/forIn.d.ts","text":"import { forIn } from \"./index\";\nexport = forIn;\n","type":2},{"name":"node_modules/@types/lodash/forInRight.d.ts","text":"import { forInRight } from \"./index\";\nexport = forInRight;\n","type":2},{"name":"node_modules/@types/lodash/forOwn.d.ts","text":"import { forOwn } from \"./index\";\nexport = forOwn;\n","type":2},{"name":"node_modules/@types/lodash/forOwnRight.d.ts","text":"import { forOwnRight } from \"./index\";\nexport = forOwnRight;\n","type":2},{"name":"node_modules/@types/lodash/fromPairs.d.ts","text":"import { fromPairs } from \"./index\";\nexport = fromPairs;\n","type":2},{"name":"node_modules/@types/lodash/functions.d.ts","text":"import { functions } from \"./index\";\nexport = functions;\n","type":2},{"name":"node_modules/@types/lodash/functionsIn.d.ts","text":"import { functionsIn } from \"./index\";\nexport = functionsIn;\n","type":2},{"name":"node_modules/@types/lodash/get.d.ts","text":"import { get } from \"./index\";\nexport = get;\n","type":2},{"name":"node_modules/@types/lodash/groupBy.d.ts","text":"import { groupBy } from \"./index\";\nexport = groupBy;\n","type":2},{"name":"node_modules/@types/lodash/gt.d.ts","text":"import { gt } from \"./index\";\nexport = gt;\n","type":2},{"name":"node_modules/@types/lodash/gte.d.ts","text":"import { gte } from \"./index\";\nexport = gte;\n","type":2},{"name":"node_modules/@types/lodash/has.d.ts","text":"import { has } from \"./index\";\nexport = has;\n","type":2},{"name":"node_modules/@types/lodash/hasIn.d.ts","text":"import { hasIn } from \"./index\";\nexport = hasIn;\n","type":2},{"name":"node_modules/@types/lodash/head.d.ts","text":"import { head } from \"./index\";\nexport = head;\n","type":2},{"name":"node_modules/@types/lodash/identity.d.ts","text":"import { identity } from \"./index\";\nexport = identity;\n","type":2},{"name":"node_modules/@types/lodash/includes.d.ts","text":"import { includes } from \"./index\";\nexport = includes;\n","type":2},{"name":"node_modules/@types/lodash/indexOf.d.ts","text":"import { indexOf } from \"./index\";\nexport = indexOf;\n","type":2},{"name":"node_modules/@types/lodash/initial.d.ts","text":"import { initial } from \"./index\";\nexport = initial;\n","type":2},{"name":"node_modules/@types/lodash/inRange.d.ts","text":"import { inRange } from \"./index\";\nexport = inRange;\n","type":2},{"name":"node_modules/@types/lodash/intersection.d.ts","text":"import { intersection } from \"./index\";\nexport = intersection;\n","type":2},{"name":"node_modules/@types/lodash/intersectionBy.d.ts","text":"import { intersectionBy } from \"./index\";\nexport = intersectionBy;\n","type":2},{"name":"node_modules/@types/lodash/intersectionWith.d.ts","text":"import { intersectionWith } from \"./index\";\nexport = intersectionWith;\n","type":2},{"name":"node_modules/@types/lodash/invert.d.ts","text":"import { invert } from \"./index\";\nexport = invert;\n","type":2},{"name":"node_modules/@types/lodash/invertBy.d.ts","text":"import { invertBy } from \"./index\";\nexport = invertBy;\n","type":2},{"name":"node_modules/@types/lodash/invoke.d.ts","text":"import { invoke } from \"./index\";\nexport = invoke;\n","type":2},{"name":"node_modules/@types/lodash/invokeMap.d.ts","text":"import { invokeMap } from \"./index\";\nexport = invokeMap;\n","type":2},{"name":"node_modules/@types/lodash/isArguments.d.ts","text":"import { isArguments } from \"./index\";\nexport = isArguments;\n","type":2},{"name":"node_modules/@types/lodash/index.d.ts","text":"// Type definitions for Lo-Dash 4.14\n// Project: http://lodash.com/\n// Definitions by: Brian Zengel <https://github.com/bczengel>,\n//                 Ilya Mochalov <https://github.com/chrootsu>,\n//                 Stepan Mikhaylyuk <https://github.com/stepancar>,\n//                 Eric L Anderson <https://github.com/ericanderson>,\n//                 AJ Richardson <https://github.com/aj-r>,\n//                 Junyoung Clare Jang <https://github.com/ailrun>,\n//                 e-cloud <https://github.com/e-cloud>,\n//                 Georgii Dolzhykov <https://github.com/thorn0>,\n//                 Jack Moore <https://github.com/jtmthf>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.2\n\n/**\n### 4.0.0 Changelog (https://github.com/lodash/lodash/wiki/Changelog)\n\n#### TODO:\nremoved:\n- [x] Removed _.support\n- [x] Removed _.findWhere in favor of _.find with iteratee shorthand\n- [x] Removed _.where in favor of _.filter with iteratee shorthand\n- [x] Removed _.pluck in favor of _.map with iteratee shorthand\n\nrenamed:\n- [x] Renamed _.first to _.head\n- [x] Renamed _.indexBy to _.keyBy\n- [x] Renamed _.invoke to _.invokeMap\n- [x] Renamed _.overArgs to _.overArgs\n- [x] Renamed _.padLeft & _.padRight to _.padStart & _.padEnd\n- [x] Renamed _.pairs to _.toPairs\n- [x] Renamed _.rest to _.tail\n- [x] Renamed _.restParam to _.rest\n- [x] Renamed _.sortByOrder to _.orderBy\n- [x] Renamed _.trimLeft & _.trimRight to _.trimStart & _.trimEnd\n- [x] Renamed _.trunc to _.truncate\n\nsplit:\n- [x] Split _.indexOf & _.lastIndexOf into _.sortedIndexOf & _.sortedLastIndexOf\n- [x] Split _.max & _.min into _.maxBy & _.minBy\n- [x] Split _.omit & _.pick into _.omitBy & _.pickBy\n- [x] Split _.sample into _.sampleSize\n- [x] Split _.sortedIndex into _.sortedIndexBy\n- [x] Split _.sortedLastIndex into _.sortedLastIndexBy\n- [x] Split _.uniq into _.sortedUniq, _.sortedUniqBy, & _.uniqBy\n\nchanges:\n- [x] Absorbed _.sortByAll into _.sortBy\n- [x] Changed the category of _.at to “Object”\n- [x] Changed the category of _.bindAll to “Utility”\n- [x] Made _.capitalize uppercase the first character & lowercase the rest\n- [x] Made _.functions return only own method names\n\nadded 23 array methods:\n- [x] _.concat\n- [x] _.differenceBy\n- [x] _.differenceWith\n- [x] _.flatMap\n- [x] _.fromPairs\n- [x] _.intersectionBy\n- [x] _.intersectionWith\n- [x] _.join\n- [x] _.pullAll\n- [x] _.pullAllBy\n- [x] _.reverse\n- [x] _.sortedIndexBy\n- [x] _.sortedIndexOf\n- [x] _.sortedLastIndexBy\n- [x] _.sortedLastIndexOf\n- [x] _.sortedUniq\n- [x] _.sortedUniqBy\n- [x] _.unionBy\n- [x] _.unionWith\n- [x] _.uniqBy\n- [x] _.uniqWith\n- [x] _.xorBy\n- [x] _.xorWith\n\nadded 20 lang methods:\n- [x] _.cloneDeepWith\n- [x] _.cloneWith\n- [x] _.eq\n- [x] _.isArrayLike\n- [x] _.isArrayLikeObject\n- [x] _.isEqualWith\n- [x] _.isInteger\n- [x] _.isLength\n- [x] _.isMatchWith\n- [x] _.isNil\n- [x] _.isObjectLike\n- [x] _.isSafeInteger\n- [x] _.isSymbol\n- [x] _.toInteger\n- [x] _.toLength\n- [x] _.toNumber\n- [x] _.toSafeInteger\n- [x] _.toString\n- [X] _.conforms\n- [X] _.conformsTo\n\nadded 13 object methods:\n- [x] _.assignIn\n- [x] _.assignInWith\n- [x] _.assignWith\n- [x] _.functionsIn\n- [x] _.hasIn\n- [x] _.mergeWith\n- [x] _.omitBy\n- [x] _.pickBy\n\nadded 8 string methods:\n- [x] _.lowerCase\n- [x] _.lowerFirst\n- [x] _.upperCase\n- [x] _.upperFirst\n- [x] _.toLower\n- [x] _.toUpper\n\nadded 8 utility methods:\n- [x] _.toPath\n\nadded 4 math methods:\n- [x] _.maxBy\n- [x] _.mean\n- [x] _.minBy\n- [x] _.sumBy\n\nadded 2 function methods:\n- [x] _.flip\n- [x] _.unary\n\nadded 2 number methods:\n- [x] _.clamp\n- [x] _.subtract\n\nadded collection method:\n- [x] _.sampleSize\n\nAdded 3 aliases\n\n- [x] _.first as an alias of _.head\n\nRemoved 17 aliases\n- [x] Removed aliase _.all\n- [x] Removed aliase _.any\n- [x] Removed aliase _.backflow\n- [x] Removed aliase _.callback\n- [x] Removed aliase _.collect\n- [x] Removed aliase _.compose\n- [x] Removed aliase _.contains\n- [x] Removed aliase _.detect\n- [x] Removed aliase _.foldl\n- [x] Removed aliase _.foldr\n- [x] Removed aliase _.include\n- [x] Removed aliase _.inject\n- [x] Removed aliase _.methods\n- [x] Removed aliase _.object\n- [x] Removed aliase _.run\n- [x] Removed aliase _.select\n- [x] Removed aliase _.unique\n\nOther changes\n- [x] Added support for array buffers to _.isEqual\n- [x] Added support for converting iterators to _.toArray\n- [x] Added support for deep paths to _.zipObject\n- [x] Changed UMD to export to window or self when available regardless of other exports\n- [x] Ensured debounce cancel clears args & thisArg references\n- [x] Ensured _.add, _.subtract, & _.sum don’t skip NaN values\n- [x] Ensured _.clone treats generators like functions\n- [x] Ensured _.clone produces clones with the source’s [[Prototype]]\n- [x] Ensured _.defaults assigns properties that shadow Object.prototype\n- [x] Ensured _.defaultsDeep doesn’t merge a string into an array\n- [x] Ensured _.defaultsDeep & _.merge don’t modify sources\n- [x] Ensured _.defaultsDeep works with circular references\n- [x] Ensured _.keys skips “length” on strict mode arguments objects in Safari 9\n- [x] Ensured _.merge doesn’t convert strings to arrays\n- [x] Ensured _.merge merges plain-objects onto non plain-objects\n- [x] Ensured _#plant resets iterator data of cloned sequences\n- [x] Ensured _.random swaps min & max if min is greater than max\n- [x] Ensured _.range preserves the sign of start of -0\n- [x] Ensured _.reduce & _.reduceRight use getIteratee in their array branch\n- [x] Fixed rounding issue with the precision param of _.floor\n- [x] Added flush method to debounced & throttled functions\n\n** LATER **\nMisc:\n- [ ] Made _.forEach, _.forIn, _.forOwn, & _.times implicitly end a chain sequence\n- [ ] Removed thisArg params from most methods\n- [ ] Made “By” methods provide a single param to iteratees\n- [ ] Made _.words chainable by default\n- [ ] Removed isDeep params from _.clone & _.flatten\n- [ ] Removed _.bindAll support for binding all methods when no names are provided\n- [ ] Removed func-first param signature from _.before & _.after\n- [ ] _.extend as an alias of _.assignIn\n- [ ] _.extendWith as an alias of _.assignInWith\n- [ ] Added clear method to _.memoize.Cache\n- [ ] Added support for ES6 maps, sets, & symbols to _.clone, _.isEqual, & _.toArray\n- [x] Enabled _.flow & _.flowRight to accept an array of functions\n- [ ] Ensured “Collection” methods treat functions as objects\n- [ ] Ensured _.assign, _.defaults, & _.merge coerce object values to objects\n- [ ] Ensured _.bindKey bound functions call object[key] when called with the new operator\n- [ ] Ensured _.isFunction returns true for generator functions\n- [ ] Ensured _.merge assigns typed arrays directly\n- [ ] Made _(...) an iterator & iterable\n- [ ] Made _.drop, _.take, & right forms coerce n of undefined to 0\n\nMethods:\n- [ ] _.concat\n- [ ] _.differenceBy\n- [ ] _.differenceWith\n- [ ] _.flatMap\n- [ ] _.fromPairs\n- [ ] _.intersectionBy\n- [ ] _.intersectionWith\n- [ ] _.join\n- [ ] _.pullAll\n- [ ] _.pullAllBy\n- [ ] _.reverse\n- [ ] _.sortedLastIndexOf\n- [ ] _.unionBy\n- [ ] _.unionWith\n- [ ] _.uniqWith\n- [ ] _.xorBy\n- [ ] _.xorWith\n- [ ] _.toString\n\n- [ ] _.invoke\n- [ ] _.setWith\n- [ ] _.toPairs\n- [ ] _.toPairsIn\n- [ ] _.unset\n\n- [ ] _.replace\n- [ ] _.split\n\n- [ ] _.cond\n- [ ] _.nthArg\n- [ ] _.over\n- [ ] _.overEvery\n- [ ] _.overSome\n- [ ] _.rangeRight\n\n- [ ] _.next\n*/\n\nexport = _;\nexport as namespace _;\n\ndeclare let _: _.LoDashStatic;\n\ntype PartialObject<T> = Partial<T>;\n\ndeclare namespace _ {\n    type Many<T> = T | T[];\n\n    interface LoDashStatic {\n        /**\n        * Creates a lodash object which wraps value to enable implicit method chain sequences.\n        * Methods that operate on and return arrays, collections, and functions can be chained together.\n        * Methods that retrieve a single value or may return a primitive value will automatically end the\n        * chain sequence and return the unwrapped value. Otherwise, the value must be unwrapped with value().\n        *\n        * Explicit chain sequences, which must be unwrapped with value(), may be enabled using _.chain.\n        *\n        * The execution of chained methods is lazy, that is, it's deferred until value() is\n        * implicitly or explicitly called.\n        *\n        * Lazy evaluation allows several methods to support shortcut fusion. Shortcut fusion\n        * is an optimization to merge iteratee calls; this avoids the creation of intermediate\n        * arrays and can greatly reduce the number of iteratee executions. Sections of a chain\n        * sequence qualify for shortcut fusion if the section is applied to an array and iteratees\n        * accept only one argument. The heuristic for whether a section qualifies for shortcut\n        * fusion is subject to change.\n        *\n        * Chaining is supported in custom builds as long as the value() method is directly or\n        * indirectly included in the build.\n        *\n        * In addition to lodash methods, wrappers have Array and String methods.\n        * The wrapper Array methods are:\n        * concat, join, pop, push, shift, sort, splice, and unshift.\n        * The wrapper String methods are:\n        * replace and split.\n        *\n        * The wrapper methods that support shortcut fusion are:\n        * at, compact, drop, dropRight, dropWhile, filter, find, findLast, head, initial, last,\n        * map, reject, reverse, slice, tail, take, takeRight, takeRightWhile, takeWhile, and toArray\n        *\n        * The chainable wrapper methods are:\n        * after, ary, assign, assignIn, assignInWith, assignWith, at, before, bind, bindAll, bindKey,\n        * castArray, chain, chunk, commit, compact, concat, conforms, constant, countBy, create,\n        * curry, debounce, defaults, defaultsDeep, defer, delay, difference, differenceBy, differenceWith,\n        * drop, dropRight, dropRightWhile, dropWhile, extend, extendWith, fill, filter, flatMap,\n        * flatMapDeep, flatMapDepth, flatten, flattenDeep, flattenDepth, flip, flow, flowRight,\n        * fromPairs, functions, functionsIn, groupBy, initial, intersection, intersectionBy, intersectionWith,\n        * invert, invertBy, invokeMap, iteratee, keyBy, keys, keysIn, map, mapKeys, mapValues,\n        * matches, matchesProperty, memoize, merge, mergeWith, method, methodOf, mixin, negate,\n        * nthArg, omit, omitBy, once, orderBy, over, overArgs, overEvery, overSome, partial, partialRight,\n        * partition, pick, pickBy, plant, property, propertyOf, pull, pullAll, pullAllBy, pullAllWith, pullAt,\n        * push, range, rangeRight, rearg, reject, remove, rest, reverse, sampleSize, set, setWith,\n        * shuffle, slice, sort, sortBy, sortedUniq, sortedUniqBy, splice, spread, tail, take,\n        * takeRight, takeRightWhile, takeWhile, tap, throttle, thru, toArray, toPairs, toPairsIn,\n        * toPath, toPlainObject, transform, unary, union, unionBy, unionWith, uniq, uniqBy, uniqWith,\n        * unset, unshift, unzip, unzipWith, update, updateWith, values, valuesIn, without, wrap,\n        * xor, xorBy, xorWith, zip, zipObject, zipObjectDeep, and zipWith.\n        *\n        * The wrapper methods that are not chainable by default are:\n        * add, attempt, camelCase, capitalize, ceil, clamp, clone, cloneDeep, cloneDeepWith, cloneWith,\n        * conformsTo, deburr, defaultTo, divide, each, eachRight, endsWith, eq, escape, escapeRegExp,\n        * every, find, findIndex, findKey, findLast, findLastIndex, findLastKey, first, floor, forEach,\n        * forEachRight, forIn, forInRight, forOwn, forOwnRight, get, gt, gte, has, hasIn, head,\n        * identity, includes, indexOf, inRange, invoke, isArguments, isArray, isArrayBuffer,\n        * isArrayLike, isArrayLikeObject, isBoolean, isBuffer, isDate, isElement, isEmpty, isEqual, isEqualWith,\n        * isError, isFinite, isFunction, isInteger, isLength, isMap, isMatch, isMatchWith, isNaN,\n        * isNative, isNil, isNull, isNumber, isObject, isObjectLike, isPlainObject, isRegExp,\n        * isSafeInteger, isSet, isString, isUndefined, isTypedArray, isWeakMap, isWeakSet, join,\n        * kebabCase, last, lastIndexOf, lowerCase, lowerFirst, lt, lte, max, maxBy, mean, meanBy,\n        * min, minBy, multiply, noConflict, noop, now, nth, pad, padEnd, padStart, parseInt, pop,\n        * random, reduce, reduceRight, repeat, result, round, runInContext, sample, shift, size,\n        * snakeCase, some, sortedIndex, sortedIndexBy, sortedLastIndex, sortedLastIndexBy, startCase,\n        * startsWith, stubArray, stubFalse, stubObject, stubString, stubTrue, subtract, sum, sumBy,\n        * template, times, toFinite, toInteger, toJSON, toLength, toLower, toNumber, toSafeInteger,\n        * toString, toUpper, trim, trimEnd, trimStart, truncate, unescape, uniqueId, upperCase,\n        * upperFirst, value, and words.\n        **/\n        <T>(value: T): LoDashImplicitWrapper<T>;\n\n        /**\n        * The semantic version number.\n        **/\n        VERSION: string;\n\n        /**\n        * By default, the template delimiters used by Lo-Dash are similar to those in embedded Ruby\n        * (ERB). Change the following template settings to use alternative delimiters.\n        **/\n        templateSettings: TemplateSettings;\n    }\n\n    /**\n    * By default, the template delimiters used by Lo-Dash are similar to those in embedded Ruby\n    * (ERB). Change the following template settings to use alternative delimiters.\n    **/\n    interface TemplateSettings {\n        /**\n        * The \"escape\" delimiter.\n        **/\n        escape?: RegExp;\n\n        /**\n        * The \"evaluate\" delimiter.\n        **/\n        evaluate?: RegExp;\n\n        /**\n        * An object to import into the template as local variables.\n        **/\n        imports?: Dictionary<any>;\n\n        /**\n        * The \"interpolate\" delimiter.\n        **/\n        interpolate?: RegExp;\n\n        /**\n        * Used to reference the data object in the template text.\n        **/\n        variable?: string;\n    }\n\n    /**\n     * Creates a cache object to store key/value pairs.\n     */\n    interface MapCache {\n        /**\n         * Removes `key` and its value from the cache.\n         * @param key The key of the value to remove.\n         * @return Returns `true` if the entry was removed successfully, else `false`.\n         */\n        delete(key: string): boolean;\n\n        /**\n         * Gets the cached value for `key`.\n         * @param key The key of the value to get.\n         * @return Returns the cached value.\n         */\n        get(key: string): any;\n\n        /**\n         * Checks if a cached value for `key` exists.\n         * @param key The key of the entry to check.\n         * @return Returns `true` if an entry for `key` exists, else `false`.\n         */\n        has(key: string): boolean;\n\n        /**\n         * Sets `value` to `key` of the cache.\n         * @param key The key of the value to cache.\n         * @param value The value to cache.\n         * @return Returns the cache object.\n         */\n        set(key: string, value: any): Dictionary<any>;\n\n        /**\n         * Removes all key-value entries from the map.\n         */\n        clear(): void;\n    }\n    interface MapCacheConstructor {\n        new (): MapCache;\n    }\n\n    interface LoDashWrapper<TValue> { }\n\n    interface LoDashImplicitWrapper<TValue> extends LoDashWrapper<TValue> {\n        pop<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n        push<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>, ...items: T[]): this;\n        shift<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n        sort<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>, compareFn?: (a: T, b: T) => number): this;\n        splice<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>, start: number, deleteCount?: number, ...items: T[]): this;\n        unshift<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>, ...items: T[]): this;\n    }\n\n    interface LoDashExplicitWrapper<TValue> extends LoDashWrapper<TValue> {\n        pop<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n        push<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>, ...items: T[]): this;\n        shift<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n        sort<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>, compareFn?: (a: T, b: T) => number): this;\n        splice<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>, start: number, deleteCount?: number, ...items: T[]): this;\n        unshift<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>, ...items: T[]): this;\n    }\n\n    /*********\n     * Array *\n     *********/\n\n    //_.chunk\n    interface LoDashStatic {\n        /**\n         * Creates an array of elements split into groups the length of size. If collection can’t be split evenly, the\n         * final chunk will be the remaining elements.\n         *\n         * @param array The array to process.\n         * @param size The length of each chunk.\n         * @return Returns the new array containing chunks.\n         */\n        chunk<T>(\n            array: List<T> | null | undefined,\n            size?: number\n        ): T[][];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.chunk\n         */\n        chunk<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            size?: number,\n        ): LoDashImplicitWrapper<T[][]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.chunk\n         */\n        chunk<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            size?: number,\n        ): LoDashExplicitWrapper<T[][]>;\n    }\n\n    //_.compact\n    interface LoDashStatic {\n        /**\n         * Creates an array with all falsey values removed. The values false, null, 0, \"\", undefined, and NaN are\n         * falsey.\n         *\n         * @param array The array to compact.\n         * @return Returns the new array of filtered values.\n         */\n        compact<T>(array: List<T | null | undefined | false | \"\" | 0> | null | undefined): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.compact\n         */\n        compact<T>(this: LoDashImplicitWrapper<List<T | null | undefined | false | \"\" | 0> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.compact\n         */\n        compact<T>(this: LoDashExplicitWrapper<List<T | null | undefined | false | \"\" | 0> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.concat\n    interface LoDashStatic {\n        /**\n         * Creates a new array concatenating `array` with any additional arrays\n         * and/or values.\n         *\n         * @category Array\n         * @param array The array to concatenate.\n         * @param [values] The values to concatenate.\n         * @returns Returns the new concatenated array.\n         * @example\n         *\n         * var array = [1];\n         * var other = _.concat(array, 2, [3], [[4]]);\n         *\n         * console.log(other);\n         * // => [1, 2, 3, [4]]\n         *\n         * console.log(array);\n         * // => [1]\n         */\n         concat<T>(array: Many<T>, ...values: Array<Many<T>>): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.compact\n         */\n        concat<T>(this: LoDashImplicitWrapper<Many<T>>, ...values: Array<Many<T>>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.compact\n         */\n        concat<T>(this: LoDashExplicitWrapper<Many<T>>, ...values: Array<Many<T>>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.difference\n    interface LoDashStatic {\n        /**\n         * Creates an array of unique array values not included in the other provided arrays using SameValueZero for\n         * equality comparisons.\n         *\n         * @param array The array to inspect.\n         * @param values The arrays of values to exclude.\n         * @return Returns the new array of filtered values.\n         */\n        difference<T>(\n            array: List<T> | null | undefined,\n            ...values: Array<List<T>>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.difference\n         */\n        difference<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.difference\n         */\n        difference<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.differenceBy\n    interface LoDashStatic {\n        /**\n         * This method is like _.difference except that it accepts iteratee which is invoked for each element of array\n         * and values to generate the criterion by which uniqueness is computed. The iteratee is invoked with one\n         * argument: (value).\n         *\n         * @param array The array to inspect.\n         * @param values The values to exclude.\n         * @param iteratee The iteratee invoked per element.\n         * @returns Returns the new array of filtered values.\n         */\n        differenceBy<T1, T2>(\n            array: List<T1> | null | undefined,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): T1[];\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            iteratee: ValueIteratee<T1 | T2 | T3>\n        ): T1[];\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4>\n        ): T1[];\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5>\n        ): T1[];\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5, T6>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            values5: List<T6>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6>\n        ): T1[];\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5, T6, T7>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            values5: List<T6>,\n            ...values: Array<List<T7> | ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6 | T7>>\n        ): T1[];\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T>(\n            array: List<T> | null | undefined,\n            ...values: Array<List<T>>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            iteratee: ValueIteratee<T1 | T2 | T3>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5, T6>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            values5: List<T6>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5, T6, T7>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            values5: List<T6>,\n            ...values: Array<List<T7> | ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6 | T7>>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            iteratee: ValueIteratee<T1 | T2 | T3>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5, T6>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            values5: List<T6>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5, T6, T7>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            values5: List<T6>,\n            ...values: Array<List<T7> | ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6 | T7>>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.differenceWith\n    interface LoDashStatic {\n        /**\n         * Creates an array of unique `array` values not included in the other\n         * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n         * for equality comparisons.\n         *\n         * @category Array\n         * @param [values] The arrays to inspect.\n         * @param [comparator] The comparator invoked per element.\n         * @returns Returns the new array of filtered values.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n\n         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n         * // => [{ 'x': 2, 'y': 1 }]\n         */\n        differenceWith<T1, T2>(\n            array: List<T1> | null | undefined,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): T1[];\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2, T3>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            comparator: Comparator2<T1, T2 | T3>\n        ): T1[];\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2, T3, T4>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>\n        ): T1[];\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T>(\n            array: List<T> | null | undefined,\n            ...values: Array<List<T>>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2, T3>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            comparator: Comparator2<T1, T2 | T3>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2, T3, T4>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2, T3>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            comparator: Comparator2<T1, T2 | T3>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2, T3, T4>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.drop\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array with n elements dropped from the beginning.\n         *\n         * @param array The array to query.\n         * @param n The number of elements to drop.\n         * @return Returns the slice of array.\n         */\n        drop<T>(array: List<T> | null | undefined, n?: number): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.drop\n         */\n        drop<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>, n?: number): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.drop\n         */\n        drop<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>, n?: number): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.dropRight\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array with n elements dropped from the end.\n         *\n         * @param array The array to query.\n         * @param n The number of elements to drop.\n         * @return Returns the slice of array.\n         */\n        dropRight<T>(\n            array: List<T> | null | undefined,\n            n?: number\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.dropRight\n         */\n        dropRight<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>, n?: number): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.dropRight\n         */\n        dropRight<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>, n?: number): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.dropRightWhile\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array excluding elements dropped from the end. Elements are dropped until predicate\n         * returns falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * match the properties of the given object, else false.\n         *\n         * @param array The array to query.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the slice of array.\n         */\n        dropRightWhile<T>(\n            array: List<T> | null | undefined,\n            predicate?: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.dropRightWhile\n         */\n        dropRightWhile<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.dropRightWhile\n         */\n        dropRightWhile<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.dropWhile\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array excluding elements dropped from the beginning. Elements are dropped until predicate\n         * returns falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param array The array to query.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the slice of array.\n         */\n        dropWhile<T>(\n            array: List<T> | null | undefined,\n            predicate?: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.dropWhile\n         */\n        dropWhile<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.dropWhile\n         */\n        dropWhile<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.fill\n    interface LoDashStatic {\n        /**\n         * Fills elements of array with value from start up to, but not including, end.\n         *\n         * Note: This method mutates array.\n         *\n         * @param array The array to fill.\n         * @param value The value to fill array with.\n         * @param start The start position.\n         * @param end The end position.\n         * @return Returns array.\n         */\n        fill<T>(\n            array: any[] | null | undefined,\n            value: T\n        ): T[];\n\n        /**\n         * @see _.fill\n         */\n        fill<T>(\n            array: List<any> | null | undefined,\n            value: T\n        ): List<T>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T, U>(\n            array: U[] | null | undefined,\n            value: T,\n            start?: number,\n            end?: number\n        ): Array<T | U>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T, U>(\n            array: List<U> | null | undefined,\n            value: T,\n            start?: number,\n            end?: number\n        ): List<T | U>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.fill\n         */\n        fill<T>(\n            this: LoDashImplicitWrapper<any[] | null | undefined>,\n            value: T\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T>(\n            this: LoDashImplicitWrapper<List<any> | null | undefined>,\n            value: T\n        ): LoDashImplicitWrapper<List<T>>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T, U>(\n            this: LoDashImplicitWrapper<U[] | null | undefined>,\n            value: T,\n            start?: number,\n            end?: number\n        ): LoDashImplicitWrapper<Array<T | U>>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T, U>(\n            this: LoDashImplicitWrapper<List<U> | null | undefined>,\n            value: T,\n            start?: number,\n            end?: number\n        ): LoDashImplicitWrapper<List<T | U>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.fill\n         */\n        fill<T>(\n            this: LoDashExplicitWrapper<any[] | null | undefined>,\n            value: T\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T>(\n            this: LoDashExplicitWrapper<List<any> | null | undefined>,\n            value: T\n        ): LoDashExplicitWrapper<List<T>>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T, U>(\n            this: LoDashExplicitWrapper<U[] | null | undefined>,\n            value: T,\n            start?: number,\n            end?: number\n        ): LoDashExplicitWrapper<Array<T | U>>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T, U>(\n            this: LoDashExplicitWrapper<List<U> | null | undefined>,\n            value: T,\n            start?: number,\n            end?: number\n        ): LoDashExplicitWrapper<List<T | U>>;\n    }\n\n    //_.findIndex\n    interface LoDashStatic {\n        /**\n         * This method is like _.find except that it returns the index of the first element predicate returns truthy\n         * for instead of the element itself.\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param array The array to search.\n         * @param predicate The function invoked per iteration.\n         * @param fromIndex The index to search from.\n         * @return Returns the index of the found element, else -1.\n         */\n        findIndex<T>(\n            array: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.findIndex\n         */\n        findIndex<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.findIndex\n         */\n        findIndex<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.findLastIndex\n    interface LoDashStatic {\n        /**\n         * This method is like _.findIndex except that it iterates over elements of collection from right to left.\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param array The array to search.\n         * @param predicate The function invoked per iteration.\n         * @param fromIndex The index to search from.\n         * @return Returns the index of the found element, else -1.\n         */\n        findLastIndex<T>(\n            array: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.findLastIndex\n         */\n        findLastIndex<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.findLastIndex\n         */\n        findLastIndex<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.first\n    interface LoDashStatic {\n        first: typeof _.head; // tslint:disable-line:no-unnecessary-qualifier\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.head\n         */\n        first<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.head\n         */\n        first<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    interface RecursiveArray<T> extends Array<T|RecursiveArray<T>> {}\n    interface ListOfRecursiveArraysOrValues<T> extends List<T|RecursiveArray<T>> {}\n\n    //_.flatten\n    interface LoDashStatic {\n        /**\n         * Flattens a nested array. If isDeep is true the array is recursively flattened, otherwise it’s only\n         * flattened a single level.\n         *\n         * @param array The array to flatten.\n         * @param isDeep Specify a deep flatten.\n         * @return Returns the new flattened array.\n         */\n        flatten<T>(array: ListOfRecursiveArraysOrValues<T> | null | undefined, isDeep: boolean): T[];\n\n        /**\n         * @see _.flatten\n         */\n        flatten<T>(array: List<Many<T>> | null | undefined): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flatten\n         */\n        flatten<T>(this: LoDashImplicitWrapper<ListOfRecursiveArraysOrValues<T> | null | undefined>, isDeep: boolean): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatten\n         */\n        flatten<T>(this: LoDashImplicitWrapper<List<Many<T>> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flatten\n         */\n        flatten<T>(this: LoDashExplicitWrapper<ListOfRecursiveArraysOrValues<T> | null | undefined>, isDeep: boolean): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatten\n         */\n        flatten<T>(this: LoDashExplicitWrapper<List<Many<T>> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.flattenDeep\n    interface LoDashStatic {\n        /**\n         * Recursively flattens a nested array.\n         *\n         * @param array The array to recursively flatten.\n         * @return Returns the new flattened array.\n         */\n        flattenDeep<T>(array: ListOfRecursiveArraysOrValues<T> | null | undefined): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flattenDeep\n         */\n        flattenDeep<T>(this: LoDashImplicitWrapper<ListOfRecursiveArraysOrValues<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flattenDeep\n         */\n        flattenDeep<T>(this: LoDashExplicitWrapper<ListOfRecursiveArraysOrValues<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    // _.flattenDepth\n    interface LoDashStatic {\n        /**\n        * Recursively flatten array up to depth times.\n        *\n        * @param array The array to recursively flatten.\n        * @param number The maximum recursion depth.\n        * @return Returns the new flattened array.\n        */\n        flattenDepth<T>(array: ListOfRecursiveArraysOrValues<T> | null | undefined, depth?: number): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flattenDeep\n         */\n        flattenDepth<T>(this: LoDashImplicitWrapper<ListOfRecursiveArraysOrValues<T> | null | undefined>, depth?: number): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flattenDeep\n         */\n        flattenDepth<T>(this: LoDashExplicitWrapper<ListOfRecursiveArraysOrValues<T> | null | undefined>, depth?: number): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.fromPairs\n    interface LoDashStatic {\n        /**\n         * The inverse of `_.toPairs`; this method returns an object composed\n         * from key-value `pairs`.\n         *\n         * @category Array\n         * @param pairs The key-value pairs.\n         * @returns Returns the new object.\n         * @example\n         *\n         * _.fromPairs([['fred', 30], ['barney', 40]]);\n         * // => { 'fred': 30, 'barney': 40 }\n         */\n        fromPairs<T>(\n            pairs: List<[PropertyName, T]> | null | undefined\n        ): Dictionary<T>;\n\n        /**\n         @see _.fromPairs\n         */\n        fromPairs(\n            pairs: List<any[]> | null | undefined\n        ): Dictionary<any>;\n    }\n\n    //_.fromPairs\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.fromPairs\n         */\n        fromPairs<T>(\n          this: LoDashImplicitWrapper<List<[PropertyName, T]> | null | undefined>\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         @see _.fromPairs\n         */\n        fromPairs(\n            this: LoDashImplicitWrapper<List<any[]> | null | undefined>\n        ): LoDashImplicitWrapper<Dictionary<any>>;\n    }\n    //_.fromPairs\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.fromPairs\n         */\n        fromPairs<T>(\n          this: LoDashExplicitWrapper<List<[PropertyName, T]> | null | undefined>\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         @see _.fromPairs\n         */\n        fromPairs(\n            this: LoDashExplicitWrapper<List<any[]> | null | undefined>\n        ): LoDashExplicitWrapper<Dictionary<any>>;\n    }\n\n    //_.head\n    interface LoDashStatic {\n        /**\n         * Gets the first element of array.\n         *\n         * @alias _.first\n         *\n         * @param array The array to query.\n         * @return Returns the first element of array.\n         */\n        head<T>(array: List<T> | null | undefined): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.head\n         */\n        head<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.head\n         */\n        head<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.indexOf\n    interface LoDashStatic {\n        /**\n         * Gets the index at which the first occurrence of `value` is found in `array`\n         * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n         * for equality comparisons. If `fromIndex` is negative, it's used as the offset\n         * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`\n         * performs a faster binary search.\n         *\n         * @category Array\n         * @param array The array to search.\n         * @param value The value to search for.\n         * @param [fromIndex=0] The index to search from.\n         * @returns Returns the index of the matched value, else `-1`.\n         * @example\n         *\n         * _.indexOf([1, 2, 1, 2], 2);\n         * // => 1\n         *\n         * // using `fromIndex`\n         * _.indexOf([1, 2, 1, 2], 2, 2);\n         * // => 3\n         */\n        indexOf<T>(\n            array: List<T> | null | undefined,\n            value: T,\n            fromIndex?: boolean|number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.indexOf\n         */\n        indexOf<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            fromIndex?: boolean|number\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.indexOf\n         */\n        indexOf<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            fromIndex?: boolean|number\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.sortedIndexOf\n    interface LoDashStatic {\n        /**\n         * This method is like `_.indexOf` except that it performs a binary\n         * search on a sorted `array`.\n         *\n         * @category Array\n         * @param array The array to search.\n         * @param value The value to search for.\n         * @returns Returns the index of the matched value, else `-1`.\n         * @example\n         *\n         * _.sortedIndexOf([1, 1, 2, 2], 2);\n         * // => 2\n         */\n        sortedIndexOf<T>(\n            array: List<T> | null | undefined,\n            value: T\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedIndexOf\n         */\n        sortedIndexOf<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedIndexOf\n         */\n        sortedIndexOf<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.initial\n    interface LoDashStatic {\n        /**\n         * Gets all but the last element of array.\n         *\n         * @param array The array to query.\n         * @return Returns the slice of array.\n         */\n        initial<T>(array: List<T> | null | undefined): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.initial\n         */\n        initial<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.initial\n         */\n        initial<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.intersection\n    interface LoDashStatic {\n        /**\n         * Creates an array of unique values that are included in all of the provided arrays using SameValueZero for\n         * equality comparisons.\n         *\n         * @param arrays The arrays to inspect.\n         * @return Returns the new array of shared values.\n         */\n        intersection<T>(...arrays: Array<List<T>>): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.intersection\n         */\n        intersection<T>(\n            this: LoDashImplicitWrapper<List<T>>,\n            ...arrays: Array<List<T>>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.intersection\n         */\n        intersection<T>(\n            this: LoDashExplicitWrapper<List<T>>,\n            ...arrays: Array<List<T>>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.intersectionBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.intersection` except that it accepts `iteratee`\n         * which is invoked for each element of each `arrays` to generate the criterion\n         * by which uniqueness is computed. The iteratee is invoked with one argument: (value).\n         *\n         * @category Array\n         * @param [arrays] The arrays to inspect.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the new array of shared values.\n         * @example\n         *\n         * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n         * // => [2.1]\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n         * // => [{ 'x': 1 }]\n         */\n        intersectionBy<T1, T2>(\n            array: List<T1> | null,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): T1[];\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2, T3>(\n            array: List<T1> | null,\n            values1: List<T2>,\n            values2: List<T3>,\n            iteratee: ValueIteratee<T1 | T2 | T3>\n        ): T1[];\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2, T3, T4>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | ValueIteratee<T1 | T2 | T3 | T4>>\n        ): T1[];\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T>(\n            array?: List<T> | null,\n            ...values: Array<List<T>>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2, T3>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            iteratee: ValueIteratee<T1 | T2 | T3>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2, T3, T4>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | ValueIteratee<T1 | T2 | T3 | T4>>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2, T3>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            iteratee: ValueIteratee<T1 | T2 | T3>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2, T3, T4>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | ValueIteratee<T1 | T2 | T3 | T4>>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.intersectionWith\n    interface LoDashStatic {\n        /**\n         * Creates an array of unique `array` values not included in the other\n         * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n         * for equality comparisons.\n         *\n         * @category Array\n         * @param [values] The arrays to inspect.\n         * @param [comparator] The comparator invoked per element.\n         * @returns Returns the new array of filtered values.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\n         * _.intersectionWith(objects, others, _.isEqual);\n         * // => [{ 'x': 1, 'y': 2 }]\n         */\n        intersectionWith<T1, T2>(\n            array: List<T1> | null | undefined,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): T1[];\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2, T3>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            comparator: Comparator2<T1, T2 | T3>\n        ): T1[];\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2, T3, T4>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>\n        ): T1[];\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T>(\n            array?: List<T> | null,\n            ...values: Array<List<T>>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2, T3>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            comparator: Comparator2<T1, T2 | T3>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2, T3, T4>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>,\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2, T3>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            comparator: Comparator2<T1, T2 | T3>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2, T3, T4>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>,\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.join\n    interface LoDashStatic {\n        /**\n         * Converts all elements in `array` into a string separated by `separator`.\n         *\n         * @param array The array to convert.\n         * @param separator The element separator.\n         * @returns Returns the joined string.\n         */\n        join(\n            array: List<any> | null | undefined,\n            separator?: string\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.join\n         */\n        join(separator?: string): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.join\n         */\n        join(separator?: string): LoDashExplicitWrapper<string>;\n    }\n\n    //_.reverse\n    interface LoDashStatic {\n        /**\n         * Reverses `array` so that the first element becomes the last, the second\n         * element becomes the second to last, and so on.\n         *\n         * **Note:** This method mutates `array` and is based on\n         * [`Array#reverse`](https://mdn.io/Array/reverse).\n         *\n         * @category Array\n         * @returns Returns `array`.\n         * @example\n         *\n         * var array = [1, 2, 3];\n         *\n         * _.reverse(array);\n         * // => [3, 2, 1]\n         *\n         * console.log(array);\n         * // => [3, 2, 1]\n         */\n        reverse<TList extends List<any>>(\n            array: TList,\n        ): TList;\n    }\n\n    //_.prototype.reverse\n    interface LoDashWrapper<TValue> {\n        /**\n         * Reverses the wrapped array so the first element becomes the last, the second element becomes the second to\n         * last, and so on.\n         *\n         * Note: This method mutates the wrapped array.\n         *\n         * @return Returns the new reversed lodash wrapper instance.\n         */\n        reverse(): this;\n    }\n\n    //_.last\n    interface LoDashStatic {\n        /**\n         * Gets the last element of array.\n         *\n         * @param array The array to query.\n         * @return Returns the last element of array.\n         */\n        last<T>(array: List<T> | null | undefined): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.last\n         */\n        last<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.last\n         */\n        last<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.lastIndexOf\n    interface LoDashStatic {\n        /**\n         * This method is like _.indexOf except that it iterates over elements of array from right to left.\n         *\n         * @param array The array to search.\n         * @param value The value to search for.\n         * @param fromIndex The index to search from or true to perform a binary search on a sorted array.\n         * @return Returns the index of the matched value, else -1.\n         */\n        lastIndexOf<T>(\n            array: List<T> | null | undefined,\n            value: T,\n            fromIndex?: true|number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.indexOf\n         */\n        lastIndexOf<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            fromIndex?: true|number\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.indexOf\n         */\n        lastIndexOf<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            fromIndex?: true|number\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.nth\n    interface LoDashStatic {\n        /**\n         * Gets the element at index `n` of `array`. If `n` is negative, the nth element from the end is returned.\n         *\n         * @param array array The array to query.\n         * @param value The index of the element to return.\n         * @return Returns the nth element of `array`.\n         */\n        nth<T>(\n            array: List<T> | null | undefined,\n            n?: number\n        ): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.nth\n         */\n        nth<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            n?: number\n        ): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.nth\n         */\n        nth<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            n?: number\n        ): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.pull\n    interface LoDashStatic {\n        /**\n         * Removes all provided values from array using SameValueZero for equality comparisons.\n         *\n         * Note: Unlike _.without, this method mutates array.\n         *\n         * @param array The array to modify.\n         * @param values The values to remove.\n         * @return Returns array.\n         */\n        pull<T>(\n            array: T[],\n            ...values: T[]\n        ): T[];\n\n        /**\n         * @see _.pull\n         */\n        pull<T>(\n            array: List<T>,\n            ...values: T[]\n        ): List<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.pull\n         */\n        pull<T>(\n            this: LoDashImplicitWrapper<List<T>>,\n            ...values: T[]\n        ): this;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.pull\n         */\n        pull<T>(\n            this: LoDashExplicitWrapper<List<T>>,\n            ...values: T[]\n        ): this;\n    }\n\n    //_.pullAt\n    interface LoDashStatic {\n        /**\n         * Removes elements from array corresponding to the given indexes and returns an array of the removed elements.\n         * Indexes may be specified as an array of indexes or as individual arguments.\n         *\n         * Note: Unlike _.at, this method mutates array.\n         *\n         * @param array The array to modify.\n         * @param indexes The indexes of elements to remove, specified as individual indexes or arrays of indexes.\n         * @return Returns the new array of removed elements.\n         */\n        pullAt<T>(\n            array: T[],\n            ...indexes: Array<Many<number>>\n        ): T[];\n\n        /**\n         * @see _.pullAt\n         */\n        pullAt<T>(\n            array: List<T>,\n            ...indexes: Array<Many<number>>\n        ): List<T>;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.pullAt\n         */\n        pullAt(...indexes: Array<Many<number>>): this;\n    }\n\n    //_.pullAll\n    interface LoDashStatic {\n        /**\n         * This method is like `_.pull` except that it accepts an array of values to remove.\n         *\n         * **Note:** Unlike `_.difference`, this method mutates `array`.\n         *\n         * @category Array\n         * @param array The array to modify.\n         * @param values The values to remove.\n         * @returns Returns `array`.\n         * @example\n         *\n         * var array = [1, 2, 3, 1, 2, 3];\n         *\n         * _.pull(array, [2, 3]);\n         * console.log(array);\n         * // => [1, 1]\n         */\n        pullAll<T>(\n            array: T[],\n            values?: List<T>,\n        ): T[];\n\n        /**\n         * @see _.pullAll\n         */\n        pullAll<T>(\n            array: List<T>,\n            values?: List<T>,\n        ): List<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.pullAll\n         */\n        pullAll<T>(\n            this: LoDashImplicitWrapper<List<T>>,\n            values?: List<T>\n        ): this;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.pullAll\n         */\n        pullAll<T>(\n            this: LoDashExplicitWrapper<List<T>>,\n            values?: List<T>\n        ): this;\n    }\n\n    //_.pullAllBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.pullAll` except that it accepts `iteratee` which is\n         * invoked for each element of `array` and `values` to to generate the criterion\n         * by which uniqueness is computed. The iteratee is invoked with one argument: (value).\n         *\n         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n         *\n         * @category Array\n         * @param array The array to modify.\n         * @param values The values to remove.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns `array`.\n         * @example\n         *\n         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n         *\n         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n         * console.log(array);\n         * // => [{ 'x': 2 }]\n         */\n        pullAllBy<T>(\n            array: T[],\n            values?: List<T>,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.pullAllBy\n         */\n        pullAllBy<T>(\n            array: List<T>,\n            values?: List<T>,\n            iteratee?: ValueIteratee<T>\n        ): List<T>;\n\n        /**\n         * @see _.pullAllBy\n         */\n        pullAllBy<T1, T2>(\n            array: T1[],\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): T1[];\n\n        /**\n         * @see _.pullAllBy\n         */\n        pullAllBy<T1, T2>(\n            array: List<T1>,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): List<T1>;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.pullAllBy\n         */\n        pullAllBy<T>(\n            this: LoDashWrapper<List<T>>,\n            values?: List<T>,\n            iteratee?: ValueIteratee<T>\n        ): this;\n\n        /**\n         * @see _.pullAllBy\n         */\n        pullAllBy<T1, T2>(\n            this: LoDashWrapper<List<T1>>,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): this;\n    }\n\n    //_.pullAllWith\n    interface LoDashStatic {\n        /**\n         * This method is like `_.pullAll` except that it accepts `comparator` which is\n         * invoked to compare elements of array to values. The comparator is invoked with\n         * two arguments: (arrVal, othVal).\n         *\n         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n         *\n         * @category Array\n         * @param array The array to modify.\n         * @param values The values to remove.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns `array`.\n         * @example\n         *\n         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n         *\n         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n         * console.log(array);\n         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n         */\n        pullAllWith<T>(\n            array: T[],\n            values?: List<T>,\n            comparator?: Comparator<T>\n        ): T[];\n\n        /**\n         * @see _.pullAllWith\n         */\n        pullAllWith<T>(\n            array: List<T>,\n            values?: List<T>,\n            comparator?: Comparator<T>\n        ): List<T>;\n\n        /**\n         * @see _.pullAllWith\n         */\n        pullAllWith<T1, T2>(\n            array: T1[],\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): T1[];\n\n        /**\n         * @see _.pullAllWith\n         */\n        pullAllWith<T1, T2>(\n            array: List<T1>,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): List<T1>;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.pullAllWith\n         */\n        pullAllWith<T>(\n            this: LoDashWrapper<List<T>>,\n            values?: List<T>,\n            comparator?: Comparator<T>\n        ): this;\n\n        /**\n         * @see _.pullAllWith\n         */\n        pullAllWith<T1, T2>(\n            this: LoDashWrapper<List<T1>>,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): this;\n    }\n\n    //_.remove\n    interface LoDashStatic {\n        /**\n         * Removes all elements from array that predicate returns truthy for and returns an array of the removed\n         * elements. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * Note: Unlike _.filter, this method mutates array.\n         *\n         * @param array The array to modify.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the new array of removed elements.\n         */\n        remove<T>(\n            array: List<T>,\n            predicate?: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.remove\n         */\n        remove<T>(\n            this: LoDashImplicitWrapper<List<T>>,\n            predicate?: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.remove\n         */\n        remove<T>(\n            this: LoDashExplicitWrapper<List<T>>,\n            predicate?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.tail\n    interface LoDashStatic {\n        /**\n         * Gets all but the first element of array.\n         *\n         * @param array The array to query.\n         * @return Returns the slice of array.\n         */\n        tail<T>(array: List<T> | null | undefined): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.tail\n         */\n        tail<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.tail\n         */\n        tail<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.slice\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array from start up to, but not including, end.\n         *\n         * @param array The array to slice.\n         * @param start The start position.\n         * @param end The end position.\n         * @return Returns the slice of array.\n         */\n        slice<T>(\n            array: List<T> | null | undefined,\n            start?: number,\n            end?: number\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.slice\n         */\n        slice<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            start?: number,\n            end?: number\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.slice\n         */\n        slice<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            start?: number,\n            end?: number\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.sortedIndex\n    interface LoDashStatic {\n        /**\n         * Uses a binary search to determine the lowest index at which `value` should\n         * be inserted into `array` in order to maintain its sort order.\n         *\n         * @category Array\n         * @param array The sorted array to inspect.\n         * @param value The value to evaluate.\n         * @returns Returns the index at which `value` should be inserted into `array`.\n         * @example\n         *\n         * _.sortedIndex([30, 50], 40);\n         * // => 1\n         *\n         * _.sortedIndex([4, 5], 4);\n         * // => 0\n         */\n        sortedIndex<T>(\n            array: List<T> | null | undefined,\n            value: T\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedIndex\n         */\n        sortedIndex<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedIndex\n         */\n        sortedIndex<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    // _.sortedIndexBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.sortedIndex` except that it accepts `iteratee`\n         * which is invoked for `value` and each element of `array` to compute their\n         * sort ranking. The iteratee is invoked with one argument: (value).\n         *\n         * @category Array\n         * @param array The sorted array to inspect.\n         * @param value The value to evaluate.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the index at which `value` should be inserted into `array`.\n         * @example\n         *\n         * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };\n         *\n         * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));\n         * // => 1\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\n         * // => 0\n         */\n        sortedIndexBy<T>(\n            array: List<T> | null | undefined,\n            value: T,\n            iteratee?: ValueIteratee<T>\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedIndexBy\n         */\n        sortedIndexBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            iteratee?: ValueIteratee<T>\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedIndexBy\n         */\n        sortedIndexBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.sortedLastIndex\n    interface LoDashStatic {\n        /**\n         * This method is like `_.sortedIndex` except that it returns the highest\n         * index at which `value` should be inserted into `array` in order to\n         * maintain its sort order.\n         *\n         * @category Array\n         * @param array The sorted array to inspect.\n         * @param value The value to evaluate.\n         * @returns Returns the index at which `value` should be inserted into `array`.\n         * @example\n         *\n         * _.sortedLastIndex([4, 5], 4);\n         * // => 1\n         */\n        sortedLastIndex<T>(\n            array: List<T> | null | undefined,\n            value: T\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedLastIndex\n         */\n        sortedLastIndex<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedLastIndex\n         */\n        sortedLastIndex<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.sortedLastIndexBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n         * which is invoked for `value` and each element of `array` to compute their\n         * sort ranking. The iteratee is invoked with one argument: (value).\n         *\n         * @category Array\n         * @param array The sorted array to inspect.\n         * @param value The value to evaluate.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the index at which `value` should be inserted into `array`.\n         * @example\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\n         * // => 1\n         */\n        sortedLastIndexBy<T>(\n            array: List<T> | null | undefined,\n            value: T,\n            iteratee: ValueIteratee<T>\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedLastIndexBy\n         */\n        sortedLastIndexBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            iteratee: ValueIteratee<T>\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedLastIndexBy\n         */\n        sortedLastIndexBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            iteratee: ValueIteratee<T>\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.sortedLastIndexOf\n    interface LoDashStatic {\n        /**\n         * This method is like `_.lastIndexOf` except that it performs a binary\n         * search on a sorted `array`.\n         *\n         * @category Array\n         * @param array The array to search.\n         * @param value The value to search for.\n         * @returns Returns the index of the matched value, else `-1`.\n         * @example\n         *\n         * _.sortedLastIndexOf([1, 1, 2, 2], 2);\n         * // => 3\n         */\n        sortedLastIndexOf<T>(\n            array: List<T> | null | undefined,\n            value: T\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedLastIndexOf\n         */\n        sortedLastIndexOf<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedLastIndexOf\n         */\n        sortedLastIndexOf<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.take\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array with n elements taken from the beginning.\n         *\n         * @param array The array to query.\n         * @param n The number of elements to take.\n         * @return Returns the slice of array.\n         */\n        take<T>(\n            array: List<T> | null | undefined,\n            n?: number\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.take\n         */\n        take<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            n?: number\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.take\n         */\n        take<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            n?: number\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.takeRight\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array with n elements taken from the end.\n         *\n         * @param array The array to query.\n         * @param n The number of elements to take.\n         * @return Returns the slice of array.\n         */\n        takeRight<T>(\n            array: List<T> | null | undefined,\n            n?: number\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.takeRight\n         */\n        takeRight<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            n?: number\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.takeRight\n         */\n        takeRight<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            n?: number\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.takeRightWhile\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array with elements taken from the end. Elements are taken until predicate returns\n         * falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param array The array to query.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the slice of array.\n         */\n        takeRightWhile<T>(\n            array: List<T> | null | undefined,\n            predicate?: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.takeRightWhile\n         */\n        takeRightWhile<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.takeRightWhile\n         */\n        takeRightWhile<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.takeWhile\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array with elements taken from the beginning. Elements are taken until predicate returns\n         * falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param array The array to query.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the slice of array.\n         */\n        takeWhile<T>(\n            array: List<T> | null | undefined,\n            predicate?: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.takeWhile\n         */\n        takeWhile<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.takeWhile\n         */\n        takeWhile<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.union\n    interface LoDashStatic {\n        /**\n         * Creates an array of unique values, in order, from all of the provided arrays using SameValueZero for\n         * equality comparisons.\n         *\n         * @param arrays The arrays to inspect.\n         * @return Returns the new array of combined values.\n         */\n        union<T>(...arrays: Array<List<T> | null | undefined>): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.union\n         */\n        union<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.union\n         */\n        union<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.unionBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.union` except that it accepts `iteratee` which is\n         * invoked for each element of each `arrays` to generate the criterion by which\n         * uniqueness is computed. The iteratee is invoked with one argument: (value).\n         *\n         * @param arrays The arrays to inspect.\n         * @param iteratee The iteratee invoked per element.\n         * @return Returns the new array of combined values.\n         */\n        unionBy<T>(\n            arrays: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            arrays1: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            arrays1: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            arrays1: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            arrays1: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            arrays5: List<T> | null | undefined,\n            ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            arrays5: List<T> | null | undefined,\n            ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            arrays5: List<T> | null | undefined,\n            ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.unionWith\n    interface LoDashStatic {\n        /**\n         * This method is like `_.union` except that it accepts `comparator` which\n         * is invoked to compare elements of `arrays`. The comparator is invoked\n         * with two arguments: (arrVal, othVal).\n         *\n         * @category Array\n         * @param [arrays] The arrays to inspect.\n         * @param [comparator] The comparator invoked per element.\n         * @returns Returns the new array of combined values.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n         *\n         * _.unionWith(objects, others, _.isEqual);\n         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n         */\n        unionWith<T>(\n            arrays: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): T[];\n\n        /**\n         * @see _.unionBy\n         */\n        unionWith<T>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): T[];\n\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...comparator: Array<Comparator<T> | List<T> | null | undefined>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            comparator?: Comparator<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...comparator: Array<Comparator<T> | List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            comparator?: Comparator<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...comparator: Array<Comparator<T> | List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.uniq\n    interface LoDashStatic {\n        /**\n         * Creates a duplicate-free version of an array, using\n         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n         * for equality comparisons, in which only the first occurrence of each element\n         * is kept.\n         *\n         * @category Array\n         * @param array The array to inspect.\n         * @returns Returns the new duplicate free array.\n         * @example\n         *\n         * _.uniq([2, 1, 2]);\n         * // => [2, 1]\n         */\n        uniq<T>(\n            array: List<T> | null | undefined\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.uniq\n         */\n        uniq<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.uniq\n         */\n        uniq<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.uniqBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.uniq` except that it accepts `iteratee` which is\n         * invoked for each element in `array` to generate the criterion by which\n         * uniqueness is computed. The iteratee is invoked with one argument: (value).\n         *\n         * @category Array\n         * @param array The array to inspect.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the new duplicate free array.\n         * @example\n         *\n         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n         * // => [2.1, 1.2]\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n         * // => [{ 'x': 1 }, { 'x': 2 }]\n         */\n        uniqBy(\n            array: string | null | undefined,\n            iteratee: StringIterator<NotVoid>\n        ): string[];\n\n        /**\n         * @see _.uniqBy\n         */\n        uniqBy<T>(\n            array: List<T> | null | undefined,\n            iteratee: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.uniqBy\n         */\n        uniqBy(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            iteratee: StringIterator<NotVoid>\n        ): LoDashImplicitWrapper<string[]>;\n\n        /**\n         * @see _.uniqBy\n         */\n        uniqBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.uniqBy\n         */\n        uniqBy(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            iteratee: StringIterator<NotVoid>\n        ): LoDashExplicitWrapper<string[]>;\n\n        /**\n         * @see _.uniqBy\n         */\n        uniqBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.uniqWith\n    interface LoDashStatic {\n        /**\n         * This method is like `_.uniq` except that it accepts `comparator` which\n         * is invoked to compare elements of `array`. The comparator is invoked with\n         * two arguments: (arrVal, othVal).\n         *\n         * @category Array\n         * @param array The array to inspect.\n         * @param [comparator] The comparator invoked per element.\n         * @returns Returns the new duplicate free array.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];\n         *\n         * _.uniqWith(objects, _.isEqual);\n         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n         */\n        uniqWith<T>(\n            array: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.uniqWith\n         */\n        uniqWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            comparator?: Comparator<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.uniqWith\n         */\n        uniqWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            comparator?: Comparator<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.sortedUniq\n    interface LoDashStatic {\n        /**\n         * This method is like `_.uniq` except that it's designed and optimized\n         * for sorted arrays.\n         *\n         * @category Array\n         * @param array The array to inspect.\n         * @returns Returns the new duplicate free array.\n         * @example\n         *\n         * _.sortedUniq([1, 1, 2]);\n         * // => [1, 2]\n         */\n        sortedUniq<T>(\n            array: List<T> | null | undefined\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedUniq\n         */\n        sortedUniq<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedUniq\n         */\n        sortedUniq<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.sortedUniqBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.uniqBy` except that it's designed and optimized\n         * for sorted arrays.\n         *\n         * @category Array\n         * @param array The array to inspect.\n         * @param [iteratee] The iteratee invoked per element.\n         * @returns Returns the new duplicate free array.\n         * @example\n         *\n         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n         * // => [1.1, 2.2]\n         */\n        sortedUniqBy(\n            array: string | null | undefined,\n            iteratee: StringIterator<NotVoid>\n        ): string[];\n\n        /**\n         * @see _.sortedUniqBy\n         */\n        sortedUniqBy<T>(\n            array: List<T> | null | undefined,\n            iteratee: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedUniqBy\n         */\n        sortedUniqBy(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            iteratee: StringIterator<NotVoid>\n        ): LoDashImplicitWrapper<string[]>;\n\n        /**\n         * @see _.sortedUniqBy\n         */\n        sortedUniqBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedUniqBy\n         */\n        sortedUniqBy(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            iteratee: StringIterator<NotVoid>\n        ): LoDashExplicitWrapper<string[]>;\n\n        /**\n         * @see _.sortedUniqBy\n         */\n        sortedUniqBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.unzip\n    interface LoDashStatic {\n        /**\n         * This method is like _.zip except that it accepts an array of grouped elements and creates an array\n         * regrouping the elements to their pre-zip configuration.\n         *\n         * @param array The array of grouped elements to process.\n         * @return Returns the new array of regrouped elements.\n         */\n        unzip<T>(array: T[][] | List<List<T>> | null | undefined): T[][];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unzip\n         */\n        unzip<T>(this: LoDashImplicitWrapper<T[][] | List<List<T>> | null | undefined>): LoDashImplicitWrapper<T[][]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unzip\n         */\n        unzip<T>(this: LoDashExplicitWrapper<T[][] | List<List<T>> | null | undefined>): LoDashExplicitWrapper<T[][]>;\n    }\n\n    //_.unzipWith\n    interface LoDashStatic {\n        /**\n         * This method is like _.unzip except that it accepts an iteratee to specify how regrouped values should be\n         * combined. The iteratee is bound to thisArg and invoked with four arguments: (accumulator, value, index,\n         * group).\n         *\n         * @param array The array of grouped elements to process.\n         * @param iteratee The function to combine regrouped values.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the new array of regrouped elements.\n         */\n        unzipWith<T, TResult>(\n            array: List<List<T>> | null | undefined,\n            iteratee: (...values: T[]) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.unzipWith\n         */\n        unzipWith<T>(\n            array: List<List<T>> | null | undefined\n        ): T[][];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unzipWith\n         */\n        unzipWith<T, TResult>(\n            this: LoDashImplicitWrapper<List<List<T>> | null | undefined>,\n            iteratee: (...values: T[]) => TResult\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.unzipWith\n         */\n        unzipWith<T>(\n            this: LoDashImplicitWrapper<List<List<T>> | null | undefined>\n        ): LoDashImplicitWrapper<T[][]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unzipWith\n         */\n        unzipWith<T, TResult>(\n            this: LoDashExplicitWrapper<List<List<T>> | null | undefined>,\n            iteratee: (...values: T[]) => TResult\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.unzipWith\n         */\n        unzipWith<T>(\n            this: LoDashExplicitWrapper<List<List<T>> | null | undefined>\n        ): LoDashExplicitWrapper<T[][]>;\n    }\n\n    //_.without\n    interface LoDashStatic {\n        /**\n         * Creates an array excluding all provided values using SameValueZero for equality comparisons.\n         *\n         * @param array The array to filter.\n         * @param values The values to exclude.\n         * @return Returns the new array of filtered values.\n         */\n        without<T>(\n            array: List<T> | null | undefined,\n            ...values: T[]\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.without\n         */\n        without<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...values: T[]\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.without\n         */\n        without<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...values: T[]\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.xor\n    interface LoDashStatic {\n        /**\n         * Creates an array of unique values that is the symmetric difference of the provided arrays.\n         *\n         * @param arrays The arrays to inspect.\n         * @return Returns the new array of values.\n         */\n        xor<T>(...arrays: Array<List<T> | null | undefined>): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.xor\n         */\n        xor<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.xor\n         */\n        xor<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.xorBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.xor` except that it accepts `iteratee` which is\n         * invoked for each element of each `arrays` to generate the criterion by which\n         * uniqueness is computed. The iteratee is invoked with one argument: (value).\n         *\n         * @category Array\n         * @param [arrays] The arrays to inspect.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the new array of values.\n         * @example\n         *\n         * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n         * // => [1.2, 4.3]\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n         * // => [{ 'x': 2 }]\n         */\n        xorBy<T>(\n            arrays: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.xor\n         */\n        xorBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.xorWith\n    interface LoDashStatic {\n        /**\n         * This method is like `_.xor` except that it accepts `comparator` which is\n         * invoked to compare elements of `arrays`. The comparator is invoked with\n         * two arguments: (arrVal, othVal).\n         *\n         * @category Array\n         * @param [arrays] The arrays to inspect.\n         * @param [comparator] The comparator invoked per element.\n         * @returns Returns the new array of values.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n         *\n         * _.xorWith(objects, others, _.isEqual);\n         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n         */\n        xorWith<T>(\n            arrays: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): T[];\n\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): T[];\n\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...comparator: Array<Comparator<T> | List<T> | null | undefined>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            comparator?: Comparator<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...comparator: Array<Comparator<T> | List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            comparator?: Comparator<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...comparator: Array<Comparator<T> | List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.zip\n    interface LoDashStatic {\n        /**\n         * Creates an array of grouped elements, the first of which contains the first elements of the given arrays,\n         * the second of which contains the second elements of the given arrays, and so on.\n         *\n         * @param arrays The arrays to process.\n         * @return Returns the new array of grouped elements.\n         */\n        zip<T>(...arrays: Array<List<T> | null | undefined>): T[][];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.zip\n         */\n        zip<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[][]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.zip\n         */\n        zip<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[][]>;\n    }\n\n    //_.zipObject\n    interface LoDashStatic {\n        /**\n         * This method is like _.fromPairs except that it accepts two arrays, one of property\n         * identifiers and one of corresponding values.\n         *\n         * @param props The property names.\n         * @param values The property values.\n         * @return Returns the new object.\n         */\n        zipObject<T>(\n            props: List<PropertyName>,\n            values: List<T>\n        ): Dictionary<T>;\n\n        /**\n         * @see _.zipObject\n         */\n        zipObject(\n            props?: List<PropertyName>\n        ): Dictionary<undefined>;\n\n        /**\n         * This method is like _.zipObject except that it supports property paths.\n         *\n         * @param paths The property names.\n         * @param values The property values.\n         * @return Returns the new object.\n         */\n        zipObjectDeep(\n            paths?: List<PropertyPath>,\n            values?: List<any>\n        ): object;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.zipObject\n         */\n        zipObject<T>(\n            this: LoDashImplicitWrapper<List<PropertyName>>,\n            values: List<T>\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.zipObject\n         */\n        zipObject(\n            this: LoDashImplicitWrapper<List<PropertyName>>\n        ): LoDashImplicitWrapper<Dictionary<undefined>>;\n\n        /**\n         * @see _.zipObjectDeep\n         */\n        zipObjectDeep(\n            this: LoDashImplicitWrapper<List<PropertyPath>>,\n            values?: List<any>\n        ): LoDashImplicitWrapper<object>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.zipObject\n         */\n        zipObject<T>(\n            this: LoDashExplicitWrapper<List<PropertyName>>,\n            values: List<T>\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.zipObject\n         */\n        zipObject(\n            this: LoDashExplicitWrapper<List<PropertyName>>\n        ): LoDashExplicitWrapper<Dictionary<undefined>>;\n\n        /**\n         * @see _.zipObjectDeep\n         */\n        zipObjectDeep(\n            this: LoDashExplicitWrapper<List<PropertyPath>>,\n            values?: List<any>\n        ): LoDashExplicitWrapper<object>;\n    }\n\n    //_.zipWith\n    interface LoDashStatic {\n        /**\n         * This method is like _.zip except that it accepts an iteratee to specify how grouped values should be\n         * combined. The iteratee is bound to thisArg and invoked with four arguments: (accumulator, value, index,\n         * group).\n         * @param [arrays] The arrays to process.\n         * @param [iteratee] The function to combine grouped values.\n         * @param [thisArg] The `this` binding of `iteratee`.\n         * @return Returns the new array of grouped elements.\n         */\n        zipWith<T>(\n            ...arrays: Array<List<T> | null | undefined>\n        ): T[][];\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            arrays: List<T> | null | undefined,\n            iteratee: (value1: T) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T, value4: T) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            arrays5: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T, value4: T, value5: T) => TResult\n        ): TResult[];\n\n        zipWith<T, TResult>(\n            ...iteratee: Array<((...group: T[]) => TResult) | List<T> | null | undefined>\n        ): TResult[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[][]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: (value1: T) => TResult\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T) => TResult\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T) => TResult\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T, value4: T) => TResult\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            arrays5: List<T> | null | undefined,\n            ...iteratee: Array<((...group: T[]) => TResult) | List<T> | null | undefined>\n        ): LoDashImplicitWrapper<TResult[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[][]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: (value1: T) => TResult\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T) => TResult\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T) => TResult\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T, value4: T) => TResult\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            arrays5: List<T> | null | undefined,\n            ...iteratee: Array<((...group: T[]) => TResult) | List<T> | null | undefined>\n        ): LoDashExplicitWrapper<TResult[]>;\n    }\n\n    /*********\n     * Chain *\n     *********/\n\n    //_.chain\n    interface LoDashStatic {\n        /**\n         * Creates a lodash object that wraps value with explicit method chaining enabled.\n         *\n         * @param value The value to wrap.\n         * @return Returns the new lodash wrapper instance.\n         */\n        chain<T>(value: T): LoDashExplicitWrapper<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.chain\n         */\n        chain(): LoDashExplicitWrapper<TValue>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.chain\n         */\n        chain(): this;\n    }\n\n    //_.tap\n    interface LoDashStatic {\n        /**\n         * This method invokes interceptor and returns value. The interceptor is bound to thisArg and invoked with one\n         * argument; (value). The purpose of this method is to \"tap into\" a method chain in order to perform operations\n         * on intermediate results within the chain.\n         *\n         * @param value The value to provide to interceptor.\n         * @param interceptor The function to invoke.\n         * @parem thisArg The this binding of interceptor.\n         * @return Returns value.\n         **/\n        tap<T>(\n            value: T,\n            interceptor: (value: T) => void\n        ): T;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.tap\n         */\n        tap(\n            interceptor: (value: TValue) => void\n        ): this;\n    }\n\n    //_.thru\n    interface LoDashStatic {\n        /**\n         * This method is like _.tap except that it returns the result of interceptor.\n         *\n         * @param value The value to provide to interceptor.\n         * @param interceptor The function to invoke.\n         * @param thisArg The this binding of interceptor.\n         * @return Returns the result of interceptor.\n         */\n        thru<T, TResult>(\n            value: T,\n            interceptor: (value: T) => TResult\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.thru\n         */\n        thru<TResult>(interceptor: (value: TValue) => TResult): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.thru\n         */\n        thru<TResult>(interceptor: (value: TValue) => TResult): LoDashExplicitWrapper<TResult>;\n    }\n\n    //_.prototype.commit\n    interface LoDashWrapper<TValue> {\n        /**\n         * Executes the chained sequence and returns the wrapped result.\n         *\n         * @return Returns the new lodash wrapper instance.\n         */\n        commit(): this;\n    }\n\n    //_.prototype.plant\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * Creates a clone of the chained sequence planting value as the wrapped value.\n         * @param value The value to plant as the wrapped value.\n         * @return Returns the new lodash wrapper instance.\n         */\n        plant<T>(value: T): LoDashImplicitWrapper<T>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.plant\n         */\n        plant<T>(value: T): LoDashExplicitWrapper<T>;\n    }\n\n    //_.prototype.toJSON\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.value\n         */\n        toJSON(): TValue;\n    }\n\n    //_.prototype.toString\n    interface LoDashWrapper<TValue> {\n        /**\n         * Produces the result of coercing the unwrapped value to a string.\n         *\n         * @return Returns the coerced string value.\n         */\n        toString(): string;\n    }\n\n    //_.prototype.value\n    interface LoDashWrapper<TValue> {\n        /**\n         * Executes the chained sequence to extract the unwrapped value.\n         *\n         * @alias _.toJSON, _.valueOf\n         *\n         * @return Returns the resolved unwrapped value.\n         */\n        value(): TValue;\n    }\n\n    //_.valueOf\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.value\n         */\n        valueOf(): TValue;\n    }\n\n    /**************\n     * Collection *\n     **************/\n\n    //_.at\n    interface LoDashStatic {\n        /**\n         * Creates an array of elements corresponding to the given keys, or indexes, of collection. Keys may be\n         * specified as individual arguments or as arrays of keys.\n         *\n         * @param object The object to iterate over.\n         * @param props The property names or indexes of elements to pick, specified individually or in arrays.\n         * @return Returns the new array of picked elements.\n         */\n        at<T>(\n            object: List<T> | Dictionary<T> | null | undefined,\n            ...props: PropertyPath[]\n        ): T[];\n\n        /**\n         * @see _.at\n         */\n        at<T extends object>(\n            object: T | null | undefined,\n            ...props: Array<Many<keyof T>>\n        ): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.at\n         */\n        at<T>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | null | undefined>,\n            ...props: PropertyPath[]\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.at\n         */\n        at<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            ...props: Array<Many<keyof T>>\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.at\n         */\n        at<T>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | null | undefined>,\n            ...props: PropertyPath[]\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.at\n         */\n        at<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            ...props: Array<Many<keyof T>>\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.countBy\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of keys generated from the results of running each element of collection through\n         * iteratee. The corresponding value of each key is the number of times the key was returned by iteratee. The\n         * iteratee is bound to thisArg and invoked with three arguments:\n         * (value, index|key, collection).\n         *\n         * If a property name is provided for iteratee the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for iteratee the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the composed aggregate object.\n         */\n        countBy<T>(\n            collection: string | null | undefined,\n            iteratee?: StringIterator<T>\n        ): Dictionary<number>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ListIteratee<T>\n        ): Dictionary<number>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee?: NumericDictionaryIteratee<T>\n        ): Dictionary<number>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T extends object>(\n            collection: T | null | undefined,\n            iteratee?: ObjectIteratee<T>\n        ): Dictionary<number>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            iteratee?: StringIterator<T>\n        ): LoDashImplicitWrapper<Dictionary<number>>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<number>>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee?: ObjectIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<number>>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<number>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            iteratee?: StringIterator<T>\n        ): LoDashExplicitWrapper<Dictionary<number>>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<number>>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee?: ObjectIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<number>>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<number>>;\n    }\n\n    //_.each\n    interface LoDashStatic {\n        each: typeof _.forEach; // tslint:disable-line:no-unnecessary-qualifier\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forEach\n         */\n        each<T>(\n            this: LoDashWrapper<T[] | null | undefined>,\n            iteratee?: ArrayIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEach\n         */\n        each(\n            this: LoDashWrapper<string | null | undefined>,\n            iteratee?: StringIterator<any>\n        ): this;\n\n        /**\n         * @see _.forEach\n         */\n        each<T>(\n            this: LoDashWrapper<List<T> | null | undefined>,\n            iteratee?: ListIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEach\n         */\n        each<T extends object>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.eachRight\n    interface LoDashStatic {\n        eachRight: typeof _.forEachRight; // tslint:disable-line:no-unnecessary-qualifier\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forEachRight\n         */\n        eachRight<T>(\n            this: LoDashWrapper<T[] | null | undefined>,\n            iteratee?: ArrayIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEachRight\n         */\n        eachRight(\n            this: LoDashWrapper<string | null | undefined>,\n            iteratee?: StringIterator<any>\n        ): this;\n\n        /**\n         * @see _.forEachRight\n         */\n        eachRight<T>(\n            this: LoDashWrapper<List<T> | null | undefined>,\n            iteratee?: ListIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEachRight\n         */\n        eachRight<T extends object>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.every\n    interface LoDashStatic {\n        /**\n         * Checks if predicate returns truthy for all elements of collection. Iteration is stopped once predicate\n         * returns falsey. The predicate is invoked with three arguments: (value, index|key, collection).\n         *\n         * @param collection The collection to iterate over.\n         * @param predicate The function invoked per iteration.\n         * @return Returns true if all elements pass the predicate check, else false.\n         */\n        every<T>(\n            collection: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.every\n         */\n        every<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            predicate?: NumericDictionaryIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.every\n         */\n        every<T extends object>(\n            collection: T | null | undefined,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.every\n         */\n        every<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.every\n         */\n        every<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.every\n         */\n        every<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            predicate?: NumericDictionaryIterateeCustom<T, boolean>\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.every\n         */\n        every<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<boolean>;\n\n        /**\n         * @see _.every\n         */\n        every<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<boolean>;\n\n        /**\n         * @see _.every\n         */\n        every<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            predicate?: NumericDictionaryIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.filter\n    interface LoDashStatic {\n        /**\n         * Iterates over elements of collection, returning an array of all elements predicate returns truthy for. The\n         * predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param collection The collection to iterate over.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the new filtered array.\n         */\n        filter(\n            collection: string | null | undefined,\n            predicate?: StringIterator<boolean>\n        ): string[];\n\n        /**\n         * @see _.filter\n         */\n        filter<T, S extends T>(\n            collection: List<T> | null | undefined,\n            predicate: ListIteratorTypeGuard<T, S>\n        ): S[];\n\n        /**\n         * @see _.filter\n         */\n        filter<T>(\n            collection: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): T[];\n\n        /**\n         * @see _.filter\n         */\n        filter<T extends object, S extends T[keyof T]>(\n            collection: T | null | undefined,\n            predicate: ObjectIteratorTypeGuard<T, S>\n        ): S[];\n\n        /**\n         * @see _.filter\n         */\n        filter<T extends object>(\n            collection: T | null | undefined,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.filter\n         */\n        filter(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            predicate?: StringIterator<boolean>\n        ): LoDashImplicitWrapper<string[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T, S extends T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate: ListIteratorTypeGuard<T, S>\n        ): LoDashImplicitWrapper<S[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T extends object, S extends T[keyof T]>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate: ObjectIteratorTypeGuard<T, S>\n        ): LoDashImplicitWrapper<S[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.filter\n         */\n        filter(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            predicate?: StringIterator<boolean>\n        ): LoDashExplicitWrapper<string[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T, S extends T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate: ListIteratorTypeGuard<T, S>\n        ): LoDashExplicitWrapper<S[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T extends object, S extends T[keyof T]>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate: ObjectIteratorTypeGuard<T, S>\n        ): LoDashExplicitWrapper<S[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.find\n    interface LoDashStatic {\n        /**\n         * Iterates over elements of collection, returning the first element predicate returns truthy for.\n         * The predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param collection The collection to search.\n         * @param predicate The function invoked per iteration.\n         * @param fromIndex The index to search from.\n         * @return Returns the matched element, else undefined.\n         */\n        find<T, S extends T>(\n            collection: List<T> | null | undefined,\n            predicate: ListIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.find\n         */\n        find<T>(\n            collection: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T|undefined;\n\n        /**\n         * @see _.find\n         */\n        find<T extends object, S extends T[keyof T]>(\n            collection: T | null | undefined,\n            predicate: ObjectIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.find\n         */\n        find<T extends object>(\n            collection: T | null | undefined,\n            predicate?: ObjectIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T[keyof T]|undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.find\n         */\n        find<T, S extends T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate: ListIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.find\n         */\n        find<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T|undefined;\n\n        /**\n         * @see _.find\n         */\n        find<T extends object, S extends T[keyof T]>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate: ObjectIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.find\n         */\n        find<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T[keyof T]|undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.find\n         */\n        find<T, S extends T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate: ListIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<S|undefined>;\n\n        /**\n         * @see _.find\n         */\n        find<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<T|undefined>;\n\n        /**\n         * @see _.find\n         */\n        find<T extends object, S extends T[keyof T]>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate: ObjectIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<S|undefined>;\n\n        /**\n         * @see _.find\n         */\n        find<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<T[keyof T]|undefined>;\n    }\n\n    //_.findLast\n    interface LoDashStatic {\n        /**\n        * This method is like _.find except that it iterates over elements of a collection from\n        * right to left.\n        * @param collection Searches for a value in this list.\n        * @param predicate The function called per iteration.\n        * @param fromIndex The index to search from.\n        * @return The found element, else undefined.\n        **/\n        findLast<T, S extends T>(\n            collection: List<T> | null | undefined,\n            predicate: ListIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T>(\n            collection: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T|undefined;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T extends object, S extends T[keyof T]>(\n            collection: T | null | undefined,\n            predicate: ObjectIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T extends object>(\n            collection: T | null | undefined,\n            predicate?: ObjectIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T[keyof T]|undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.findLast\n         */\n        findLast<T, S extends T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate: ListIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S | undefined;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T | undefined;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T extends object, S extends T[keyof T]>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate: ObjectIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T[keyof T]|undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.findLast\n         */\n        findLast<T, S extends T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate: ListIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<S | undefined>;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<T | undefined>;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T extends object, S extends T[keyof T]>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate: ObjectIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<S|undefined>;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<T[keyof T]|undefined>;\n    }\n\n    //_.flatMap\n    interface LoDashStatic {\n        /**\n         * Creates an array of flattened values by running each element in collection through iteratee\n         * and concating its result to the other mapped values. The iteratee is invoked with three arguments:\n         * (value, index|key, collection).\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @return Returns the new flattened array.\n         */\n        flatMap<T>(\n            collection: List<Many<T>> | Dictionary<Many<T>> | NumericDictionary<Many<T>> | null | undefined\n        ): T[];\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            collection: object | null | undefined\n        ): any[];\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T, TResult>(\n            collection: List<T> | null | undefined,\n            iteratee: ListIterator<T, Many<TResult>>\n        ): TResult[];\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee: NumericDictionaryIterator<T, Many<TResult>>\n        ): TResult[];\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T extends object, TResult>(\n            collection: T | null | undefined,\n            iteratee: ObjectIterator<T, Many<TResult>>\n        ): TResult[];\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            collection: object | null | undefined,\n            iteratee: string\n        ): any[];\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            collection: object | null | undefined,\n            iteratee: object\n        ): boolean[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T>(this: LoDashImplicitWrapper<List<Many<T>> | Dictionary<Many<T>> | NumericDictionary<Many<T>> | null | undefined>): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(): LoDashImplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, Many<TResult>>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee: ObjectIterator<T, Many<TResult>>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee: NumericDictionaryIterator<T, Many<TResult>>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            iteratee: string\n        ): LoDashImplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            iteratee: object\n        ): LoDashImplicitWrapper<boolean[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T>(this: LoDashExplicitWrapper<List<Many<T>> | Dictionary<Many<T>> | NumericDictionary<Many<T>> | null | undefined>): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(): LoDashExplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, Many<TResult>>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee: NumericDictionaryIterator<T, Many<TResult>>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee: ObjectIterator<T, Many<TResult>>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            iteratee: string\n        ): LoDashExplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            iteratee: object\n        ): LoDashExplicitWrapper<boolean[]>;\n    }\n\n    //_.flatMapDeep\n    interface LoDashStatic {\n        /**\n         * This method is like `_.flatMap` except that it recursively flattens the\n         * mapped results.\n         *\n         * @since 4.7.0\n         * @category Collection\n         * @param collection The collection to iterate over.\n         * @param [iteratee=_.identity] The function invoked per iteration.\n         * @returns Returns the new flattened array.\n         * @example\n         *\n         * function duplicate(n) {\n         *   return [[[n, n]]];\n         * }\n         *\n         * _.flatMapDeep([1, 2], duplicate);\n         * // => [1, 1, 2, 2]\n         */\n        flatMapDeep<T>(\n            collection: List<ListOfRecursiveArraysOrValues<T> | T> | Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined\n        ): T[];\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T, TResult>(\n            collection: List<T> | null | undefined,\n            iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): TResult[];\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee: NumericDictionaryIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): TResult[];\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T extends object, TResult>(\n            collection: T | null | undefined,\n            iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): TResult[];\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep(\n            collection: object | null | undefined,\n            iteratee: string\n        ): any[];\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep(\n            collection: object | null | undefined,\n            iteratee: object\n        ): boolean[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T>(\n            this: LoDashImplicitWrapper<List<ListOfRecursiveArraysOrValues<T> | T> | Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee: NumericDictionaryIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep(\n            this: LoDashImplicitWrapper<object | null | undefined>,\n            iteratee: string\n        ): LoDashImplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep(\n            this: LoDashImplicitWrapper<object | null | undefined>,\n            iteratee: object\n        ): LoDashImplicitWrapper<boolean[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T>(\n            this: LoDashExplicitWrapper<List<ListOfRecursiveArraysOrValues<T> | T> | Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee: NumericDictionaryIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep(\n            this: LoDashExplicitWrapper<object | null | undefined>,\n            iteratee: string\n        ): LoDashExplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep(\n            this: LoDashExplicitWrapper<object | null | undefined>,\n            iteratee: object\n        ): LoDashExplicitWrapper<boolean[]>;\n    }\n\n    //_.flatMapDepth\n    interface LoDashStatic {\n        /**\n         * This method is like `_.flatMap` except that it recursively flattens the\n         * mapped results up to `depth` times.\n         *\n         * @since 4.7.0\n         * @category Collection\n         * @param collection The collection to iterate over.\n         * @param [iteratee=_.identity] The function invoked per iteration.\n         * @param [depth=1] The maximum recursion depth.\n         * @returns Returns the new flattened array.\n         * @example\n         *\n         * function duplicate(n) {\n         *   return [[[n, n]]];\n         * }\n         *\n         * _.flatMapDepth([1, 2], duplicate, 2);\n         * // => [[1, 1], [2, 2]]\n         */\n        flatMapDepth<T>(\n            collection: List<ListOfRecursiveArraysOrValues<T> | T> | Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined\n        ): T[];\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T, TResult>(\n            collection: List<T> | null | undefined,\n            iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): TResult[];\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee: NumericDictionaryIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): TResult[];\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T extends object, TResult>(\n            collection: T | null | undefined,\n            iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): TResult[];\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth(\n            collection: object | null | undefined,\n            iteratee: string,\n            depth?: number\n        ): any[];\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth(\n            collection: object | null | undefined,\n            iteratee: object,\n            depth?: number\n        ): boolean[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T>(\n            this: LoDashImplicitWrapper<List<ListOfRecursiveArraysOrValues<T> | T> | Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee: NumericDictionaryIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth(\n            this: LoDashImplicitWrapper<object | null | undefined>,\n            iteratee: string,\n            depth?: number\n        ): LoDashImplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth(\n            this: LoDashImplicitWrapper<object | null | undefined>,\n            iteratee: object,\n            depth?: number\n        ): LoDashImplicitWrapper<boolean[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T>(\n            this: LoDashExplicitWrapper<List<ListOfRecursiveArraysOrValues<T> | T> | Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee: NumericDictionaryIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth(\n            this: LoDashExplicitWrapper<object | null | undefined>,\n            iteratee: string,\n            depth?: number\n        ): LoDashExplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth(\n            this: LoDashExplicitWrapper<object | null | undefined>,\n            iteratee: object,\n            depth?: number\n        ): LoDashExplicitWrapper<boolean[]>;\n    }\n\n    //_.forEach\n    interface LoDashStatic {\n        /**\n         * Iterates over elements of collection invoking iteratee for each element. The iteratee is bound to thisArg\n         * and invoked with three arguments:\n         * (value, index|key, collection). Iteratee functions may exit iteration early by explicitly returning false.\n         *\n         * Note: As with other \"Collections\" methods, objects with a \"length\" property are iterated like arrays. To\n         * avoid this behavior _.forIn or _.forOwn may be used for object iteration.\n         *\n         * @alias _.each\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         */\n        forEach<T>(\n            collection: T[],\n            iteratee?: ArrayIterator<T, any>\n        ): T[];\n\n        /**\n         * @see _.forEach\n         */\n        forEach(\n            collection: string,\n            iteratee?: StringIterator<any>\n        ): string;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T>(\n            collection: List<T>,\n            iteratee?: ListIterator<T, any>\n        ): List<T>;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T extends object>(\n            collection: T,\n            iteratee?: ObjectIterator<T, any>\n        ): T;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T, TArray extends T[] | null | undefined>(\n            collection: TArray & (T[] | null | undefined),\n            iteratee?: ArrayIterator<T, any>\n        ): TArray;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<TString extends string | null | undefined>(\n            collection: TString,\n            iteratee?: StringIterator<any>\n        ): TString;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T, TList extends List<T> | null | undefined>(\n            collection: TList & (List<T> | null | undefined),\n            iteratee?: ListIterator<T, any>\n        ): TList;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T extends object>(\n            collection: T | null | undefined,\n            iteratee?: ObjectIterator<T, any>\n        ): T | null | undefined;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forEach\n         */\n        forEach<T>(\n            this: LoDashWrapper<T[] | null | undefined>,\n            iteratee?: ArrayIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEach\n         */\n        forEach(\n            this: LoDashWrapper<string | null | undefined>,\n            iteratee?: StringIterator<any>\n        ): this;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T>(\n            this: LoDashWrapper<List<T> | null | undefined>,\n            iteratee?: ListIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T extends object>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.forEachRight\n    interface LoDashStatic {\n        /**\n         * This method is like _.forEach except that it iterates over elements of collection from right to left.\n         *\n         * @alias _.eachRight\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function called per iteration.\n         * @param thisArg The this binding of callback.\n         */\n        forEachRight<T>(\n            collection: T[],\n            iteratee?: ArrayIterator<T, any>\n        ): T[];\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight(\n            collection: string,\n            iteratee?: StringIterator<any>\n        ): string;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T>(\n            collection: List<T>,\n            iteratee?: ListIterator<T, any>\n        ): List<T>;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T extends object>(\n            collection: T,\n            iteratee?: ObjectIterator<T, any>\n        ): T;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T, TArray extends T[] | null | undefined>(\n            collection: TArray & (T[] | null | undefined),\n            iteratee?: ArrayIterator<T, any>\n        ): TArray;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<TString extends string | null | undefined>(\n            collection: TString,\n            iteratee?: StringIterator<any>\n        ): TString;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T, TList extends List<T> | null | undefined>(\n            collection: TList & (List<T> | null | undefined),\n            iteratee?: ListIterator<T, any>\n        ): TList;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T extends object>(\n            collection: T | null | undefined,\n            iteratee?: ObjectIterator<T, any>\n        ): T | null | undefined;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T>(\n            this: LoDashWrapper<T[] | null | undefined>,\n            iteratee?: ArrayIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight(\n            this: LoDashWrapper<string | null | undefined>,\n            iteratee?: StringIterator<any>\n        ): this;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T>(\n            this: LoDashWrapper<List<T> | null | undefined>,\n            iteratee?: ListIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T extends object>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.groupBy\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of keys generated from the results of running each element of collection through\n         * iteratee. The corresponding value of each key is an array of the elements responsible for generating the\n         * key. The iteratee is bound to thisArg and invoked with three arguments:\n         * (value, index|key, collection).\n         *\n         * If a property name is provided for iteratee the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for iteratee the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the composed aggregate object.\n         */\n        groupBy(\n            collection: string | null | undefined,\n            iteratee?: StringIterator<NotVoid>\n        ): Dictionary<string[]>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ListIteratee<T>\n        ): Dictionary<T[]>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee?: NumericDictionaryIteratee<T>\n        ): Dictionary<T[]>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T extends object>(\n            collection: T | null | undefined,\n            iteratee?: ObjectIteratee<T>\n        ): Dictionary<Array<T[keyof T]>>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.groupBy\n         */\n        groupBy(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            iteratee?: StringIterator<NotVoid>\n        ): LoDashImplicitWrapper<Dictionary<string[]>>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<T[]>>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee?: ObjectIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<Array<T[keyof T]>>>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<T[]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.groupBy\n         */\n        groupBy(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            iteratee?: StringIterator<NotVoid>\n        ): LoDashExplicitWrapper<Dictionary<string[]>>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<T[]>>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<T[]>>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee?: ObjectIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<Array<T[keyof T]>>>;\n    }\n\n    //_.includes\n    interface LoDashStatic {\n        /**\n         * Checks if target is in collection using SameValueZero for equality comparisons. If fromIndex is negative,\n         * it’s used as the offset from the end of collection.\n         *\n         * @param collection The collection to search.\n         * @param target The value to search for.\n         * @param fromIndex The index to search from.\n         * @return True if the target element is found, else false.\n         */\n        includes<T>(\n            collection: List<T>|Dictionary<T> | null | undefined,\n            target: T,\n            fromIndex?: number\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.includes\n         */\n        includes<T>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | null | undefined>,\n            target: T,\n            fromIndex?: number\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.includes\n         */\n        includes<T>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | null | undefined>,\n            target: T,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.keyBy\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of keys generated from the results of running each element of collection through\n         * iteratee. The corresponding value of each key is the last element responsible for generating the key. The\n         * iteratee function is bound to thisArg and invoked with three arguments:\n         * (value, index|key, collection).\n         *\n         * If a property name is provided for iteratee the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for iteratee the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the composed aggregate object.\n         */\n        keyBy(\n            collection: string | null | undefined,\n            iteratee?: StringIterator<PropertyName>\n        ): Dictionary<string>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ListIterateeCustom<T, PropertyName>\n        ): Dictionary<T>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T extends object>(\n            collection: T | null | undefined,\n            iteratee?: ObjectIterateeCustom<T, PropertyName>\n        ): Dictionary<T[keyof T]>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee?: NumericDictionaryIterateeCustom<T, PropertyName>\n        ): Dictionary<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.keyBy\n         */\n        keyBy(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            iteratee?: StringIterator<PropertyName>\n        ): LoDashImplicitWrapper<Dictionary<string>>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIterateeCustom<T, PropertyName>\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee?: ObjectIterateeCustom<T, PropertyName>\n        ): LoDashImplicitWrapper<Dictionary<T[keyof T]>>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIterateeCustom<T, PropertyName>\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.keyBy\n         */\n        keyBy(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            iteratee?: StringIterator<PropertyName>\n        ): LoDashExplicitWrapper<Dictionary<string>>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIterateeCustom<T, PropertyName>\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee?: ObjectIterateeCustom<T, PropertyName>\n        ): LoDashExplicitWrapper<Dictionary<T[keyof T]>>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIterateeCustom<T, PropertyName>\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n    }\n\n    //_.invoke\n    interface LoDashStatic {\n        /**\n        * Invokes the method at path of object.\n        * @param object The object to query.\n        * @param path The path of the method to invoke.\n        * @param args The arguments to invoke the method with.\n        **/\n        invoke(\n            object: any,\n            path: PropertyPath,\n            ...args: any[]): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n        * @see _.invoke\n        **/\n        invoke(\n            path: PropertyPath,\n            ...args: any[]): any;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n        * @see _.invoke\n        **/\n        invoke(\n            path: PropertyPath,\n            ...args: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.invokeMap\n    interface LoDashStatic {\n        /**\n        * Invokes the method named by methodName on each element in the collection returning\n        * an array of the results of each invoked method. Additional arguments will be provided\n        * to each invoked method. If methodName is a function it will be invoked for, and this\n        * bound to, each element in the collection.\n        * @param collection The collection to iterate over.\n        * @param methodName The name of the method to invoke.\n        * @param args Arguments to invoke the method with.\n        **/\n        invokeMap(\n            collection: object | null | undefined,\n            methodName: string,\n            ...args: any[]): any[];\n\n        /**\n        * @see _.invokeMap\n        **/\n        invokeMap<TResult>(\n            collection: object | null | undefined,\n            method: (...args: any[]) => TResult,\n            ...args: any[]): TResult[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n        * @see _.invokeMap\n        **/\n        invokeMap(\n            methodName: string,\n            ...args: any[]): LoDashImplicitWrapper<any[]>;\n\n        /**\n        * @see _.invokeMap\n        **/\n        invokeMap<TResult>(\n            method: (...args: any[]) => TResult,\n            ...args: any[]): LoDashImplicitWrapper<TResult[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n        * @see _.invokeMap\n        **/\n        invokeMap(\n            methodName: string,\n            ...args: any[]): LoDashExplicitWrapper<any[]>;\n\n        /**\n        * @see _.invokeMap\n        **/\n        invokeMap<TResult>(\n            method: (...args: any[]) => TResult,\n            ...args: any[]): LoDashExplicitWrapper<TResult[]>;\n    }\n\n    //_.map\n    interface LoDashStatic {\n        /**\n         * Creates an array of values by running each element in collection through iteratee. The iteratee is bound to\n         * thisArg and invoked with three arguments: (value, index|key, collection).\n         *\n         * If a property name is provided for iteratee the created _.property style callback returns the property value\n         * of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for iteratee the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * Many lodash methods are guarded to work as iteratees for methods like _.every, _.filter, _.map, _.mapValues,\n         * _.reject, and _.some.\n         *\n         * The guarded methods are:\n         * ary, callback, chunk, clone, create, curry, curryRight, drop, dropRight, every, fill, flatten, invert, max,\n         * min, parseInt, slice, sortBy, take, takeRight, template, trim, trimLeft, trimRight, trunc, random, range,\n         * sample, some, sum, uniq, and words\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the new mapped array.\n         */\n        map<T, TResult>(\n            collection: List<T> | null | undefined,\n            iteratee: ListIterator<T, TResult>\n        ): TResult[];\n\n        /**\n         * @see _.map\n         */\n        map<T>(collection: List<T> | Dictionary<T> | null | undefined): T[];\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            collection: Dictionary<T> | null | undefined,\n            iteratee: DictionaryIterator<T, TResult>\n        ): TResult[];\n\n        /** @see _.map */\n        map<T, K extends keyof T>(\n            collection: List<T> | Dictionary<T> | null | undefined,\n            iteratee: K\n        ): Array<T[K]>;\n\n        /** @see _.map */\n        map<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee?: NumericDictionaryIterator<T, TResult>\n        ): TResult[];\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            collection: List<T>|Dictionary<T>|NumericDictionary<T> | null | undefined,\n            iteratee?: string\n        ): TResult[];\n\n        /**\n         * @see _.map\n         */\n        map<T>(\n            collection: List<T>|Dictionary<T>|NumericDictionary<T> | null | undefined,\n            iteratee?: object\n        ): boolean[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, TResult>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T>(this: LoDashImplicitWrapper<List<T> | Dictionary<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashImplicitWrapper<Dictionary<T> | null | undefined>,\n            iteratee: DictionaryIterator<T, TResult>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /** @see _.map */\n        map<T, K extends keyof T>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | null | undefined>,\n            iteratee: K\n        ): LoDashImplicitWrapper<Array<T[K]>>;\n\n        /** @see _.map */\n        map<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIterator<T, TResult>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>,\n            iteratee?: string\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>,\n            iteratee?: object\n        ): LoDashImplicitWrapper<boolean[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, TResult>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T>(this: LoDashExplicitWrapper<List<T> | Dictionary<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashExplicitWrapper<Dictionary<T> | null | undefined>,\n            iteratee: DictionaryIterator<T, TResult>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /** @see _.map */\n        map<T, K extends keyof T>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | null | undefined>,\n            iteratee: K\n        ): LoDashExplicitWrapper<Array<T[K]>>;\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIterator<T, TResult>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>,\n            iteratee?: string\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>,\n            iteratee?: object\n        ): LoDashExplicitWrapper<boolean[]>;\n    }\n\n    //_.partition\n    interface LoDashStatic {\n        /**\n        * Creates an array of elements split into two groups, the first of which contains elements predicate returns truthy for,\n        * while the second of which contains elements predicate returns falsey for.\n        * The predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).\n        *\n        * If a property name is provided for predicate the created _.property style callback\n        * returns the property value of the given element.\n        *\n        * If a value is also provided for thisArg the created _.matchesProperty style callback\n        * returns true for elements that have a matching property value, else false.\n        *\n        * If an object is provided for predicate the created _.matches style callback returns\n        * true for elements that have the properties of the given object, else false.\n        *\n        * @param collection The collection to iterate over.\n        * @param callback The function called per iteration.\n        * @param thisArg The this binding of predicate.\n        * @return Returns the array of grouped elements.\n        **/\n        partition<T>(\n            collection: List<T> | null | undefined,\n            callback: ValueIteratee<T>\n        ): [T[], T[]];\n\n        /**\n         * @see _.partition\n         */\n        partition<T extends object>(\n            collection: T | null | undefined,\n            callback: ValueIteratee<T[keyof T]>\n        ): [Array<T[keyof T]>, Array<T[keyof T]>];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.partition\n         */\n        partition<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            callback: ValueIteratee<T>\n        ): LoDashImplicitWrapper<[T[], T[]]>;\n\n        /**\n         * @see _.partition\n         */\n        partition<T>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            callback: ValueIteratee<T[keyof T]>\n        ): LoDashImplicitWrapper<[Array<T[keyof T]>, Array<T[keyof T]>]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.partition\n         */\n        partition<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            callback: ValueIteratee<T>\n        ): LoDashExplicitWrapper<[T[], T[]]>;\n\n        /**\n         * @see _.partition\n         */\n        partition<T>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            callback: ValueIteratee<T[keyof T]>\n        ): LoDashExplicitWrapper<[Array<T[keyof T]>, Array<T[keyof T]>]>;\n    }\n\n    //_.reduce\n    interface LoDashStatic {\n        /**\n        * Reduces a collection to a value which is the accumulated result of running each\n        * element in the collection through the callback, where each successive callback execution\n        * consumes the return value of the previous execution. If accumulator is not provided the\n        * first element of the collection will be used as the initial accumulator value. The callback\n        * is bound to thisArg and invoked with four arguments; (accumulator, value, index|key, collection).\n        * @param collection The collection to iterate over.\n        * @param callback The function called per iteration.\n        * @param accumulator Initial value of the accumulator.\n        * @return Returns the accumulated value.\n        **/\n        reduce<T, TResult>(\n            collection: T[] | null | undefined,\n            callback: MemoListIterator<T, TResult, T[]>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            collection: List<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, List<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T extends object, TResult>(\n            collection: T | null | undefined,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            collection: T[] | null | undefined,\n            callback: MemoListIterator<T, TResult, T[]>\n        ): TResult | undefined;\n\n        /**\n         * @see _.reduce\n         **/\n        reduce<T, TResult>(\n            collection: List<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, List<T>>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T extends object, TResult>(\n            collection: T | null | undefined,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>\n        ): TResult | undefined;\n\n        /**\n         * @see _.reduce\n         **/\n        reduce<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>\n        ): TResult | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n         /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashImplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n         * @see _.reduce\n         **/\n        reduce<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n         * @see _.reduce\n         **/\n        reduce<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashImplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>\n        ): TResult | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashExplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashExplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n\n        /**\n         * @see _.reduce\n         **/\n        reduce<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n    }\n\n    //_.reduceRight\n    interface LoDashStatic {\n        /**\n        * This method is like _.reduce except that it iterates over elements of a collection from\n        * right to left.\n        * @param collection The collection to iterate over.\n        * @param callback The function called per iteration.\n        * @param accumulator Initial value of the accumulator.\n        * @return The accumulated value.\n        **/\n        reduceRight<T, TResult>(\n            collection: T[] | null | undefined,\n            callback: MemoListIterator<T, TResult, T[]>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            collection: List<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, List<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T extends object, TResult>(\n            collection: T | null | undefined,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            collection: T[] | null | undefined,\n            callback: MemoListIterator<T, TResult, T[]>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            collection: List<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, List<T>>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T extends object, TResult>(\n            collection: T | null | undefined,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>\n        ): TResult | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n         /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashImplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashImplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>\n        ): TResult | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashExplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashExplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n\n        /**\n         * @see _.reduceRight\n         **/\n        reduceRight<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n    }\n\n    //_.reject\n    interface LoDashStatic {\n        /**\n         * The opposite of _.filter; this method returns the elements of collection that predicate does not return\n         * truthy for.\n         *\n         * @param collection The collection to iterate over.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the new filtered array.\n         */\n        reject(\n            collection: string | null | undefined,\n            predicate?: StringIterator<boolean>\n        ): string[];\n\n        /**\n         * @see _.reject\n         */\n        reject<T>(\n            collection: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): T[];\n\n        /**\n         * @see _.reject\n         */\n        reject<T extends object>(\n            collection: T | null | undefined,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.reject\n         */\n        reject(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            predicate?: StringIterator<boolean>\n        ): LoDashImplicitWrapper<string[]>;\n\n        /**\n         * @see _.reject\n         */\n        reject<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.reject\n         */\n        reject<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.reject\n         */\n        reject(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            predicate?: StringIterator<boolean>\n        ): LoDashExplicitWrapper<string[]>;\n\n        /**\n         * @see _.reject\n         */\n        reject<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.reject\n         */\n        reject<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.sample\n    interface LoDashStatic {\n        /**\n         * Gets a random element from collection.\n         *\n         * @param collection The collection to sample.\n         * @return Returns the random element.\n         */\n        sample<T>(\n            collection: List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined\n        ): T | undefined;\n\n        /**\n         * @see _.sample\n         */\n        sample<T extends object>(\n            collection: T\n        ): T[keyof T];\n\n        /**\n         * @see _.sample\n         */\n        sample<T extends object>(\n            collection: T | null | undefined\n        ): T[keyof T] | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sample\n         */\n        sample<T>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>\n        ): T | undefined;\n\n        /**\n         * @see _.sample\n         */\n        sample<T extends object>(\n            this: LoDashImplicitWrapper<T>,\n        ): T[keyof T];\n\n        /**\n         * @see _.sample\n         */\n        sample<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>\n        ): T[keyof T] | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sample\n         */\n        sample<T>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>\n        ): LoDashExplicitWrapper<T | undefined>;\n\n        /**\n         * @see _.sample\n         */\n        sample<T extends object>(\n            this: LoDashExplicitWrapper<T>,\n        ): LoDashExplicitWrapper<T[keyof T]>;\n\n        /**\n         * @see _.sample\n         */\n        sample<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>\n        ): LoDashExplicitWrapper<T[keyof T] | undefined>;\n    }\n\n    //_.sampleSize\n    interface LoDashStatic {\n        /**\n         * Gets n random elements at unique keys from collection up to the size of collection.\n         *\n         * @param collection The collection to sample.\n         * @param n The number of elements to sample.\n         * @return Returns the random elements.\n         */\n        sampleSize<T>(\n            collection: List<T>|Dictionary<T>|NumericDictionary<T> | null | undefined,\n            n?: number\n        ): T[];\n\n        /**\n         * @see _.sampleSize\n         */\n        sampleSize<T extends object>(\n            collection: T | null | undefined,\n            n?: number\n        ): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sampleSize\n         */\n        sampleSize<T>(\n            this: LoDashImplicitWrapper<List<T>|Dictionary<T>|NumericDictionary<T> | null | undefined>,\n            n?: number\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.sampleSize\n         */\n        sampleSize<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            n?: number\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sampleSize\n         */\n        sampleSize<T>(\n            this: LoDashExplicitWrapper<List<T>|Dictionary<T>|NumericDictionary<T> | null | undefined>,\n            n?: number\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.sampleSize\n         */\n        sampleSize<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            n?: number\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.shuffle\n    interface LoDashStatic {\n        /**\n         * Creates an array of shuffled values, using a version of the Fisher-Yates shuffle.\n         *\n         * @param collection The collection to shuffle.\n         * @return Returns the new shuffled array.\n         */\n        shuffle<T>(collection: List<T> | null | undefined): T[];\n\n        /**\n         * @see _.shuffle\n         */\n        shuffle<T extends object>(collection: T | null | undefined): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.shuffle\n         */\n        shuffle<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.shuffle\n         */\n        shuffle<T extends object>(this: LoDashImplicitWrapper<T | null | undefined>): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.shuffle\n         */\n        shuffle<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.shuffle\n         */\n        shuffle<T extends object>(this: LoDashExplicitWrapper<T | null | undefined>): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.size\n    interface LoDashStatic {\n        /**\n         * Gets the size of collection by returning its length for array-like values or the number of own enumerable\n         * properties for objects.\n         *\n         * @param collection The collection to inspect.\n         * @return Returns the size of collection.\n         */\n        size(collection: object | string | null | undefined): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.size\n         */\n        size(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.size\n         */\n        size(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.some\n    interface LoDashStatic {\n        /**\n         * Checks if predicate returns truthy for any element of collection. Iteration is stopped once predicate\n         * returns truthy. The predicate is invoked with three arguments: (value, index|key, collection).\n         *\n         * @param collection The collection to iterate over.\n         * @param predicate The function invoked per iteration.\n         * @return Returns true if any element passes the predicate check, else false.\n         */\n        some<T>(\n            collection: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.some\n         */\n        some<T extends object>(\n            collection: T | null | undefined,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.some\n         */\n        some<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            predicate?: NumericDictionaryIterateeCustom<T, boolean>\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.some\n         */\n        some<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.some\n         */\n        some<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.some\n         */\n        some<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            predicate?: NumericDictionaryIterateeCustom<T, boolean>\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.some\n         */\n        some<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<boolean>;\n\n        /**\n         * @see _.some\n         */\n        some<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<boolean>;\n\n        /**\n         * @see _.some\n         */\n        some<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            predicate?: NumericDictionaryIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.sortBy\n    interface LoDashStatic {\n        /**\n         * Creates an array of elements, sorted in ascending order by the results of\n         * running each element in a collection through each iteratee. This method\n         * performs a stable sort, that is, it preserves the original sort order of\n         * equal elements. The iteratees are invoked with one argument: (value).\n         *\n         * @category Collection\n         * @param collection The collection to iterate over.\n         * @param [iteratees=[_.identity]]\n         *  The iteratees to sort by, specified individually or in arrays.\n         * @returns Returns the new sorted array.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'fred',   'age': 48 },\n         *   { 'user': 'barney', 'age': 36 },\n         *   { 'user': 'fred',   'age': 42 },\n         *   { 'user': 'barney', 'age': 34 }\n         * ];\n         *\n         * _.sortBy(users, function(o) { return o.user; });\n         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n         *\n         * _.sortBy(users, ['user', 'age']);\n         * // => objects for [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]\n         *\n         * _.sortBy(users, 'user', function(o) {\n         *   return Math.floor(o.age / 10);\n         * });\n         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n         */\n        sortBy<T>(\n            collection: List<T> | null | undefined,\n            ...iteratees: Array<Many<ListIteratee<T>>>\n        ): T[];\n\n        /**\n         * @see _.sortBy\n         */\n        sortBy<T extends object>(\n            collection: T | null | undefined,\n            ...iteratees: Array<Many<ObjectIteratee<T>>>\n        ): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortBy\n         */\n        sortBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...iteratees: Array<Many<ListIteratee<T>>>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.sortBy\n         */\n        sortBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            ...iteratees: Array<Many<ObjectIteratee<T>>>\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortBy\n         */\n        sortBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...iteratees: Array<Many<ListIteratee<T>>>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.sortBy\n         */\n        sortBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            ...iteratees: Array<Many<ObjectIteratee<T>>>\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.orderBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.sortBy` except that it allows specifying the sort\n         * orders of the iteratees to sort by. If `orders` is unspecified, all values\n         * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n         * descending or \"asc\" for ascending sort order of corresponding values.\n         *\n         * @category Collection\n         * @param collection The collection to iterate over.\n         * @param [iteratees=[_.identity]] The iteratees to sort by.\n         * @param [orders] The sort orders of `iteratees`.\n         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.reduce`.\n         * @returns Returns the new sorted array.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'fred',   'age': 48 },\n         *   { 'user': 'barney', 'age': 34 },\n         *   { 'user': 'fred',   'age': 42 },\n         *   { 'user': 'barney', 'age': 36 }\n         * ];\n         *\n         * // sort by `user` in ascending order and by `age` in descending order\n         * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n         */\n        orderBy<T>(\n            collection: List<T> | null | undefined,\n            iteratees?: Many<ListIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): T[];\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            collection: List<T> | null | undefined,\n            iteratees?: Many<ListIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): T[];\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T extends object>(\n            collection: T | null | undefined,\n            iteratees?: Many<ObjectIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): Array<T[keyof T]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T extends object>(\n            collection: T | null | undefined,\n            iteratees?: Many<ObjectIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): Array<T[keyof T]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratees?: Many<NumericDictionaryIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): T[];\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratees?: Many<NumericDictionaryIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratees?: Many<ListIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratees?: Many<ListIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratees?: Many<ObjectIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratees?: Many<ObjectIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratees?: Many<NumericDictionaryIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratees?: Many<NumericDictionaryIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratees?: Many<ListIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratees?: Many<ListIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratees?: Many<ObjectIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratees?: Many<ObjectIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratees?: Many<NumericDictionaryIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratees?: Many<NumericDictionaryIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    /********\n     * Date *\n     ********/\n\n    //_.now\n    interface LoDashStatic {\n        /**\n         * Gets the number of milliseconds that have elapsed since the Unix epoch (1 January 1970 00:00:00 UTC).\n         *\n         * @return The number of milliseconds.\n         */\n        now(): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.now\n         */\n        now(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.now\n         */\n        now(): LoDashExplicitWrapper<number>;\n    }\n\n    /*************\n     * Functions *\n     *************/\n\n    //_.after\n    interface LoDashStatic {\n        /**\n         * The opposite of _.before; this method creates a function that invokes func once it’s called n or more times.\n         *\n         * @param n The number of calls before func is invoked.\n         * @param func The function to restrict.\n         * @return Returns the new restricted function.\n         */\n        after<TFunc extends (...args: any[]) => any>(\n            n: number,\n            func: TFunc\n        ): TFunc;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n        * @see _.after\n        **/\n        after<TFunc extends (...args: any[]) => any>(func: TFunc): LoDashImplicitWrapper<TFunc>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.after\n         **/\n        after<TFunc extends (...args: any[]) => any>(func: TFunc): LoDashExplicitWrapper<TFunc>;\n    }\n\n    //_.ary\n    interface LoDashStatic {\n        /**\n         * Creates a function that accepts up to n arguments ignoring any additional arguments.\n         *\n         * @param func The function to cap arguments for.\n         * @param n The arity cap.\n         * @returns Returns the new function.\n         */\n        ary(\n            func: (...args: any[]) => any,\n            n?: number\n        ): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.ary\n         */\n        ary(n?: number): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.ary\n         */\n        ary(n?: number): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.before\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes func, with the this binding and arguments of the created function, while\n         * it’s called less than n times. Subsequent calls to the created function return the result of the last func\n         * invocation.\n         *\n         * @param n The number of calls at which func is no longer invoked.\n         * @param func The function to restrict.\n         * @return Returns the new restricted function.\n         */\n        before<TFunc extends (...args: any[]) => any>(\n            n: number,\n            func: TFunc\n        ): TFunc;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.before\n         **/\n        before<TFunc extends (...args: any[]) => any>(func: TFunc): LoDashImplicitWrapper<TFunc>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.before\n         **/\n        before<TFunc extends (...args: any[]) => any>(func: TFunc): LoDashExplicitWrapper<TFunc>;\n    }\n\n    //_.bind\n    interface FunctionBind {\n        placeholder: any;\n\n        (\n            func: (...args: any[]) => any,\n            thisArg: any,\n            ...partials: any[]\n        ): (...args: any[]) => any;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes func with the this binding of thisArg and prepends any additional _.bind\n         * arguments to those provided to the bound function.\n         *\n         * The _.bind.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder for\n         * partially applied arguments.\n         *\n         * Note: Unlike native Function#bind this method does not set the \"length\" property of bound functions.\n         *\n         * @param func The function to bind.\n         * @param thisArg The this binding of func.\n         * @param partials The arguments to be partially applied.\n         * @return Returns the new bound function.\n         */\n        bind: FunctionBind;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.bind\n         */\n        bind(\n            thisArg: any,\n            ...partials: any[]\n        ): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.bind\n         */\n        bind(\n            thisArg: any,\n            ...partials: any[]\n        ): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.bindAll\n    interface LoDashStatic {\n        /**\n         * Binds methods of an object to the object itself, overwriting the existing method. Method names may be\n         * specified as individual arguments or as arrays of method names. If no method names are provided all\n         * enumerable function properties, own and inherited, of object are bound.\n         *\n         * Note: This method does not set the \"length\" property of bound functions.\n         *\n         * @param object The object to bind and assign the bound methods to.\n         * @param methodNames The object method names to bind, specified as individual method names or arrays of\n         * method names.\n         * @return Returns object.\n         */\n        bindAll<T>(\n            object: T,\n            ...methodNames: Array<Many<string>>\n        ): T;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.bindAll\n         */\n        bindAll(...methodNames: Array<Many<string>>): this;\n    }\n\n    //_.bindKey\n    interface FunctionBindKey {\n        placeholder: any;\n\n        (\n            object: object,\n            key: string,\n            ...partials: any[]\n        ): (...args: any[]) => any;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes the method at object[key] and prepends any additional _.bindKey arguments\n         * to those provided to the bound function.\n         *\n         * This method differs from _.bind by allowing bound functions to reference methods that may be redefined\n         * or don’t yet exist. See Peter Michaux’s article for more details.\n         *\n         * The _.bindKey.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder\n         * for partially applied arguments.\n         *\n         * @param object The object the method belongs to.\n         * @param key The key of the method.\n         * @param partials The arguments to be partially applied.\n         * @return Returns the new bound function.\n         */\n        bindKey: FunctionBindKey;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.bindKey\n         */\n        bindKey(\n            key: string,\n            ...partials: any[]\n        ): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.bindKey\n         */\n        bindKey(\n            key: string,\n            ...partials: any[]\n        ): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.curry\n    interface LoDashStatic {\n        /**\n         * Creates a function that accepts one or more arguments of func that when called either invokes func returning\n         * its result, if all func arguments have been provided, or returns a function that accepts one or more of the\n         * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curry<T1, R>(func: (t1: T1) => R, arity?: number):\n            CurriedFunction1<T1, R>;\n        /**\n         * Creates a function that accepts one or more arguments of func that when called either invokes func returning\n         * its result, if all func arguments have been provided, or returns a function that accepts one or more of the\n         * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curry<T1, T2, R>(func: (t1: T1, t2: T2) => R, arity?: number):\n            CurriedFunction2<T1, T2, R>;\n        /**\n         * Creates a function that accepts one or more arguments of func that when called either invokes func returning\n         * its result, if all func arguments have been provided, or returns a function that accepts one or more of the\n         * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curry<T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, arity?: number):\n            CurriedFunction3<T1, T2, T3, R>;\n        /**\n         * Creates a function that accepts one or more arguments of func that when called either invokes func returning\n         * its result, if all func arguments have been provided, or returns a function that accepts one or more of the\n         * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curry<T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R, arity?: number):\n            CurriedFunction4<T1, T2, T3, T4, R>;\n        /**\n         * Creates a function that accepts one or more arguments of func that when called either invokes func returning\n         * its result, if all func arguments have been provided, or returns a function that accepts one or more of the\n         * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curry<T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R, arity?: number):\n            CurriedFunction5<T1, T2, T3, T4, T5, R>;\n        /**\n         * Creates a function that accepts one or more arguments of func that when called either invokes func returning\n         * its result, if all func arguments have been provided, or returns a function that accepts one or more of the\n         * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curry(func: (...args: any[]) => any, arity?: number): (...args: any[]) => any;\n    }\n\n    interface CurriedFunction1<T1, R> {\n        (): CurriedFunction1<T1, R>;\n        (t1: T1): R;\n    }\n\n    interface CurriedFunction2<T1, T2, R> {\n        (): CurriedFunction2<T1, T2, R>;\n        (t1: T1): CurriedFunction1<T2, R>;\n        (t1: T1, t2: T2): R;\n    }\n\n    interface CurriedFunction3<T1, T2, T3, R> {\n        (): CurriedFunction3<T1, T2, T3, R>;\n        (t1: T1): CurriedFunction2<T2, T3, R>;\n        (t1: T1, t2: T2): CurriedFunction1<T3, R>;\n        (t1: T1, t2: T2, t3: T3): R;\n    }\n\n    interface CurriedFunction4<T1, T2, T3, T4, R> {\n        (): CurriedFunction4<T1, T2, T3, T4, R>;\n        (t1: T1): CurriedFunction3<T2, T3, T4, R>;\n        (t1: T1, t2: T2): CurriedFunction2<T3, T4, R>;\n        (t1: T1, t2: T2, t3: T3): CurriedFunction1<T4, R>;\n        (t1: T1, t2: T2, t3: T3, t4: T4): R;\n    }\n\n    interface CurriedFunction5<T1, T2, T3, T4, T5, R> {\n        (): CurriedFunction5<T1, T2, T3, T4, T5, R>;\n        (t1: T1): CurriedFunction4<T2, T3, T4, T5, R>;\n        (t1: T1, t2: T2): CurriedFunction3<T3, T4, T5, R>;\n        (t1: T1, t2: T2, t3: T3): CurriedFunction2<T4, T5, R>;\n        (t1: T1, t2: T2, t3: T3, t4: T4): CurriedFunction1<T5, R>;\n        (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R;\n    }\n    interface RightCurriedFunction1<T1, R> {\n        (): RightCurriedFunction1<T1, R>;\n        (t1: T1): R;\n    }\n    interface RightCurriedFunction2<T1, T2, R> {\n        (): RightCurriedFunction2<T1, T2, R>;\n        (t2: T2): RightCurriedFunction1<T1, R>;\n        (t1: T1, t2: T2): R;\n    }\n    interface RightCurriedFunction3<T1, T2, T3, R> {\n        (): RightCurriedFunction3<T1, T2, T3, R>;\n        (t3: T3): RightCurriedFunction2<T1, T2, R>;\n        (t2: T2, t3: T3): RightCurriedFunction1<T1, R>;\n        (t1: T1, t2: T2, t3: T3): R;\n    }\n    interface RightCurriedFunction4<T1, T2, T3, T4, R> {\n        (): RightCurriedFunction4<T1, T2, T3, T4, R>;\n        (t4: T4): RightCurriedFunction3<T1, T2, T3, R>;\n        (t3: T3, t4: T4): RightCurriedFunction2<T1, T2, R>;\n        (t2: T2, t3: T3, t4: T4): RightCurriedFunction1<T1, R>;\n        (t1: T1, t2: T2, t3: T3, t4: T4): R;\n    }\n    interface RightCurriedFunction5<T1, T2, T3, T4, T5, R> {\n        (): RightCurriedFunction5<T1, T2, T3, T4, T5, R>;\n        (t5: T5): RightCurriedFunction4<T1, T2, T3, T4, R>;\n        (t4: T4, t5: T5): RightCurriedFunction3<T1, T2, T3, R>;\n        (t3: T3, t4: T4, t5: T5): RightCurriedFunction2<T1, T2, R>;\n        (t2: T2, t3: T3, t4: T4, t5: T5): RightCurriedFunction1<T1, R>;\n        (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n        * @see _.curry\n        **/\n        curry<T1, R>(this: LoDashImplicitWrapper<(t1: T1) => R>, arity?: number):\n            LoDashImplicitWrapper<CurriedFunction1<T1, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2) => R>, arity?: number):\n            LoDashImplicitWrapper<CurriedFunction2<T1, T2, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, T3, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2, t3: T3) => R>, arity?: number):\n            LoDashImplicitWrapper<CurriedFunction3<T1, T2, T3, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4) => R>, arity?: number):\n            LoDashImplicitWrapper<CurriedFunction4<T1, T2, T3, T4, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, T3, T4, T5, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R>, arity?: number):\n            LoDashImplicitWrapper<CurriedFunction5<T1, T2, T3, T4, T5, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry(arity?: number): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n        * @see _.curry\n        **/\n        curry<T1, R>(this: LoDashExplicitWrapper<(t1: T1) => R>):\n            LoDashExplicitWrapper<CurriedFunction1<T1, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2) => R>):\n            LoDashExplicitWrapper<CurriedFunction2<T1, T2, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, T3, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2, t3: T3) => R>):\n            LoDashExplicitWrapper<CurriedFunction3<T1, T2, T3, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4) => R>):\n            LoDashExplicitWrapper<CurriedFunction4<T1, T2, T3, T4, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, T3, T4, T5, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R>):\n            LoDashExplicitWrapper<CurriedFunction5<T1, T2, T3, T4, T5, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry(arity?: number): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.curryRight\n    interface LoDashStatic {\n        /**\n         * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight\n         * instead of _.partial.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curryRight<T1, R>(func: (t1: T1) => R, arity?: number):\n            RightCurriedFunction1<T1, R>;\n        /**\n         * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight\n         * instead of _.partial.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curryRight<T1, T2, R>(func: (t1: T1, t2: T2) => R, arity?: number):\n            RightCurriedFunction2<T1, T2, R>;\n        /**\n         * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight\n         * instead of _.partial.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curryRight<T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, arity?: number):\n            RightCurriedFunction3<T1, T2, T3, R>;\n        /**\n         * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight\n         * instead of _.partial.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curryRight<T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R, arity?: number):\n            RightCurriedFunction4<T1, T2, T3, T4, R>;\n        /**\n         * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight\n         * instead of _.partial.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curryRight<T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R, arity?: number):\n            RightCurriedFunction5<T1, T2, T3, T4, T5, R>;\n        /**\n         * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight\n         * instead of _.partial.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curryRight(func: (...args: any[]) => any, arity?: number): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, R>(this: LoDashImplicitWrapper<(t1: T1) => R>, arity?: number):\n            LoDashImplicitWrapper<RightCurriedFunction1<T1, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2) => R>, arity?: number):\n            LoDashImplicitWrapper<RightCurriedFunction2<T1, T2, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, T3, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2, t3: T3) => R>, arity?: number):\n            LoDashImplicitWrapper<RightCurriedFunction3<T1, T2, T3, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4) => R>, arity?: number):\n            LoDashImplicitWrapper<RightCurriedFunction4<T1, T2, T3, T4, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, T3, T4, T5, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R>, arity?: number):\n            LoDashImplicitWrapper<RightCurriedFunction5<T1, T2, T3, T4, T5, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight(arity?: number): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, R>(this: LoDashExplicitWrapper<(t1: T1) => R>, arity?: number):\n            LoDashExplicitWrapper<RightCurriedFunction1<T1, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2) => R>, arity?: number):\n            LoDashExplicitWrapper<RightCurriedFunction2<T1, T2, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, T3, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2, t3: T3) => R>, arity?: number):\n            LoDashExplicitWrapper<RightCurriedFunction3<T1, T2, T3, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4) => R>, arity?: number):\n            LoDashExplicitWrapper<RightCurriedFunction4<T1, T2, T3, T4, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, T3, T4, T5, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R>, arity?: number):\n            LoDashExplicitWrapper<RightCurriedFunction5<T1, T2, T3, T4, T5, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight(arity?: number): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.debounce\n    interface DebounceSettings {\n        /**\n         * Specify invoking on the leading edge of the timeout.\n         */\n        leading?: boolean;\n\n        /**\n         * The maximum time func is allowed to be delayed before it’s invoked.\n         */\n        maxWait?: number;\n\n        /**\n         * Specify invoking on the trailing edge of the timeout.\n         */\n        trailing?: boolean;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since\n         * the last time the debounced function was invoked. The debounced function comes with a cancel method to\n         * cancel delayed invocations and a flush method to immediately invoke them. Provide an options object to\n         * indicate that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent\n         * calls to the debounced function return the result of the last func invocation.\n         *\n         * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only\n         * if the the debounced function is invoked more than once during the wait timeout.\n         *\n         * See David Corbacho’s article for details over the differences between _.debounce and _.throttle.\n         *\n         * @param func The function to debounce.\n         * @param wait The number of milliseconds to delay.\n         * @param options The options object.\n         * @param options.leading Specify invoking on the leading edge of the timeout.\n         * @param options.maxWait The maximum time func is allowed to be delayed before it’s invoked.\n         * @param options.trailing Specify invoking on the trailing edge of the timeout.\n         * @return Returns the new debounced function.\n         */\n        debounce<T extends (...args: any[]) => any>(\n            func: T,\n            wait?: number,\n            options?: DebounceSettings\n        ): T & Cancelable;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.debounce\n         */\n        debounce(\n            wait?: number,\n            options?: DebounceSettings\n        ): LoDashImplicitWrapper<TValue & Cancelable>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.debounce\n         */\n        debounce(\n            wait?: number,\n            options?: DebounceSettings\n        ): LoDashExplicitWrapper<TValue & Cancelable>;\n    }\n\n    //_.defer\n    interface LoDashStatic {\n        /**\n         * Defers invoking the func until the current call stack has cleared. Any additional arguments are provided to\n         * func when it’s invoked.\n         *\n         * @param func The function to defer.\n         * @param args The arguments to invoke the function with.\n         * @return Returns the timer id.\n         */\n        defer(\n            func: (...args: any[]) => any,\n            ...args: any[]\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.defer\n         */\n        defer(...args: any[]): LoDashImplicitWrapper<number>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.defer\n         */\n        defer(...args: any[]): LoDashExplicitWrapper<number>;\n    }\n\n    //_.delay\n    interface LoDashStatic {\n        /**\n         * Invokes func after wait milliseconds. Any additional arguments are provided to func when it’s invoked.\n         *\n         * @param func The function to delay.\n         * @param wait The number of milliseconds to delay invocation.\n         * @param args The arguments to invoke the function with.\n         * @return Returns the timer id.\n         */\n        delay(\n            func: (...args: any[]) => any,\n            wait: number,\n            ...args: any[]\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.delay\n         */\n        delay(\n            wait: number,\n            ...args: any[]\n        ): LoDashImplicitWrapper<number>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.delay\n         */\n        delay(\n            wait: number,\n            ...args: any[]\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes `func` with arguments reversed.\n         *\n         * @category Function\n         * @param func The function to flip arguments for.\n         * @returns Returns the new function.\n         * @example\n         *\n         * var flipped = _.flip(function() {\n         *   return _.toArray(arguments);\n         * });\n         *\n         * flipped('a', 'b', 'c', 'd');\n         * // => ['d', 'c', 'b', 'a']\n         */\n        flip<T extends (...args: any[]) => any>(func: T): T;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.flip\n         */\n        flip(): this;\n    }\n\n    //_.flow\n    interface LoDashStatic {\n        /**\n         * Creates a function that returns the result of invoking the provided functions with the this binding of the\n         * created function, where each successive invocation is supplied the return value of the previous.\n         *\n         * @param funcs Functions to invoke.\n         * @return Returns the new function.\n         */\n        // 0-argument first function\n        flow<R1, R2>(f1: () => R1, f2: (a: R1) => R2): () => R2;\n        flow<R1, R2, R3>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): () => R3;\n        flow<R1, R2, R3, R4>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): () => R4;\n        flow<R1, R2, R3, R4, R5>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): () => R5;\n        flow<R1, R2, R3, R4, R5, R6>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): () => R6;\n        flow<R1, R2, R3, R4, R5, R6, R7>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): () => R7;\n        flow<R1, R2, R3, R4, R5, R6, R7>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): () => any;\n        // 1-argument first function\n        flow<A1, R1, R2>(f1: (a1: A1) => R1, f2: (a: R1) => R2): (a1: A1) => R2;\n        flow<A1, R1, R2, R3>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1) => R3;\n        flow<A1, R1, R2, R3, R4>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1) => R4;\n        flow<A1, R1, R2, R3, R4, R5>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1) => R5;\n        flow<A1, R1, R2, R3, R4, R5, R6>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1) => R6;\n        flow<A1, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1) => R7;\n        flow<A1, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): (a1: A1) => any;\n        // 2-argument first function\n        flow<A1, A2, R1, R2>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2): (a1: A1, a2: A2) => R2;\n        flow<A1, A2, R1, R2, R3>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1, a2: A2) => R3;\n        flow<A1, A2, R1, R2, R3, R4>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1, a2: A2) => R4;\n        flow<A1, A2, R1, R2, R3, R4, R5>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1, a2: A2) => R5;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1, a2: A2) => R6;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1, a2: A2) => R7;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): (a1: A1, a2: A2) => any;\n        // 3-argument first function\n        flow<A1, A2, A3, R1, R2>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2): (a1: A1, a2: A2, a3: A3) => R2;\n        flow<A1, A2, A3, R1, R2, R3>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1, a2: A2, a3: A3) => R3;\n        flow<A1, A2, A3, R1, R2, R3, R4>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1, a2: A2, a3: A3) => R4;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1, a2: A2, a3: A3) => R5;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1, a2: A2, a3: A3) => R6;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1, a2: A2, a3: A3) => R7;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): (a1: A1, a2: A2, a3: A3) => any;\n        // 4-argument first function\n        flow<A1, A2, A3, A4, R1, R2>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2): (a1: A1, a2: A2, a3: A3, a4: A4) => R2;\n        flow<A1, A2, A3, A4, R1, R2, R3>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1, a2: A2, a3: A3, a4: A4) => R3;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1, a2: A2, a3: A3, a4: A4) => R4;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1, a2: A2, a3: A3, a4: A4) => R5;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1, a2: A2, a3: A3, a4: A4) => R6;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1, a2: A2, a3: A3, a4: A4) => R7;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): (a1: A1, a2: A2, a3: A3, a4: A4) => any;\n        // any-argument first function\n        flow<A1, A2, A3, A4, R1, R2>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R2;\n        flow<A1, A2, A3, A4, R1, R2, R3>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R3;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R4;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R5;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R6;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R7;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => any;\n        flow(funcs: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flow\n         */\n        // 0-argument first function\n        flow<R1, R2>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2): LoDashImplicitWrapper<() => R2>;\n        flow<R1, R2, R3>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashImplicitWrapper<() => R3>;\n        flow<R1, R2, R3, R4>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashImplicitWrapper<() => R4>;\n        flow<R1, R2, R3, R4, R5>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashImplicitWrapper<() => R5>;\n        flow<R1, R2, R3, R4, R5, R6>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashImplicitWrapper<() => R6>;\n        flow<R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashImplicitWrapper<() => R7>;\n        flow<R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<() => any>;\n        // 1-argument first function\n        flow<A1, R1, R2>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2): LoDashImplicitWrapper<(a1: A1) => R2>;\n        flow<A1, R1, R2, R3>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashImplicitWrapper<(a1: A1) => R3>;\n        flow<A1, R1, R2, R3, R4>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashImplicitWrapper<(a1: A1) => R4>;\n        flow<A1, R1, R2, R3, R4, R5>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashImplicitWrapper<(a1: A1) => R5>;\n        flow<A1, R1, R2, R3, R4, R5, R6>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashImplicitWrapper<(a1: A1) => R6>;\n        flow<A1, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashImplicitWrapper<(a1: A1) => R7>;\n        flow<A1, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<(a1: A1) => any>;\n        // 2-argument first function\n        flow<A1, A2, R1, R2>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2): LoDashImplicitWrapper<(a1: A1, a2: A2) => R2>;\n        flow<A1, A2, R1, R2, R3>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashImplicitWrapper<(a1: A1, a2: A2) => R3>;\n        flow<A1, A2, R1, R2, R3, R4>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashImplicitWrapper<(a1: A1, a2: A2) => R4>;\n        flow<A1, A2, R1, R2, R3, R4, R5>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashImplicitWrapper<(a1: A1, a2: A2) => R5>;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashImplicitWrapper<(a1: A1, a2: A2) => R6>;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashImplicitWrapper<(a1: A1, a2: A2) => R7>;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<(a1: A1, a2: A2) => any>;\n        // 3-argument first function\n        flow<A1, A2, A3, R1, R2>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R2>;\n        flow<A1, A2, A3, R1, R2, R3>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R3>;\n        flow<A1, A2, A3, R1, R2, R3, R4>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R4>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R5>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R6>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R7>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => any>;\n        // 4-argument first function\n        flow<A1, A2, A3, A4, R1, R2>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R2>;\n        flow<A1, A2, A3, A4, R1, R2, R3>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R3>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R4>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R5>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R6>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R7>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => any>;\n        // any-argument first function\n        flow<A1, A2, A3, A4, R1, R2>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R2>;\n        flow<A1, A2, A3, A4, R1, R2, R3>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R3>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R4>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R5>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R6>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R7>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => any>;\n        flow(this: LoDashImplicitWrapper<(...args: any[]) => any>, funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flow\n         */\n        // 0-argument first function\n        flow<R1, R2>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2): LoDashExplicitWrapper<() => R2>;\n        flow<R1, R2, R3>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashExplicitWrapper<() => R3>;\n        flow<R1, R2, R3, R4>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashExplicitWrapper<() => R4>;\n        flow<R1, R2, R3, R4, R5>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashExplicitWrapper<() => R5>;\n        flow<R1, R2, R3, R4, R5, R6>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashExplicitWrapper<() => R6>;\n        flow<R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashExplicitWrapper<() => R7>;\n        flow<R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<() => any>;\n        // 1-argument first function\n        flow<A1, R1, R2>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2): LoDashExplicitWrapper<(a1: A1) => R2>;\n        flow<A1, R1, R2, R3>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashExplicitWrapper<(a1: A1) => R3>;\n        flow<A1, R1, R2, R3, R4>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashExplicitWrapper<(a1: A1) => R4>;\n        flow<A1, R1, R2, R3, R4, R5>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashExplicitWrapper<(a1: A1) => R5>;\n        flow<A1, R1, R2, R3, R4, R5, R6>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashExplicitWrapper<(a1: A1) => R6>;\n        flow<A1, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashExplicitWrapper<(a1: A1) => R7>;\n        flow<A1, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<(a1: A1) => any>;\n        // 2-argument first function\n        flow<A1, A2, R1, R2>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2): LoDashExplicitWrapper<(a1: A1, a2: A2) => R2>;\n        flow<A1, A2, R1, R2, R3>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashExplicitWrapper<(a1: A1, a2: A2) => R3>;\n        flow<A1, A2, R1, R2, R3, R4>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashExplicitWrapper<(a1: A1, a2: A2) => R4>;\n        flow<A1, A2, R1, R2, R3, R4, R5>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashExplicitWrapper<(a1: A1, a2: A2) => R5>;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashExplicitWrapper<(a1: A1, a2: A2) => R6>;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashExplicitWrapper<(a1: A1, a2: A2) => R7>;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<(a1: A1, a2: A2) => any>;\n        // 3-argument first function\n        flow<A1, A2, A3, R1, R2>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R2>;\n        flow<A1, A2, A3, R1, R2, R3>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R3>;\n        flow<A1, A2, A3, R1, R2, R3, R4>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R4>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R5>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R6>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R7>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => any>;\n        // 4-argument first function\n        flow<A1, A2, A3, A4, R1, R2>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R2>;\n        flow<A1, A2, A3, A4, R1, R2, R3>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R3>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R4>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R5>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R6>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R7>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => any>;\n        // any-argument first function\n        flow<A1, A2, A3, A4, R1, R2>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R2>;\n        flow<A1, A2, A3, A4, R1, R2, R3>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R3>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R4>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R5>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R6>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R7>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => any>;\n        flow(this: LoDashExplicitWrapper<(...args: any[]) => any>, funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.flowRight\n    interface LoDashStatic {\n        /**\n         * This method is like _.flow except that it creates a function that invokes the provided functions from right\n         * to left.\n         *\n         * @param funcs Functions to invoke.\n         * @return Returns the new function.\n         */\n        // 0-argument first function\n        flowRight<R2, R1>(f2: (a: R1) => R2, f1: () => R1): () => R2;\n        flowRight<R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R3;\n        flowRight<R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R4;\n        flowRight<R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R5;\n        flowRight<R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R6;\n        flowRight<R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R7;\n        // 1-argument first function\n        flowRight<A1, R2, R1>(f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R2;\n        flowRight<A1, R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R3;\n        flowRight<A1, R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R4;\n        flowRight<A1, R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R5;\n        flowRight<A1, R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R6;\n        flowRight<A1, R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R7;\n        // 2-argument first function\n        flowRight<A1, A2, R2, R1>(f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R2;\n        flowRight<A1, A2, R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R3;\n        flowRight<A1, A2, R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R4;\n        flowRight<A1, A2, R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R5;\n        flowRight<A1, A2, R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R6;\n        flowRight<A1, A2, R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R7;\n        // 3-argument first function\n        flowRight<A1, A2, A3, R2, R1>(f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R2;\n        flowRight<A1, A2, A3, R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R3;\n        flowRight<A1, A2, A3, R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R4;\n        flowRight<A1, A2, A3, R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R5;\n        flowRight<A1, A2, A3, R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R6;\n        flowRight<A1, A2, A3, R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R7;\n        // 4-argument first function\n        flowRight<A1, A2, A3, A4, R2, R1>(f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R2;\n        flowRight<A1, A2, A3, A4, R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R3;\n        flowRight<A1, A2, A3, A4, R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R4;\n        flowRight<A1, A2, A3, A4, R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R5;\n        flowRight<A1, A2, A3, A4, R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R6;\n        flowRight<A1, A2, A3, A4, R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R7;\n        // any-argument first function\n        flowRight<R2, R1>(f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R2;\n        flowRight<R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R3;\n        flowRight<R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R4;\n        flowRight<R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R5;\n        flowRight<R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R6;\n        flowRight<R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R7;\n        flowRight(f7: (a: any) => any, f6: (a: any) => any, f5: (a: any) => any, f4: (a: any) => any, f3: (a: any) => any, f2: (a: any) => any, f1: () => any, ...funcs: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any;\n        flowRight(funcs: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flowRight\n         */\n        // 0-argument first function\n        flowRight<R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f1: () => R1): LoDashImplicitWrapper<() => R2>;\n        flowRight<R3, R2, R1>(this: LoDashImplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: () => R1): LoDashImplicitWrapper<() => R3>;\n        flowRight<R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashImplicitWrapper<() => R4>;\n        flowRight<R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashImplicitWrapper<() => R5>;\n        flowRight<R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashImplicitWrapper<() => R6>;\n        flowRight<R7, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashImplicitWrapper<() => R7>;\n        // 1-argument first function\n        flowRight<A1, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f1: (a1: A1) => R1): LoDashImplicitWrapper<(a1: A1) => R2>;\n        flowRight<A1, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashImplicitWrapper<(a1: A1) => R3>;\n        flowRight<A1, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashImplicitWrapper<(a1: A1) => R4>;\n        flowRight<A1, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashImplicitWrapper<(a1: A1) => R5>;\n        flowRight<A1, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashImplicitWrapper<(a1: A1) => R6>;\n        flowRight<A1, R7, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashImplicitWrapper<(a1: A1) => R7>;\n        // 2-argument first function\n        flowRight<A1, A2, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f1: (a1: A1, a2: A2) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2) => R2>;\n        flowRight<A1, A2, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2) => R3>;\n        flowRight<A1, A2, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2) => R4>;\n        flowRight<A1, A2, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2) => R5>;\n        flowRight<A1, A2, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2) => R6>;\n        flowRight<A1, A2, R7, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2) => R7>;\n        // 3-argument first function\n        flowRight<A1, A2, A3, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R2>;\n        flowRight<A1, A2, A3, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R3>;\n        flowRight<A1, A2, A3, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R4>;\n        flowRight<A1, A2, A3, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R5>;\n        flowRight<A1, A2, A3, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R6>;\n        flowRight<A1, A2, A3, R7, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R7>;\n        // 4-argument first function\n        flowRight<A1, A2, A3, A4, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R2>;\n        flowRight<A1, A2, A3, A4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R3>;\n        flowRight<A1, A2, A3, A4, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R4>;\n        flowRight<A1, A2, A3, A4, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R5>;\n        flowRight<A1, A2, A3, A4, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R6>;\n        flowRight<A1, A2, A3, A4, R7, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R7>;\n        // any-argument first function\n        flowRight<R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f1: (...args: any[]) => R1): LoDashImplicitWrapper<(...args: any[]) => R2>;\n        flowRight<R3, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashImplicitWrapper<(...args: any[]) => R3>;\n        flowRight<R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashImplicitWrapper<(...args: any[]) => R4>;\n        flowRight<R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashImplicitWrapper<(...args: any[]) => R5>;\n        flowRight<R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashImplicitWrapper<(...args: any[]) => R6>;\n        flowRight<R7, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashImplicitWrapper<(...args: any[]) => R7>;\n        flowRight(this: LoDashImplicitWrapper<(a: any) => any>, f6: (a: any) => any, f5: (a: any) => any, f4: (a: any) => any, f3: (a: any) => any, f2: (a: any) => any, f1: () => any, ...funcs: Array<Many<(...args: any[]) => any>>): LoDashImplicitWrapper<(...args: any[]) => any>;\n        flowRight(this: LoDashImplicitWrapper<(a: any) => any>, funcs: Array<Many<(...args: any[]) => any>>): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flowRight\n         */\n        // 0-argument first function\n        flowRight<R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f1: () => R1): LoDashExplicitWrapper<() => R2>;\n        flowRight<R3, R2, R1>(this: LoDashExplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: () => R1): LoDashExplicitWrapper<() => R3>;\n        flowRight<R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashExplicitWrapper<() => R4>;\n        flowRight<R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashExplicitWrapper<() => R5>;\n        flowRight<R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashExplicitWrapper<() => R6>;\n        flowRight<R7, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashExplicitWrapper<() => R7>;\n        // 1-argument first function\n        flowRight<A1, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f1: (a1: A1) => R1): LoDashExplicitWrapper<(a1: A1) => R2>;\n        flowRight<A1, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashExplicitWrapper<(a1: A1) => R3>;\n        flowRight<A1, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashExplicitWrapper<(a1: A1) => R4>;\n        flowRight<A1, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashExplicitWrapper<(a1: A1) => R5>;\n        flowRight<A1, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashExplicitWrapper<(a1: A1) => R6>;\n        flowRight<A1, R7, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashExplicitWrapper<(a1: A1) => R7>;\n        // 2-argument first function\n        flowRight<A1, A2, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f1: (a1: A1, a2: A2) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2) => R2>;\n        flowRight<A1, A2, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2) => R3>;\n        flowRight<A1, A2, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2) => R4>;\n        flowRight<A1, A2, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2) => R5>;\n        flowRight<A1, A2, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2) => R6>;\n        flowRight<A1, A2, R7, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2) => R7>;\n        // 3-argument first function\n        flowRight<A1, A2, A3, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R2>;\n        flowRight<A1, A2, A3, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R3>;\n        flowRight<A1, A2, A3, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R4>;\n        flowRight<A1, A2, A3, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R5>;\n        flowRight<A1, A2, A3, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R6>;\n        flowRight<A1, A2, A3, R7, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R7>;\n        // 4-argument first function\n        flowRight<A1, A2, A3, A4, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R2>;\n        flowRight<A1, A2, A3, A4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R3>;\n        flowRight<A1, A2, A3, A4, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R4>;\n        flowRight<A1, A2, A3, A4, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R5>;\n        flowRight<A1, A2, A3, A4, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R6>;\n        flowRight<A1, A2, A3, A4, R7, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R7>;\n        // any-argument first function\n        flowRight<R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f1: (...args: any[]) => R1): LoDashExplicitWrapper<(...args: any[]) => R2>;\n        flowRight<R3, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashExplicitWrapper<(...args: any[]) => R3>;\n        flowRight<R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashExplicitWrapper<(...args: any[]) => R4>;\n        flowRight<R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashExplicitWrapper<(...args: any[]) => R5>;\n        flowRight<R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashExplicitWrapper<(...args: any[]) => R6>;\n        flowRight<R7, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashExplicitWrapper<(...args: any[]) => R7>;\n        flowRight(this: LoDashExplicitWrapper<(a: any) => any>, f6: (a: any) => any, f5: (a: any) => any, f4: (a: any) => any, f3: (a: any) => any, f2: (a: any) => any, f1: () => any, ...funcs: Array<Many<(...args: any[]) => any>>): LoDashExplicitWrapper<(...args: any[]) => any>;\n        flowRight(this: LoDashExplicitWrapper<(a: any) => any>, funcs: Array<Many<(...args: any[]) => any>>): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.memoize\n    interface MemoizedFunction {\n        cache: MapCache;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a function that memoizes the result of func. If resolver is provided it determines the cache key for\n         * storing the result based on the arguments provided to the memoized function. By default, the first argument\n         * provided to the memoized function is coerced to a string and used as the cache key. The func is invoked with\n         * the this binding of the memoized function.\n         *\n         * @param func The function to have its output memoized.\n         * @param resolver The function to resolve the cache key.\n         * @return Returns the new memoizing function.\n         */\n        memoize: {\n            <T extends (...args: any[]) => any>(func: T, resolver?: (...args: any[]) => any): T & MemoizedFunction;\n            Cache: MapCacheConstructor;\n        };\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.memoize\n         */\n        memoize(resolver?: (...args: any[]) => any): LoDashImplicitWrapper<TValue & MemoizedFunction>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.memoize\n         */\n        memoize(resolver?: (...args: any[]) => any): LoDashExplicitWrapper<TValue & MemoizedFunction>;\n    }\n\n    //_.overArgs (was _.modArgs)\n    interface LoDashStatic {\n        /**\n         * Creates a function that runs each argument through a corresponding transform function.\n         *\n         * @param func The function to wrap.\n         * @param transforms The functions to transform arguments, specified as individual functions or arrays\n         * of functions.\n         * @return Returns the new function.\n         */\n        overArgs(\n            func: (...args: any[]) => any,\n            ...transforms: Array<Many<(...args: any[]) => any>>\n        ): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.overArgs\n         */\n        overArgs(...transforms: Array<Many<(...args: any[]) => any>>): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.overArgs\n         */\n        overArgs(...transforms: Array<Many<(...args: any[]) => any>>): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.negate\n    interface LoDashStatic {\n        /**\n         * Creates a function that negates the result of the predicate func. The func predicate is invoked with\n         * the this binding and arguments of the created function.\n         *\n         * @param predicate The predicate to negate.\n         * @return Returns the new function.\n         */\n        negate<T extends (...args: any[]) => any>(predicate: T): T;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.negate\n         */\n        negate(): this;\n    }\n\n    //_.once\n    interface LoDashStatic {\n        /**\n         * Creates a function that is restricted to invoking func once. Repeat calls to the function return the value\n         * of the first call. The func is invoked with the this binding and arguments of the created function.\n         *\n         * @param func The function to restrict.\n         * @return Returns the new restricted function.\n         */\n        once<T extends (...args: any[]) => any>(func: T): T;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.once\n         */\n        once(): this;\n    }\n\n    //_.partial\n    interface LoDashStatic {\n        /**\n        * Creates a function that, when called, invokes func with any additional partial arguments\n        * prepended to those provided to the new function. This method is similar to _.bind except\n        * it does not alter the this binding.\n        * @param func The function to partially apply arguments to.\n        * @param args Arguments to be partially applied.\n        * @return The new partially applied function.\n        **/\n        partial: Partial;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.partial\n         */\n        partial: ImplicitPartial;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.partial\n         */\n        partial: ExplicitPartial;\n    }\n\n    type PH = LoDashStatic;\n\n    type Function0<R> = () => R;\n    type Function1<T1, R> = (t1: T1) => R;\n    type Function2<T1, T2, R> = (t1: T1, t2: T2) => R;\n    type Function3<T1, T2, T3, R> = (t1: T1, t2: T2, t3: T3) => R;\n    type Function4<T1, T2, T3, T4, R> = (t1: T1, t2: T2, t3: T3, t4: T4) => R;\n\n    interface Partial {\n        // arity 0\n        <R>(func: Function0<R>): Function0<R>;\n        // arity 1\n        <T1, R>(func: Function1<T1, R>): Function1<T1, R>;\n        <T1, R>(func: Function1<T1, R>, arg1: T1): Function0<R>;\n        // arity 2\n        <T1, T2, R>(func: Function2<T1, T2, R>):                      Function2<T1, T2, R>;\n        <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1):            Function1<    T2, R>;\n        <T1, T2, R>(func: Function2<T1, T2, R>, plc1: PH, arg2: T2):  Function1<T1,     R>;\n        <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1, arg2: T2):  Function0<        R>;\n        // arity 3\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>):                                Function3<T1, T2, T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1):                      Function2<    T2, T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, plc1: PH, arg2: T2):            Function2<T1,     T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2):            Function1<        T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, plc1: PH, plc2: PH, arg3: T3):  Function2<T1, T2,     R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, plc2: PH, arg3: T3):  Function1<    T2,     R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, plc1: PH, arg2: T2, arg3: T3):  Function1<T1,         R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3):  Function0<            R>;\n        // arity 4\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>):                                          Function4<T1, T2, T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1):                                Function3<    T2, T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, arg2: T2):                      Function3<T1,     T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2):                      Function2<        T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, plc2: PH, arg3: T3):            Function3<T1, T2,     T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, arg3: T3):            Function2<    T2,     T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, arg2: T2, arg3: T3):            Function2<T1,         T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3):            Function1<            T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, plc2: PH, plc3: PH, arg4: T4):  Function3<T1, T2, T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, plc3: PH, arg4: T4):  Function2<    T2, T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, arg2: T2, plc3: PH, arg4: T4):  Function2<T1,     T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: PH, arg4: T4):  Function1<        T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, plc2: PH, arg3: T3, arg4: T4):  Function2<T1, T2,         R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, arg3: T3, arg4: T4):  Function1<    T2,         R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, arg2: T2, arg3: T3, arg4: T4):  Function1<T1,             R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4):  Function0<                R>;\n        // catch-all\n        (func: (...args: any[]) => any, ...args: any[]): (...args: any[]) => any;\n    }\n\n    interface ImplicitPartial {\n        // arity 0\n        <R>(this: LoDashImplicitWrapper<Function0<R>>): LoDashImplicitWrapper<Function0<R>>;\n        // arity 1\n        <T1, R>(this: LoDashImplicitWrapper<Function1<T1, R>>): LoDashImplicitWrapper<Function1<T1, R>>;\n        <T1, R>(this: LoDashImplicitWrapper<Function1<T1, R>>, arg1: T1): LoDashImplicitWrapper<Function0<R>>;\n        // arity 2\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>):                      LoDashImplicitWrapper<Function2<T1, T2, R>>;\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>, arg1: T1):            LoDashImplicitWrapper<Function1<    T2, R>>;\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>, plc1: PH, arg2: T2):  LoDashImplicitWrapper<Function1<T1,     R>>;\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>, arg1: T1, arg2: T2):  LoDashImplicitWrapper<Function0<        R>>;\n        // arity 3\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>):                                LoDashImplicitWrapper<Function3<T1, T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1):                      LoDashImplicitWrapper<Function2<    T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, plc1: PH, arg2: T2):            LoDashImplicitWrapper<Function2<T1,     T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2):            LoDashImplicitWrapper<Function1<        T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, plc1: PH, plc2: PH, arg3: T3):  LoDashImplicitWrapper<Function2<T1, T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, plc2: PH, arg3: T3):  LoDashImplicitWrapper<Function1<    T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, plc1: PH, arg2: T2, arg3: T3):  LoDashImplicitWrapper<Function1<T1,         R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2, arg3: T3):  LoDashImplicitWrapper<Function0<            R>>;\n        // arity 4\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>):                                          LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1):                                LoDashImplicitWrapper<Function3<    T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2):                      LoDashImplicitWrapper<Function3<T1,     T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2):                      LoDashImplicitWrapper<Function2<        T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, plc2: PH, arg3: T3):            LoDashImplicitWrapper<Function3<T1, T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3):            LoDashImplicitWrapper<Function2<    T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2, arg3: T3):            LoDashImplicitWrapper<Function2<T1,         T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3):            LoDashImplicitWrapper<Function1<            T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, plc2: PH, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function3<T1, T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function2<    T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function2<T1,     T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function1<        T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, plc2: PH, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function2<T1, T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function1<    T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function1<T1,             R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function0<                R>>;\n        // catch-all\n        (...args: any[]): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface ExplicitPartial {\n        // arity 0\n        <R>(this: LoDashExplicitWrapper<Function0<R>>): LoDashExplicitWrapper<Function0<R>>;\n        // arity 1\n        <T1, R>(this: LoDashExplicitWrapper<Function1<T1, R>>): LoDashExplicitWrapper<Function1<T1, R>>;\n        <T1, R>(this: LoDashExplicitWrapper<Function1<T1, R>>, arg1: T1): LoDashExplicitWrapper<Function0<R>>;\n        // arity 2\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>):                      LoDashExplicitWrapper<Function2<T1, T2, R>>;\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>, arg1: T1):            LoDashExplicitWrapper<Function1<    T2, R>>;\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>, plc1: PH, arg2: T2):  LoDashExplicitWrapper<Function1<T1,     R>>;\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>, arg1: T1, arg2: T2):  LoDashExplicitWrapper<Function0<        R>>;\n        // arity 3\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>):                                LoDashExplicitWrapper<Function3<T1, T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1):                      LoDashExplicitWrapper<Function2<    T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, plc1: PH, arg2: T2):            LoDashExplicitWrapper<Function2<T1,     T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2):            LoDashExplicitWrapper<Function1<        T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, plc1: PH, plc2: PH, arg3: T3):  LoDashExplicitWrapper<Function2<T1, T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, plc2: PH, arg3: T3):  LoDashExplicitWrapper<Function1<    T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, plc1: PH, arg2: T2, arg3: T3):  LoDashExplicitWrapper<Function1<T1,         R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2, arg3: T3):  LoDashExplicitWrapper<Function0<            R>>;\n        // arity 4\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>):                                          LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1):                                LoDashExplicitWrapper<Function3<    T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2):                      LoDashExplicitWrapper<Function3<T1,     T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2):                      LoDashExplicitWrapper<Function2<        T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, plc2: PH, arg3: T3):            LoDashExplicitWrapper<Function3<T1, T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3):            LoDashExplicitWrapper<Function2<    T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2, arg3: T3):            LoDashExplicitWrapper<Function2<T1,         T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3):            LoDashExplicitWrapper<Function1<            T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, plc2: PH, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function3<T1, T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function2<    T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function2<T1,     T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function1<        T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, plc2: PH, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function2<T1, T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function1<    T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function1<T1,             R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function0<                R>>;\n        // catch-all\n        (...args: any[]): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.partialRight\n    interface LoDashStatic {\n        /**\n        * This method is like _.partial except that partial arguments are appended to those provided\n        * to the new function.\n        * @param func The function to partially apply arguments to.\n        * @param args Arguments to be partially applied.\n        * @return The new partially applied function.\n        **/\n        partialRight: PartialRight;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.partialRight\n         */\n        partialRight: ImplicitPartialRight;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.partialRight\n         */\n        partialRight: ExplicitPartialRight;\n    }\n\n    interface PartialRight {\n        // arity 0\n        <R>(func: Function0<R>): Function0<R>;\n        // arity 1\n        <T1, R>(func: Function1<T1, R>): Function1<T1, R>;\n        <T1, R>(func: Function1<T1, R>, arg1: T1): Function0<R>;\n        // arity 2\n        <T1, T2, R>(func: Function2<T1, T2, R>):                      Function2<T1, T2, R>;\n        <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1, plc2: PH):  Function1<    T2, R>;\n        <T1, T2, R>(func: Function2<T1, T2, R>,           arg2: T2):  Function1<T1,     R>;\n        <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1, arg2: T2):  Function0<        R>;\n        // arity 3\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>):                                Function3<T1, T2, T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, plc2: PH, plc3: PH):  Function2<    T2, T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>,           arg2: T2, plc3: PH):  Function2<T1,     T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, plc3: PH):  Function1<        T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>,                     arg3: T3):  Function2<T1, T2,     R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, plc2: PH, arg3: T3):  Function1<    T2,     R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>,           arg2: T2, arg3: T3):  Function1<T1,         R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3):  Function0<            R>;\n        // arity 4\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>):                                          Function4<T1, T2, T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, plc3: PH, plc4: PH):  Function3<    T2, T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,           arg2: T2, plc3: PH, plc4: PH):  Function3<T1,     T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: PH, plc4: PH):  Function2<        T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,                     arg3: T3, plc4: PH):  Function3<T1, T2,     T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, arg3: T3, plc4: PH):  Function2<    T2,     T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,           arg2: T2, arg3: T3, plc4: PH):  Function2<T1,         T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, plc4: PH):  Function1<            T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,                               arg4: T4):  Function3<T1, T2, T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, plc3: PH, arg4: T4):  Function2<    T2, T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,           arg2: T2, plc3: PH, arg4: T4):  Function2<T1,     T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: PH, arg4: T4):  Function1<        T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,                     arg3: T3, arg4: T4):  Function2<T1, T2,         R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, arg3: T3, arg4: T4):  Function1<    T2,         R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,           arg2: T2, arg3: T3, arg4: T4):  Function1<T1,             R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4):  Function0<                R>;\n        // catch-all\n        (func: (...args: any[]) => any, ...args: any[]): (...args: any[]) => any;\n    }\n\n    interface ImplicitPartialRight {\n        // arity 0\n        <R>(this: LoDashImplicitWrapper<Function0<R>>): LoDashImplicitWrapper<Function0<R>>;\n        // arity 1\n        <T1, R>(this: LoDashImplicitWrapper<Function1<T1, R>>): LoDashImplicitWrapper<Function1<T1, R>>;\n        <T1, R>(this: LoDashImplicitWrapper<Function1<T1, R>>, arg1: T1): LoDashImplicitWrapper<Function0<R>>;\n        // arity 2\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>):                      LoDashImplicitWrapper<Function2<T1, T2, R>>;\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>, arg1: T1, plc2: PH):  LoDashImplicitWrapper<Function1<    T2, R>>;\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>,           arg2: T2):  LoDashImplicitWrapper<Function1<T1,     R>>;\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>, arg1: T1, arg2: T2):  LoDashImplicitWrapper<Function0<        R>>;\n        // arity 3\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>):                                LoDashImplicitWrapper<Function3<T1, T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, plc2: PH, plc3: PH):  LoDashImplicitWrapper<Function2<    T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>,           arg2: T2, plc3: PH):  LoDashImplicitWrapper<Function2<T1,     T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2, plc3: PH):  LoDashImplicitWrapper<Function1<        T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>,                     arg3: T3):  LoDashImplicitWrapper<Function2<T1, T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, plc2: PH, arg3: T3):  LoDashImplicitWrapper<Function1<    T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>,           arg2: T2, arg3: T3):  LoDashImplicitWrapper<Function1<T1,         R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2, arg3: T3):  LoDashImplicitWrapper<Function0<            R>>;\n        // arity 4\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>):                                          LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, plc3: PH, plc4: PH):  LoDashImplicitWrapper<Function3<    T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, plc3: PH, plc4: PH):  LoDashImplicitWrapper<Function3<T1,     T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, plc3: PH, plc4: PH):  LoDashImplicitWrapper<Function2<        T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,                     arg3: T3, plc4: PH):  LoDashImplicitWrapper<Function3<T1, T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3, plc4: PH):  LoDashImplicitWrapper<Function2<    T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, arg3: T3, plc4: PH):  LoDashImplicitWrapper<Function2<T1,         T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3, plc4: PH):  LoDashImplicitWrapper<Function1<            T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,                               arg4: T4):  LoDashImplicitWrapper<Function3<T1, T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function2<    T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function2<T1,     T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function1<        T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,                     arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function2<T1, T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function1<    T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function1<T1,             R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function0<                R>>;\n        // catch-all\n        (...args: any[]): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface ExplicitPartialRight {\n        // arity 0\n        <R>(this: LoDashExplicitWrapper<Function0<R>>): LoDashExplicitWrapper<Function0<R>>;\n        // arity 1\n        <T1, R>(this: LoDashExplicitWrapper<Function1<T1, R>>): LoDashExplicitWrapper<Function1<T1, R>>;\n        <T1, R>(this: LoDashExplicitWrapper<Function1<T1, R>>, arg1: T1): LoDashExplicitWrapper<Function0<R>>;\n        // arity 2\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>):                      LoDashExplicitWrapper<Function2<T1, T2, R>>;\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>, arg1: T1, plc2: PH):  LoDashExplicitWrapper<Function1<    T2, R>>;\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>,           arg2: T2):  LoDashExplicitWrapper<Function1<T1,     R>>;\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>, arg1: T1, arg2: T2):  LoDashExplicitWrapper<Function0<        R>>;\n        // arity 3\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>):                                LoDashExplicitWrapper<Function3<T1, T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, plc2: PH, plc3: PH):  LoDashExplicitWrapper<Function2<    T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>,           arg2: T2, plc3: PH):  LoDashExplicitWrapper<Function2<T1,     T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2, plc3: PH):  LoDashExplicitWrapper<Function1<        T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>,                     arg3: T3):  LoDashExplicitWrapper<Function2<T1, T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, plc2: PH, arg3: T3):  LoDashExplicitWrapper<Function1<    T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>,           arg2: T2, arg3: T3):  LoDashExplicitWrapper<Function1<T1,         R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2, arg3: T3):  LoDashExplicitWrapper<Function0<            R>>;\n        // arity 4\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>):                                          LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, plc3: PH, plc4: PH):  LoDashExplicitWrapper<Function3<    T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, plc3: PH, plc4: PH):  LoDashExplicitWrapper<Function3<T1,     T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, plc3: PH, plc4: PH):  LoDashExplicitWrapper<Function2<        T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,                     arg3: T3, plc4: PH):  LoDashExplicitWrapper<Function3<T1, T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3, plc4: PH):  LoDashExplicitWrapper<Function2<    T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, arg3: T3, plc4: PH):  LoDashExplicitWrapper<Function2<T1,         T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3, plc4: PH):  LoDashExplicitWrapper<Function1<            T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,                               arg4: T4):  LoDashExplicitWrapper<Function3<T1, T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function2<    T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function2<T1,     T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function1<        T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,                     arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function2<T1, T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function1<    T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function1<T1,             R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function0<                R>>;\n        // catch-all\n        (...args: any[]): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.rearg\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes func with arguments arranged according to the specified indexes where the\n         * argument value at the first index is provided as the first argument, the argument value at the second index\n         * is provided as the second argument, and so on.\n         * @param func The function to rearrange arguments for.\n         * @param indexes The arranged argument indexes, specified as individual indexes or arrays of indexes.\n         * @return Returns the new function.\n         */\n        rearg(func: (...args: any[]) => any, ...indexes: Array<Many<number>>): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.rearg\n         */\n        rearg(...indexes: Array<Many<number>>): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.rearg\n         */\n        rearg(...indexes: Array<Many<number>>): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.rest\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes func with the this binding of the created function and arguments from start\n         * and beyond provided as an array.\n         *\n         * Note: This method is based on the rest parameter.\n         *\n         * @param func The function to apply a rest parameter to.\n         * @param start The start position of the rest parameter.\n         * @return Returns the new function.\n         */\n        rest(\n            func: (...args: any[]) => any,\n            start?: number\n        ): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.rest\n         */\n        rest(start?: number): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.rest\n         */\n        rest(start?: number): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.spread\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes func with the this binding of the created function and an array of arguments\n         * much like Function#apply.\n         *\n         * Note: This method is based on the spread operator.\n         *\n         * @param func The function to spread arguments over.\n         * @return Returns the new function.\n         */\n        spread<TResult>(func: (...args: any[]) => TResult): (...args: any[]) => TResult;\n\n        /**\n         * @see _.spread\n         */\n        spread<TResult>(func: (...args: any[]) => TResult, start: number): (...args: any[]) => TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.spread\n         */\n        spread<TResult>(this: LoDashImplicitWrapper<(...args: any[]) => TResult>): LoDashImplicitWrapper<(...args: any[]) => TResult>;\n\n        /**\n         * @see _.spread\n         */\n        spread<TResult>(this: LoDashImplicitWrapper<(...args: any[]) => TResult>, start: number): LoDashImplicitWrapper<(...args: any[]) => TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.spread\n         */\n        spread<TResult>(this: LoDashExplicitWrapper<(...args: any[]) => TResult>): LoDashExplicitWrapper<(...args: any[]) => TResult>;\n\n        /**\n         * @see _.spread\n         */\n        spread<TResult>(this: LoDashExplicitWrapper<(...args: any[]) => TResult>, start: number): LoDashExplicitWrapper<(...args: any[]) => TResult>;\n    }\n\n    //_.throttle\n    interface ThrottleSettings {\n        /**\n         * If you'd like to disable the leading-edge call, pass this as false.\n         */\n        leading?: boolean;\n\n        /**\n         * If you'd like to disable the execution on the trailing-edge, pass false.\n         */\n        trailing?: boolean;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a throttled function that only invokes func at most once per every wait milliseconds. The throttled\n         * function comes with a cancel method to cancel delayed invocations and a flush method to immediately invoke\n         * them. Provide an options object to indicate that func should be invoked on the leading and/or trailing edge\n         * of the wait timeout. Subsequent calls to the throttled function return the result of the last func call.\n         *\n         * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only if\n         * the the throttled function is invoked more than once during the wait timeout.\n         *\n         * @param func The function to throttle.\n         * @param wait The number of milliseconds to throttle invocations to.\n         * @param options The options object.\n         * @param options.leading Specify invoking on the leading edge of the timeout.\n         * @param options.trailing Specify invoking on the trailing edge of the timeout.\n         * @return Returns the new throttled function.\n         */\n        throttle<T extends (...args: any[]) => any>(\n            func: T,\n            wait?: number,\n            options?: ThrottleSettings\n        ): T & Cancelable;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.throttle\n         */\n        throttle(\n            wait?: number,\n            options?: ThrottleSettings\n        ): LoDashImplicitWrapper<TValue & Cancelable>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.throttle\n         */\n        throttle(\n            wait?: number,\n            options?: ThrottleSettings\n        ): LoDashExplicitWrapper<TValue & Cancelable>;\n    }\n\n    //_.unary\n    interface LoDashStatic {\n        /**\n         * Creates a function that accepts up to one argument, ignoring any\n         * additional arguments.\n         *\n         * @category Function\n         * @param func The function to cap arguments for.\n         * @returns Returns the new function.\n         * @example\n         *\n         * _.map(['6', '8', '10'], _.unary(parseInt));\n         * // => [6, 8, 10]\n         */\n        unary<T, TResult>(func: (arg1: T, ...args: any[]) => TResult): (arg1: T) => TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unary\n         */\n        unary<T, TResult>(this: LoDashImplicitWrapper<(arg1: T, ...args: any[]) => TResult>): LoDashImplicitWrapper<(arg1: T) => TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unary\n         */\n        unary<T, TResult>(this: LoDashExplicitWrapper<(arg1: T, ...args: any[]) => TResult>): LoDashExplicitWrapper<(arg1: T) => TResult>;\n    }\n\n    //_.wrap\n    interface LoDashStatic {\n        /**\n         * Creates a function that provides value to the wrapper function as its first argument. Any additional\n         * arguments provided to the function are appended to those provided to the wrapper function. The wrapper is\n         * invoked with the this binding of the created function.\n         *\n         * @param value The value to wrap.\n         * @param wrapper The wrapper function.\n         * @return Returns the new function.\n         */\n        wrap<T, TArgs, TResult>(\n            value: T,\n            wrapper: (value: T, ...args: TArgs[]) => TResult\n        ): (...args: TArgs[]) => TResult;\n\n        /**\n         * @see _.wrap\n         */\n        wrap<T, TResult>(\n            value: T,\n            wrapper: (value: T, ...args: any[]) => TResult\n        ): (...args: any[]) => TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.wrap\n         */\n        wrap<TArgs, TResult>(\n            wrapper: (value: TValue, ...args: TArgs[]) => TResult\n        ): LoDashImplicitWrapper<(...args: TArgs[]) => TResult>;\n\n        /**\n         * @see _.wrap\n         */\n        wrap<TResult>(\n            wrapper: (value: TValue, ...args: any[]) => TResult\n        ): LoDashImplicitWrapper<(...args: any[]) => TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.wrap\n         */\n        /**\n         * @see _.wrap\n         */\n        wrap<TArgs, TResult>(\n            wrapper: (value: TValue, ...args: TArgs[]) => TResult\n        ): LoDashExplicitWrapper<(...args: TArgs[]) => TResult>;\n\n        /**\n         * @see _.wrap\n         */\n        wrap<TResult>(\n            wrapper: (value: TValue, ...args: any[]) => TResult\n        ): LoDashExplicitWrapper<(...args: any[]) => TResult>;\n    }\n\n    /********\n     * Lang *\n     ********/\n\n    //_.castArray\n    interface LoDashStatic {\n        /**\n         * Casts value as an array if it’s not one.\n         *\n         * @param value The value to inspect.\n         * @return Returns the cast array.\n         */\n        castArray<T>(value?: Many<T>): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.castArray\n         */\n        castArray<T>(this: LoDashImplicitWrapper<Many<T>>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.castArray\n         */\n        castArray<T>(this: LoDashExplicitWrapper<Many<T>>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.clone\n    interface LoDashStatic {\n        /**\n         * Creates a shallow clone of value.\n         *\n         * Note: This method is loosely based on the structured clone algorithm and supports cloning arrays,\n         * array buffers, booleans, date objects, maps, numbers, Object objects, regexes, sets, strings, symbols,\n         * and typed arrays. The own enumerable properties of arguments objects are cloned as plain objects. An empty\n         * object is returned for uncloneable values such as error objects, functions, DOM nodes, and WeakMaps.\n         *\n         * @param value The value to clone.\n         * @return Returns the cloned value.\n         */\n        clone<T>(value: T): T;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.clone\n         */\n        clone(): TValue;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.clone\n         */\n        clone(): this;\n    }\n\n    //_.cloneDeep\n    interface LoDashStatic {\n        /**\n         * This method is like _.clone except that it recursively clones value.\n         *\n         * @param value The value to recursively clone.\n         * @return Returns the deep cloned value.\n         */\n        cloneDeep<T>(value: T): T;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.cloneDeep\n         */\n        cloneDeep(): TValue;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.cloneDeep\n         */\n        cloneDeep(): this;\n    }\n\n    //_.cloneDeepWith\n    type CloneDeepWithCustomizer<TObject> = (value: any, key: number | string | undefined, object: TObject | undefined, stack: any) => any;\n\n    interface LoDashStatic {\n        /**\n         * This method is like _.cloneWith except that it recursively clones value.\n         *\n         * @param value The value to recursively clone.\n         * @param customizer The function to customize cloning.\n         * @return Returns the deep cloned value.\n         */\n        cloneDeepWith<T>(\n            value: T,\n            customizer: CloneDeepWithCustomizer<T>\n        ): any;\n\n        /**\n         * @see _.cloneDeepWith\n         */\n        cloneDeepWith<T>(value: T): T;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.cloneDeepWith\n         */\n        cloneDeepWith(\n            customizer: CloneDeepWithCustomizer<TValue>\n        ): any;\n\n        /**\n         * @see _.cloneDeepWith\n         */\n        cloneDeepWith(): TValue;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.cloneDeepWith\n         */\n        cloneDeepWith(\n            customizer: CloneDeepWithCustomizer<TValue>\n        ): LoDashExplicitWrapper<any>;\n\n        /**\n         * @see _.cloneDeepWith\n         */\n        cloneDeepWith(): this;\n    }\n\n    //_.cloneWith\n    type CloneWithCustomizer<TValue, TResult> = (value: TValue, key: number | string | undefined, object: any, stack: any) => TResult;\n\n    interface LoDashStatic {\n        /**\n         * This method is like _.clone except that it accepts customizer which is invoked to produce the cloned value.\n         * If customizer returns undefined cloning is handled by the method instead.\n         *\n         * @param value The value to clone.\n         * @param customizer The function to customize cloning.\n         * @return Returns the cloned value.\n         */\n        cloneWith<T, TResult extends object | string | number | boolean | null>(\n            value: T,\n            customizer: CloneWithCustomizer<T, TResult>\n        ): TResult;\n\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith<T, TResult>(\n            value: T,\n            customizer: CloneWithCustomizer<T, TResult | undefined>\n        ): TResult | T;\n\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith<T>(value: T): T;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith<TResult extends object | string | number | boolean | null>(\n            customizer: CloneWithCustomizer<TValue, TResult>\n        ): TResult;\n\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith<TResult>(\n            customizer: CloneWithCustomizer<TValue, TResult | undefined>\n        ): TResult | TValue;\n\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith(): TValue;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith<TResult extends object | string | number | boolean | null>(\n            customizer: CloneWithCustomizer<TValue, TResult>\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith<TResult>(\n            customizer: CloneWithCustomizer<TValue, TResult | undefined>\n        ): LoDashExplicitWrapper<TResult | TValue>;\n\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith(): this;\n    }\n\n    /**\n     * An object containing predicate functions for each property of T\n     */\n    type ConformsPredicateObject<T> = {\n        [P in keyof T]?: (val: T[P]) => boolean;\n    };\n\n    //_.conforms\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes the predicate properties of `source` with the corresponding\n         * property values of a given object, returning true if all predicates return truthy, else false.\n         */\n        conforms<T>(source: ConformsPredicateObject<T>): (value: T) => boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.conforms\n         */\n        conforms<T>(this: LoDashImplicitWrapper<ConformsPredicateObject<T>>): LoDashImplicitWrapper<(value: T) => boolean>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.conforms\n         */\n        conforms<T>(this: LoDashExplicitWrapper<ConformsPredicateObject<T>>): LoDashExplicitWrapper<(value: T) => boolean>;\n    }\n\n    //_.conformsTo\n    interface LoDashStatic {\n        /**\n         * Checks if object conforms to source by invoking the predicate properties of source with the\n         * corresponding property values of object.\n         *\n         * Note: This method is equivalent to _.conforms when source is partially applied.\n         */\n        conformsTo<T>(object: T, source: ConformsPredicateObject<T>): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.conformsTo\n         */\n        conformsTo<T>(this: LoDashImplicitWrapper<T>, source: ConformsPredicateObject<T>): boolean;\n        // Note: we can't use TValue here,  because it generates a typescript error when strictFunctionTypes is enabled.\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.conformsTo\n         */\n        conformsTo<T>(this: LoDashImplicitWrapper<T>, source: ConformsPredicateObject<T>): LoDashExplicitWrapper<boolean>;\n        // Note: we can't use TValue here,  because it generates a typescript error when strictFunctionTypes is enabled.\n    }\n\n    type CondPair<T, R> = [(val: T) => boolean, (val: T) => R]\n\n    //_.cond\n    interface LoDashStatic {\n        /**\n         * Creates a function that iterates over `pairs` and invokes the corresponding\n         * function of the first predicate to return truthy. The predicate-function\n         * pairs are invoked with the `this` binding and arguments of the created\n         * function.\n         *\n         * @since 4.0.0\n         * @category Util\n         * @param pairs The predicate-function pairs.\n         * @returns Returns the new composite function.\n         * @example\n         *\n         * var func = _.cond([\n         *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n         *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n         *   [_.stubTrue,                      _.constant('no match')]\n         * ]);\n         *\n         * func({ 'a': 1, 'b': 2 });\n         * // => 'matches A'\n         *\n         * func({ 'a': 0, 'b': 1 });\n         * // => 'matches B'\n         *\n         * func({ 'a': '1', 'b': '2' });\n         * // => 'no match'\n         */\n        cond<T, R>(pairs: CondPair<T, R>[]): (Target: T) => R;\n    }\n\n    //_.eq\n    interface LoDashStatic {\n        /**\n         * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n         * comparison between two values to determine if they are equivalent.\n         *\n         * @category Lang\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @returns Returns `true` if the values are equivalent, else `false`.\n         * @example\n         *\n         * var object = { 'user': 'fred' };\n         * var other = { 'user': 'fred' };\n         *\n         * _.eq(object, object);\n         * // => true\n         *\n         * _.eq(object, other);\n         * // => false\n         *\n         * _.eq('a', 'a');\n         * // => true\n         *\n         * _.eq('a', Object('a'));\n         * // => false\n         *\n         * _.eq(NaN, NaN);\n         * // => true\n         */\n        eq(\n            value: any,\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.eq\n         */\n        eq(\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.eq\n         */\n        eq(\n            other: any\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.gt\n    interface LoDashStatic {\n        /**\n         * Checks if value is greater than other.\n         *\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @return Returns true if value is greater than other, else false.\n         */\n        gt(\n            value: any,\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.gt\n         */\n        gt(other: any): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.gt\n         */\n        gt(other: any): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.gte\n    interface LoDashStatic {\n        /**\n         * Checks if value is greater than or equal to other.\n         *\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @return Returns true if value is greater than or equal to other, else false.\n         */\n        gte(\n            value: any,\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.gte\n         */\n        gte(other: any): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.gte\n         */\n        gte(other: any): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isArguments\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as an arguments object.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isArguments(value?: any): value is IArguments;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isArguments\n         */\n        isArguments(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isArguments\n         */\n        isArguments(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isArray\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as an Array object.\n         * @param value The value to check.\n         *\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isArray(value?: any): value is any[];\n\n        /**\n         * DEPRECATED\n         */\n        isArray<T>(value?: any): value is any[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isArray\n         */\n        isArray(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isArray\n         */\n        isArray(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isArrayBuffer\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as an ArrayBuffer object.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isArrayBuffer(value?: any): value is ArrayBuffer;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isArrayBuffer\n         */\n        isArrayBuffer(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isArrayBuffer\n         */\n        isArrayBuffer(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isArrayLike\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is array-like. A value is considered array-like if it's\n         * not a function and has a `value.length` that's an integer greater than or\n         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is array-like, else `false`.\n         * @example\n         *\n         * _.isArrayLike([1, 2, 3]);\n         * // => true\n         *\n         * _.isArrayLike(document.body.children);\n         * // => true\n         *\n         * _.isArrayLike('abc');\n         * // => true\n         *\n         * _.isArrayLike(_.noop);\n         * // => false\n         */\n        isArrayLike<T>(value: T & string & number): boolean; // should only match if T = any\n\n        /**\n         * @see _.isArrayLike\n         */\n        isArrayLike(value: ((...args: any[]) => any) | Function | null | undefined): value is never;\n\n        /**\n         * @see _.isArrayLike\n         */\n        isArrayLike(value: any): value is { length: number };\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isArrayLike\n         */\n        isArrayLike(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isArrayLike\n         */\n        isArrayLike(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isArrayLikeObject\n    interface LoDashStatic {\n        /**\n         * This method is like `_.isArrayLike` except that it also checks if `value`\n         * is an object.\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is an array-like object, else `false`.\n         * @example\n         *\n         * _.isArrayLikeObject([1, 2, 3]);\n         * // => true\n         *\n         * _.isArrayLikeObject(document.body.children);\n         * // => true\n         *\n         * _.isArrayLikeObject('abc');\n         * // => false\n         *\n         * _.isArrayLikeObject(_.noop);\n         * // => false\n         */\n        isArrayLikeObject<T>(value: T & string & number): boolean; // should only match if T = any\n\n        /**\n         * @see _.isArrayLike\n         */\n        isArrayLikeObject(value: ((...args: any[]) => any) | Function | string | boolean | number | null | undefined): value is never;\n\n        /**\n         * @see _.isArrayLike\n         */\n        isArrayLikeObject<T extends object>(value: T | string | boolean | number | null | undefined): value is T & { length: number };\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isArrayLikeObject\n         */\n        isArrayLikeObject(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isArrayLikeObject\n         */\n        isArrayLikeObject(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isBoolean\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a boolean primitive or object.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isBoolean(value?: any): value is boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isBoolean\n         */\n        isBoolean(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isBoolean\n         */\n        isBoolean(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isBuffer\n    interface LoDashStatic {\n        /**\n         * Checks if value is a buffer.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is a buffer, else false.\n         */\n        isBuffer(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isBuffer\n         */\n        isBuffer(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isBuffer\n         */\n        isBuffer(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isDate\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a Date object.\n         * @param value The value to check.\n         *\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isDate(value?: any): value is Date;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isDate\n         */\n        isDate(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isDate\n         */\n        isDate(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isElement\n    interface LoDashStatic {\n        /**\n         * Checks if value is a DOM element.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is a DOM element, else false.\n         */\n        isElement(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isElement\n         */\n        isElement(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isElement\n         */\n        isElement(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isEmpty\n    interface LoDashStatic {\n        /**\n         * Checks if value is empty. A value is considered empty unless it’s an arguments object, array, string, or\n         * jQuery-like collection with a length greater than 0 or an object with own enumerable properties.\n         *\n         * @param value The value to inspect.\n         * @return Returns true if value is empty, else false.\n         */\n        isEmpty(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isEmpty\n         */\n        isEmpty(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isEmpty\n         */\n        isEmpty(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isEqual\n    interface LoDashStatic {\n        /**\n         * Performs a deep comparison between two values to determine if they are\n         * equivalent.\n         *\n         * **Note:** This method supports comparing arrays, array buffers, booleans,\n         * date objects, error objects, maps, numbers, `Object` objects, regexes,\n         * sets, strings, symbols, and typed arrays. `Object` objects are compared\n         * by their own, not inherited, enumerable properties. Functions and DOM\n         * nodes are **not** supported.\n         *\n         * @category Lang\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @returns Returns `true` if the values are equivalent, else `false`.\n         * @example\n         *\n         * var object = { 'user': 'fred' };\n         * var other = { 'user': 'fred' };\n         *\n         * _.isEqual(object, other);\n         * // => true\n         *\n         * object === other;\n         * // => false\n         */\n        isEqual(\n            value: any,\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isEqual\n         */\n        isEqual(\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isEqual\n         */\n        isEqual(\n            other: any\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    // _.isEqualWith\n    type IsEqualCustomizer = (value: any, other: any, indexOrKey: PropertyName | undefined, parent: any, otherParent: any, stack: any) => boolean|undefined;\n\n    interface LoDashStatic {\n        /**\n         * This method is like `_.isEqual` except that it accepts `customizer` which is\n         * invoked to compare values. If `customizer` returns `undefined` comparisons are\n         * handled by the method instead. The `customizer` is invoked with up to seven arguments:\n         * (objValue, othValue [, index|key, object, other, stack]).\n         *\n         * @category Lang\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @param [customizer] The function to customize comparisons.\n         * @returns Returns `true` if the values are equivalent, else `false`.\n         * @example\n         *\n         * function isGreeting(value) {\n         *   return /^h(?:i|ello)$/.test(value);\n         * }\n         *\n         * function customizer(objValue, othValue) {\n         *   if (isGreeting(objValue) && isGreeting(othValue)) {\n         *     return true;\n         *   }\n         * }\n         *\n         * var array = ['hello', 'goodbye'];\n         * var other = ['hi', 'goodbye'];\n         *\n         * _.isEqualWith(array, other, customizer);\n         * // => true\n         */\n        isEqualWith(\n            value: any,\n            other: any,\n            customizer?: IsEqualCustomizer\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isEqualWith\n         */\n        isEqualWith(\n            other: any,\n            customizer?: IsEqualCustomizer\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isEqualWith\n         */\n        isEqualWith(\n            other: any,\n            customizer?: IsEqualCustomizer\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isError\n    interface LoDashStatic {\n        /**\n         * Checks if value is an Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, or URIError\n         * object.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is an error object, else false.\n         */\n        isError(value: any): value is Error;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isError\n         */\n        isError(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isError\n         */\n        isError(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isFinite\n    interface LoDashStatic {\n        /**\n         * Checks if value is a finite primitive number.\n         *\n         * Note: This method is based on Number.isFinite.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is a finite number, else false.\n         */\n        isFinite(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isFinite\n         */\n        isFinite(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isFinite\n         */\n        isFinite(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isFunction\n    interface LoDashStatic {\n        /**\n         * Checks if value is a callable function.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isFunction(value: any): value is (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isFunction\n         */\n        isFunction(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isFunction\n         */\n        isFunction(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isInteger\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is an integer.\n         *\n         * **Note:** This method is based on [`Number.isInteger`](https://mdn.io/Number/isInteger).\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is an integer, else `false`.\n         * @example\n         *\n         * _.isInteger(3);\n         * // => true\n         *\n         * _.isInteger(Number.MIN_VALUE);\n         * // => false\n         *\n         * _.isInteger(Infinity);\n         * // => false\n         *\n         * _.isInteger('3');\n         * // => false\n         */\n        isInteger(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isInteger\n         */\n        isInteger(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isInteger\n         */\n        isInteger(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isLength\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is a valid array-like length.\n         *\n         * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is a valid length, else `false`.\n         * @example\n         *\n         * _.isLength(3);\n         * // => true\n         *\n         * _.isLength(Number.MIN_VALUE);\n         * // => false\n         *\n         * _.isLength(Infinity);\n         * // => false\n         *\n         * _.isLength('3');\n         * // => false\n         */\n        isLength(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isLength\n         */\n        isLength(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isLength\n         */\n        isLength(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isMap\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a Map object.\n         *\n         * @param value The value to check.\n         * @returns Returns true if value is correctly classified, else false.\n         */\n        isMap(value?: any): value is Map<any, any>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isMap\n         */\n        isMap(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isMap\n         */\n        isMap(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isMatch\n    type isMatchCustomizer = (value: any, other: any, indexOrKey?: PropertyName) => boolean;\n\n    interface LoDashStatic {\n        /**\n         * Performs a deep comparison between `object` and `source` to determine if\n         * `object` contains equivalent property values.\n         *\n         * **Note:** This method supports comparing the same values as `_.isEqual`.\n         *\n         * @category Lang\n         * @param object The object to inspect.\n         * @param source The object of property values to match.\n         * @returns Returns `true` if `object` is a match, else `false`.\n         * @example\n         *\n         * var object = { 'user': 'fred', 'age': 40 };\n         *\n         * _.isMatch(object, { 'age': 40 });\n         * // => true\n         *\n         * _.isMatch(object, { 'age': 36 });\n         * // => false\n         */\n        isMatch(object: object, source: object): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isMatch\n         */\n        isMatch(source: object): boolean;\n    }\n\n    //_.isMatchWith\n    type isMatchWithCustomizer = (value: any, other: any, indexOrKey: PropertyName) => boolean;\n\n    interface LoDashStatic {\n        /**\n         * This method is like `_.isMatch` except that it accepts `customizer` which\n         * is invoked to compare values. If `customizer` returns `undefined` comparisons\n         * are handled by the method instead. The `customizer` is invoked with three\n         * arguments: (objValue, srcValue, index|key, object, source).\n         *\n         * @category Lang\n         * @param object The object to inspect.\n         * @param source The object of property values to match.\n         * @param [customizer] The function to customize comparisons.\n         * @returns Returns `true` if `object` is a match, else `false`.\n         * @example\n         *\n         * function isGreeting(value) {\n         *   return /^h(?:i|ello)$/.test(value);\n         * }\n         *\n         * function customizer(objValue, srcValue) {\n         *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n         *     return true;\n         *   }\n         * }\n         *\n         * var object = { 'greeting': 'hello' };\n         * var source = { 'greeting': 'hi' };\n         *\n         * _.isMatchWith(object, source, customizer);\n         * // => true\n         */\n        isMatchWith(object: object, source: object, customizer: isMatchWithCustomizer): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isMatchWith\n         */\n        isMatchWith(source: object, customizer: isMatchWithCustomizer): boolean;\n    }\n\n    //_.isNaN\n    interface LoDashStatic {\n        /**\n         * Checks if value is NaN.\n         *\n         * Note: This method is not the same as isNaN which returns true for undefined and other non-numeric values.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is NaN, else false.\n         */\n        isNaN(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isNaN\n         */\n        isNaN(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isNaN\n         */\n        isNaN(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isNative\n    interface LoDashStatic {\n        /**\n         * Checks if value is a native function.\n         * @param value The value to check.\n         *\n         * @retrun Returns true if value is a native function, else false.\n         */\n        isNative(value: any): value is ((...args: any[]) => any) | Function;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isNative\n         */\n        isNative(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isNative\n         */\n        isNative(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isNil\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is `null` or `undefined`.\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is nullish, else `false`.\n         * @example\n         *\n         * _.isNil(null);\n         * // => true\n         *\n         * _.isNil(void 0);\n         * // => true\n         *\n         * _.isNil(NaN);\n         * // => false\n         */\n        isNil(value: any): value is null | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isNil\n         */\n        isNil(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isNil\n         */\n        isNil(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isNull\n    interface LoDashStatic {\n        /**\n         * Checks if value is null.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is null, else false.\n         */\n        isNull(value: any): value is null;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isNull\n         */\n        isNull(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isNull\n         */\n        isNull(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isNumber\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a Number primitive or object.\n         *\n         * Note: To exclude Infinity, -Infinity, and NaN, which are classified as numbers, use the _.isFinite method.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isNumber(value?: any): value is number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isNumber\n         */\n        isNumber(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isNumber\n         */\n        isNumber(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isObject\n    interface LoDashStatic {\n        /**\n         * Checks if value is the language type of Object. (e.g. arrays, functions, objects, regexes, new Number(0),\n         * and new String(''))\n         *\n         * @param value The value to check.\n         * @return Returns true if value is an object, else false.\n         */\n        isObject(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isObject\n         */\n        isObject(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isObject\n         */\n        isObject(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isObjectLike\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is object-like. A value is object-like if it's not `null`\n         * and has a `typeof` result of \"object\".\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is object-like, else `false`.\n         * @example\n         *\n         * _.isObjectLike({});\n         * // => true\n         *\n         * _.isObjectLike([1, 2, 3]);\n         * // => true\n         *\n         * _.isObjectLike(_.noop);\n         * // => false\n         *\n         * _.isObjectLike(null);\n         * // => false\n         */\n        isObjectLike(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isObjectLike\n         */\n        isObjectLike(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isObjectLike\n         */\n        isObjectLike(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isPlainObject\n    interface LoDashStatic {\n        /**\n         * Checks if value is a plain object, that is, an object created by the Object constructor or one with a\n         * [[Prototype]] of null.\n         *\n         * Note: This method assumes objects created by the Object constructor have no inherited enumerable properties.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is a plain object, else false.\n         */\n        isPlainObject(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isPlainObject\n         */\n        isPlainObject(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isPlainObject\n         */\n        isPlainObject(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isRegExp\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a RegExp object.\n         * @param value The value to check.\n         *\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isRegExp(value?: any): value is RegExp;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isRegExp\n         */\n        isRegExp(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isRegExp\n         */\n        isRegExp(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isSafeInteger\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n         * double precision number which isn't the result of a rounded unsafe integer.\n         *\n         * **Note:** This method is based on [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is a safe integer, else `false`.\n         * @example\n         *\n         * _.isSafeInteger(3);\n         * // => true\n         *\n         * _.isSafeInteger(Number.MIN_VALUE);\n         * // => false\n         *\n         * _.isSafeInteger(Infinity);\n         * // => false\n         *\n         * _.isSafeInteger('3');\n         * // => false\n         */\n        isSafeInteger(value: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isSafeInteger\n         */\n        isSafeInteger(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isSafeInteger\n         */\n        isSafeInteger(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isSet\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a Set object.\n         *\n         * @param value The value to check.\n         * @returns Returns true if value is correctly classified, else false.\n         */\n        isSet(value?: any): value is Set<any>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isSet\n         */\n        isSet(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isSet\n         */\n        isSet(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isString\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a String primitive or object.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isString(value?: any): value is string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isString\n         */\n        isString(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isString\n         */\n        isString(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isSymbol\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is classified as a `Symbol` primitive or object.\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is correctly classified, else `false`.\n         * @example\n         *\n         * _.isSymbol(Symbol.iterator);\n         * // => true\n         *\n         * _.isSymbol('abc');\n         * // => false\n         */\n        isSymbol(value: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isSymbol\n         */\n        isSymbol(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isSymbol\n         */\n        isSymbol(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isTypedArray\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a typed array.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isTypedArray(value: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isTypedArray\n         */\n        isTypedArray(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isTypedArray\n         */\n        isTypedArray(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isUndefined\n    interface LoDashStatic {\n        /**\n         * Checks if value is undefined.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is undefined, else false.\n         */\n        isUndefined(value: any): value is undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isUndefined\n         */\n        isUndefined(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isUndefined\n         */\n        isUndefined(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isWeakMap\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a WeakMap object.\n         *\n         * @param value The value to check.\n         * @returns Returns true if value is correctly classified, else false.\n         */\n        isWeakMap(value?: any): value is WeakMap<object, any>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isSet\n         */\n        isWeakMap(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isSet\n         */\n        isWeakMap(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isWeakSet\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a WeakSet object.\n         *\n         * @param value The value to check.\n         * @returns Returns true if value is correctly classified, else false.\n         */\n        isWeakSet(value?: any): value is WeakSet<object>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isWeakSet\n         */\n        isWeakSet(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isWeakSet\n         */\n        isWeakSet(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.lt\n    interface LoDashStatic {\n        /**\n         * Checks if value is less than other.\n         *\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @return Returns true if value is less than other, else false.\n         */\n        lt(\n            value: any,\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.lt\n         */\n        lt(other: any): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.lt\n         */\n        lt(other: any): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.lte\n    interface LoDashStatic {\n        /**\n         * Checks if value is less than or equal to other.\n         *\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @return Returns true if value is less than or equal to other, else false.\n         */\n        lte(\n            value: any,\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.lte\n         */\n        lte(other: any): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.lte\n         */\n        lte(other: any): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.toArray\n    interface LoDashStatic {\n        /**\n         * Converts value to an array.\n         *\n         * @param value The value to convert.\n         * @return Returns the converted array.\n         */\n        toArray<T>(value: List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined): T[];\n\n        /**\n         * @see _.toArray\n         */\n        toArray<T>(value: T): Array<T[keyof T]>;\n\n        /**\n         * @see _.toArray\n         */\n        toArray(): any[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toArray\n         */\n        toArray<T>(this: LoDashImplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.toArray\n         */\n        toArray<T extends object>(this: LoDashImplicitWrapper<T>): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toArray\n         */\n        toArray<T>(this: LoDashExplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.toArray\n         */\n        toArray<T extends object>(this: LoDashImplicitWrapper<T>): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.toPlainObject\n    interface LoDashStatic {\n        /**\n         * Converts value to a plain object flattening inherited enumerable properties of value to own properties\n         * of the plain object.\n         *\n         * @param value The value to convert.\n         * @return Returns the converted plain object.\n         */\n        toPlainObject(value?: any): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPlainObject\n         */\n        toPlainObject(): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPlainObject\n         */\n        toPlainObject(): LoDashExplicitWrapper<any>;\n    }\n\n    //_.toFinite\n    interface LoDashStatic {\n        /**\n         * Converts `value` to a finite number.\n         *\n         * @since 4.12.0\n         * @category Lang\n         * @param value The value to convert.\n         * @returns Returns the converted number.\n         * @example\n         *\n         * _.toFinite(3.2);\n         * // => 3.2\n         *\n         * _.toFinite(Number.MIN_VALUE);\n         * // => 5e-324\n         *\n         * _.toFinite(Infinity);\n         * // => 1.7976931348623157e+308\n         *\n         * _.toFinite('3.2');\n         * // => 3.2\n         */\n        toFinite(value: any): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toFinite\n         */\n        toFinite(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toFinite\n         */\n        toFinite(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.toInteger\n    interface LoDashStatic {\n        /**\n         * Converts `value` to an integer.\n         *\n         * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).\n         *\n         * @category Lang\n         * @param value The value to convert.\n         * @returns Returns the converted integer.\n         * @example\n         *\n         * _.toInteger(3);\n         * // => 3\n         *\n         * _.toInteger(Number.MIN_VALUE);\n         * // => 0\n         *\n         * _.toInteger(Infinity);\n         * // => 1.7976931348623157e+308\n         *\n         * _.toInteger('3');\n         * // => 3\n         */\n        toInteger(value: any): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toInteger\n         */\n        toInteger(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toInteger\n         */\n        toInteger(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.toLength\n    interface LoDashStatic {\n        /**\n         * Converts `value` to an integer suitable for use as the length of an\n         * array-like object.\n         *\n         * **Note:** This method is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n         *\n         * @category Lang\n         * @param value The value to convert.\n         * @return Returns the converted integer.\n         * @example\n         *\n         * _.toLength(3);\n         * // => 3\n         *\n         * _.toLength(Number.MIN_VALUE);\n         * // => 0\n         *\n         * _.toLength(Infinity);\n         * // => 4294967295\n         *\n         * _.toLength('3');\n         * // => 3\n         */\n        toLength(value: any): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toLength\n         */\n        toLength(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toLength\n         */\n        toLength(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.toNumber\n    interface LoDashStatic {\n        /**\n         * Converts `value` to a number.\n         *\n         * @category Lang\n         * @param value The value to process.\n         * @returns Returns the number.\n         * @example\n         *\n         * _.toNumber(3);\n         * // => 3\n         *\n         * _.toNumber(Number.MIN_VALUE);\n         * // => 5e-324\n         *\n         * _.toNumber(Infinity);\n         * // => Infinity\n         *\n         * _.toNumber('3');\n         * // => 3\n         */\n        toNumber(value: any): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toNumber\n         */\n        toNumber(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toNumber\n         */\n        toNumber(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.toSafeInteger\n    interface LoDashStatic {\n        /**\n         * Converts `value` to a safe integer. A safe integer can be compared and\n         * represented correctly.\n         *\n         * @category Lang\n         * @param value The value to convert.\n         * @returns Returns the converted integer.\n         * @example\n         *\n         * _.toSafeInteger(3);\n         * // => 3\n         *\n         * _.toSafeInteger(Number.MIN_VALUE);\n         * // => 0\n         *\n         * _.toSafeInteger(Infinity);\n         * // => 9007199254740991\n         *\n         * _.toSafeInteger('3');\n         * // => 3\n         */\n        toSafeInteger(value: any): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toSafeInteger\n         */\n        toSafeInteger(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toSafeInteger\n         */\n        toSafeInteger(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.toString\n    interface LoDashStatic {\n        /**\n         * Converts `value` to a string if it's not one. An empty string is returned\n         * for `null` and `undefined` values. The sign of `-0` is preserved.\n         *\n         * @category Lang\n         * @param value The value to process.\n         * @returns Returns the string.\n         * @example\n         *\n         * _.toString(null);\n         * // => ''\n         *\n         * _.toString(-0);\n         * // => '-0'\n         *\n         * _.toString([1, 2, 3]);\n         * // => '1,2,3'\n         */\n        toString(value: any): string;\n    }\n\n    /********\n     * Math *\n     ********/\n\n    //_.add\n    interface LoDashStatic {\n        /**\n         * Adds two numbers.\n         *\n         * @param augend The first number to add.\n         * @param addend The second number to add.\n         * @return Returns the sum.\n         */\n        add(\n            augend: number,\n            addend: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.add\n         */\n        add(addend: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.add\n         */\n        add(addend: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.ceil\n    interface LoDashStatic {\n        /**\n         * Calculates n rounded up to precision.\n         *\n         * @param n The number to round up.\n         * @param precision The precision to round up to.\n         * @return Returns the rounded up number.\n         */\n        ceil(\n            n: number,\n            precision?: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.ceil\n         */\n        ceil(precision?: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.ceil\n         */\n        ceil(precision?: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.divide\n    interface LoDashStatic {\n       /**\n        * Divide two numbers.\n        *\n        * @param dividend The first number in a division.\n        * @param divisor The second number in a division.\n        * @returns Returns the quotient.\n        */\n        divide(\n            dividend: number,\n            divisor: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.divide\n         */\n        divide(divisor: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.divide\n         */\n        divide(divisor: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.floor\n    interface LoDashStatic {\n        /**\n         * Calculates n rounded down to precision.\n         *\n         * @param n The number to round down.\n         * @param precision The precision to round down to.\n         * @return Returns the rounded down number.\n         */\n        floor(\n            n: number,\n            precision?: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.floor\n         */\n        floor(precision?: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.floor\n         */\n        floor(precision?: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.max\n    interface LoDashStatic {\n         /**\n          * Computes the maximum value of `array`. If `array` is empty or falsey\n          * `undefined` is returned.\n          *\n          * @category Math\n          * @param array The array to iterate over.\n          * @returns Returns the maximum value.\n          */\n        max<T>(\n            collection: List<T> | null | undefined\n        ): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.max\n         */\n        max<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.max\n         */\n        max<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.maxBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.max` except that it accepts `iteratee` which is\n         * invoked for each element in `array` to generate the criterion by which\n         * the value is ranked. The iteratee is invoked with one argument: (value).\n         *\n         * @category Math\n         * @param array The array to iterate over.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the maximum value.\n         * @example\n         *\n         * var objects = [{ 'n': 1 }, { 'n': 2 }];\n         *\n         * _.maxBy(objects, function(o) { return o.a; });\n         * // => { 'n': 2 }\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.maxBy(objects, 'n');\n         * // => { 'n': 2 }\n         */\n        maxBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ListIteratee<T>\n        ): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.maxBy\n         */\n        maxBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.maxBy\n         */\n        maxBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.mean\n    interface LoDashStatic {\n        /**\n         * Computes the mean of the values in `array`.\n         *\n         * @category Math\n         * @param array The array to iterate over.\n         * @returns Returns the mean.\n         * @example\n         *\n         * _.mean([4, 2, 8, 6]);\n         * // => 5\n         */\n        mean(\n            collection: List<any> | null | undefined\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.mean\n         */\n        mean(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.mean\n         */\n        mean(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.meanBy\n    interface LoDashStatic {\n      /**\n       * Computes the mean of the provided propties of the objects in the `array`\n       *\n       * @category Math\n       * @param array The array to iterate over.\n       * @param [iteratee=_.identity] The iteratee invoked per element.\n       * @returns Returns the mean.\n       * @example\n       *\n       * _.mean([{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }], 'n');\n       * // => 5\n       */\n        meanBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ListIteratee<T>\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.meanBy\n         */\n        meanBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.meanBy\n         */\n        meanBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.min\n    interface LoDashStatic {\n        /**\n         * Computes the minimum value of `array`. If `array` is empty or falsey\n         * `undefined` is returned.\n         *\n         * @category Math\n         * @param array The array to iterate over.\n         * @returns Returns the minimum value.\n         */\n        min<T>(\n            collection: List<T> | null | undefined\n        ): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.min\n         */\n        min<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.min\n         */\n        min<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.minBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.min` except that it accepts `iteratee` which is\n         * invoked for each element in `array` to generate the criterion by which\n         * the value is ranked. The iteratee is invoked with one argument: (value).\n         *\n         * @category Math\n         * @param array The array to iterate over.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the minimum value.\n         * @example\n         *\n         * var objects = [{ 'n': 1 }, { 'n': 2 }];\n         *\n         * _.minBy(objects, function(o) { return o.a; });\n         * // => { 'n': 1 }\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.minBy(objects, 'n');\n         * // => { 'n': 1 }\n         */\n        minBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ListIteratee<T>\n        ): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.minBy\n         */\n        minBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.minBy\n         */\n        minBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.multiply\n    interface LoDashStatic {\n        /**\n         * Multiply two numbers.\n         * @param multiplier The first number in a multiplication.\n         * @param multiplicand The second number in a multiplication.\n         * @returns Returns the product.\n         */\n        multiply(\n            multiplier: number,\n            multiplicand: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.multiply\n         */\n        multiply(multiplicand: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.multiply\n         */\n        multiply(multiplicand: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.round\n    interface LoDashStatic {\n        /**\n         * Calculates n rounded to precision.\n         *\n         * @param n The number to round.\n         * @param precision The precision to round to.\n         * @return Returns the rounded number.\n         */\n        round(\n            n: number,\n            precision?: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.round\n         */\n        round(precision?: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.round\n         */\n        round(precision?: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.sum\n    interface LoDashStatic {\n        /**\n         * Computes the sum of the values in `array`.\n         *\n         * @category Math\n         * @param array The array to iterate over.\n         * @returns Returns the sum.\n         * @example\n         *\n         * _.sum([4, 2, 8, 6]);\n         * // => 20\n         */\n        sum(collection: List<any> | null | undefined): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sum\n         */\n        sum(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sum\n         */\n        sum(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.sumBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.sum` except that it accepts `iteratee` which is\n         * invoked for each element in `array` to generate the value to be summed.\n         * The iteratee is invoked with one argument: (value).\n         *\n         * @category Math\n         * @param array The array to iterate over.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the sum.\n         * @example\n         *\n         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n         *\n         * _.sumBy(objects, function(o) { return o.n; });\n         * // => 20\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.sumBy(objects, 'n');\n         * // => 20\n         */\n        sumBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ((value: T) => number) | string\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sumBy\n         */\n        sumBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ((value: T) => number) | string\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sumBy\n         */\n        sumBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ((value: T) => number) | string\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    /**********\n     * Number *\n     **********/\n\n    //_.subtract\n    interface LoDashStatic {\n        /**\n         * Subtract two numbers.\n         *\n         * @category Math\n         * @param minuend The first number in a subtraction.\n         * @param subtrahend The second number in a subtraction.\n         * @returns Returns the difference.\n         * @example\n         *\n         * _.subtract(6, 4);\n         * // => 2\n         */\n        subtract(\n            minuend: number,\n            subtrahend: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.subtract\n         */\n        subtract(\n            subtrahend: number\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.subtract\n         */\n        subtract(\n            subtrahend: number\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.clamp\n    interface LoDashStatic {\n        /**\n         * Clamps `number` within the inclusive `lower` and `upper` bounds.\n         *\n         * @category Number\n         * @param number The number to clamp.\n         * @param [lower] The lower bound.\n         * @param upper The upper bound.\n         * @returns Returns the clamped number.\n         * @example\n         *\n         * _.clamp(-10, -5, 5);\n         * // => -5\n         *\n         * _.clamp(10, -5, 5);\n         * // => 5\n         */\n        clamp(\n            number: number,\n            lower: number,\n            upper: number\n        ): number;\n        clamp(\n            number: number,\n            upper: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.clamp\n         */\n        clamp(\n            lower: number,\n            upper: number\n        ): number;\n        clamp(\n            upper: number\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.clamp\n         */\n        clamp(\n            lower: number,\n            upper: number\n        ): LoDashExplicitWrapper<number>;\n        clamp(\n            upper: number\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.inRange\n    interface LoDashStatic {\n        /**\n         * Checks if n is between start and up to but not including, end. If end is not specified it’s set to start\n         * with start then set to 0.\n         *\n         * @param n The number to check.\n         * @param start The start of the range.\n         * @param end The end of the range.\n         * @return Returns true if n is in the range, else false.\n         */\n        inRange(\n            n: number,\n            start: number,\n            end?: number\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.inRange\n         */\n        inRange(\n            start: number,\n            end?: number\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.inRange\n         */\n        inRange(\n            start: number,\n            end?: number\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.random\n    interface LoDashStatic {\n        /**\n         * Produces a random number between min and max (inclusive). If only one argument is provided a number between\n         * 0 and the given number is returned. If floating is true, or either min or max are floats, a floating-point\n         * number is returned instead of an integer.\n         *\n         * @param min The minimum possible value.\n         * @param max The maximum possible value.\n         * @param floating Specify returning a floating-point number.\n         * @return Returns the random number.\n         */\n        random(\n            floating?: boolean\n        ): number;\n\n        /**\n         * @see _.random\n         */\n        random(\n            max: number,\n            floating?: boolean\n        ): number;\n\n        /**\n         * @see _.random\n         */\n        random(\n            min: number,\n            max: number,\n            floating?: boolean\n        ): number;\n\n        /**\n         * Produces a random number between min and max (inclusive). If only one argument is provided a number between\n         * 0 and the given number is returned. If floating is true, or either min or max are floats, a floating-point\n         * number is returned instead of an integer.\n         *\n         * @param min The minimum possible value.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns the random number.\n         */\n        random(\n            min: number,\n            index: string | number,\n            guard: object\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.random\n         */\n        random(floating?: boolean): number;\n\n        /**\n         * @see _.random\n         */\n        random(\n            max: number,\n            floating?: boolean\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.random\n         */\n        random(floating?: boolean): LoDashExplicitWrapper<number>;\n\n        /**\n         * @see _.random\n         */\n        random(\n            max: number,\n            floating?: boolean\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    /**********\n     * Object *\n     **********/\n\n    //_.assign\n    interface LoDashStatic {\n        /**\n         * Assigns own enumerable properties of source objects to the destination\n         * object. Source objects are applied from left to right. Subsequent sources\n         * overwrite property assignments of previous sources.\n         *\n         * **Note:** This method mutates `object` and is loosely based on\n         * [`Object.assign`](https://mdn.io/Object/assign).\n         *\n         * @category Object\n         * @param object The destination object.\n         * @param [sources] The source objects.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function Foo() {\n         *   this.c = 3;\n         * }\n         *\n         * function Bar() {\n         *   this.e = 5;\n         * }\n         *\n         * Foo.prototype.d = 4;\n         * Bar.prototype.f = 6;\n         *\n         * _.assign({ 'a': 1 }, new Foo, new Bar);\n         * // => { 'a': 1, 'c': 3, 'e': 5 }\n         */\n        assign<TObject, TSource>(\n            object: TObject,\n            source: TSource\n        ): TObject & TSource;\n\n        /**\n         * @see assign\n         */\n        assign<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see assign\n         */\n        assign<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see assign\n         */\n        assign<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.assign\n         */\n        assign<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.assign\n         */\n        assign(\n            object: any,\n            ...otherArgs: any[]\n        ): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.assign\n         */\n        assign<TSource>(\n            source: TSource\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assign\n         */\n        assign<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assign\n         */\n        assign<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assign\n         */\n        assign<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assign\n         */\n        assign(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.assign\n         */\n        assign(...otherArgs: any[]): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.assign\n         */\n        assign<TSource>(\n            source: TSource\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assign\n         */\n        assign<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assign\n         */\n        assign<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assign\n         */\n        assign<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assign\n         */\n        assign(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.assign\n         */\n        assign(...otherArgs: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    interface LoDashStatic {\n        /**\n         * This method is like `_.assign` except that it accepts `customizer` which\n         * is invoked to produce the assigned values. If `customizer` returns `undefined`\n         * assignment is handled by the method instead. The `customizer` is invoked\n         * with five arguments: (objValue, srcValue, key, object, source).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @category Object\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @param [customizer] The function to customize assigned values.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function customizer(objValue, srcValue) {\n         *   return _.isUndefined(objValue) ? srcValue : objValue;\n         * }\n         *\n         * var defaults = _.partialRight(_.assignWith, customizer);\n         *\n         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n         * // => { 'a': 1, 'b': 2 }\n         */\n        assignWith<TObject, TSource>(\n            object: TObject,\n            source: TSource,\n            customizer: AssignCustomizer\n        ): TObject & TSource;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TResult>(\n            object: any,\n            ...otherArgs: any[]\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TSource>(\n            source: TSource,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignWith\n         */\n        assignWith(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TResult>(...otherArgs: any[]): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TSource>(\n            source: TSource,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignWith\n         */\n        assignWith(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignWith\n         */\n        assignWith(...otherArgs: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.assignIn\n    interface LoDashStatic {\n        /**\n         * This method is like `_.assign` except that it iterates over own and\n         * inherited source properties.\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @alias extend\n         * @category Object\n         * @param object The destination object.\n         * @param [sources] The source objects.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function Foo() {\n         *   this.b = 2;\n         * }\n         *\n         * function Bar() {\n         *   this.d = 4;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         * Bar.prototype.e = 5;\n         *\n         * _.assignIn({ 'a': 1 }, new Foo, new Bar);\n         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }\n         */\n        assignIn<TObject, TSource>(\n            object: TObject,\n            source: TSource\n        ): TObject & TSource;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TResult>(\n            object: any,\n            ...otherArgs: any[]\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TSource>(\n            source: TSource\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignIn\n         */\n        assignIn(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TResult>(...otherArgs: any[]): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TSource>(\n            source: TSource\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignIn\n         */\n        assignIn(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignIn\n         */\n        assignIn(...otherArgs: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.assignInWith\n    type AssignCustomizer = (objectValue: any, sourceValue: any, key?: string, object?: {}, source?: {}) => any;\n\n    interface LoDashStatic {\n        /**\n         * This method is like `_.assignIn` except that it accepts `customizer` which\n         * is invoked to produce the assigned values. If `customizer` returns `undefined`\n         * assignment is handled by the method instead. The `customizer` is invoked\n         * with five arguments: (objValue, srcValue, key, object, source).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @alias extendWith\n         * @category Object\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @param [customizer] The function to customize assigned values.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function customizer(objValue, srcValue) {\n         *   return _.isUndefined(objValue) ? srcValue : objValue;\n         * }\n         *\n         * var defaults = _.partialRight(_.assignInWith, customizer);\n         *\n         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n         * // => { 'a': 1, 'b': 2 }\n         */\n        assignInWith<TObject, TSource>(\n            object: TObject,\n            source: TSource,\n            customizer: AssignCustomizer\n        ): TObject & TSource;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TResult>(\n            object: any,\n            ...otherArgs: any[]\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TSource>(\n            source: TSource,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TResult>(...otherArgs: any[]): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TSource>(\n            source: TSource,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith(...otherArgs: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.create\n    interface LoDashStatic {\n        /**\n         * Creates an object that inherits from the given prototype object. If a properties object is provided its own\n         * enumerable properties are assigned to the created object.\n         *\n         * @param prototype The object to inherit from.\n         * @param properties The properties to assign to the object.\n         * @return Returns the new object.\n         */\n        create<T extends object, U extends object>(\n            prototype: T,\n            properties?: U\n        ): T & U;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.create\n         */\n        create<U extends object>(properties?: U): LoDashImplicitWrapper<TValue & U>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.create\n         */\n        create<U extends object>(properties?: U): LoDashExplicitWrapper<TValue & U>;\n    }\n\n    //_.defaults\n    interface LoDashStatic {\n        /**\n         * Assigns own enumerable properties of source object(s) to the destination object for all destination\n         * properties that resolve to undefined. Once a property is set, additional values of the same property are\n         * ignored.\n         *\n         * Note: This method mutates object.\n         *\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @return The destination object.\n         */\n        defaults<TObject, TSource>(\n            object: TObject,\n            source: TSource\n        ): TSource & TObject;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2\n        ): TSource2 & TSource1 & TObject;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): TSource3 & TSource2 & TSource1 & TObject;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): TSource4 & TSource3 & TSource2 & TSource1 & TObject;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.defaults\n         */\n        defaults(\n            object: any,\n            ...sources: any[]\n        ): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource>(\n            source: TSource\n        ): LoDashImplicitWrapper<TSource & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashImplicitWrapper<TSource2 & TSource1 & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashImplicitWrapper<TSource3 & TSource2 & TSource1 & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashImplicitWrapper<TSource4 & TSource3 & TSource2 & TSource1 & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults(...sources: any[]): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource>(\n            source: TSource\n        ): LoDashExplicitWrapper<TSource & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashExplicitWrapper<TSource2 & TSource1 & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashExplicitWrapper<TSource3 & TSource2 & TSource1 & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashExplicitWrapper<TSource4 & TSource3 & TSource2 & TSource1 & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults(...sources: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.defaultsDeep\n    interface LoDashStatic {\n        /**\n         * This method is like _.defaults except that it recursively assigns default properties.\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @return Returns object.\n         **/\n        defaultsDeep(\n            object: any,\n            ...sources: any[]): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.defaultsDeep\n         **/\n        defaultsDeep(...sources: any[]): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.defaultsDeep\n         **/\n        defaultsDeep(...sources: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.entries\n    interface LoDashStatic {\n        /**\n         * @see _.toPairs\n         */\n        entries<T>(object?: Dictionary<T>): Array<[string, T]>;\n\n        /**\n         * @see _.toPairs\n         */\n        entries(object?: object): Array<[string, any]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPairs\n         */\n        entries<T>(this: LoDashImplicitWrapper<Dictionary<T>>): LoDashImplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairs\n         */\n        entries(): LoDashImplicitWrapper<Array<[string, any]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPairs\n         */\n        entries<T>(this: LoDashExplicitWrapper<Dictionary<T>>): LoDashExplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairs\n         */\n        entries(): LoDashExplicitWrapper<Array<[string, any]>>;\n    }\n\n    //_.entriesIn\n    interface LoDashStatic {\n        /**\n         * @see _.toPairsIn\n         */\n        entriesIn<T>(object?: Dictionary<T>): Array<[string, T]>;\n\n        /**\n         * @see _.toPairsIn\n         */\n        entriesIn(object?: object): Array<[string, any]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPairsIn\n         */\n        entriesIn<T>(this: LoDashImplicitWrapper<Dictionary<T>>): LoDashImplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairsIn\n         */\n        entriesIn(): LoDashImplicitWrapper<Array<[string, any]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPairsIn\n         */\n        entriesIn<T>(this: LoDashExplicitWrapper<Dictionary<T>>): LoDashExplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairsIn\n         */\n        entriesIn(): LoDashExplicitWrapper<Array<[string, any]>>;\n    }\n\n    // _.extend\n    interface LoDashStatic {\n        /**\n         * @see _.assignIn\n         */\n        extend<TObject, TSource>(\n            object: TObject,\n            source: TSource\n        ): TObject & TSource;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TResult>(\n            object: any,\n            ...otherArgs: any[]\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource>(\n            source: TSource\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend(...otherArgs: any[]): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource>(\n            source: TSource\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend(...otherArgs: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    interface LoDashStatic {\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TObject, TSource>(\n            object: TObject,\n            source: TSource,\n            customizer: AssignCustomizer\n        ): TObject & TSource;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TResult>(\n            object: any,\n            ...otherArgs: any[]\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource>(\n            source: TSource,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith(...otherArgs: any[]): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource>(\n            source: TSource,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith(...otherArgs: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.findKey\n    interface LoDashStatic {\n        /**\n         * This method is like _.find except that it returns the key of the first element predicate returns truthy for\n         * instead of the element itself.\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param object The object to search.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the key of the matched element, else undefined.\n         */\n        findKey<T>(\n            object: T | null | undefined,\n            predicate?: ObjectIteratee<T>\n        ): string | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.findKey\n         */\n        findKey<T>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIteratee<T>\n        ): string | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.findKey\n         */\n        findKey<T>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIteratee<T>\n        ): LoDashExplicitWrapper<string | undefined>;\n    }\n\n    //_.findLastKey\n    interface LoDashStatic {\n        /**\n         * This method is like _.findKey except that it iterates over elements of a collection in the opposite order.\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param object The object to search.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the key of the matched element, else undefined.\n         */\n        findLastKey<T>(\n            object: T | null | undefined,\n            predicate?: ObjectIteratee<T>\n        ): string | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.findLastKey\n         */\n        findLastKey<T>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIteratee<T>\n        ): string | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.findLastKey\n         */\n        findLastKey<T>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIteratee<T>\n        ): LoDashExplicitWrapper<string | undefined>;\n    }\n\n    //_.forIn\n    interface LoDashStatic {\n        /**\n         * Iterates over own and inherited enumerable properties of an object invoking iteratee for each property. The\n         * iteratee is bound to thisArg and invoked with three arguments: (value, key, object). Iteratee functions may\n         * exit iteration early by explicitly returning false.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns object.\n         */\n        forIn<T>(\n            object: T,\n            iteratee?: ObjectIterator<T, any>\n        ): T;\n\n        /**\n         * @see _.forIn\n         */\n        forIn<T>(\n            object: T | null | undefined,\n            iteratee?: ObjectIterator<T, any>\n        ): T | null | undefined;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forIn\n         */\n        forIn<T>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.forInRight\n    interface LoDashStatic {\n        /**\n         * This method is like _.forIn except that it iterates over properties of object in the opposite order.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns object.\n         */\n        forInRight<T>(\n            object: T,\n            iteratee?: ObjectIterator<T, any>\n        ): T;\n\n        /**\n         * @see _.forInRight\n         */\n        forInRight<T>(\n            object: T | null | undefined,\n            iteratee?: ObjectIterator<T, any>\n        ): T | null | undefined;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forInRight\n         */\n        forInRight<T>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.forOwn\n    interface LoDashStatic {\n        /**\n         * Iterates over own enumerable properties of an object invoking iteratee for each property. The iteratee is\n         * bound to thisArg and invoked with three arguments: (value, key, object). Iteratee functions may exit\n         * iteration early by explicitly returning false.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns object.\n         */\n        forOwn<T>(\n            object: T,\n            iteratee?: ObjectIterator<T, any>\n        ): T;\n\n        /**\n         * @see _.forOwn\n         */\n        forOwn<T>(\n            object: T | null | undefined,\n            iteratee?: ObjectIterator<T, any>\n        ): T | null | undefined;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forOwn\n         */\n        forOwn<T>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.forOwnRight\n    interface LoDashStatic {\n        /**\n         * This method is like _.forOwn except that it iterates over properties of object in the opposite order.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns object.\n         */\n        forOwnRight<T>(\n            object: T,\n            iteratee?: ObjectIterator<T, any>\n        ): T;\n\n        /**\n         * @see _.forOwnRight\n         */\n        forOwnRight<T>(\n            object: T | null | undefined,\n            iteratee?: ObjectIterator<T, any>\n        ): T | null | undefined;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forOwnRight\n         */\n        forOwnRight<T>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.functions\n    interface LoDashStatic {\n        /**\n         * Creates an array of function property names from own enumerable properties\n         * of `object`.\n         *\n         * @category Object\n         * @param object The object to inspect.\n         * @returns Returns the new array of property names.\n         * @example\n         *\n         * function Foo() {\n         *   this.a = _.constant('a');\n         *   this.b = _.constant('b');\n         * }\n         *\n         * Foo.prototype.c = _.constant('c');\n         *\n         * _.functions(new Foo);\n         * // => ['a', 'b']\n         */\n        functions(object: any): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.functions\n         */\n        functions(): LoDashImplicitWrapper<string[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.functions\n         */\n        functions(): LoDashExplicitWrapper<string[]>;\n    }\n\n    //_.functionsIn\n    interface LoDashStatic {\n        /**\n         * Creates an array of function property names from own and inherited\n         * enumerable properties of `object`.\n         *\n         * @category Object\n         * @param object The object to inspect.\n         * @returns Returns the new array of property names.\n         * @example\n         *\n         * function Foo() {\n         *   this.a = _.constant('a');\n         *   this.b = _.constant('b');\n         * }\n         *\n         * Foo.prototype.c = _.constant('c');\n         *\n         * _.functionsIn(new Foo);\n         * // => ['a', 'b', 'c']\n         */\n        functionsIn<T extends {}>(object: any): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.functionsIn\n         */\n        functionsIn(): LoDashImplicitWrapper<string[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.functionsIn\n         */\n        functionsIn(): LoDashExplicitWrapper<string[]>;\n    }\n\n    //_.get\n    interface LoDashStatic {\n        /**\n         * Gets the property value at path of object. If the resolved value is undefined the defaultValue is used\n         * in its place.\n         *\n         * @param object The object to query.\n         * @param path The path of the property to get.\n         * @param defaultValue The value returned if the resolved value is undefined.\n         * @return Returns the resolved value.\n         */\n        get<TObject extends object, TKey extends keyof TObject>(\n            object: TObject,\n            path: TKey | [TKey]\n        ): TObject[TKey];\n\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject>(\n            object: TObject | null | undefined,\n            path: TKey | [TKey]\n        ): TObject[TKey] | undefined;\n\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject, TDefault>(\n            object: TObject | null | undefined,\n            path: TKey | [TKey],\n            defaultValue: TDefault\n        ): TObject[TKey] | TDefault;\n\n        /**\n         * @see _.get\n         */\n        get<TDefault>(\n            object: null | undefined,\n            path: PropertyPath,\n            defaultValue: TDefault\n        ): TDefault;\n\n        /**\n         * @see _.get\n         */\n        get(\n            object: null | undefined,\n            path: PropertyPath\n        ): undefined;\n\n        /**\n         * @see _.get\n         */\n        get(\n            object: any,\n            path: PropertyPath,\n            defaultValue?: any\n        ): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.get\n         */\n        get<TKey extends keyof TValue>(\n            path: TKey | [TKey]\n        ): TValue[TKey];\n\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject>(\n            this: LoDashImplicitWrapper<TObject | null | undefined>,\n            path: TKey | [TKey],\n        ): TObject[TKey] | undefined;\n\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject, TDefault>(\n            this: LoDashImplicitWrapper<TObject | null | undefined>,\n            path: TKey | [TKey],\n            defaultValue: TDefault\n        ): TObject[TKey] | TDefault;\n\n        /**\n         * @see _.get\n         */\n        get<TDefault>(\n            this: LoDashImplicitWrapper<null | undefined>,\n            path: PropertyPath,\n            defaultValue: TDefault\n        ): TDefault;\n\n        /**\n         * @see _.get\n         */\n        get(\n            this: LoDashImplicitWrapper<null | undefined>,\n            path: PropertyPath\n        ): undefined;\n\n        /**\n         * @see _.get\n         */\n        get<TResult>(\n            path: PropertyPath,\n            defaultValue?: any\n        ): any;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.get\n         */\n        get<TKey extends keyof TValue>(\n            path: TKey | [TKey]\n        ): LoDashExplicitWrapper<TValue[TKey]>;\n\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject>(\n            this: LoDashExplicitWrapper<TObject | null | undefined>,\n            path: TKey | [TKey],\n        ): LoDashExplicitWrapper<TObject[TKey] | undefined>;\n\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject, TDefault>(\n            this: LoDashExplicitWrapper<TObject | null | undefined>,\n            path: TKey | [TKey],\n            defaultValue: TDefault\n        ): LoDashExplicitWrapper<TObject[TKey] | TDefault>;\n\n        /**\n         * @see _.get\n         */\n        get<TDefault>(\n            this: LoDashExplicitWrapper<null | undefined>,\n            path: PropertyPath,\n            defaultValue: TDefault\n        ): LoDashExplicitWrapper<TDefault>;\n\n        /**\n         * @see _.get\n         */\n        get(\n            this: LoDashExplicitWrapper<null | undefined>,\n            path: PropertyPath\n        ): LoDashExplicitWrapper<undefined>;\n\n        /**\n         * @see _.get\n         */\n        get(\n            path: PropertyPath,\n            defaultValue?: any\n        ): LoDashExplicitWrapper<any>;\n    }\n\n    //_.has\n    interface LoDashStatic {\n        /**\n         * Checks if `path` is a direct property of `object`.\n         *\n         * @category Object\n         * @param object The object to query.\n         * @param path The path to check.\n         * @returns Returns `true` if `path` exists, else `false`.\n         * @example\n         *\n         * var object = { 'a': { 'b': { 'c': 3 } } };\n         * var other = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });\n         *\n         * _.has(object, 'a');\n         * // => true\n         *\n         * _.has(object, 'a.b.c');\n         * // => true\n         *\n         * _.has(object, ['a', 'b', 'c']);\n         * // => true\n         *\n         * _.has(other, 'a');\n         * // => false\n         */\n        has<T>(\n            object: T,\n            path: PropertyPath\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.has\n         */\n        has(path: PropertyPath): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.has\n         */\n        has(path: PropertyPath): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.hasIn\n    interface LoDashStatic {\n        /**\n         * Checks if `path` is a direct or inherited property of `object`.\n         *\n         * @category Object\n         * @param object The object to query.\n         * @param path The path to check.\n         * @returns Returns `true` if `path` exists, else `false`.\n         * @example\n         *\n         * var object = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });\n         *\n         * _.hasIn(object, 'a');\n         * // => true\n         *\n         * _.hasIn(object, 'a.b.c');\n         * // => true\n         *\n         * _.hasIn(object, ['a', 'b', 'c']);\n         * // => true\n         *\n         * _.hasIn(object, 'b');\n         * // => false\n         */\n        hasIn<T>(\n            object: T,\n            path: PropertyPath\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.hasIn\n         */\n        hasIn(path: PropertyPath): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.hasIn\n         */\n        hasIn(path: PropertyPath): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.invert\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of the inverted keys and values of object. If object contains duplicate values,\n         * subsequent values overwrite property assignments of previous values unless multiValue is true.\n         *\n         * @param object The object to invert.\n         * @param multiValue Allow multiple values per key.\n         * @return Returns the new inverted object.\n         */\n        invert(\n            object: object\n        ): Dictionary<string>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.invert\n         */\n        invert(): LoDashImplicitWrapper<Dictionary<string>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.invert\n         */\n        invert(): LoDashExplicitWrapper<Dictionary<string>>;\n    }\n\n    //_.invertBy\n    interface LoDashStatic {\n        /**\n         * This method is like _.invert except that the inverted object is generated from the results of running each\n         * element of object through iteratee. The corresponding inverted value of each inverted key is an array of\n         * keys responsible for generating the inverted value. The iteratee is invoked with one argument: (value).\n         *\n         * @param object The object to invert.\n         * @param interatee The iteratee invoked per element.\n         * @return Returns the new inverted object.\n         */\n        invertBy<T>(\n            object: List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined,\n            interatee?: ValueIteratee<T>\n        ): Dictionary<string[]>;\n\n        /**\n         * @see _.invertBy\n         */\n        invertBy<T extends object>(\n            object: T | null | undefined,\n            interatee?: ValueIteratee<T[keyof T]>\n        ): Dictionary<string[]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.invertBy\n         */\n        invertBy<T>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>,\n            interatee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<string[]>>;\n\n        /**\n         * @see _.invertBy\n         */\n        invertBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            interatee?: ValueIteratee<T[keyof T]>\n        ): LoDashImplicitWrapper<Dictionary<string[]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.invertBy\n         */\n        invertBy<T>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>,\n            interatee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<string[]>>;\n\n        /**\n         * @see _.invertBy\n         */\n        invertBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            interatee?: ValueIteratee<T[keyof T]>\n        ): LoDashExplicitWrapper<Dictionary<string[]>>;\n    }\n\n    //_.keys\n    interface LoDashStatic {\n        /**\n         * Creates an array of the own enumerable property names of object.\n         *\n         * Note: Non-object values are coerced to objects. See the ES spec for more details.\n         *\n         * @param object The object to query.\n         * @return Returns the array of property names.\n         */\n        keys(object?: any): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.keys\n         */\n        keys(): LoDashImplicitWrapper<string[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.keys\n         */\n        keys(): LoDashExplicitWrapper<string[]>;\n    }\n\n    //_.keysIn\n    interface LoDashStatic {\n        /**\n         * Creates an array of the own and inherited enumerable property names of object.\n         *\n         * Note: Non-object values are coerced to objects.\n         *\n         * @param object The object to query.\n         * @return An array of property names.\n         */\n        keysIn(object?: any): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.keysIn\n         */\n        keysIn(): LoDashImplicitWrapper<string[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.keysIn\n         */\n        keysIn(): LoDashExplicitWrapper<string[]>;\n    }\n\n    //_.mapKeys\n    interface LoDashStatic {\n        /**\n         * The opposite of _.mapValues; this method creates an object with the same values as object and keys generated\n         * by running each own enumerable property of object through iteratee.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the new mapped object.\n         */\n        mapKeys<T>(\n            object: List<T> | null | undefined,\n            iteratee?: ListIteratee<T>\n        ): Dictionary<T>;\n\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys<T>(\n            object: Dictionary<T> | null | undefined,\n            iteratee?: DictionaryIteratee<T>\n        ): Dictionary<T>;\n\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys(\n            object: object | null | undefined,\n            iteratee?: ObjectIteratee<any>\n        ): Dictionary<any>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys<T>(\n            this: LoDashImplicitWrapper<Dictionary<T> | null | undefined>,\n            iteratee?: DictionaryIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys(\n            this: LoDashImplicitWrapper<object | null | undefined>,\n            iteratee?: ObjectIteratee<any>\n        ): LoDashImplicitWrapper<Dictionary<any>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys<T>(\n            this: LoDashExplicitWrapper<Dictionary<T> | null | undefined>,\n            iteratee?: DictionaryIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys(\n            this: LoDashExplicitWrapper<object | null | undefined>,\n            iteratee?: ObjectIteratee<any>\n        ): LoDashExplicitWrapper<Dictionary<any>>;\n    }\n\n    //_.mapValues\n    interface LoDashStatic {\n        /**\n        * Creates an object with the same keys as object and values generated by running each own\n        * enumerable property of object through iteratee. The iteratee function is bound to thisArg\n        * and invoked with three arguments: (value, key, object).\n        *\n        * If a property name is provided iteratee the created \"_.property\" style callback returns\n        * the property value of the given element.\n        *\n        * If a value is also provided for thisArg the creted \"_.matchesProperty\" style callback returns\n        * true for elements that have a matching property value, else false;.\n        *\n        * If an object is provided for iteratee the created \"_.matches\" style callback returns true\n        * for elements that have the properties of the given object, else false.\n        *\n        * @param object The object to iterate over.\n        * @param [iteratee=_.identity]  The function invoked per iteration.\n        * @param [thisArg] The `this` binding of `iteratee`.\n        * @return Returns the new mapped object.\n        */\n        mapValues<T extends object, TResult>(obj: T | null | undefined, callback: ObjectIterator<T, TResult>): { [P in keyof T]: TResult };\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(obj: T | null | undefined, iteratee: object): { [P in keyof T]: boolean };\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T, TKey extends keyof T>(obj: Dictionary<T> | null | undefined, iteratee: TKey): Dictionary<T[TKey]>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object, TKey extends keyof T>(obj: T | null | undefined, iteratee: string): { [P in keyof T]: any };\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(obj: string | null | undefined, callback: StringIterator<TResult>): NumericDictionary<TResult>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T>(obj: Dictionary<T> | null | undefined): Dictionary<T>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(obj: T): T;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(obj: T | null | undefined): T | {};\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues(obj: string | null | undefined): NumericDictionary<string>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            callback: ObjectIterator<T, TResult>\n        ): LoDashImplicitWrapper<{ [P in keyof T]: TResult }>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee: object\n        ): LoDashImplicitWrapper<{ [P in keyof T]: boolean }>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T, TKey extends keyof T>(\n            this: LoDashImplicitWrapper<Dictionary<T> | null | undefined>,\n            iteratee: TKey\n        ): LoDashImplicitWrapper<Dictionary<T[TKey]>>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object, TKey extends keyof T>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee: string\n        ): LoDashImplicitWrapper<{ [P in keyof T]: any }>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            callback: StringIterator<TResult>\n        ): LoDashImplicitWrapper<NumericDictionary<TResult>>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T>(this: LoDashImplicitWrapper<Dictionary<T> | null | undefined>): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(this: LoDashImplicitWrapper<T>): LoDashImplicitWrapper<T>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(this: LoDashImplicitWrapper<T | null | undefined>): LoDashImplicitWrapper<T | {}>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues(this: LoDashImplicitWrapper<string | null | undefined>): LoDashImplicitWrapper<NumericDictionary<string>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            callback: ObjectIterator<T, TResult>\n        ): LoDashExplicitWrapper<{ [P in keyof T]: TResult }>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee: object\n        ): LoDashExplicitWrapper<{ [P in keyof T]: boolean }>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T, TKey extends keyof T>(\n            this: LoDashExplicitWrapper<Dictionary<T> | null | undefined>,\n            iteratee: TKey\n        ): LoDashExplicitWrapper<Dictionary<T[TKey]>>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object, TKey extends keyof T>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee: string\n        ): LoDashExplicitWrapper<{ [P in keyof T]: any }>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            callback: StringIterator<TResult>\n        ): LoDashExplicitWrapper<NumericDictionary<TResult>>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T>(this: LoDashExplicitWrapper<Dictionary<T> | null | undefined>): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(this: LoDashExplicitWrapper<T>): LoDashExplicitWrapper<T>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(this: LoDashExplicitWrapper<T | null | undefined>): LoDashExplicitWrapper<T | {}>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues(this: LoDashExplicitWrapper<string | null | undefined>): LoDashExplicitWrapper<NumericDictionary<string>>;\n    }\n\n    //_.merge\n    interface LoDashStatic {\n        /**\n         * Recursively merges own and inherited enumerable properties of source\n         * objects into the destination object, skipping source properties that resolve\n         * to `undefined`. Array and plain object properties are merged recursively.\n         * Other objects and value types are overridden by assignment. Source objects\n         * are applied from left to right. Subsequent sources overwrite property\n         * assignments of previous sources.\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @category Object\n         * @param object The destination object.\n         * @param [sources] The source objects.\n         * @returns Returns `object`.\n         * @example\n         *\n         * var users = {\n         *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n         * };\n         *\n         * var ages = {\n         *   'data': [{ 'age': 36 }, { 'age': 40 }]\n         * };\n         *\n         * _.merge(users, ages);\n         * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n         */\n        merge<TObject, TSource>(\n            object: TObject,\n            source: TSource\n        ): TObject & TSource;\n\n        /**\n         * @see _.merge\n         */\n        merge<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see _.merge\n         */\n        merge<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see _.merge\n         */\n        merge<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.merge\n         */\n        merge(\n            object: any,\n            ...otherArgs: any[]\n        ): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.merge\n         */\n        merge<TSource>(\n            source: TSource\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.merge\n         */\n        merge(\n            ...otherArgs: any[]\n        ): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.merge\n         */\n        merge<TSource>(\n            source: TSource\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2, TSource3, TSource4>(\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.merge\n         */\n        merge(\n            ...otherArgs: any[]\n        ): LoDashExplicitWrapper<any>;\n    }\n\n    //_.mergeWith\n    type MergeWithCustomizer = { bivariantHack(value: any, srcValue: any, key: string, object: any, source: any): any; }[\"bivariantHack\"]\n\n    interface LoDashStatic {\n        /**\n         * This method is like `_.merge` except that it accepts `customizer` which\n         * is invoked to produce the merged values of the destination and source\n         * properties. If `customizer` returns `undefined` merging is handled by the\n         * method instead. The `customizer` is invoked with seven arguments:\n         * (objValue, srcValue, key, object, source, stack).\n         *\n         * @category Object\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @param customizer The function to customize assigned values.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function customizer(objValue, srcValue) {\n         *   if (_.isArray(objValue)) {\n         *     return objValue.concat(srcValue);\n         *   }\n         * }\n         *\n         * var object = {\n         *   'fruits': ['apple'],\n         *   'vegetables': ['beet']\n         * };\n         *\n         * var other = {\n         *   'fruits': ['banana'],\n         *   'vegetables': ['carrot']\n         * };\n         *\n         * _.merge(object, other, customizer);\n         * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n         */\n        mergeWith<TObject, TSource>(\n            object: TObject,\n            source: TSource,\n            customizer: MergeWithCustomizer\n        ): TObject & TSource;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            customizer: MergeWithCustomizer\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: MergeWithCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: MergeWithCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith(\n            object: any,\n            ...otherArgs: any[]\n        ): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource>(\n            source: TSource,\n            customizer: MergeWithCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: MergeWithCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: MergeWithCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: MergeWithCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith(\n            ...otherArgs: any[]\n        ): LoDashImplicitWrapper<any>;\n    }\n\n    //_.omit\n    interface LoDashStatic {\n        /**\n         * The opposite of `_.pick`; this method creates an object composed of the\n         * own and inherited enumerable properties of `object` that are not omitted.\n         *\n         * @category Object\n         * @param object The source object.\n         * @param [paths] The property names to omit, specified\n         *  individually or in arrays..\n         * @returns Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.omit(object, ['a', 'c']);\n         * // => { 'b': '2' }\n         */\n        omit<T>(\n            object: Dictionary<T>,\n            ...paths: PropertyPath[]\n        ): Dictionary<T>;\n\n        /**\n         * @see _.omit\n         */\n        omit<T extends object>(\n            object: T | null | undefined,\n            ...paths: PropertyPath[]\n        ): PartialObject<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.omit\n         */\n        omit<T>(\n            this: LoDashImplicitWrapper<Dictionary<T>>,\n            ...paths: PropertyPath[]\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.omit\n         */\n        omit<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            ...paths: PropertyPath[]\n        ): LoDashImplicitWrapper<PartialObject<T>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.omit\n         */\n        omit<T>(\n            this: LoDashExplicitWrapper<Dictionary<T>>,\n            ...paths: PropertyPath[]\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.omit\n         */\n        omit<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            ...paths: PropertyPath[]\n        ): LoDashExplicitWrapper<PartialObject<T>>;\n    }\n\n    //_.omitBy\n    interface LoDashStatic {\n        /**\n         * The opposite of `_.pickBy`; this method creates an object composed of the\n         * own and inherited enumerable properties of `object` that `predicate`\n         * doesn't return truthy for.\n         *\n         * @category Object\n         * @param object The source object.\n         * @param [predicate=_.identity] The function invoked per property.\n         * @returns Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.omitBy(object, _.isNumber);\n         * // => { 'b': '2' }\n         */\n        omitBy<T extends object>(\n            object: T | null | undefined,\n            predicate: ValueKeyIteratee<T[keyof T]>\n        ): PartialObject<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.omitBy\n         */\n        omitBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate: ValueKeyIteratee<T[keyof T]>\n        ): LoDashImplicitWrapper<PartialObject<T>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.omitBy\n         */\n        omitBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate: ValueKeyIteratee<T[keyof T]>\n        ): LoDashExplicitWrapper<PartialObject<T>>;\n    }\n\n    //_.pick\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of the picked `object` properties.\n         *\n         * @category Object\n         * @param object The source object.\n         * @param [props] The property names to pick, specified\n         *  individually or in arrays.\n         * @returns Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.pick(object, ['a', 'c']);\n         * // => { 'a': 1, 'c': 3 }\n         */\n        pick<T extends object, U extends keyof T>(\n            object: T,\n             ...props: Array<Many<U>>\n        ): Pick<T, U>;\n\n        /**\n         * @see _.pick\n         */\n        pick<T>(\n            object: T | null | undefined,\n            ...props: PropertyPath[]\n        ): PartialDeep<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.pick\n         */\n        pick<T extends object, U extends keyof T>(\n            this: LoDashImplicitWrapper<T>,\n            ...props: Array<Many<U>>\n        ): LoDashImplicitWrapper<Pick<T, U>>;\n\n        /**\n         * @see _.pick\n         */\n        pick<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            ...props: PropertyPath[]\n        ): LoDashImplicitWrapper<PartialObject<T>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.pick\n         */\n        pick<T extends object, U extends keyof T>(\n            this: LoDashExplicitWrapper<T>,\n            ...props: Array<Many<U>>\n        ): LoDashExplicitWrapper<Pick<T, U>>;\n\n        /**\n         * @see _.pick\n         */\n        pick<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            ...props: PropertyPath[]\n        ): LoDashExplicitWrapper<PartialObject<T>>;\n    }\n\n    //_.pickBy\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of the `object` properties `predicate` returns\n         * truthy for. The predicate is invoked with two arguments: (value, key).\n         *\n         * @category Object\n         * @param object The source object.\n         * @param [predicate=_.identity] The function invoked per property.\n         * @returns Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.pickBy(object, _.isNumber);\n         * // => { 'a': 1, 'c': 3 }\n         */\n        pickBy<T extends object>(\n            object: T | null | undefined,\n            predicate?: ValueKeyIteratee<T[keyof T]>\n        ): PartialObject<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.pickBy\n         */\n        pickBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ValueKeyIteratee<T[keyof T]>\n        ): LoDashImplicitWrapper<PartialObject<T>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.pickBy\n         */\n        pickBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ValueKeyIteratee<T[keyof T]>\n        ): LoDashExplicitWrapper<PartialObject<T>>;\n    }\n\n    //_.result\n    interface LoDashStatic {\n        /**\n         * This method is like _.get except that if the resolved value is a function it’s invoked with the this binding\n         * of its parent object and its result is returned.\n         *\n         * @param object The object to query.\n         * @param path The path of the property to resolve.\n         * @param defaultValue The value returned if the resolved value is undefined.\n         * @return Returns the resolved value.\n         */\n        result<TResult>(\n            object: any,\n            path: PropertyPath,\n            defaultValue?: TResult|((...args: any[]) => TResult)\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.result\n         */\n        result<TResult>(\n            path: PropertyPath,\n            defaultValue?: TResult|((...args: any[]) => TResult)\n        ): TResult;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.result\n         */\n        result<TResult>(\n            path: PropertyPath,\n            defaultValue?: TResult|((...args: any[]) => TResult)\n        ): LoDashExplicitWrapper<TResult>;\n    }\n\n    //_.set\n    interface LoDashStatic {\n        /**\n         * Sets the value at path of object. If a portion of path doesn’t exist it’s created. Arrays are created for\n         * missing index properties while objects are created for all other missing properties. Use _.setWith to\n         * customize path creation.\n         *\n         * @param object The object to modify.\n         * @param path The path of the property to set.\n         * @param value The value to set.\n         * @return Returns object.\n         */\n        set<T extends object>(\n            object: T,\n            path: PropertyPath,\n            value: any\n        ): T;\n\n        /**\n         * @see _.set\n         */\n        set<TResult>(\n            object: object,\n            path: PropertyPath,\n            value: any\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.set\n         */\n        set(\n            path: PropertyPath,\n            value: any\n        ): this;\n\n        /**\n         * @see _.set\n         */\n        set<TResult>(\n            path: PropertyPath,\n            value: any\n        ): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.set\n         */\n        set(\n            path: PropertyPath,\n            value: any\n        ): this;\n\n        /**\n         * @see _.set\n         */\n        set<TResult>(\n            path: PropertyPath,\n            value: any\n        ): LoDashExplicitWrapper<TResult>;\n    }\n\n    //_.setWith\n    type SetWithCustomizer<T> = (nsValue: any, key: string, nsObject: T) => any;\n\n    interface LoDashStatic {\n        /**\n         * This method is like _.set except that it accepts customizer which is invoked to produce the objects of\n         * path. If customizer returns undefined path creation is handled by the method instead. The customizer is\n         * invoked with three arguments: (nsValue, key, nsObject).\n         *\n         * @param object The object to modify.\n         * @param path The path of the property to set.\n         * @param value The value to set.\n         * @parem customizer The function to customize assigned values.\n         * @return Returns object.\n         */\n        setWith<T extends object>(\n            object: T,\n            path: PropertyPath,\n            value: any,\n            customizer?: SetWithCustomizer<T>\n        ): T;\n\n        setWith<T extends object, TResult>(\n            object: T,\n            path: PropertyPath,\n            value: any,\n            customizer?: SetWithCustomizer<T>\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.setWith\n         */\n        setWith(\n            path: PropertyPath,\n            value: any,\n            customizer?: SetWithCustomizer<TValue>\n        ): this;\n\n        /**\n         * @see _.setWith\n         */\n        setWith<TResult>(\n            path: PropertyPath,\n            value: any,\n            customizer?: SetWithCustomizer<TValue>\n        ): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.setWith\n         */\n        setWith(\n            path: PropertyPath,\n            value: any,\n            customizer?: SetWithCustomizer<TValue>\n        ): this;\n\n        /**\n         * @see _.setWith\n         */\n        setWith<TResult>(\n            path: PropertyPath,\n            value: any,\n            customizer?: SetWithCustomizer<TValue>\n        ): LoDashExplicitWrapper<TResult>;\n    }\n\n    //_.toPairs\n    interface LoDashStatic {\n        /**\n         * Creates an array of own enumerable key-value pairs for object.\n         *\n         * @param object The object to query.\n         * @return Returns the new array of key-value pairs.\n         */\n        toPairs<T>(object?: Dictionary<T>): Array<[string, T]>;\n\n        /**\n         * @see _.toPairs\n         */\n        toPairs(object?: object): Array<[string, any]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPairs\n         */\n        toPairs<T>(this: LoDashImplicitWrapper<Dictionary<T>>): LoDashImplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairs\n         */\n        toPairs(): LoDashImplicitWrapper<Array<[string, any]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPairs\n         */\n        toPairs<T>(this: LoDashExplicitWrapper<Dictionary<T>>): LoDashExplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairs\n         */\n        toPairs(): LoDashExplicitWrapper<Array<[string, any]>>;\n    }\n\n    //_.toPairsIn\n    interface LoDashStatic {\n        /**\n         * Creates an array of own and inherited enumerable key-value pairs for object.\n         *\n         * @param object The object to query.\n         * @return Returns the new array of key-value pairs.\n         */\n        toPairsIn<T>(object?: Dictionary<T>): Array<[string, T]>;\n\n        /**\n         * @see _.toPairsIn\n         */\n        toPairsIn(object?: object): Array<[string, any]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPairsIn\n         */\n        toPairsIn<T>(this: LoDashImplicitWrapper<Dictionary<T>>): LoDashImplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairsIn\n         */\n        toPairsIn(): LoDashImplicitWrapper<Array<[string, any]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPairsIn\n         */\n        toPairsIn<T>(this: LoDashExplicitWrapper<Dictionary<T>>): LoDashExplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairsIn\n         */\n        toPairsIn(): LoDashExplicitWrapper<Array<[string, any]>>;\n    }\n\n    //_.transform\n    interface LoDashStatic {\n        /**\n         * An alternative to _.reduce; this method transforms object to a new accumulator object which is the result of\n         * running each of its own enumerable properties through iteratee, with each invocation potentially mutating\n         * the accumulator object. The iteratee is bound to thisArg and invoked with four arguments: (accumulator,\n         * value, key, object). Iteratee functions may exit iteration early by explicitly returning false.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param accumulator The custom accumulator value.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the accumulated value.\n         */\n        transform<T, TResult>(\n            object: T[],\n            iteratee: MemoVoidArrayIterator<T, TResult[]>,\n            accumulator?: TResult[]\n        ): TResult[];\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            object: T[],\n            iteratee: MemoVoidArrayIterator<T, Dictionary<TResult>>,\n            accumulator: Dictionary<TResult>\n        ): Dictionary<TResult>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            object: Dictionary<T>,\n            iteratee: MemoVoidDictionaryIterator<T, Dictionary<TResult>>,\n            accumulator?: Dictionary<TResult>\n        ): Dictionary<TResult>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            object: Dictionary<T>,\n            iteratee: MemoVoidDictionaryIterator<T, TResult[]>,\n            accumulator: TResult[]\n        ): TResult[];\n\n        /**\n         * @see _.transform\n         */\n        transform(\n            object: any[],\n        ): any[];\n\n        /**\n         * @see _.transform\n         */\n        transform(\n            object: object,\n        ): Dictionary<any>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashImplicitWrapper<T[]>,\n            iteratee: MemoVoidArrayIterator<T, TResult[]>,\n            accumulator?: TResult[]\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashImplicitWrapper<T[]>,\n            iteratee: MemoVoidArrayIterator<T, Dictionary<TResult>>,\n            accumulator: Dictionary<TResult>\n        ): LoDashImplicitWrapper<Dictionary<TResult>>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashImplicitWrapper<Dictionary<T>>,\n            iteratee: MemoVoidDictionaryIterator<T, Dictionary<TResult>>,\n            accumulator?: Dictionary<TResult>\n        ): LoDashImplicitWrapper<Dictionary<TResult>>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashImplicitWrapper<Dictionary<T>>,\n            iteratee: MemoVoidDictionaryIterator<T, TResult[]>,\n            accumulator: TResult[]\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.transform\n         */\n        transform(\n            this: LoDashImplicitWrapper<any[]>,\n        ): LoDashImplicitWrapper<any[]>;\n\n        /**\n         * @see _.transform\n         */\n        transform(): LoDashImplicitWrapper<Dictionary<any>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashExplicitWrapper<T[]>,\n            iteratee: MemoVoidArrayIterator<T, TResult[]>,\n            accumulator?: TResult[]\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashExplicitWrapper<T[]>,\n            iteratee: MemoVoidArrayIterator<T, Dictionary<TResult>>,\n            accumulator?: Dictionary<TResult>\n        ): LoDashExplicitWrapper<Dictionary<TResult>>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashExplicitWrapper<Dictionary<T>>,\n            iteratee: MemoVoidDictionaryIterator<T, Dictionary<TResult>>,\n            accumulator?: Dictionary<TResult>\n        ): LoDashExplicitWrapper<Dictionary<TResult>>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashExplicitWrapper<Dictionary<T>>,\n            iteratee: MemoVoidDictionaryIterator<T, TResult[]>,\n            accumulator?: TResult[]\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.transform\n         */\n        transform(\n            this: LoDashExplicitWrapper<any[]>,\n        ): LoDashExplicitWrapper<any[]>;\n\n        /**\n         * @see _.transform\n         */\n        transform(): LoDashExplicitWrapper<Dictionary<any>>;\n    }\n\n    //_.unset\n    interface LoDashStatic {\n        /**\n         * Removes the property at path of object.\n         *\n         * Note: This method mutates object.\n         *\n         * @param object The object to modify.\n         * @param path The path of the property to unset.\n         * @return Returns true if the property is deleted, else false.\n         */\n        unset(\n            object: any,\n            path: PropertyPath\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unset\n         */\n        unset(path: PropertyPath): LoDashImplicitWrapper<boolean>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unset\n         */\n        unset(path: PropertyPath): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.update\n    interface LoDashStatic {\n        /**\n         * This method is like _.set except that accepts updater to produce the value to set. Use _.updateWith to\n         * customize path creation. The updater is invoked with one argument: (value).\n         *\n         * @param object The object to modify.\n         * @param path The path of the property to set.\n         * @param updater The function to produce the updated value.\n         * @return Returns object.\n         */\n        update(\n            object: object,\n            path: PropertyPath,\n            updater: (value: any) => any\n        ): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.update\n         */\n        update(\n            path: PropertyPath,\n            updater: (value: any) => any\n        ): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.update\n         */\n        update(\n            path: PropertyPath,\n            updater: (value: any) => any\n        ): LoDashExplicitWrapper<any>;\n    }\n\n    //_.updateWith\n    interface LoDashStatic {\n        /**\n         * This method is like `_.update` except that it accepts `customizer` which is\n         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n         * path creation is handled by the method instead. The `customizer` is invoked\n         * with three arguments: (nsValue, key, nsObject).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @since 4.6.0\n         * @category Object\n         * @param object The object to modify.\n         * @param path The path of the property to set.\n         * @param updater The function to produce the updated value.\n         * @param [customizer] The function to customize assigned values.\n         * @returns Returns `object`.\n         * @example\n         *\n         * var object = {};\n         *\n         * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n         * // => { '0': { '1': 'a' } }\n         */\n        updateWith<T extends object>(\n            object: T,\n            path: PropertyPath,\n            updater: (oldValue: any) => any,\n            customizer?: SetWithCustomizer<T>\n        ): T;\n\n        /**\n         * @see _.updateWith\n         */\n        updateWith<T extends object, TResult>(\n            object: T,\n            path: PropertyPath,\n            updater: (oldValue: any) => any,\n            customizer?: SetWithCustomizer<T>\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.updateWith\n         */\n        updateWith(\n            path: PropertyPath,\n            updater: (oldValue: any) => any,\n            customizer?: SetWithCustomizer<TValue>\n        ): this;\n\n        /**\n         * @see _.updateWith\n         */\n        updateWith<TResult>(\n            path: PropertyPath,\n            updater: (oldValue: any) => any,\n            customizer?: SetWithCustomizer<TValue>\n        ): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.updateWith\n         */\n        updateWith(\n            path: PropertyPath,\n            updater: (oldValue: any) => any,\n            customizer?: SetWithCustomizer<TValue>\n        ): this;\n\n        /**\n         * @see _.updateWith\n         */\n        updateWith<TResult>(\n            path: PropertyPath,\n            updater: (oldValue: any) => any,\n            customizer?: SetWithCustomizer<TValue>\n        ): LoDashExplicitWrapper<TResult>;\n    }\n\n    //_.values\n    interface LoDashStatic {\n        /**\n         * Creates an array of the own enumerable property values of object.\n         *\n         * @param object The object to query.\n         * @return Returns an array of property values.\n         */\n        values<T>(object: Dictionary<T>|NumericDictionary<T>|List<T> | null | undefined): T[];\n\n        /**\n         * @see _.values\n         */\n        values<T extends object>(object: T | null | undefined): Array<T[keyof T]>;\n\n        /**\n         * @see _.values\n         */\n        values(object: any): any[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.values\n         */\n        values<T>(this: LoDashImplicitWrapper<Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.values\n         */\n        values<T extends object>(this: LoDashImplicitWrapper<T | null | undefined>): LoDashImplicitWrapper<Array<T[keyof T]>>;\n\n        /**\n         * @see _.values\n         */\n        values(): LoDashImplicitWrapper<any[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.values\n         */\n        values<T>(this: LoDashExplicitWrapper<Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.values\n         */\n        values<T extends object>(this: LoDashExplicitWrapper<T | null | undefined>): LoDashExplicitWrapper<Array<T[keyof T]>>;\n\n        /**\n         * @see _.values\n         */\n        values(): LoDashExplicitWrapper<any[]>;\n    }\n\n    //_.valuesIn\n    interface LoDashStatic {\n        /**\n         * Creates an array of the own and inherited enumerable property values of object.\n         *\n         * @param object The object to query.\n         * @return Returns the array of property values.\n         */\n        valuesIn<T>(object: Dictionary<T>|NumericDictionary<T>|List<T> | null | undefined): T[];\n\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn<T extends object>(object: T | null | undefined): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn<T>(this: LoDashImplicitWrapper<Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn<T extends object>(this: LoDashImplicitWrapper<T | null | undefined>): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn<T>(this: LoDashExplicitWrapper<Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn<T extends object>(this: LoDashExplicitWrapper<T | null | undefined>): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    /**********\n     * String *\n     **********/\n\n    //_.camelCase\n    interface LoDashStatic {\n        /**\n         * Converts string to camel case.\n         *\n         * @param string The string to convert.\n         * @return Returns the camel cased string.\n         */\n        camelCase(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.camelCase\n         */\n        camelCase(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.camelCase\n         */\n        camelCase(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.capitalize\n    interface LoDashStatic {\n        /**\n         * Converts the first character of string to upper case and the remaining to lower case.\n         *\n         * @param string The string to capitalize.\n         * @return Returns the capitalized string.\n         */\n        capitalize(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.capitalize\n         */\n        capitalize(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.capitalize\n         */\n        capitalize(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.deburr\n    interface LoDashStatic {\n        /**\n         * Deburrs string by converting latin-1 supplementary letters to basic latin letters and removing combining\n         * diacritical marks.\n         *\n         * @param string The string to deburr.\n         * @return Returns the deburred string.\n         */\n        deburr(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.deburr\n         */\n        deburr(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.deburr\n         */\n        deburr(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.endsWith\n    interface LoDashStatic {\n        /**\n         * Checks if string ends with the given target string.\n         *\n         * @param string The string to search.\n         * @param target The string to search for.\n         * @param position The position to search from.\n         * @return Returns true if string ends with target, else false.\n         */\n        endsWith(\n            string?: string,\n            target?: string,\n            position?: number\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.endsWith\n         */\n        endsWith(\n            target?: string,\n            position?: number\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.endsWith\n         */\n        endsWith(\n            target?: string,\n            position?: number\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    // _.escape\n    interface LoDashStatic {\n        /**\n         * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"`\" in string to their corresponding HTML entities.\n         *\n         * Note: No other characters are escaped. To escape additional characters use a third-party library like he.\n         *\n         * hough the \">\" character is escaped for symmetry, characters like \">\" and \"/\" don’t need escaping in HTML\n         * and have no special meaning unless they're part of a tag or unquoted attribute value. See Mathias Bynens’s\n         * article (under \"semi-related fun fact\") for more details.\n         *\n         * Backticks are escaped because in IE < 9, they can break out of attribute values or HTML comments. See #59,\n         * #102, #108, and #133 of the HTML5 Security Cheatsheet for more details.\n         *\n         * When working with HTML you should always quote attribute values to reduce XSS vectors.\n         *\n         * @param string The string to escape.\n         * @return Returns the escaped string.\n         */\n        escape(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.escape\n         */\n        escape(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.escape\n         */\n        escape(): LoDashExplicitWrapper<string>;\n    }\n\n    // _.escapeRegExp\n    interface LoDashStatic {\n        /**\n         * Escapes the RegExp special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\", \"?\", \"(\", \")\", \"[\", \"]\",\n         * \"{\", \"}\", and \"|\" in string.\n         *\n         * @param string The string to escape.\n         * @return Returns the escaped string.\n         */\n        escapeRegExp(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.escapeRegExp\n         */\n        escapeRegExp(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.escapeRegExp\n         */\n        escapeRegExp(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.kebabCase\n    interface LoDashStatic {\n        /**\n         * Converts string to kebab case.\n         *\n         * @param string The string to convert.\n         * @return Returns the kebab cased string.\n         */\n        kebabCase(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.kebabCase\n         */\n        kebabCase(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.kebabCase\n         */\n        kebabCase(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.lowerCase\n    interface LoDashStatic {\n        /**\n         * Converts `string`, as space separated words, to lower case.\n         *\n         * @param string The string to convert.\n         * @return Returns the lower cased string.\n         */\n        lowerCase(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.lowerCase\n         */\n        lowerCase(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.lowerCase\n         */\n        lowerCase(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.lowerFirst\n    interface LoDashStatic {\n        /**\n         * Converts the first character of `string` to lower case.\n         *\n         * @param string The string to convert.\n         * @return Returns the converted string.\n         */\n        lowerFirst(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.lowerFirst\n         */\n        lowerFirst(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.lowerFirst\n         */\n        lowerFirst(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.pad\n    interface LoDashStatic {\n        /**\n         * Pads string on the left and right sides if it’s shorter than length. Padding characters are truncated if\n         * they can’t be evenly divided by length.\n         *\n         * @param string The string to pad.\n         * @param length The padding length.\n         * @param chars The string used as padding.\n         * @return Returns the padded string.\n         */\n        pad(\n            string?: string,\n            length?: number,\n            chars?: string\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.pad\n         */\n        pad(\n            length?: number,\n            chars?: string\n        ): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.pad\n         */\n        pad(\n            length?: number,\n            chars?: string\n        ): LoDashExplicitWrapper<string>;\n    }\n\n    //_.padEnd\n    interface LoDashStatic {\n        /**\n         * Pads string on the right side if it’s shorter than length. Padding characters are truncated if they exceed\n         * length.\n         *\n         * @param string The string to pad.\n         * @param length The padding length.\n         * @param chars The string used as padding.\n         * @return Returns the padded string.\n         */\n        padEnd(\n            string?: string,\n            length?: number,\n            chars?: string\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.padEnd\n         */\n        padEnd(\n            length?: number,\n            chars?: string\n        ): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.padEnd\n         */\n        padEnd(\n            length?: number,\n            chars?: string\n        ): LoDashExplicitWrapper<string>;\n    }\n\n    //_.padStart\n    interface LoDashStatic {\n        /**\n         * Pads string on the left side if it’s shorter than length. Padding characters are truncated if they exceed\n         * length.\n         *\n         * @param string The string to pad.\n         * @param length The padding length.\n         * @param chars The string used as padding.\n         * @return Returns the padded string.\n         */\n        padStart(\n            string?: string,\n            length?: number,\n            chars?: string\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.padStart\n         */\n        padStart(\n            length?: number,\n            chars?: string\n        ): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.padStart\n         */\n        padStart(\n            length?: number,\n            chars?: string\n        ): LoDashExplicitWrapper<string>;\n    }\n\n    //_.parseInt\n    interface LoDashStatic {\n        /**\n         * Converts string to an integer of the specified radix. If radix is undefined or 0, a radix of 10 is used\n         * unless value is a hexadecimal, in which case a radix of 16 is used.\n         *\n         * Note: This method aligns with the ES5 implementation of parseInt.\n         *\n         * @param string The string to convert.\n         * @param radix The radix to interpret value by.\n         * @return Returns the converted integer.\n         */\n        parseInt(\n            string: string,\n            radix?: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.parseInt\n         */\n        parseInt(radix?: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.parseInt\n         */\n        parseInt(radix?: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.repeat\n    interface LoDashStatic {\n        /**\n         * Repeats the given string n times.\n         *\n         * @param string The string to repeat.\n         * @param n The number of times to repeat the string.\n         * @return Returns the repeated string.\n         */\n        repeat(\n            string?: string,\n            n?: number\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.repeat\n         */\n        repeat(n?: number): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.repeat\n         */\n        repeat(n?: number): LoDashExplicitWrapper<string>;\n    }\n\n    type ReplaceFunction = (match: string, ...args: any[]) => string;\n\n    //_.replace\n    interface LoDashStatic {\n        /**\n         * Replaces matches for pattern in string with replacement.\n         *\n         * Note: This method is based on String#replace.\n         *\n         * @return Returns the modified string.\n         */\n        replace(\n            string: string,\n            pattern: RegExp | string,\n            replacement: ReplaceFunction | string\n        ): string;\n\n        /**\n         * @see _.replace\n         */\n        replace(\n            pattern: RegExp | string,\n            replacement: ReplaceFunction | string\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.replace\n         */\n        replace(\n            pattern: RegExp|string,\n            replacement: ReplaceFunction | string\n        ): string;\n\n        /**\n         * @see _.replace\n         */\n        replace(\n            replacement: ReplaceFunction | string\n        ): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.replace\n         */\n        replace(\n            pattern: RegExp | string,\n            replacement: ReplaceFunction | string\n        ): LoDashExplicitWrapper<string>;\n\n        /**\n         * @see _.replace\n         */\n        replace(\n            replacement: ReplaceFunction | string\n        ): LoDashExplicitWrapper<string>;\n    }\n\n    //_.snakeCase\n    interface LoDashStatic {\n        /**\n         * Converts string to snake case.\n         *\n         * @param string The string to convert.\n         * @return Returns the snake cased string.\n         */\n        snakeCase(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.snakeCase\n         */\n        snakeCase(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.snakeCase\n         */\n        snakeCase(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.split\n    interface LoDashStatic {\n        /**\n         * Splits string by separator.\n         *\n         * Note: This method is based on String#split.\n         *\n         * @param string The string to trim.\n         * @param separator The separator pattern to split by.\n         * @param limit The length to truncate results to.\n         * @return Returns the new array of string segments.\n         */\n        split(\n            string: string,\n            separator?: RegExp|string,\n            limit?: number\n        ): string[];\n\n        /**\n         * Splits string by separator.\n         *\n         * Note: This method is based on String#split.\n         *\n         * @param string The string to trim.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns the new array of string segments.\n         */\n        split(\n            string: string,\n            index: string | number,\n            guard: object\n        ): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.split\n         */\n        split(\n            separator?: RegExp|string,\n            limit?: number\n        ): LoDashImplicitWrapper<string[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.split\n         */\n        split(\n            separator?: RegExp|string,\n            limit?: number\n        ): LoDashExplicitWrapper<string[]>;\n    }\n\n    //_.startCase\n    interface LoDashStatic {\n        /**\n         * Converts string to start case.\n         *\n         * @param string The string to convert.\n         * @return Returns the start cased string.\n         */\n        startCase(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.startCase\n         */\n        startCase(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.startCase\n         */\n        startCase(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.startsWith\n    interface LoDashStatic {\n        /**\n         * Checks if string starts with the given target string.\n         *\n         * @param string The string to search.\n         * @param target The string to search for.\n         * @param position The position to search from.\n         * @return Returns true if string starts with target, else false.\n         */\n        startsWith(\n            string?: string,\n            target?: string,\n            position?: number\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.startsWith\n         */\n        startsWith(\n            target?: string,\n            position?: number\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.startsWith\n         */\n        startsWith(\n            target?: string,\n            position?: number\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.template\n    interface TemplateOptions extends TemplateSettings {\n        /**\n         * The sourceURL of the template's compiled source.\n         */\n        sourceURL?: string;\n    }\n\n    interface TemplateExecutor {\n        (data?: object): string;\n        source: string;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a compiled template function that can interpolate data properties in \"interpolate\" delimiters,\n         * HTML-escape interpolated data properties in \"escape\" delimiters, and execute JavaScript in \"evaluate\"\n         * delimiters. Data properties may be accessed as free variables in the template. If a setting object is\n         * provided it takes precedence over _.templateSettings values.\n         *\n         * Note: In the development build _.template utilizes\n         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) for easier\n         * debugging.\n         *\n         * For more information on precompiling templates see\n         * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n         *\n         * For more information on Chrome extension sandboxes see\n         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n         *\n         * @param string The template string.\n         * @param options The options object.\n         * @param options.escape The HTML \"escape\" delimiter.\n         * @param options.evaluate The \"evaluate\" delimiter.\n         * @param options.imports An object to import into the template as free variables.\n         * @param options.interpolate The \"interpolate\" delimiter.\n         * @param options.sourceURL The sourceURL of the template's compiled source.\n         * @param options.variable The data object variable name.\n         * @return Returns the compiled template function.\n         */\n        template(\n            string?: string,\n            options?: TemplateOptions\n        ): TemplateExecutor;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.template\n         */\n        template(options?: TemplateOptions): TemplateExecutor;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.template\n         */\n        template(options?: TemplateOptions): LoDashExplicitWrapper<TemplateExecutor>;\n    }\n\n    //_.toLower\n    interface LoDashStatic {\n        /**\n         * Converts `string`, as a whole, to lower case.\n         *\n         * @param string The string to convert.\n         * @return Returns the lower cased string.\n         */\n        toLower(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toLower\n         */\n        toLower(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toLower\n         */\n        toLower(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.toUpper\n    interface LoDashStatic {\n        /**\n         * Converts `string`, as a whole, to upper case.\n         *\n         * @param string The string to convert.\n         * @return Returns the upper cased string.\n         */\n        toUpper(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toUpper\n         */\n        toUpper(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toUpper\n         */\n        toUpper(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.trim\n    interface LoDashStatic {\n        /**\n         * Removes leading and trailing whitespace or specified characters from string.\n         *\n         * @param string The string to trim.\n         * @param chars The characters to trim.\n         * @return Returns the trimmed string.\n         */\n        trim(\n            string?: string,\n            chars?: string\n        ): string;\n\n        /**\n         * Removes leading and trailing whitespace or specified characters from string.\n         *\n         * @param string The string to trim.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns the trimmed string.\n         */\n        trim(\n            string: string,\n            index: string | number,\n            guard: object\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.trim\n         */\n        trim(chars?: string): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.trim\n         */\n        trim(chars?: string): LoDashExplicitWrapper<string>;\n    }\n\n    //_.trimEnd\n    interface LoDashStatic {\n        /**\n         * Removes trailing whitespace or specified characters from string.\n         *\n         * @param string The string to trim.\n         * @param chars The characters to trim.\n         * @return Returns the trimmed string.\n         */\n        trimEnd(\n            string?: string,\n            chars?: string\n        ): string;\n\n        /**\n         * Removes trailing whitespace or specified characters from string.\n         *\n         * @param string The string to trim.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns the trimmed string.\n         */\n        trimEnd(\n            string: string,\n            index: string | number,\n            guard: object\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.trimEnd\n         */\n        trimEnd(chars?: string): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.trimEnd\n         */\n        trimEnd(chars?: string): LoDashExplicitWrapper<string>;\n    }\n\n    //_.trimStart\n    interface LoDashStatic {\n        /**\n         * Removes leading whitespace or specified characters from string.\n         *\n         * @param string The string to trim.\n         * @param chars The characters to trim.\n         * @return Returns the trimmed string.\n         */\n        trimStart(\n            string?: string,\n            chars?: string\n        ): string;\n\n        /**\n         * Removes leading whitespace or specified characters from string.\n         *\n         * @param string The string to trim.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns the trimmed string.\n         */\n        trimStart(\n            string: string,\n            index: string | number,\n            guard: object\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.trimStart\n         */\n        trimStart(chars?: string): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.trimStart\n         */\n        trimStart(chars?: string): LoDashExplicitWrapper<string>;\n    }\n\n    //_.truncate\n    interface TruncateOptions {\n        /** The maximum string length. */\n        length?: number;\n        /** The string to indicate text is omitted. */\n        omission?: string;\n        /** The separator pattern to truncate to. */\n        separator?: string|RegExp;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Truncates string if it’s longer than the given maximum string length. The last characters of the truncated\n         * string are replaced with the omission string which defaults to \"…\".\n         *\n         * @param string The string to truncate.\n         * @param options The options object or maximum string length.\n         * @return Returns the truncated string.\n         */\n        truncate(\n            string?: string,\n            options?: TruncateOptions\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.truncate\n         */\n        truncate(options?: TruncateOptions): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.truncate\n         */\n        truncate(options?: TruncateOptions): LoDashExplicitWrapper<string>;\n    }\n\n    //_.unescape\n    interface LoDashStatic {\n        /**\n         * The inverse of _.escape; this method converts the HTML entities &amp;, &lt;, &gt;, &quot;, &#39;, and &#96;\n         * in string to their corresponding characters.\n         *\n         * Note: No other HTML entities are unescaped. To unescape additional HTML entities use a third-party library\n         * like he.\n         *\n         * @param string The string to unescape.\n         * @return Returns the unescaped string.\n         */\n        unescape(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unescape\n         */\n        unescape(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unescape\n         */\n        unescape(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.upperCase\n    interface LoDashStatic {\n        /**\n         * Converts `string`, as space separated words, to upper case.\n         *\n         * @param string The string to convert.\n         * @return Returns the upper cased string.\n         */\n        upperCase(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.upperCase\n         */\n        upperCase(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.upperCase\n         */\n        upperCase(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.upperFirst\n    interface LoDashStatic {\n        /**\n         * Converts the first character of `string` to upper case.\n         *\n         * @param string The string to convert.\n         * @return Returns the converted string.\n         */\n        upperFirst(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.upperFirst\n         */\n        upperFirst(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.upperFirst\n         */\n        upperFirst(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.words\n    interface LoDashStatic {\n        /**\n         * Splits `string` into an array of its words.\n         *\n         * @param string The string to inspect.\n         * @param pattern The pattern to match words.\n         * @return Returns the words of `string`.\n         */\n        words(\n            string?: string,\n            pattern?: string|RegExp\n        ): string[];\n\n        /**\n         * Splits `string` into an array of its words.\n         *\n         * @param string The string to inspect.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns the words of `string`.\n         */\n        words(\n            string: string,\n            index: string | number,\n            guard: object\n        ): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.words\n         */\n        words(pattern?: string|RegExp): string[];\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.words\n         */\n        words(pattern?: string|RegExp): LoDashExplicitWrapper<string[]>;\n    }\n\n    /***********\n     * Utility *\n     ***********/\n\n    //_.attempt\n    interface LoDashStatic {\n        /**\n         * Attempts to invoke func, returning either the result or the caught error object. Any additional arguments\n         * are provided to func when it’s invoked.\n         *\n         * @param func The function to attempt.\n         * @return Returns the func result or error object.\n         */\n        attempt<TResult>(func: (...args: any[]) => TResult, ...args: any[]): TResult|Error;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.attempt\n         */\n        attempt<TResult>(...args: any[]): TResult|Error;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.attempt\n         */\n        attempt<TResult>(...args: any[]): LoDashExplicitWrapper<TResult|Error>;\n    }\n\n    //_.constant\n    interface LoDashStatic {\n        /**\n         * Creates a function that returns value.\n         *\n         * @param value The value to return from the new function.\n         * @return Returns the new function.\n         */\n        constant<T>(value: T): () => T;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.constant\n         */\n        constant(): LoDashImplicitWrapper<() => TValue>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.constant\n         */\n        constant(): LoDashExplicitWrapper<() => TValue>;\n    }\n\n    //_.defaultTo\n    interface LoDashStatic {\n        /**\n         * Checks `value` to determine whether a default value should be returned in\n         * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n         * or `undefined`.\n         *\n         * @param value The value to check.\n         * @param defaultValue The default value.\n         * @returns Returns the resolved value.\n         */\n        defaultTo<T>(value: T | null | undefined, defaultValue: T): T;\n\n        /**\n         * @see _.defaultTo\n         */\n        defaultTo<T, TDefault>(\n            value: T | null | undefined,\n            defaultValue: TDefault\n        ): T | TDefault;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.defaultTo\n         */\n        defaultTo<T>(this: LoDashImplicitWrapper<T | null | undefined>, defaultValue: T): T;\n\n        /**\n         * @see _.defaultTo\n         */\n        defaultTo<T, TDefault>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            defaultValue: TDefault\n        ): T | TDefault;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.defaultTo\n         */\n        defaultTo<T>(this: LoDashExplicitWrapper<T | null | undefined>, defaultValue: T): LoDashExplicitWrapper<T>;\n\n        /**\n         * @see _.defaultTo\n         */\n        defaultTo<T, TDefault>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            defaultValue: TDefault\n        ): LoDashExplicitWrapper<T | TDefault>;\n    }\n\n    //_.identity\n    interface LoDashStatic {\n        /**\n         * This method returns the first argument provided to it.\n         *\n         * @param value Any value.\n         * @return Returns value.\n         */\n        identity<T>(value: T): T;\n\n        /**\n         * @see _.identity\n         */\n        identity(): undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.identity\n         */\n        identity(): TValue;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.identity\n         */\n        identity(): this;\n    }\n\n    //_.iteratee\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes `func` with the arguments of the created\n         * function. If `func` is a property name the created callback returns the\n         * property value for a given element. If `func` is an object the created\n         * callback returns `true` for elements that contain the equivalent object properties, otherwise it returns `false`.\n         *\n         * @category Util\n         * @param [func=_.identity] The value to convert to a callback.\n         * @returns Returns the callback.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney', 'age': 36 },\n         *   { 'user': 'fred',   'age': 40 }\n         * ];\n         *\n         * // create custom iteratee shorthands\n         * _.iteratee = _.wrap(_.iteratee, function(callback, func) {\n         *   var p = /^(\\S+)\\s*([<>])\\s*(\\S+)$/.exec(func);\n         *   return !p ? callback(func) : function(object) {\n         *     return (p[2] == '>' ? object[p[1]] > p[3] : object[p[1]] < p[3]);\n         *   };\n         * });\n         *\n         * _.filter(users, 'age > 36');\n         * // => [{ 'user': 'fred', 'age': 40 }]\n         */\n        iteratee<TFunction extends (...args: any[]) => any>(\n            func: TFunction | string | object\n        ): TFunction;\n\n        /**\n         * @see _.iteratee\n         */\n        iteratee(): typeof _.identity; // tslint:disable-line:no-unnecessary-qualifier\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.iteratee\n         */\n        iteratee<TFunction extends (...args: any[]) => any>(\n            this: LoDashImplicitWrapper<TFunction | string | object>\n        ): LoDashImplicitWrapper<TFunction>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.iteratee\n         */\n        iteratee<TFunction extends (...args: any[]) => any>(\n            this: LoDashExplicitWrapper<TFunction | string | object>\n        ): LoDashExplicitWrapper<TFunction>;\n    }\n\n    //_.matches\n    interface LoDashStatic {\n        /**\n         * Creates a function that performs a deep comparison between a given object and source, returning true if the\n         * given object has equivalent property values, else false.\n         *\n         * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and\n         * strings. Objects are compared by their own, not inherited, enumerable properties. For comparing a single own\n         * or inherited property value see _.matchesProperty.\n         *\n         * @param source The object of property values to match.\n         * @return Returns the new function.\n         */\n        matches<T>(source: T): (value: any) => boolean;\n\n        /**\n         * @see _.matches\n         */\n        matches<T, V>(source: T): (value: V) => boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.matches\n         */\n        matches<V>(): LoDashImplicitWrapper<(value: V) => boolean>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.matches\n         */\n        matches<V>(): LoDashExplicitWrapper<(value: V) => boolean>;\n    }\n\n    //_.matchesProperty\n    interface LoDashStatic {\n        /**\n         * Creates a function that compares the property value of path on a given object to value.\n         *\n         * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and\n         * strings. Objects are compared by their own, not inherited, enumerable properties.\n         *\n         * @param path The path of the property to get.\n         * @param srcValue The value to match.\n         * @return Returns the new function.\n         */\n        matchesProperty<T>(\n            path: PropertyPath,\n            srcValue: T\n        ): (value: any) => boolean;\n\n        /**\n         * @see _.matchesProperty\n         */\n        matchesProperty<T, V>(\n            path: PropertyPath,\n            srcValue: T\n        ): (value: V) => boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.matchesProperty\n         */\n        matchesProperty<SrcValue>(\n            srcValue: SrcValue\n        ): LoDashImplicitWrapper<(value: any) => boolean>;\n\n        /**\n         * @see _.matchesProperty\n         */\n        matchesProperty<SrcValue, Value>(\n            srcValue: SrcValue\n        ): LoDashImplicitWrapper<(value: Value) => boolean>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.matchesProperty\n         */\n        matchesProperty<SrcValue>(\n            srcValue: SrcValue\n        ): LoDashExplicitWrapper<(value: any) => boolean>;\n\n        /**\n         * @see _.matchesProperty\n         */\n        matchesProperty<SrcValue, Value>(\n            srcValue: SrcValue\n        ): LoDashExplicitWrapper<(value: Value) => boolean>;\n    }\n\n    //_.method\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes the method at path on a given object. Any additional arguments are provided\n         * to the invoked method.\n         *\n         * @param path The path of the method to invoke.\n         * @param args The arguments to invoke the method with.\n         * @return Returns the new function.\n         */\n        method(\n            path: PropertyPath,\n            ...args: any[]\n        ): (object: any) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.method\n         */\n        method(...args: any[]): LoDashImplicitWrapper<(object: any) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.method\n         */\n        method(...args: any[]): LoDashExplicitWrapper<(object: any) => any>;\n    }\n\n    //_.methodOf\n    interface LoDashStatic {\n        /**\n         * The opposite of _.method; this method creates a function that invokes the method at a given path on object.\n         * Any additional arguments are provided to the invoked method.\n         *\n         * @param object The object to query.\n         * @param args The arguments to invoke the method with.\n         * @return Returns the new function.\n         */\n        methodOf(\n            object: object,\n            ...args: any[]\n        ): (path: PropertyPath) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.methodOf\n         */\n        methodOf(\n            ...args: any[]\n        ): LoDashImplicitWrapper<(path: PropertyPath) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.methodOf\n         */\n        methodOf(\n            ...args: any[]\n        ): LoDashExplicitWrapper<(path: PropertyPath) => any>;\n    }\n\n    //_.mixin\n    interface MixinOptions {\n        chain?: boolean;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Adds all own enumerable function properties of a source object to the destination object. If object is a\n         * function then methods are added to its prototype as well.\n         *\n         * Note: Use _.runInContext to create a pristine lodash function to avoid conflicts caused by modifying\n         * the original.\n         *\n         * @param object The destination object.\n         * @param source The object of functions to add.\n         * @param options The options object.\n         * @param options.chain Specify whether the functions added are chainable.\n         * @return Returns object.\n         */\n        mixin<TObject>(\n            object: TObject,\n            source: Dictionary<(...args: any[]) => any>,\n            options?: MixinOptions\n        ): TObject;\n\n        /**\n         * @see _.mixin\n         */\n        mixin<TResult>(\n            source: Dictionary<(...args: any[]) => any>,\n            options?: MixinOptions\n        ): LoDashStatic;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.mixin\n         */\n        mixin(\n            source: Dictionary<(...args: any[]) => any>,\n            options?: MixinOptions\n        ): this;\n\n        /**\n         * @see _.mixin\n         */\n        mixin(\n            options?: MixinOptions\n        ): LoDashImplicitWrapper<LoDashStatic>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.mixin\n         */\n        mixin(\n            source: Dictionary<(...args: any[]) => any>,\n            options?: MixinOptions\n        ): this;\n\n        /**\n         * @see _.mixin\n         */\n        mixin(\n            options?: MixinOptions\n        ): LoDashExplicitWrapper<LoDashStatic>;\n    }\n\n    //_.noConflict\n    interface LoDashStatic {\n        /**\n         * Reverts the _ variable to its previous value and returns a reference to the lodash function.\n         *\n         * @return Returns the lodash function.\n         */\n        noConflict(): typeof _;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.noConflict\n         */\n        noConflict(): typeof _;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.noConflict\n         */\n        noConflict(): LoDashExplicitWrapper<typeof _>;\n    }\n\n    //_.noop\n    interface LoDashStatic {\n        /**\n         * A no-operation function that returns undefined regardless of the arguments it receives.\n         *\n         * @return undefined\n         */\n        noop(...args: any[]): void;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.noop\n         */\n        noop(...args: any[]): void;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.noop\n         */\n        noop(...args: any[]): LoDashExplicitWrapper<undefined>;\n    }\n\n    //_.nthArg\n    interface LoDashStatic {\n        /**\n         * Creates a function that returns its nth argument.\n         *\n         * @param n The index of the argument to return.\n         * @return Returns the new function.\n         */\n        nthArg(n?: number): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.nthArg\n         */\n        nthArg(): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.nthArg\n         */\n        nthArg(): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.over\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes iteratees with the arguments provided to the created function and returns\n         * their results.\n         *\n         * @param iteratees The iteratees to invoke.\n         * @return Returns the new function.\n         */\n        over<TResult>(...iteratees: Array<Many<(...args: any[]) => TResult>>): (...args: any[]) => TResult[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.over\n         */\n        over<TResult>(\n            this: LoDashImplicitWrapper<Many<(...args: any[]) => TResult>>,\n            ...iteratees: Array<Many<(...args: any[]) => TResult>>\n        ): LoDashImplicitWrapper<(...args: any[]) => TResult[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.over\n         */\n        over<TResult>(\n            this: LoDashExplicitWrapper<Many<(...args: any[]) => TResult>>,\n            ...iteratees: Array<Many<(...args: any[]) => TResult>>\n        ): LoDashExplicitWrapper<(...args: any[]) => TResult[]>;\n    }\n\n    //_.overEvery\n    interface LoDashStatic {\n        /**\n         * Creates a function that checks if all of the predicates return truthy when invoked with the arguments\n         * provided to the created function.\n         *\n         * @param predicates The predicates to check.\n         * @return Returns the new function.\n         */\n        overEvery<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): (...args: T[]) => boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.overEvery\n         */\n        overEvery<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): LoDashImplicitWrapper<(...args: T[]) => boolean>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.overEvery\n         */\n        overEvery<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): LoDashExplicitWrapper<(...args: T[]) => boolean>;\n    }\n\n    //_.overSome\n    interface LoDashStatic {\n        /**\n         * Creates a function that checks if any of the predicates return truthy when invoked with the arguments\n         * provided to the created function.\n         *\n         * @param predicates The predicates to check.\n         * @return Returns the new function.\n         */\n        overSome<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): (...args: T[]) => boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.overSome\n         */\n        overSome<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): LoDashImplicitWrapper<(...args: T[]) => boolean>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.overSome\n         */\n        overSome<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): LoDashExplicitWrapper<(...args: T[]) => boolean>;\n    }\n\n    //_.property\n    interface LoDashStatic {\n        /**\n         * Creates a function that returns the property value at path on a given object.\n         *\n         * @param path The path of the property to get.\n         * @return Returns the new function.\n         */\n        property<TObj, TResult>(path: PropertyPath): (obj: TObj) => TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.property\n         */\n        property<TObj, TResult>(): LoDashImplicitWrapper<(obj: TObj) => TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.property\n         */\n        property<TObj, TResult>(): LoDashExplicitWrapper<(obj: TObj) => TResult>;\n    }\n\n    //_.propertyOf\n    interface LoDashStatic {\n        /**\n         * The opposite of _.property; this method creates a function that returns the property value at a given path\n         * on object.\n         *\n         * @param object The object to query.\n         * @return Returns the new function.\n         */\n        propertyOf<T extends {}>(object: T): (path: PropertyPath) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.propertyOf\n         */\n        propertyOf(): LoDashImplicitWrapper<(path: PropertyPath) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.propertyOf\n         */\n        propertyOf(): LoDashExplicitWrapper<(path: PropertyPath) => any>;\n    }\n\n    //_.range\n    interface LoDashStatic {\n        /**\n         * Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end.\n         * If end is not specified it’s set to start with start then set to 0. If end is less than start a zero-length\n         * range is created unless a negative step is specified.\n         *\n         * @param start The start of the range.\n         * @param end The end of the range.\n         * @param step The value to increment or decrement by.\n         * @return Returns a new range array.\n         */\n        range(\n            start: number,\n            end?: number,\n            step?: number\n        ): number[];\n\n        /**\n         * Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end.\n         * If end is not specified it’s set to start with start then set to 0. If end is less than start a zero-length\n         * range is created unless a negative step is specified.\n         *\n         * @param start The start of the range.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns a new range array.\n         */\n        range(\n            end: number,\n            index: string | number,\n            guard: object\n        ): number[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.range\n         */\n        range(\n            end?: number,\n            step?: number\n        ): LoDashImplicitWrapper<number[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.range\n         */\n        range(\n            end?: number,\n            step?: number\n        ): LoDashExplicitWrapper<number[]>;\n    }\n\n    //_.rangeRight\n    interface LoDashStatic {\n        /**\n         * This method is like `_.range` except that it populates values in\n         * descending order.\n         *\n         * @category Util\n         * @param start The start of the range.\n         * @param end The end of the range.\n         * @param step The value to increment or decrement by.\n         * @returns Returns the new array of numbers.\n         * @example\n         *\n         * _.rangeRight(4);\n         * // => [3, 2, 1, 0]\n         *\n         * _.rangeRight(-4);\n         * // => [-3, -2, -1, 0]\n         *\n         * _.rangeRight(1, 5);\n         * // => [4, 3, 2, 1]\n         *\n         * _.rangeRight(0, 20, 5);\n         * // => [15, 10, 5, 0]\n         *\n         * _.rangeRight(0, -4, -1);\n         * // => [-3, -2, -1, 0]\n         *\n         * _.rangeRight(1, 4, 0);\n         * // => [1, 1, 1]\n         *\n         * _.rangeRight(0);\n         * // => []\n         */\n        rangeRight(\n            start: number,\n            end?: number,\n            step?: number\n        ): number[];\n\n        /**\n         * This method is like _.range except that it populates values in\n         * descending order.\n         *\n         * @param start The start of the range.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns a new range array.\n         */\n        rangeRight(\n            end: number,\n            index: string | number,\n            guard: object\n        ): number[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.rangeRight\n         */\n        rangeRight(\n            end?: number,\n            step?: number\n        ): LoDashImplicitWrapper<number[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.rangeRight\n         */\n        rangeRight(\n            end?: number,\n            step?: number\n        ): LoDashExplicitWrapper<number[]>;\n    }\n\n    //_.runInContext\n    interface LoDashStatic {\n        /**\n         * Create a new pristine lodash function using the given context object.\n         *\n         * @param context The context object.\n         * @return Returns a new lodash function.\n         */\n        runInContext(context?: object): typeof _;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.runInContext\n         */\n        runInContext(): typeof _;\n    }\n\n    // _.stubArray\n    interface LoDashStatic {\n        /**\n         * This method returns a new empty array.\n         *\n         * @returns Returns the new empty array.\n         */\n        stubArray(): any[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.stubArray\n         */\n        stubArray(): any[];\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.stubArray\n         */\n        stubArray(): LoDashExplicitWrapper<any[]>;\n    }\n\n    // _.stubFalse\n    interface LoDashStatic {\n        /**\n         * This method returns `false`.\n         *\n         * @returns Returns `false`.\n         */\n        stubFalse(): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.stubFalse\n         */\n        stubFalse(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.stubFalse\n         */\n        stubFalse(): LoDashExplicitWrapper<boolean>;\n    }\n\n    interface LoDashStatic {\n        /**\n         * This method returns a new empty object.\n         *\n         * @returns Returns the new empty object.\n         */\n        stubObject(): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.stubObject\n         */\n        stubObject(): any;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.stubObject\n         */\n        stubObject(): LoDashExplicitWrapper<any>;\n    }\n\n    interface LoDashStatic {\n        /**\n         * This method returns an empty string.\n         *\n         * @returns Returns the empty string.\n         */\n        stubString(): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.stubString\n         */\n        stubString(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.stubString\n         */\n        stubString(): LoDashExplicitWrapper<string>;\n    }\n\n    interface LoDashStatic {\n        /**\n         * This method returns `true`.\n         *\n         * @returns Returns `true`.\n         */\n        stubTrue(): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.stubTrue\n         */\n        stubTrue(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.stubTrue\n         */\n        stubTrue(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.times\n    interface LoDashStatic {\n        /**\n         * Invokes the iteratee function n times, returning an array of the results of each invocation. The iteratee\n         * is invoked with one argument; (index).\n         *\n         * @param n The number of times to invoke iteratee.\n         * @param iteratee The function invoked per iteration.\n         * @return Returns the array of results.\n         */\n        times<TResult>(\n            n: number,\n            iteratee: (num: number) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.times\n         */\n        times(n: number): number[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.times\n         */\n        times<TResult>(\n            iteratee: (num: number) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.times\n         */\n        times(): number[];\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.times\n         */\n        times<TResult>(\n            iteratee: (num: number) => TResult\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.times\n         */\n        times(): LoDashExplicitWrapper<number[]>;\n    }\n\n    //_.toPath\n    interface LoDashStatic {\n        /**\n         * Converts `value` to a property path array.\n         *\n         * @category Util\n         * @param value The value to convert.\n         * @returns Returns the new property path array.\n         * @example\n         *\n         * _.toPath('a.b.c');\n         * // => ['a', 'b', 'c']\n         *\n         * _.toPath('a[0].b.c');\n         * // => ['a', '0', 'b', 'c']\n         *\n         * var path = ['a', 'b', 'c'],\n         *     newPath = _.toPath(path);\n         *\n         * console.log(newPath);\n         * // => ['a', 'b', 'c']\n         *\n         * console.log(path === newPath);\n         * // => false\n         */\n        toPath(value: any): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPath\n         */\n        toPath(): LoDashImplicitWrapper<string[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPath\n         */\n        toPath(): LoDashExplicitWrapper<string[]>;\n    }\n\n    //_.uniqueId\n    interface LoDashStatic {\n        /**\n         * Generates a unique ID. If prefix is provided the ID is appended to it.\n         *\n         * @param prefix The value to prefix the ID with.\n         * @return Returns the unique ID.\n         */\n        uniqueId(prefix?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.uniqueId\n         */\n        uniqueId(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.uniqueId\n         */\n        uniqueId(): LoDashExplicitWrapper<string>;\n    }\n\n    type NotVoid = {} | null | undefined;\n    type ArrayIterator<T, TResult> = (value: T, index: number, collection: T[]) => TResult;\n    type ListIterator<T, TResult> = (value: T, index: number, collection: List<T>) => TResult;\n    type ListIteratee<T> = ListIterator<T, NotVoid> | string | [string, any] | PartialDeep<T>;\n    type ListIterateeCustom<T, TResult> = ListIterator<T, TResult> | string | object | [string, any] | PartialDeep<T>;\n    type ListIteratorTypeGuard<T, S extends T> = (value: T, index: number, collection: List<T>) => value is S;\n\n    // Note: key should be string, not keyof T, because the actual object may contain extra properties that were not specified in the type.\n    type ObjectIterator<TObject, TResult> = (value: TObject[keyof TObject], key: string, collection: TObject) => TResult;\n    type ObjectIteratee<TObject> = ObjectIterator<TObject, NotVoid> | string | [string, any] | PartialDeep<TObject[keyof TObject]>;\n    type ObjectIterateeCustom<TObject, TResult> = ObjectIterator<TObject, TResult> | string | object | [string, any] | PartialDeep<TObject[keyof TObject]>;\n    type ObjectIteratorTypeGuard<TObject, S extends TObject[keyof TObject]> = (value: TObject[keyof TObject], key: string, collection: TObject) => value is S;\n\n    type DictionaryIterator<T, TResult> = ObjectIterator<Dictionary<T>, TResult>;\n    type DictionaryIteratee<T> = ObjectIteratee<Dictionary<T>>;\n    type DictionaryIteratorTypeGuard<T, S extends T> = ObjectIteratorTypeGuard<Dictionary<T>, S>;\n\n    type NumericDictionaryIterator<T, TResult> = (value: T, key: number, collection: NumericDictionary<T>) => TResult;\n    type NumericDictionaryIteratee<T> = NumericDictionaryIterator<T, NotVoid> | string | [string, any] | PartialDeep<T>;\n    type NumericDictionaryIterateeCustom<T, TResult> = NumericDictionaryIterator<T, TResult> | string | [string, any] | PartialDeep<T>;\n\n    type StringIterator<TResult> = (char: string, index: number, string: string) => TResult;\n\n    type MemoVoidIterator<T, TResult> = (prev: TResult, curr: T, indexOrKey: any, list: T[]) => void;\n\n    /** @deprecated Use MemoListIterator or MemoObjectIterator instead.  */\n    type MemoIterator<T, TResult> = (prev: TResult, curr: T, indexOrKey: any, list: T[]) => TResult;\n    type MemoListIterator<T, TResult, TList> = (prev: TResult, curr: T, index: number, list: TList) => TResult;\n    type MemoObjectIterator<T, TResult, TList> = (prev: TResult, curr: T, key: string, list: TList) => TResult;\n\n    type MemoVoidArrayIterator<T, TResult> = (acc: TResult, curr: T, index: number, arr: T[]) => void;\n    type MemoVoidDictionaryIterator<T, TResult> = (acc: TResult, curr: T, key: string, dict: Dictionary<T>) => void;\n\n    type ValueIteratee<T> = ((value: T) => NotVoid) | string | [string, any] | PartialDeep<T>;\n    type ValueKeyIteratee<T> = ((value: T, key: string) => NotVoid) | string | [string, any] | PartialDeep<T>;\n    type Comparator<T> = (a: T, b: T) => boolean;\n    type Comparator2<T1, T2> = (a: T1, b: T2) => boolean;\n\n    type PropertyName = string | number | symbol;\n    type PropertyPath = Many<PropertyName>;\n\n    /** Common interface between Arrays and jQuery objects */\n    type List<T> = ArrayLike<T>;\n\n    interface Dictionary<T> {\n        [index: string]: T;\n    }\n\n    interface NumericDictionary<T> {\n        [index: number]: T;\n    }\n\n    interface Cancelable {\n        cancel(): void;\n        flush(): void;\n    }\n\n    type PartialDeep<T> = {\n        [P in keyof T]?: PartialDeep<T[P]>;\n    };\n\n    // For backwards compatibility\n    type LoDashImplicitArrayWrapper<T> = LoDashImplicitWrapper<T[]>;\n    type LoDashImplicitNillableArrayWrapper<T> = LoDashImplicitWrapper<T[] | null | undefined>;\n    type LoDashImplicitObjectWrapper<T> = LoDashImplicitWrapper<T>;\n    type LoDashImplicitNillableObjectWrapper<T> = LoDashImplicitWrapper<T | null | undefined>;\n    type LoDashImplicitNumberArrayWrapper = LoDashImplicitWrapper<number[]>;\n    type LoDashImplicitStringWrapper = LoDashImplicitWrapper<string>;\n    type LoDashExplicitArrayWrapper<T> = LoDashExplicitWrapper<T[]>;\n    type LoDashExplicitNillableArrayWrapper<T> = LoDashExplicitWrapper<T[] | null | undefined>;\n    type LoDashExplicitObjectWrapper<T> = LoDashExplicitWrapper<T>;\n    type LoDashExplicitNillableObjectWrapper<T> = LoDashExplicitWrapper<T | null | undefined>;\n    type LoDashExplicitNumberArrayWrapper = LoDashExplicitWrapper<number[]>;\n    type LoDashExplicitStringWrapper = LoDashExplicitWrapper<string>;\n}\n\n// Backward compatibility with --target es5\ndeclare global {\n    interface Set<T> { }\n    interface Map<K, V> { }\n    interface WeakSet<T> { }\n    interface WeakMap<K extends object, V> { }\n}\n","type":2},{"name":"node_modules/@types/lodash/isArray.d.ts","text":"import { isArray } from \"./index\";\nexport = isArray;\n","type":2},{"name":"node_modules/@types/lodash/isArrayBuffer.d.ts","text":"import { isArrayBuffer } from \"./index\";\nexport = isArrayBuffer;\n","type":2},{"name":"node_modules/@types/lodash/isArrayLike.d.ts","text":"import { isArrayLike } from \"./index\";\nexport = isArrayLike;\n","type":2},{"name":"node_modules/@types/lodash/isArrayLikeObject.d.ts","text":"import { isArrayLikeObject } from \"./index\";\nexport = isArrayLikeObject;\n","type":2},{"name":"node_modules/@types/lodash/isBoolean.d.ts","text":"import { isBoolean } from \"./index\";\nexport = isBoolean;\n","type":2},{"name":"node_modules/@types/lodash/isBuffer.d.ts","text":"import { isBuffer } from \"./index\";\nexport = isBuffer;\n","type":2},{"name":"node_modules/@types/lodash/isDate.d.ts","text":"import { isDate } from \"./index\";\nexport = isDate;\n","type":2},{"name":"node_modules/@types/lodash/isElement.d.ts","text":"import { isElement } from \"./index\";\nexport = isElement;\n","type":2},{"name":"node_modules/@types/lodash/isEmpty.d.ts","text":"import { isEmpty } from \"./index\";\nexport = isEmpty;\n","type":2},{"name":"node_modules/@types/lodash/isEqual.d.ts","text":"import { isEqual } from \"./index\";\nexport = isEqual;\n","type":2},{"name":"node_modules/@types/lodash/isEqualWith.d.ts","text":"import { isEqualWith } from \"./index\";\nexport = isEqualWith;\n","type":2},{"name":"node_modules/@types/lodash/isError.d.ts","text":"import { isError } from \"./index\";\nexport = isError;\n","type":2},{"name":"node_modules/@types/lodash/isFinite.d.ts","text":"import { isFinite } from \"./index\";\nexport = isFinite;\n","type":2},{"name":"node_modules/@types/lodash/isFunction.d.ts","text":"import { isFunction } from \"./index\";\nexport = isFunction;\n","type":2},{"name":"node_modules/@types/lodash/isInteger.d.ts","text":"import { isInteger } from \"./index\";\nexport = isInteger;\n","type":2},{"name":"node_modules/@types/lodash/isLength.d.ts","text":"import { isLength } from \"./index\";\nexport = isLength;\n","type":2},{"name":"node_modules/@types/lodash/isMap.d.ts","text":"import { isMap } from \"./index\";\nexport = isMap;\n","type":2},{"name":"node_modules/@types/lodash/isMatch.d.ts","text":"import { isMatch } from \"./index\";\nexport = isMatch;\n","type":2},{"name":"node_modules/@types/lodash/isMatchWith.d.ts","text":"import { isMatchWith } from \"./index\";\nexport = isMatchWith;\n","type":2},{"name":"node_modules/@types/lodash/isNaN.d.ts","text":"import { isNaN } from \"./index\";\nexport = isNaN;\n","type":2},{"name":"node_modules/@types/lodash/isNative.d.ts","text":"import { isNative } from \"./index\";\nexport = isNative;\n","type":2},{"name":"node_modules/@types/lodash/isNil.d.ts","text":"import { isNil } from \"./index\";\nexport = isNil;\n","type":2},{"name":"node_modules/@types/lodash/isNull.d.ts","text":"import { isNull } from \"./index\";\nexport = isNull;\n","type":2},{"name":"node_modules/@types/lodash/isNumber.d.ts","text":"import { isNumber } from \"./index\";\nexport = isNumber;\n","type":2},{"name":"node_modules/@types/lodash/isObject.d.ts","text":"import { isObject } from \"./index\";\nexport = isObject;\n","type":2},{"name":"node_modules/@types/lodash/isObjectLike.d.ts","text":"import { isObjectLike } from \"./index\";\nexport = isObjectLike;\n","type":2},{"name":"node_modules/@types/lodash/isPlainObject.d.ts","text":"import { isPlainObject } from \"./index\";\nexport = isPlainObject;\n","type":2},{"name":"node_modules/@types/lodash/isRegExp.d.ts","text":"import { isRegExp } from \"./index\";\nexport = isRegExp;\n","type":2},{"name":"node_modules/@types/lodash/isSafeInteger.d.ts","text":"import { isSafeInteger } from \"./index\";\nexport = isSafeInteger;\n","type":2},{"name":"node_modules/@types/lodash/isSet.d.ts","text":"import { isSet } from \"./index\";\nexport = isSet;\n","type":2},{"name":"node_modules/@types/lodash/isString.d.ts","text":"import { isString } from \"./index\";\nexport = isString;\n","type":2},{"name":"node_modules/@types/lodash/isSymbol.d.ts","text":"import { isSymbol } from \"./index\";\nexport = isSymbol;\n","type":2},{"name":"node_modules/@types/lodash/isTypedArray.d.ts","text":"import { isTypedArray } from \"./index\";\nexport = isTypedArray;\n","type":2},{"name":"node_modules/@types/lodash/isUndefined.d.ts","text":"import { isUndefined } from \"./index\";\nexport = isUndefined;\n","type":2},{"name":"node_modules/@types/lodash/isWeakMap.d.ts","text":"import { isWeakMap } from \"./index\";\nexport = isWeakMap;\n","type":2},{"name":"node_modules/@types/lodash/isWeakSet.d.ts","text":"import { isWeakSet } from \"./index\";\nexport = isWeakSet;\n","type":2},{"name":"node_modules/@types/lodash/iteratee.d.ts","text":"import { iteratee } from \"./index\";\nexport = iteratee;\n","type":2},{"name":"node_modules/@types/lodash/join.d.ts","text":"import { join } from \"./index\";\nexport = join;\n","type":2},{"name":"node_modules/@types/lodash/kebabCase.d.ts","text":"import { kebabCase } from \"./index\";\nexport = kebabCase;\n","type":2},{"name":"node_modules/@types/lodash/keyBy.d.ts","text":"import { keyBy } from \"./index\";\nexport = keyBy;\n","type":2},{"name":"node_modules/@types/lodash/keys.d.ts","text":"import { keys } from \"./index\";\nexport = keys;\n","type":2},{"name":"node_modules/@types/lodash/keysIn.d.ts","text":"import { keysIn } from \"./index\";\nexport = keysIn;\n","type":2},{"name":"node_modules/@types/lodash/last.d.ts","text":"import { last } from \"./index\";\nexport = last;\n","type":2},{"name":"node_modules/@types/lodash/lastIndexOf.d.ts","text":"import { lastIndexOf } from \"./index\";\nexport = lastIndexOf;\n","type":2},{"name":"node_modules/@types/lodash/lowerCase.d.ts","text":"import { lowerCase } from \"./index\";\nexport = lowerCase;\n","type":2},{"name":"node_modules/@types/lodash/lowerFirst.d.ts","text":"import { lowerFirst } from \"./index\";\nexport = lowerFirst;\n","type":2},{"name":"node_modules/@types/lodash/lt.d.ts","text":"import { lt } from \"./index\";\nexport = lt;\n","type":2},{"name":"node_modules/@types/lodash/lte.d.ts","text":"import { lte } from \"./index\";\nexport = lte;\n","type":2},{"name":"node_modules/@types/lodash/map.d.ts","text":"import { map } from \"./index\";\nexport = map;\n","type":2},{"name":"node_modules/@types/lodash/mapKeys.d.ts","text":"import { mapKeys } from \"./index\";\nexport = mapKeys;\n","type":2},{"name":"node_modules/@types/lodash/mapValues.d.ts","text":"import { mapValues } from \"./index\";\nexport = mapValues;\n","type":2},{"name":"node_modules/@types/lodash/matches.d.ts","text":"import { matches } from \"./index\";\nexport = matches;\n","type":2},{"name":"node_modules/@types/lodash/matchesProperty.d.ts","text":"import { matchesProperty } from \"./index\";\nexport = matchesProperty;\n","type":2},{"name":"node_modules/@types/lodash/max.d.ts","text":"import { max } from \"./index\";\nexport = max;\n","type":2},{"name":"node_modules/@types/lodash/maxBy.d.ts","text":"import { maxBy } from \"./index\";\nexport = maxBy;\n","type":2},{"name":"node_modules/@types/lodash/mean.d.ts","text":"import { mean } from \"./index\";\nexport = mean;\n","type":2},{"name":"node_modules/@types/lodash/meanBy.d.ts","text":"import { meanBy } from \"./index\";\nexport = meanBy;\n","type":2},{"name":"node_modules/@types/lodash/memoize.d.ts","text":"import { memoize } from \"./index\";\nexport = memoize;\n","type":2},{"name":"node_modules/@types/lodash/merge.d.ts","text":"import { merge } from \"./index\";\nexport = merge;\n","type":2},{"name":"node_modules/@types/lodash/mergeWith.d.ts","text":"import { mergeWith } from \"./index\";\nexport = mergeWith;\n","type":2},{"name":"node_modules/@types/lodash/method.d.ts","text":"import { method } from \"./index\";\nexport = method;\n","type":2},{"name":"node_modules/@types/lodash/methodOf.d.ts","text":"import { methodOf } from \"./index\";\nexport = methodOf;\n","type":2},{"name":"node_modules/@types/lodash/min.d.ts","text":"import { min } from \"./index\";\nexport = min;\n","type":2},{"name":"node_modules/@types/lodash/minBy.d.ts","text":"import { minBy } from \"./index\";\nexport = minBy;\n","type":2},{"name":"node_modules/@types/lodash/mixin.d.ts","text":"import { mixin } from \"./index\";\nexport = mixin;\n","type":2},{"name":"node_modules/@types/lodash/negate.d.ts","text":"import { negate } from \"./index\";\nexport = negate;\n","type":2},{"name":"node_modules/@types/lodash/noConflict.d.ts","text":"import { noConflict } from \"./index\";\nexport = noConflict;\n","type":2},{"name":"node_modules/@types/lodash/noop.d.ts","text":"import { noop } from \"./index\";\nexport = noop;\n","type":2},{"name":"node_modules/@types/lodash/now.d.ts","text":"import { now } from \"./index\";\nexport = now;\n","type":2},{"name":"node_modules/@types/lodash/nth.d.ts","text":"import { nth } from \"./index\";\nexport = nth;\n","type":2},{"name":"node_modules/@types/lodash/nthArg.d.ts","text":"import { nthArg } from \"./index\";\nexport = nthArg;\n","type":2},{"name":"node_modules/@types/lodash/omit.d.ts","text":"import { omit } from \"./index\";\nexport = omit;\n","type":2},{"name":"node_modules/@types/lodash/omitBy.d.ts","text":"import { omitBy } from \"./index\";\nexport = omitBy;\n","type":2},{"name":"node_modules/@types/lodash/once.d.ts","text":"import { once } from \"./index\";\nexport = once;\n","type":2},{"name":"node_modules/@types/lodash/orderBy.d.ts","text":"import { orderBy } from \"./index\";\nexport = orderBy;\n","type":2},{"name":"node_modules/@types/lodash/over.d.ts","text":"import { over } from \"./index\";\nexport = over;\n","type":2},{"name":"node_modules/@types/lodash/overArgs.d.ts","text":"import { overArgs } from \"./index\";\nexport = overArgs;\n","type":2},{"name":"node_modules/@types/lodash/overEvery.d.ts","text":"import { overEvery } from \"./index\";\nexport = overEvery;\n","type":2},{"name":"node_modules/@types/lodash/overSome.d.ts","text":"import { overSome } from \"./index\";\nexport = overSome;\n","type":2},{"name":"node_modules/@types/lodash/pad.d.ts","text":"import { pad } from \"./index\";\nexport = pad;\n","type":2},{"name":"node_modules/@types/lodash/padEnd.d.ts","text":"import { padEnd } from \"./index\";\nexport = padEnd;\n","type":2},{"name":"node_modules/@types/lodash/padStart.d.ts","text":"import { padStart } from \"./index\";\nexport = padStart;\n","type":2},{"name":"node_modules/@types/lodash/parseInt.d.ts","text":"import { parseInt } from \"./index\";\nexport = parseInt;\n","type":2},{"name":"node_modules/@types/lodash/partial.d.ts","text":"import { partial } from \"./index\";\nexport = partial;\n","type":2},{"name":"node_modules/@types/lodash/partialRight.d.ts","text":"import { partialRight } from \"./index\";\nexport = partialRight;\n","type":2},{"name":"node_modules/@types/lodash/partition.d.ts","text":"import { partition } from \"./index\";\nexport = partition;\n","type":2},{"name":"node_modules/@types/lodash/pick.d.ts","text":"import { pick } from \"./index\";\nexport = pick;\n","type":2},{"name":"node_modules/@types/lodash/pickBy.d.ts","text":"import { pickBy } from \"./index\";\nexport = pickBy;\n","type":2},{"name":"node_modules/@types/lodash/property.d.ts","text":"import { property } from \"./index\";\nexport = property;\n","type":2},{"name":"node_modules/@types/lodash/propertyOf.d.ts","text":"import { propertyOf } from \"./index\";\nexport = propertyOf;\n","type":2},{"name":"node_modules/@types/lodash/pull.d.ts","text":"import { pull } from \"./index\";\nexport = pull;\n","type":2},{"name":"node_modules/@types/lodash/pullAll.d.ts","text":"import { pullAll } from \"./index\";\nexport = pullAll;\n","type":2},{"name":"node_modules/@types/lodash/pullAllBy.d.ts","text":"import { pullAllBy } from \"./index\";\nexport = pullAllBy;\n","type":2},{"name":"node_modules/@types/lodash/pullAllWith.d.ts","text":"import { pullAllWith } from \"./index\";\nexport = pullAllWith;\n","type":2},{"name":"node_modules/@types/lodash/pullAt.d.ts","text":"import { pullAt } from \"./index\";\nexport = pullAt;\n","type":2},{"name":"node_modules/@types/lodash/random.d.ts","text":"import { random } from \"./index\";\nexport = random;\n","type":2},{"name":"node_modules/@types/lodash/range.d.ts","text":"import { range } from \"./index\";\nexport = range;\n","type":2},{"name":"node_modules/@types/lodash/rangeRight.d.ts","text":"import { rangeRight } from \"./index\";\nexport = rangeRight;\n","type":2},{"name":"node_modules/@types/lodash/rearg.d.ts","text":"import { rearg } from \"./index\";\nexport = rearg;\n","type":2},{"name":"node_modules/@types/lodash/reduce.d.ts","text":"import { reduce } from \"./index\";\nexport = reduce;\n","type":2},{"name":"node_modules/@types/lodash/reduceRight.d.ts","text":"import { reduceRight } from \"./index\";\nexport = reduceRight;\n","type":2},{"name":"node_modules/@types/lodash/reject.d.ts","text":"import { reject } from \"./index\";\nexport = reject;\n","type":2},{"name":"node_modules/@types/lodash/remove.d.ts","text":"import { remove } from \"./index\";\nexport = remove;\n","type":2},{"name":"node_modules/@types/lodash/repeat.d.ts","text":"import { repeat } from \"./index\";\nexport = repeat;\n","type":2},{"name":"node_modules/@types/lodash/replace.d.ts","text":"import { replace } from \"./index\";\nexport = replace;\n","type":2},{"name":"node_modules/@types/lodash/rest.d.ts","text":"import { rest } from \"./index\";\nexport = rest;\n","type":2},{"name":"node_modules/@types/lodash/result.d.ts","text":"import { result } from \"./index\";\nexport = result;\n","type":2},{"name":"node_modules/@types/lodash/reverse.d.ts","text":"import { reverse } from \"./index\";\nexport = reverse;\n","type":2},{"name":"node_modules/@types/lodash/round.d.ts","text":"import { round } from \"./index\";\nexport = round;\n","type":2},{"name":"node_modules/@types/lodash/runInContext.d.ts","text":"import { runInContext } from \"./index\";\nexport = runInContext;\n","type":2},{"name":"node_modules/@types/lodash/sample.d.ts","text":"import { sample } from \"./index\";\nexport = sample;\n","type":2},{"name":"node_modules/@types/lodash/sampleSize.d.ts","text":"import { sampleSize } from \"./index\";\nexport = sampleSize;\n","type":2},{"name":"node_modules/@types/lodash/set.d.ts","text":"import { set } from \"./index\";\nexport = set;\n","type":2},{"name":"node_modules/@types/lodash/setWith.d.ts","text":"import { setWith } from \"./index\";\nexport = setWith;\n","type":2},{"name":"node_modules/@types/lodash/shuffle.d.ts","text":"import { shuffle } from \"./index\";\nexport = shuffle;\n","type":2},{"name":"node_modules/@types/lodash/size.d.ts","text":"import { size } from \"./index\";\nexport = size;\n","type":2},{"name":"node_modules/@types/lodash/slice.d.ts","text":"import { slice } from \"./index\";\nexport = slice;\n","type":2},{"name":"node_modules/@types/lodash/snakeCase.d.ts","text":"import { snakeCase } from \"./index\";\nexport = snakeCase;\n","type":2},{"name":"node_modules/@types/lodash/some.d.ts","text":"import { some } from \"./index\";\nexport = some;\n","type":2},{"name":"node_modules/@types/lodash/sortBy.d.ts","text":"import { sortBy } from \"./index\";\nexport = sortBy;\n","type":2},{"name":"node_modules/@types/lodash/sortedIndex.d.ts","text":"import { sortedIndex } from \"./index\";\nexport = sortedIndex;\n","type":2},{"name":"node_modules/@types/lodash/sortedIndexBy.d.ts","text":"import { sortedIndexBy } from \"./index\";\nexport = sortedIndexBy;\n","type":2},{"name":"node_modules/@types/lodash/sortedIndexOf.d.ts","text":"import { sortedIndexOf } from \"./index\";\nexport = sortedIndexOf;\n","type":2},{"name":"node_modules/@types/lodash/sortedLastIndex.d.ts","text":"import { sortedLastIndex } from \"./index\";\nexport = sortedLastIndex;\n","type":2},{"name":"node_modules/@types/lodash/sortedLastIndexBy.d.ts","text":"import { sortedLastIndexBy } from \"./index\";\nexport = sortedLastIndexBy;\n","type":2},{"name":"node_modules/@types/lodash/sortedLastIndexOf.d.ts","text":"import { sortedLastIndexOf } from \"./index\";\nexport = sortedLastIndexOf;\n","type":2},{"name":"node_modules/@types/lodash/sortedUniq.d.ts","text":"import { sortedUniq } from \"./index\";\nexport = sortedUniq;\n","type":2},{"name":"node_modules/@types/lodash/sortedUniqBy.d.ts","text":"import { sortedUniqBy } from \"./index\";\nexport = sortedUniqBy;\n","type":2},{"name":"node_modules/@types/lodash/split.d.ts","text":"import { split } from \"./index\";\nexport = split;\n","type":2},{"name":"node_modules/@types/lodash/spread.d.ts","text":"import { spread } from \"./index\";\nexport = spread;\n","type":2},{"name":"node_modules/@types/lodash/startCase.d.ts","text":"import { startCase } from \"./index\";\nexport = startCase;\n","type":2},{"name":"node_modules/@types/lodash/startsWith.d.ts","text":"import { startsWith } from \"./index\";\nexport = startsWith;\n","type":2},{"name":"node_modules/@types/lodash/subtract.d.ts","text":"import { subtract } from \"./index\";\nexport = subtract;\n","type":2},{"name":"node_modules/@types/lodash/sum.d.ts","text":"import { sum } from \"./index\";\nexport = sum;\n","type":2},{"name":"node_modules/@types/lodash/sumBy.d.ts","text":"import { sumBy } from \"./index\";\nexport = sumBy;\n","type":2},{"name":"node_modules/@types/lodash/tail.d.ts","text":"import { tail } from \"./index\";\nexport = tail;\n","type":2},{"name":"node_modules/@types/lodash/take.d.ts","text":"import { take } from \"./index\";\nexport = take;\n","type":2},{"name":"node_modules/@types/lodash/takeRight.d.ts","text":"import { takeRight } from \"./index\";\nexport = takeRight;\n","type":2},{"name":"node_modules/@types/lodash/takeRightWhile.d.ts","text":"import { takeRightWhile } from \"./index\";\nexport = takeRightWhile;\n","type":2},{"name":"node_modules/@types/lodash/takeWhile.d.ts","text":"import { takeWhile } from \"./index\";\nexport = takeWhile;\n","type":2},{"name":"node_modules/@types/lodash/tap.d.ts","text":"import { tap } from \"./index\";\nexport = tap;\n","type":2},{"name":"node_modules/@types/lodash/template.d.ts","text":"import { template } from \"./index\";\nexport = template;\n","type":2},{"name":"node_modules/@types/lodash/throttle.d.ts","text":"import { throttle } from \"./index\";\nexport = throttle;\n","type":2},{"name":"node_modules/@types/lodash/thru.d.ts","text":"import { thru } from \"./index\";\nexport = thru;\n","type":2},{"name":"node_modules/@types/lodash/times.d.ts","text":"import { times } from \"./index\";\nexport = times;\n","type":2},{"name":"node_modules/@types/lodash/toArray.d.ts","text":"import { toArray } from \"./index\";\nexport = toArray;\n","type":2},{"name":"node_modules/@types/lodash/toFinite.d.ts","text":"import { toFinite } from \"./index\";\nexport = toFinite;\n","type":2},{"name":"node_modules/@types/lodash/toInteger.d.ts","text":"import { toInteger } from \"./index\";\nexport = toInteger;\n","type":2},{"name":"node_modules/@types/lodash/toLength.d.ts","text":"import { toLength } from \"./index\";\nexport = toLength;\n","type":2},{"name":"node_modules/@types/lodash/toLower.d.ts","text":"import { toLower } from \"./index\";\nexport = toLower;\n","type":2},{"name":"node_modules/@types/lodash/toNumber.d.ts","text":"import { toNumber } from \"./index\";\nexport = toNumber;\n","type":2},{"name":"node_modules/@types/lodash/toPairs.d.ts","text":"import { toPairs } from \"./index\";\nexport = toPairs;\n","type":2},{"name":"node_modules/@types/lodash/toPairsIn.d.ts","text":"import { toPairsIn } from \"./index\";\nexport = toPairsIn;\n","type":2},{"name":"node_modules/@types/lodash/toPath.d.ts","text":"import { toPath } from \"./index\";\nexport = toPath;\n","type":2},{"name":"node_modules/@types/lodash/toPlainObject.d.ts","text":"import { toPlainObject } from \"./index\";\nexport = toPlainObject;\n","type":2},{"name":"node_modules/@types/lodash/toSafeInteger.d.ts","text":"import { toSafeInteger } from \"./index\";\nexport = toSafeInteger;\n","type":2},{"name":"node_modules/@types/lodash/toString.d.ts","text":"import { toString } from \"./index\";\nexport = toString;\n","type":2},{"name":"node_modules/@types/lodash/toUpper.d.ts","text":"import { toUpper } from \"./index\";\nexport = toUpper;\n","type":2},{"name":"node_modules/@types/lodash/transform.d.ts","text":"import { transform } from \"./index\";\nexport = transform;\n","type":2},{"name":"node_modules/@types/lodash/trim.d.ts","text":"import { trim } from \"./index\";\nexport = trim;\n","type":2},{"name":"node_modules/@types/lodash/trimEnd.d.ts","text":"import { trimEnd } from \"./index\";\nexport = trimEnd;\n","type":2},{"name":"node_modules/@types/lodash/trimStart.d.ts","text":"import { trimStart } from \"./index\";\nexport = trimStart;\n","type":2},{"name":"node_modules/@types/lodash/truncate.d.ts","text":"import { truncate } from \"./index\";\nexport = truncate;\n","type":2},{"name":"node_modules/@types/lodash/unary.d.ts","text":"import { unary } from \"./index\";\nexport = unary;\n","type":2},{"name":"node_modules/@types/lodash/unescape.d.ts","text":"import { unescape } from \"./index\";\nexport = unescape;\n","type":2},{"name":"node_modules/@types/lodash/union.d.ts","text":"import { union } from \"./index\";\nexport = union;\n","type":2},{"name":"node_modules/@types/lodash/unionBy.d.ts","text":"import { unionBy } from \"./index\";\nexport = unionBy;\n","type":2},{"name":"node_modules/@types/lodash/unionWith.d.ts","text":"import { unionWith } from \"./index\";\nexport = unionWith;\n","type":2},{"name":"node_modules/@types/lodash/uniq.d.ts","text":"import { uniq } from \"./index\";\nexport = uniq;\n","type":2},{"name":"node_modules/@types/lodash/uniqBy.d.ts","text":"import { uniqBy } from \"./index\";\nexport = uniqBy;\n","type":2},{"name":"node_modules/@types/lodash/uniqueId.d.ts","text":"import { uniqueId } from \"./index\";\nexport = uniqueId;\n","type":2},{"name":"node_modules/@types/lodash/uniqWith.d.ts","text":"import { uniqWith } from \"./index\";\nexport = uniqWith;\n","type":2},{"name":"node_modules/@types/lodash/unset.d.ts","text":"import { unset } from \"./index\";\nexport = unset;\n","type":2},{"name":"node_modules/@types/lodash/unzip.d.ts","text":"import { unzip } from \"./index\";\nexport = unzip;\n","type":2},{"name":"node_modules/@types/lodash/unzipWith.d.ts","text":"import { unzipWith } from \"./index\";\nexport = unzipWith;\n","type":2},{"name":"node_modules/@types/lodash/update.d.ts","text":"import { update } from \"./index\";\nexport = update;\n","type":2},{"name":"node_modules/@types/lodash/updateWith.d.ts","text":"import { updateWith } from \"./index\";\nexport = updateWith;\n","type":2},{"name":"node_modules/@types/lodash/upperCase.d.ts","text":"import { upperCase } from \"./index\";\nexport = upperCase;\n","type":2},{"name":"node_modules/@types/lodash/upperFirst.d.ts","text":"import { upperFirst } from \"./index\";\nexport = upperFirst;\n","type":2},{"name":"node_modules/@types/lodash/values.d.ts","text":"import { values } from \"./index\";\nexport = values;\n","type":2},{"name":"node_modules/@types/lodash/valuesIn.d.ts","text":"import { valuesIn } from \"./index\";\nexport = valuesIn;\n","type":2},{"name":"node_modules/@types/lodash/without.d.ts","text":"import { without } from \"./index\";\nexport = without;\n","type":2},{"name":"node_modules/@types/lodash/words.d.ts","text":"import { words } from \"./index\";\nexport = words;\n","type":2},{"name":"node_modules/@types/lodash/wrap.d.ts","text":"import { wrap } from \"./index\";\nexport = wrap;\n","type":2},{"name":"node_modules/@types/lodash/xor.d.ts","text":"import { xor } from \"./index\";\nexport = xor;\n","type":2},{"name":"node_modules/@types/lodash/xorBy.d.ts","text":"import { xorBy } from \"./index\";\nexport = xorBy;\n","type":2},{"name":"node_modules/@types/lodash/xorWith.d.ts","text":"import { xorWith } from \"./index\";\nexport = xorWith;\n","type":2},{"name":"node_modules/@types/lodash/zip.d.ts","text":"import { zip } from \"./index\";\nexport = zip;\n","type":2},{"name":"node_modules/@types/lodash/zipObject.d.ts","text":"import { zipObject } from \"./index\";\nexport = zipObject;\n","type":2},{"name":"node_modules/@types/lodash/zipObjectDeep.d.ts","text":"import { zipObjectDeep } from \"./index\";\nexport = zipObjectDeep;\n","type":2},{"name":"node_modules/@types/lodash/zipWith.d.ts","text":"import { zipWith } from \"./index\";\nexport = zipWith;\n","type":2},{"name":"node_modules/@types/mime-types/index.d.ts","text":"// Type definitions for mime-types 2.1\r\n// Project: https://github.com/jshttp/mime-types#readme\r\n// Definitions by: Gyusun Yeom <https://github.com/Perlmint>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n\r\nexport function lookup(filenameOrExt: string): string | false;\r\nexport function contentType(filenameOrExt: string): string | false;\r\nexport function extension(typeString: string): string | false;\r\nexport function charset(typeString: string): string | false;\r\nexport const types: {[key: string]: string};\r\nexport const extensions: {[key: string]: string[]};\r\n","type":2},{"name":"node_modules/@types/mime/index.d.ts","text":"// Type definitions for mime 2.0\r\n// Project: https://github.com/broofa/node-mime\r\n// Definitions by: Jeff Goddard <https://github.com/jedigo>\r\n//                 Daniel Hritzkiv <https://github.com/dhritzkiv>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n\r\n// Originally imported from: https://github.com/soywiz/typescript-node-definitions/mime.d.ts\r\n\r\nexport as namespace mime;\r\n\r\nexport interface TypeMap { [key: string]: string[]; }\r\n\r\nexport function getType(path: string): string | null;\r\nexport function getExtension(mime: string): string | null;\r\nexport function define(mimes: TypeMap, force?: boolean): void;\r\n\r\nexport const default_type: string;\r\n","type":2},{"name":"node_modules/@types/mime/Mime.d.ts","text":"import { TypeMap } from \"./index\";\r\n\r\nexport default class Mime {\r\n\tconstructor(mimes: TypeMap);\r\n\r\n\tgetType(path: string): string | null;\r\n    getExtension(mime: string): string | null;\r\n    define(mimes: TypeMap, force?: boolean): void;\r\n}\r\n","type":2},{"name":"node_modules/@types/minimatch/index.d.ts","text":"// Type definitions for Minimatch 3.0\n// Project: https://github.com/isaacs/minimatch\n// Definitions by: vvakame <https://github.com/vvakame>\n//                 Shant Marouti <https://github.com/shantmarouti>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n/**\n * Tests a path against the pattern using the options.\n */\ndeclare function M(target: string, pattern: string, options?: M.IOptions): boolean;\n\ndeclare namespace M {\n    /**\n     * Match against the list of files, in the style of fnmatch or glob.\n     * If nothing is matched, and options.nonull is set,\n     * then return a list containing the pattern itself.\n     */\n    function match(list: string[], pattern: string, options?: IOptions): string[];\n\n    /**\n     * Returns a function that tests its supplied argument, suitable for use with Array.filter\n     */\n    function filter(pattern: string, options?: IOptions): (element: string, indexed: number, array: string[]) => boolean;\n\n    /**\n     * Make a regular expression object from the pattern.\n     */\n    function makeRe(pattern: string, options?: IOptions): RegExp;\n\n    let Minimatch: IMinimatchStatic;\n\n    interface IOptions {\n        /**\n         * Dump a ton of stuff to stderr.\n         *\n         * @default false\n         */\n        debug?: boolean;\n\n        /**\n         * Do not expand {a,b} and {1..3} brace sets.\n         *\n         * @default false\n         */\n        nobrace?: boolean;\n\n        /**\n         * Disable ** matching against multiple folder names.\n         *\n         * @default false\n         */\n        noglobstar?: boolean;\n\n        /**\n         * Allow patterns to match filenames starting with a period,\n         * even if the pattern does not explicitly have a period in that spot.\n         *\n         * @default false\n         */\n        dot?: boolean;\n\n        /**\n         * Disable \"extglob\" style patterns like +(a|b).\n         *\n         * @default false\n         */\n        noext?: boolean;\n\n        /**\n         * Perform a case-insensitive match.\n         *\n         * @default false\n         */\n        nocase?: boolean;\n\n        /**\n         * When a match is not found by minimatch.match,\n         * return a list containing the pattern itself if this option is set.\n         * Otherwise, an empty list is returned if there are no matches.\n         *\n         * @default false\n         */\n        nonull?: boolean;\n\n        /**\n         * If set, then patterns without slashes will be matched against\n         * the basename of the path if it contains slashes.\n         *\n         * @default false\n         */\n        matchBase?: boolean;\n\n        /**\n         * Suppress the behavior of treating #\n         * at the start of a pattern as a comment.\n         *\n         * @default false\n         */\n        nocomment?: boolean;\n\n        /**\n         * Suppress the behavior of treating a leading ! character as negation.\n         *\n         * @default false\n         */\n        nonegate?: boolean;\n\n        /**\n         * Returns from negate expressions the same as if they were not negated.\n         * (Ie, true on a hit, false on a miss.)\n         *\n         * @default false\n         */\n        flipNegate?: boolean;\n    }\n\n    interface IMinimatchStatic {\n        new(pattern: string, options?: IOptions): IMinimatch;\n        prototype: IMinimatch;\n    }\n\n    interface IMinimatch {\n        /**\n         * The original pattern the minimatch object represents.\n         */\n        pattern: string;\n\n        /**\n         * The options supplied to the constructor.\n         */\n        options: IOptions;\n\n        /**\n         * A 2-dimensional array of regexp or string expressions.\n         */\n        set: any[][]; // (RegExp | string)[][]\n\n        /**\n         * A single regular expression expressing the entire pattern.\n         * Created by the makeRe method.\n         */\n        regexp: RegExp;\n\n        /**\n         * True if the pattern is negated.\n         */\n        negate: boolean;\n\n        /**\n         * True if the pattern is a comment.\n         */\n        comment: boolean;\n\n        /**\n         * True if the pattern is \"\"\n         */\n        empty: boolean;\n\n        /**\n         * Generate the regexp member if necessary, and return it.\n         * Will return false if the pattern is invalid.\n         */\n        makeRe(): RegExp; // regexp or boolean\n\n        /**\n         * Return true if the filename matches the pattern, or false otherwise.\n         */\n        match(fname: string): boolean;\n\n        /**\n         * Take a /-split filename, and match it against a single row in the regExpSet.\n         * This method is mainly for internal use, but is exposed so that it can be used\n         * by a glob-walker that needs to avoid excessive filesystem calls.\n         */\n        matchOne(files: string[], pattern: string[], partial: boolean): boolean;\n\n        /**\n         * Deprecated. For internal use.\n         *\n         * @private\n         */\n        debug(): void;\n\n        /**\n         * Deprecated. For internal use.\n         *\n         * @private\n         */\n        make(): void;\n\n        /**\n         * Deprecated. For internal use.\n         *\n         * @private\n         */\n        parseNegate(): void;\n\n        /**\n         * Deprecated. For internal use.\n         *\n         * @private\n         */\n        braceExpand(pattern: string, options: IOptions): void;\n\n        /**\n         * Deprecated. For internal use.\n         *\n         * @private\n         */\n        parse(pattern: string, isSub?: boolean): void;\n    }\n}\n\nexport = M;\n","type":2},{"name":"node_modules/@types/platform/index.d.ts","text":"// Type definitions for Platform 1.3\n// Project: https://github.com/bestiejs/platform.js\n// Definitions by: Jake Hickman <https://github.com/JakeH>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\ndeclare interface Platform {\n    description?: string;\n    layout?: string;\n    manufacturer?: string;\n    name?: string;\n    prerelease?: string;\n    product?: string;\n    ua?: string;\n    version?: string;\n    os?: {\n        architecture?: number;\n        family?: string;\n        version?: string;\n        toString(): string;\n    };\n    parse?(ua: string): Platform;\n    toString?(): string;\n}\n\ndeclare var platform: Platform;\n\ndeclare module \"platform\" {\n    export = platform;\n}\n\n","type":2},{"name":"node_modules/@types/resolve/index.d.ts","text":"// Type definitions for resolve\n// Project: https://github.com/substack/node-resolve\n// Definitions by: Mario Nebl <https://github.com/marionebl>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n/// <reference types=\"node\" />\n\n/**\n * Callback invoked when resolving asynchronously\n *\n * @param error\n * @param resolved Absolute path to resolved identifier\n */\ntype resolveCallback = (err: Error, resolved?: string) => void;\n\n/**\n * Callback invoked when checking if a file exists\n *\n * @param error\n * @param isFile If the given file exists\n */\ntype isFileCallback = (err: Error, isFile?: boolean) => void;\n\n/**\n * Callback invoked when reading a file\n *\n * @param error\n * @param isFile If the given file exists\n */\ntype readFileCallback = (err: Error, file?: Buffer) => void;\n\n/**\n * Asynchronously resolve the module path string id into cb(err, res [, pkg]), where pkg (if defined) is the data from package.json\n *\n * @param id Identifier to resolve\n * @param callback\n */\ndeclare function resolve(id: string, cb: resolveCallback): void;\n\n/**\n * Asynchronously resolve the module path string id into cb(err, res [, pkg]), where pkg (if defined) is the data from package.json\n *\n * @param id Identifier to resolve\n * @param options Options to use for resolving, optional.\n * @param callback\n */\ndeclare function resolve(id: string, opts: resolve.AsyncOpts, cb: resolveCallback): void;\n\n/**\n * Synchronously resolve the module path string id, returning the result and throwing an error when id can't be resolved.\n *\n * @param id Identifier to resolve\n * @param options Options to use for resolving, optional.\n */\ndeclare function resolveSync(id: string, opts?: resolve.SyncOpts): string;\n\n/**\n * Return whether a package is in core\n *\n * @param id\n */\ndeclare function resolveIsCore(id: string): boolean;\n\ndeclare namespace resolve {\n  interface Opts {\n    // directory to begin resolving from (defaults to __dirname)\n    basedir?: string;\n    // package.json data applicable to the module being loaded\n    package?: any;\n    // array of file extensions to search in order (defaults to ['.js'])\n    extensions?: string | string[];\n    // transform the parsed package.json contents before looking at the \"main\" field\n    packageFilter?: (pkg: any, pkgfile: string) => any;\n    // transform a path within a package\n    pathFilter?: (pkg: any, path: string, relativePath: string) => string;\n    // require.paths array to use if nothing is found on the normal node_modules recursive walk (probably don't use this)\n    paths?: string | string[];\n    // directory (or directories) in which to recursively look for modules. (default to 'node_modules')\n    moduleDirectory?: string | string[]\n  }\n\n  export interface AsyncOpts extends Opts {\n    // how to read files asynchronously (defaults to fs.readFile)\n    readFile?: (file: string, cb: readFileCallback) => void;\n    // function to asynchronously test whether a file exists\n    isFile?: (file: string, cb: isFileCallback) => void;\n  }\n\n  export interface SyncOpts extends Opts {\n    // how to read files synchronously (defaults to fs.readFileSync)\n    readFileSync?: (file: string) => Buffer;\n    // function to synchronously test whether a file exists\n    isFile?: (file: string) => boolean;\n  }\n\n  export var sync: typeof resolveSync;\n  export var isCore: typeof resolveIsCore;\n}\n\nexport = resolve;\n","type":2},{"name":"node_modules/@types/serve-static/index.d.ts","text":"// Type definitions for serve-static 1.13\r\n// Project: https://github.com/expressjs/serve-static\r\n// Definitions by: Uros Smolnik <https://github.com/urossmolnik>\r\n//                 Linus Unnebäck <https://github.com/LinusU>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n// TypeScript Version: 2.2\r\n\r\n/* =================== USAGE ===================\r\n\r\n    import * as serveStatic from \"serve-static\";\r\n    app.use(serveStatic(\"public/ftp\", {\"index\": [\"default.html\", \"default.htm\"]}))\r\n\r\n =============================================== */\r\n\r\n/// <reference types=\"express-serve-static-core\" />\r\n\r\nimport * as express from \"express-serve-static-core\";\r\nimport * as m from \"mime\";\r\n\r\n/**\r\n * Create a new middleware function to serve files from within a given root directory.\r\n * The file to serve will be determined by combining req.url with the provided root directory.\r\n * When a file is not found, instead of sending a 404 response, this module will instead call next() to move on to the next middleware, allowing for stacking and fall-backs.\r\n */\r\ndeclare function serveStatic(root: string, options?: serveStatic.ServeStaticOptions): express.Handler;\r\n\r\ndeclare namespace serveStatic {\r\n    var mime: typeof m;\r\n    interface ServeStaticOptions {\r\n        /**\r\n         * Set how \"dotfiles\" are treated when encountered. A dotfile is a file or directory that begins with a dot (\".\").\r\n         * Note this check is done on the path itself without checking if the path actually exists on the disk.\r\n         * If root is specified, only the dotfiles above the root are checked (i.e. the root itself can be within a dotfile when when set to \"deny\").\r\n         * The default value is 'ignore'.\r\n         * 'allow' No special treatment for dotfiles\r\n         * 'deny' Send a 403 for any request for a dotfile\r\n         * 'ignore' Pretend like the dotfile does not exist and call next()\r\n         */\r\n        dotfiles?: string;\r\n\r\n        /**\r\n         * Enable or disable etag generation, defaults to true.\r\n         */\r\n        etag?: boolean;\r\n\r\n        /**\r\n         * Set file extension fallbacks. When set, if a file is not found, the given extensions will be added to the file name and search for.\r\n         * The first that exists will be served. Example: ['html', 'htm'].\r\n         * The default value is false.\r\n         */\r\n        extensions?: string[];\r\n\r\n        /**\r\n         * Let client errors fall-through as unhandled requests, otherwise forward a client error.\r\n         * The default value is false.\r\n         */\r\n        fallthrough?: boolean;\r\n\r\n        /**\r\n         * Enable or disable the immutable directive in the Cache-Control response header.\r\n         * If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.\r\n         */\r\n        immutable?: boolean;\r\n\r\n        /**\r\n         * By default this module will send \"index.html\" files in response to a request on a directory.\r\n         * To disable this set false or to supply a new index pass a string or an array in preferred order.\r\n         */\r\n        index?: boolean | string | string[];\r\n\r\n        /**\r\n         * Enable or disable Last-Modified header, defaults to true. Uses the file system's last modified value.\r\n         */\r\n        lastModified?: boolean;\r\n\r\n        /**\r\n         * Provide a max-age in milliseconds for http caching, defaults to 0. This can also be a string accepted by the ms module.\r\n         */\r\n        maxAge?: number | string;\r\n\r\n        /**\r\n         * Redirect to trailing \"/\" when the pathname is a dir. Defaults to true.\r\n         */\r\n        redirect?: boolean;\r\n\r\n        /**\r\n         * Function to set custom headers on response. Alterations to the headers need to occur synchronously.\r\n         * The function is called as fn(res, path, stat), where the arguments are:\r\n         * res the response object\r\n         * path the file path that is being sent\r\n         * stat the stat object of the file that is being sent\r\n         */\r\n        setHeaders?: (res: express.Response, path: string, stat: any) => any;\r\n    }\r\n    function serveStatic(root: string, options?: ServeStaticOptions): express.Handler;\r\n}\r\n\r\nexport = serveStatic;\r\n","type":2},{"name":"node_modules/@types/node/index.d.ts","text":"// Type definitions for Node.js v6.x\r\n// Project: http://nodejs.org/\r\n// Definitions by: Microsoft TypeScript <http://typescriptlang.org>\r\n//                 DefinitelyTyped <https://github.com/DefinitelyTyped/DefinitelyTyped>\r\n//                 Wilco Bakker <https://github.com/WilcoBakker>\r\n//                 Thomas Bouldin <https://github.com/inlined>\r\n//                 Sebastian Silbermann <https://github.com/eps1lon>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n\r\n/************************************************\r\n*                                               *\r\n*               Node.js v6.x API                *\r\n*                                               *\r\n************************************************/\r\n\r\n// This needs to be global to avoid TS2403 in case lib.dom.d.ts is present in the same build\r\ninterface Console {\r\n    Console: typeof NodeJS.Console;\r\n    assert(value: any, message?: string, ...optionalParams: any[]): void;\r\n    dir(obj: any, options?: NodeJS.InspectOptions): void;\r\n    error(message?: any, ...optionalParams: any[]): void;\r\n    info(message?: any, ...optionalParams: any[]): void;\r\n    log(message?: any, ...optionalParams: any[]): void;\r\n    time(label: string): void;\r\n    timeEnd(label: string): void;\r\n    trace(message?: any, ...optionalParams: any[]): void;\r\n    warn(message?: any, ...optionalParams: any[]): void;\r\n}\r\n\r\ninterface Error {\r\n    stack?: string;\r\n}\r\n\r\n// Declare \"static\" methods in Error\r\ninterface ErrorConstructor {\r\n    /** Create .stack property on a target object */\r\n    captureStackTrace(targetObject: Object, constructorOpt?: Function): void;\r\n\r\n    /**\r\n     * Optional override for formatting stack traces\r\n     *\r\n     * @see https://github.com/v8/v8/wiki/Stack%20Trace%20API#customizing-stack-traces\r\n     */\r\n    prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;\r\n\r\n    stackTraceLimit: number;\r\n}\r\n\r\n// compat for TypeScript 1.8\r\n// if you use with --target es3 or --target es5 and use below definitions,\r\n// use the lib.es6.d.ts that is bundled with TypeScript 1.8.\r\ninterface MapConstructor { }\r\ninterface WeakMapConstructor { }\r\ninterface SetConstructor { }\r\ninterface WeakSetConstructor { }\r\n\r\n/************************************************\r\n*                                               *\r\n*                   GLOBAL                      *\r\n*                                               *\r\n************************************************/\r\ndeclare var process: NodeJS.Process;\r\ndeclare var global: NodeJS.Global;\r\ndeclare var console: Console;\r\n\r\ndeclare var __filename: string;\r\ndeclare var __dirname: string;\r\n\r\ndeclare function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timer;\r\ndeclare function clearTimeout(timeoutId: NodeJS.Timer): void;\r\ndeclare function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timer;\r\ndeclare function clearInterval(intervalId: NodeJS.Timer): void;\r\ndeclare function setImmediate(callback: (...args: any[]) => void, ...args: any[]): any;\r\ndeclare function clearImmediate(immediateId: any): void;\r\n\r\ninterface NodeRequireFunction {\r\n    (id: string): any;\r\n}\r\n\r\ninterface NodeRequire extends NodeRequireFunction {\r\n    resolve(id: string): string;\r\n    cache: any;\r\n    extensions: any;\r\n    main: NodeModule | undefined;\r\n}\r\n\r\ndeclare var require: NodeRequire;\r\n\r\ninterface NodeModule {\r\n    exports: any;\r\n    require: NodeRequireFunction;\r\n    id: string;\r\n    filename: string;\r\n    loaded: boolean;\r\n    parent: NodeModule | null;\r\n    children: NodeModule[];\r\n}\r\n\r\ndeclare var module: NodeModule;\r\n\r\n// Same as module.exports\r\ndeclare var exports: any;\r\ndeclare var SlowBuffer: {\r\n    new (str: string, encoding?: string): Buffer;\r\n    new (size: number): Buffer;\r\n    new (size: Uint8Array): Buffer;\r\n    new (array: any[]): Buffer;\r\n    prototype: Buffer;\r\n    isBuffer(obj: any): boolean;\r\n    byteLength(string: string, encoding?: string): number;\r\n    concat(list: Buffer[], totalLength?: number): Buffer;\r\n};\r\n\r\n\r\n// Buffer class\r\ntype BufferEncoding = \"ascii\" | \"utf8\" | \"utf16le\" | \"ucs2\" | \"base64\" | \"latin1\" | \"binary\" | \"hex\";\r\ninterface Buffer extends NodeBuffer { }\r\n\r\n/**\r\n * Raw data is stored in instances of the Buffer class.\r\n * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.\r\n * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\r\n */\r\ndeclare var Buffer: {\r\n    /**\r\n     * Allocates a new buffer containing the given {str}.\r\n     *\r\n     * @param str String to store in buffer.\r\n     * @param encoding encoding to use, optional.  Default is 'utf8'\r\n     */\r\n    new (str: string, encoding?: string): Buffer;\r\n    /**\r\n     * Allocates a new buffer of {size} octets.\r\n     *\r\n     * @param size count of octets to allocate.\r\n     */\r\n    new (size: number): Buffer;\r\n    /**\r\n     * Allocates a new buffer containing the given {array} of octets.\r\n     *\r\n     * @param array The octets to store.\r\n     */\r\n    new (array: Uint8Array): Buffer;\r\n    /**\r\n     * Produces a Buffer backed by the same allocated memory as\r\n     * the given {ArrayBuffer}.\r\n     *\r\n     *\r\n     * @param arrayBuffer The ArrayBuffer with which to share memory.\r\n     */\r\n    new (arrayBuffer: ArrayBuffer): Buffer;\r\n    /**\r\n     * Allocates a new buffer containing the given {array} of octets.\r\n     *\r\n     * @param array The octets to store.\r\n     */\r\n    new (array: any[]): Buffer;\r\n    /**\r\n     * Copies the passed {buffer} data onto a new {Buffer} instance.\r\n     *\r\n     * @param buffer The buffer to copy.\r\n     */\r\n    new (buffer: Buffer): Buffer;\r\n    prototype: Buffer;\r\n    /**\r\n     * Allocates a new Buffer using an {array} of octets.\r\n     */\r\n    from(array: any[]): Buffer;\r\n    /**\r\n     * When passed a reference to the .buffer property of a TypedArray instance,\r\n     * the newly created Buffer will share the same allocated memory as the TypedArray.\r\n     * The optional {byteOffset} and {length} arguments specify a memory range\r\n     * within the {arrayBuffer} that will be shared by the Buffer.\r\n     *\r\n     * @param arrayBuffer The .buffer property of a TypedArray or a new ArrayBuffer()\r\n     */\r\n    from(arrayBuffer: ArrayBuffer, byteOffset?: number, length?: number): Buffer;\r\n    /**\r\n     * Copies the passed {buffer} data onto a new Buffer instance.\r\n     */\r\n    from(buffer: Buffer): Buffer;\r\n    /**\r\n     * Creates a new Buffer containing the given JavaScript string {str}.\r\n     * If provided, the {encoding} parameter identifies the character encoding.\r\n     * If not provided, {encoding} defaults to 'utf8'.\r\n     */\r\n    from(str: string, encoding?: string): Buffer;\r\n    /**\r\n     * Returns true if {obj} is a Buffer\r\n     *\r\n     * @param obj object to test.\r\n     */\r\n    isBuffer(obj: any): obj is Buffer;\r\n    /**\r\n     * Returns true if {encoding} is a valid encoding argument.\r\n     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\r\n     *\r\n     * @param encoding string to test.\r\n     */\r\n    isEncoding(encoding: string): boolean;\r\n    /**\r\n     * Gives the actual byte length of a string. encoding defaults to 'utf8'.\r\n     * This is not the same as String.prototype.length since that returns the number of characters in a string.\r\n     *\r\n     * @param string string to test.\r\n     * @param encoding encoding used to evaluate (defaults to 'utf8')\r\n     */\r\n    byteLength(string: string, encoding?: string): number;\r\n    /**\r\n     * Returns a buffer which is the result of concatenating all the buffers in the list together.\r\n     *\r\n     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.\r\n     * If the list has exactly one item, then the first item of the list is returned.\r\n     * If the list has more than one item, then a new Buffer is created.\r\n     *\r\n     * @param list An array of Buffer objects to concatenate\r\n     * @param totalLength Total length of the buffers when concatenated.\r\n     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.\r\n     */\r\n    concat(list: Buffer[], totalLength?: number): Buffer;\r\n    /**\r\n     * The same as buf1.compare(buf2).\r\n     */\r\n    compare(buf1: Buffer, buf2: Buffer): number;\r\n    /**\r\n     * Allocates a new buffer of {size} octets.\r\n     *\r\n     * @param size count of octets to allocate.\r\n     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).\r\n     *    If parameter is omitted, buffer will be filled with zeros.\r\n     * @param encoding encoding used for call to buf.fill while initalizing\r\n     */\r\n    alloc(size: number, fill?: string | Buffer | number, encoding?: string): Buffer;\r\n    /**\r\n     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents\r\n     * of the newly created Buffer are unknown and may contain sensitive data.\r\n     *\r\n     * @param size count of octets to allocate\r\n     */\r\n    allocUnsafe(size: number): Buffer;\r\n    /**\r\n     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents\r\n     * of the newly created Buffer are unknown and may contain sensitive data.\r\n     *\r\n     * @param size count of octets to allocate\r\n     */\r\n    allocUnsafeSlow(size: number): Buffer;\r\n};\r\n\r\n/************************************************\r\n*                                               *\r\n*               GLOBAL INTERFACES               *\r\n*                                               *\r\n************************************************/\r\ndeclare namespace NodeJS {\r\n    export interface InspectOptions {\r\n        showHidden?: boolean;\r\n        depth?: number | null;\r\n        colors?: boolean;\r\n        customInspect?: boolean;\r\n        showProxy?: boolean;\r\n        maxArrayLength?: number | null;\r\n        breakLength?: number;\r\n    }\r\n\r\n    export var Console: {\r\n        prototype: Console;\r\n        new(stdout: WritableStream, stderr?: WritableStream): Console;\r\n    }\r\n\r\n    export interface CallSite {\r\n        /**\r\n         * Value of \"this\"\r\n         */\r\n        getThis(): any;\r\n\r\n        /**\r\n         * Type of \"this\" as a string.\r\n         * This is the name of the function stored in the constructor field of\r\n         * \"this\", if available.  Otherwise the object's [[Class]] internal\r\n         * property.\r\n         */\r\n        getTypeName(): string | null;\r\n\r\n        /**\r\n         * Current function\r\n         */\r\n        getFunction(): Function | undefined;\r\n\r\n        /**\r\n         * Name of the current function, typically its name property.\r\n         * If a name property is not available an attempt will be made to try\r\n         * to infer a name from the function's context.\r\n         */\r\n        getFunctionName(): string | null;\r\n\r\n        /**\r\n         * Name of the property [of \"this\" or one of its prototypes] that holds\r\n         * the current function\r\n         */\r\n        getMethodName(): string | null;\r\n\r\n        /**\r\n         * Name of the script [if this function was defined in a script]\r\n         */\r\n        getFileName(): string | null;\r\n\r\n        /**\r\n         * Current line number [if this function was defined in a script]\r\n         */\r\n        getLineNumber(): number | null;\r\n\r\n        /**\r\n         * Current column number [if this function was defined in a script]\r\n         */\r\n        getColumnNumber(): number | null;\r\n\r\n        /**\r\n         * A call site object representing the location where eval was called\r\n         * [if this function was created using a call to eval]\r\n         */\r\n        getEvalOrigin(): string | undefined;\r\n\r\n        /**\r\n         * Is this a toplevel invocation, that is, is \"this\" the global object?\r\n         */\r\n        isToplevel(): boolean;\r\n\r\n        /**\r\n         * Does this call take place in code defined by a call to eval?\r\n         */\r\n        isEval(): boolean;\r\n\r\n        /**\r\n         * Is this call in native V8 code?\r\n         */\r\n        isNative(): boolean;\r\n\r\n        /**\r\n         * Is this a constructor call?\r\n         */\r\n        isConstructor(): boolean;\r\n    }\r\n\r\n    export interface ErrnoException extends Error {\r\n        errno?: number;\r\n        code?: string;\r\n        path?: string;\r\n        syscall?: string;\r\n        stack?: string;\r\n    }\r\n\r\n    export class EventEmitter {\r\n        addListener(event: string | symbol, listener: Function): this;\r\n        on(event: string | symbol, listener: Function): this;\r\n        once(event: string | symbol, listener: Function): this;\r\n        removeListener(event: string | symbol, listener: Function): this;\r\n        removeAllListeners(event?: string | symbol): this;\r\n        setMaxListeners(n: number): this;\r\n        getMaxListeners(): number;\r\n        listeners(event: string | symbol): Function[];\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        listenerCount(type: string | symbol): number;\r\n        // Added in Node 6...\r\n        prependListener(event: string | symbol, listener: Function): this;\r\n        prependOnceListener(event: string | symbol, listener: Function): this;\r\n        eventNames(): (string | symbol)[];\r\n    }\r\n\r\n    export interface ReadableStream extends EventEmitter {\r\n        readable: boolean;\r\n        read(size?: number): string | Buffer;\r\n        setEncoding(encoding: string | null): void;\r\n        pause(): this;\r\n        resume(): this;\r\n        isPaused(): boolean;\r\n        pipe<T extends WritableStream>(destination: T, options?: { end?: boolean; }): T;\r\n        unpipe<T extends WritableStream>(destination?: T): void;\r\n        unshift(chunk: string): void;\r\n        unshift(chunk: Buffer): void;\r\n        wrap(oldStream: ReadableStream): ReadableStream;\r\n    }\r\n\r\n    export interface WritableStream extends EventEmitter {\r\n        writable: boolean;\r\n        write(buffer: Buffer | string, cb?: Function): boolean;\r\n        write(str: string, encoding?: string, cb?: Function): boolean;\r\n        end(cb?: Function): void;\r\n        end(buffer: Buffer, cb?: Function): void;\r\n        end(str: string, cb?: Function): void;\r\n        end(str: string, encoding?: string, cb?: Function): void;\r\n    }\r\n\r\n    export interface ReadWriteStream extends ReadableStream, WritableStream {}\r\n\r\n    export interface Events extends EventEmitter { }\r\n\r\n    export interface Domain extends Events {\r\n        run(fn: Function): void;\r\n        add(emitter: Events): void;\r\n        remove(emitter: Events): void;\r\n        bind(cb: (err: Error, data: any) => any): any;\r\n        intercept(cb: (data: any) => any): any;\r\n        dispose(): void;\r\n\r\n        addListener(event: string, listener: Function): this;\r\n        on(event: string, listener: Function): this;\r\n        once(event: string, listener: Function): this;\r\n        removeListener(event: string, listener: Function): this;\r\n        removeAllListeners(event?: string): this;\r\n    }\r\n\r\n    export interface MemoryUsage {\r\n        rss: number;\r\n        heapTotal: number;\r\n        heapUsed: number;\r\n    }\r\n\r\n    export interface CpuUsage {\r\n        user: number;\r\n        system: number;\r\n    }\r\n\r\n    export interface ProcessVersions {\r\n        http_parser: string;\r\n        node: string;\r\n        v8: string;\r\n        ares: string;\r\n        uv: string;\r\n        zlib: string;\r\n        modules: string;\r\n        openssl: string;\r\n    }\r\n\r\n    type Platform = 'aix'\r\n                  | 'android'\r\n                  | 'darwin'\r\n                  | 'freebsd'\r\n                  | 'linux'\r\n                  | 'openbsd'\r\n                  | 'sunos'\r\n                  | 'win32';\r\n\r\n    export interface Socket extends ReadWriteStream {\r\n        isTTY?: true;\r\n    }\r\n\r\n    export interface WriteStream extends Socket {\r\n        columns?: number;\r\n        rows?: number;\r\n    }\r\n    export interface ReadStream extends Socket {\r\n        isRaw?: boolean;\r\n        setRawMode?(mode: boolean): void;\r\n    }\r\n\r\n    export interface Process extends EventEmitter {\r\n        stdout: WriteStream;\r\n        stderr: WriteStream;\r\n        stdin: ReadStream;\r\n        argv: string[];\r\n        argv0: string;\r\n        execArgv: string[];\r\n        execPath: string;\r\n        abort(): void;\r\n        chdir(directory: string): void;\r\n        cwd(): string;\r\n        emitWarning(warning: string | Error, name?: string, ctor?: Function): void;\r\n        env: any;\r\n        exit(code?: number): void;\r\n        exitCode: number;\r\n        getgid(): number;\r\n        setgid(id: number): void;\r\n        setgid(id: string): void;\r\n        getuid(): number;\r\n        setuid(id: number): void;\r\n        setuid(id: string): void;\r\n        version: string;\r\n        versions: ProcessVersions;\r\n        config: {\r\n            target_defaults: {\r\n                cflags: any[];\r\n                default_configuration: string;\r\n                defines: string[];\r\n                include_dirs: string[];\r\n                libraries: string[];\r\n            };\r\n            variables: {\r\n                clang: number;\r\n                host_arch: string;\r\n                node_install_npm: boolean;\r\n                node_install_waf: boolean;\r\n                node_prefix: string;\r\n                node_shared_openssl: boolean;\r\n                node_shared_v8: boolean;\r\n                node_shared_zlib: boolean;\r\n                node_use_dtrace: boolean;\r\n                node_use_etw: boolean;\r\n                node_use_openssl: boolean;\r\n                target_arch: string;\r\n                v8_no_strict_aliasing: number;\r\n                v8_use_snapshot: boolean;\r\n                visibility: string;\r\n            };\r\n        };\r\n        kill(pid: number, signal?: string | number): void;\r\n        pid: number;\r\n        title: string;\r\n        arch: string;\r\n        platform: Platform;\r\n        mainModule?: NodeModule;\r\n        memoryUsage(): MemoryUsage;\r\n        cpuUsage(previousValue?: CpuUsage): CpuUsage;\r\n        nextTick(callback: Function, ...args: any[]): void;\r\n        umask(mask?: number): number;\r\n        uptime(): number;\r\n        hrtime(time?: [number, number]): [number, number];\r\n        domain: Domain;\r\n\r\n        // Worker\r\n        send?(message: any, sendHandle?: any): void;\r\n        disconnect(): void;\r\n        connected: boolean;\r\n    }\r\n\r\n    export interface Global {\r\n        Array: typeof Array;\r\n        ArrayBuffer: typeof ArrayBuffer;\r\n        Boolean: typeof Boolean;\r\n        Buffer: typeof Buffer;\r\n        DataView: typeof DataView;\r\n        Date: typeof Date;\r\n        Error: typeof Error;\r\n        EvalError: typeof EvalError;\r\n        Float32Array: typeof Float32Array;\r\n        Float64Array: typeof Float64Array;\r\n        Function: typeof Function;\r\n        GLOBAL: Global;\r\n        Infinity: typeof Infinity;\r\n        Int16Array: typeof Int16Array;\r\n        Int32Array: typeof Int32Array;\r\n        Int8Array: typeof Int8Array;\r\n        Intl: typeof Intl;\r\n        JSON: typeof JSON;\r\n        Map: MapConstructor;\r\n        Math: typeof Math;\r\n        NaN: typeof NaN;\r\n        Number: typeof Number;\r\n        Object: typeof Object;\r\n        Promise: Function;\r\n        RangeError: typeof RangeError;\r\n        ReferenceError: typeof ReferenceError;\r\n        RegExp: typeof RegExp;\r\n        Set: SetConstructor;\r\n        String: typeof String;\r\n        Symbol: Function;\r\n        SyntaxError: typeof SyntaxError;\r\n        TypeError: typeof TypeError;\r\n        URIError: typeof URIError;\r\n        Uint16Array: typeof Uint16Array;\r\n        Uint32Array: typeof Uint32Array;\r\n        Uint8Array: typeof Uint8Array;\r\n        Uint8ClampedArray: Function;\r\n        WeakMap: WeakMapConstructor;\r\n        WeakSet: WeakSetConstructor;\r\n        clearImmediate: (immediateId: any) => void;\r\n        clearInterval: (intervalId: NodeJS.Timer) => void;\r\n        clearTimeout: (timeoutId: NodeJS.Timer) => void;\r\n        console: typeof console;\r\n        decodeURI: typeof decodeURI;\r\n        decodeURIComponent: typeof decodeURIComponent;\r\n        encodeURI: typeof encodeURI;\r\n        encodeURIComponent: typeof encodeURIComponent;\r\n        escape: (str: string) => string;\r\n        eval: typeof eval;\r\n        global: Global;\r\n        isFinite: typeof isFinite;\r\n        isNaN: typeof isNaN;\r\n        parseFloat: typeof parseFloat;\r\n        parseInt: typeof parseInt;\r\n        process: Process;\r\n        root: Global;\r\n        setImmediate: (callback: (...args: any[]) => void, ...args: any[]) => any;\r\n        setInterval: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => NodeJS.Timer;\r\n        setTimeout: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => NodeJS.Timer;\r\n        undefined: typeof undefined;\r\n        unescape: (str: string) => string;\r\n        gc: () => void;\r\n        v8debug?: any;\r\n    }\r\n\r\n    export interface Timer {\r\n        ref(): void;\r\n        unref(): void;\r\n    }\r\n}\r\n\r\ninterface IterableIterator<T> { }\r\n\r\n/**\r\n * @deprecated\r\n */\r\ninterface NodeBuffer extends Uint8Array {\r\n    write(string: string, offset?: number, length?: number, encoding?: string): number;\r\n    toString(encoding?: string, start?: number, end?: number): string;\r\n    toJSON(): { type: 'Buffer', data: any[] };\r\n    equals(otherBuffer: Buffer): boolean;\r\n    compare(otherBuffer: Buffer, targetStart?: number, targetEnd?: number, sourceStart?: number, sourceEnd?: number): number;\r\n    copy(targetBuffer: Buffer, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;\r\n    slice(start?: number, end?: number): Buffer;\r\n    writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\r\n    writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\r\n    writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\r\n    writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\r\n    readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\r\n    readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\r\n    readIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\r\n    readIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\r\n    readUInt8(offset: number, noAssert?: boolean): number;\r\n    readUInt16LE(offset: number, noAssert?: boolean): number;\r\n    readUInt16BE(offset: number, noAssert?: boolean): number;\r\n    readUInt32LE(offset: number, noAssert?: boolean): number;\r\n    readUInt32BE(offset: number, noAssert?: boolean): number;\r\n    readInt8(offset: number, noAssert?: boolean): number;\r\n    readInt16LE(offset: number, noAssert?: boolean): number;\r\n    readInt16BE(offset: number, noAssert?: boolean): number;\r\n    readInt32LE(offset: number, noAssert?: boolean): number;\r\n    readInt32BE(offset: number, noAssert?: boolean): number;\r\n    readFloatLE(offset: number, noAssert?: boolean): number;\r\n    readFloatBE(offset: number, noAssert?: boolean): number;\r\n    readDoubleLE(offset: number, noAssert?: boolean): number;\r\n    readDoubleBE(offset: number, noAssert?: boolean): number;\r\n    swap16(): Buffer;\r\n    swap32(): Buffer;\r\n    swap64(): Buffer;\r\n    writeUInt8(value: number, offset: number, noAssert?: boolean): number;\r\n    writeUInt16LE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeUInt16BE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeUInt32LE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeUInt32BE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeInt8(value: number, offset: number, noAssert?: boolean): number;\r\n    writeInt16LE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeInt16BE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeInt32LE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeInt32BE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeFloatLE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeFloatBE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeDoubleLE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeDoubleBE(value: number, offset: number, noAssert?: boolean): number;\r\n    fill(value: any, offset?: number, end?: number): this;\r\n    indexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;\r\n    lastIndexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;\r\n    entries(): IterableIterator<[number, number]>;\r\n    includes(value: string | number | Buffer, byteOffset?: number, encoding?: string): boolean;\r\n    keys(): IterableIterator<number>;\r\n    values(): IterableIterator<number>;\r\n}\r\n\r\n/************************************************\r\n*                                               *\r\n*                   MODULES                     *\r\n*                                               *\r\n************************************************/\r\ndeclare module \"buffer\" {\r\n    export var INSPECT_MAX_BYTES: number;\r\n    var BuffType: typeof Buffer;\r\n    var SlowBuffType: typeof SlowBuffer;\r\n    export { BuffType as Buffer, SlowBuffType as SlowBuffer };\r\n}\r\n\r\ndeclare module \"querystring\" {\r\n    export interface StringifyOptions {\r\n        encodeURIComponent?: Function;\r\n    }\r\n\r\n    export interface ParseOptions {\r\n        maxKeys?: number;\r\n        decodeURIComponent?: Function;\r\n    }\r\n\r\n    export function stringify<T>(obj: T, sep?: string, eq?: string, options?: StringifyOptions): string;\r\n    export function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): any;\r\n    export function parse<T extends {}>(str: string, sep?: string, eq?: string, options?: ParseOptions): T;\r\n    export function escape(str: string): string;\r\n    export function unescape(str: string): string;\r\n}\r\n\r\ndeclare module \"events\" {\r\n    class internal extends NodeJS.EventEmitter { }\r\n\r\n    namespace internal {\r\n        export class EventEmitter extends internal {\r\n            static listenerCount(emitter: EventEmitter, event: string | symbol): number; // deprecated\r\n            static defaultMaxListeners: number;\r\n\r\n            addListener(event: string | symbol, listener: Function): this;\r\n            on(event: string | symbol, listener: Function): this;\r\n            once(event: string | symbol, listener: Function): this;\r\n            prependListener(event: string | symbol, listener: Function): this;\r\n            prependOnceListener(event: string | symbol, listener: Function): this;\r\n            removeListener(event: string | symbol, listener: Function): this;\r\n            removeAllListeners(event?: string | symbol): this;\r\n            setMaxListeners(n: number): this;\r\n            getMaxListeners(): number;\r\n            listeners(event: string | symbol): Function[];\r\n            emit(event: string | symbol, ...args: any[]): boolean;\r\n            eventNames(): (string | symbol)[];\r\n            listenerCount(type: string | symbol): number;\r\n        }\r\n    }\r\n\r\n    export = internal;\r\n}\r\n\r\ndeclare module \"http\" {\r\n    import * as events from \"events\";\r\n    import * as net from \"net\";\r\n    import * as stream from \"stream\";\r\n\r\n    // incoming headers will never contain number\r\n    export interface IncomingHttpHeaders {\r\n        'accept'?: string;\r\n        'access-control-allow-origin'?: string;\r\n        'access-control-allow-credentials'?: string;\r\n        'access-control-expose-headers'?: string;\r\n        'access-control-max-age'?: string;\r\n        'access-control-allow-methods'?: string;\r\n        'access-control-allow-headers'?: string;\r\n        'accept-patch'?: string;\r\n        'accept-ranges'?: string;\r\n        'age'?: string;\r\n        'allow'?: string;\r\n        'alt-svc'?: string;\r\n        'cache-control'?: string;\r\n        'connection'?: string;\r\n        'content-disposition'?: string;\r\n        'content-encoding'?: string;\r\n        'content-language'?: string;\r\n        'content-length'?: string;\r\n        'content-location'?: string;\r\n        'content-range'?: string;\r\n        'content-type'?: string;\r\n        'date'?: string;\r\n        'expires'?: string;\r\n        'host'?: string;\r\n        'last-modified'?: string;\r\n        'location'?: string;\r\n        'pragma'?: string;\r\n        'proxy-authenticate'?: string;\r\n        'public-key-pins'?: string;\r\n        'retry-after'?: string;\r\n        'set-cookie'?: string[];\r\n        'strict-transport-security'?: string;\r\n        'trailer'?: string;\r\n        'transfer-encoding'?: string;\r\n        'tk'?: string;\r\n        'upgrade'?: string;\r\n        'vary'?: string;\r\n        'via'?: string;\r\n        'warning'?: string;\r\n        'www-authenticate'?: string;\r\n        [header: string]: string | string[] | undefined;\r\n    }\r\n\r\n    // outgoing headers allows numbers (as they are converted internally to strings)\r\n    export interface OutgoingHttpHeaders {\r\n        [header: string]: number | string | string[] | undefined;\r\n    }\r\n\r\n    export interface RequestOptions {\r\n        protocol?: string;\r\n        host?: string;\r\n        hostname?: string;\r\n        family?: number;\r\n        port?: number | string;\r\n        localAddress?: string;\r\n        socketPath?: string;\r\n        method?: string;\r\n        path?: string;\r\n        headers?: OutgoingHttpHeaders;\r\n        auth?: string;\r\n        agent?: Agent | boolean;\r\n        timeout?: number;\r\n    }\r\n\r\n    export type ClientRequestArgs = RequestOptions\r\n\r\n    export interface Server extends net.Server {\r\n        setTimeout(msecs: number, callback: Function): void;\r\n        maxHeadersCount: number;\r\n        timeout: number;\r\n        listening: boolean;\r\n    }\r\n    /**\r\n     * @deprecated Use IncomingMessage\r\n     */\r\n    export interface ServerRequest extends IncomingMessage {\r\n        connection: net.Socket;\r\n    }\r\n    export interface ServerResponse extends stream.Writable {\r\n        // Extended base methods\r\n        write(buffer: Buffer): boolean;\r\n        write(buffer: Buffer, cb?: Function): boolean;\r\n        write(str: string, cb?: Function): boolean;\r\n        write(str: string, encoding?: string, cb?: Function): boolean;\r\n        write(str: string, encoding?: string, fd?: string): boolean;\r\n\r\n        writeContinue(): void;\r\n        writeHead(statusCode: number, reasonPhrase?: string, headers?: OutgoingHttpHeaders): void;\r\n        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): void;\r\n        statusCode: number;\r\n        statusMessage: string;\r\n        headersSent: boolean;\r\n        setHeader(name: string, value: string | string[]): void;\r\n        setTimeout(msecs: number, callback: Function): ServerResponse;\r\n        sendDate: boolean;\r\n        getHeader(name: string): string;\r\n        removeHeader(name: string): void;\r\n        write(chunk: any, encoding?: string): any;\r\n        addTrailers(headers: OutgoingHttpHeaders): void;\r\n        finished: boolean;\r\n\r\n        // Extended base methods\r\n        end(): void;\r\n        end(buffer: Buffer, cb?: Function): void;\r\n        end(str: string, cb?: Function): void;\r\n        end(str: string, encoding?: string, cb?: Function): void;\r\n        end(data?: any, encoding?: string): void;\r\n    }\r\n    export interface ClientRequest extends stream.Writable {\r\n        // Extended base methods\r\n        write(buffer: Buffer): boolean;\r\n        write(buffer: Buffer, cb?: Function): boolean;\r\n        write(str: string, cb?: Function): boolean;\r\n        write(str: string, encoding?: string, cb?: Function): boolean;\r\n        write(str: string, encoding?: string, fd?: string): boolean;\r\n\r\n        write(chunk: any, encoding?: string): void;\r\n        abort(): void;\r\n        setTimeout(timeout: number, callback?: Function): void;\r\n        setNoDelay(noDelay?: boolean): void;\r\n        setSocketKeepAlive(enable?: boolean, initialDelay?: number): void;\r\n\r\n        setHeader(name: string, value: string | string[]): void;\r\n        getHeader(name: string): string;\r\n        removeHeader(name: string): void;\r\n        addTrailers(headers: OutgoingHttpHeaders): void;\r\n\r\n        // Extended base methods\r\n        end(): void;\r\n        end(buffer: Buffer, cb?: Function): void;\r\n        end(str: string, cb?: Function): void;\r\n        end(str: string, encoding?: string, cb?: Function): void;\r\n        end(data?: any, encoding?: string): void;\r\n    }\r\n    export interface IncomingMessage extends stream.Readable {\r\n        httpVersion: string;\r\n        httpVersionMajor: number;\r\n        httpVersionMinor: number;\r\n        connection: net.Socket;\r\n        headers: IncomingHttpHeaders;\r\n        rawHeaders: string[];\r\n        trailers: OutgoingHttpHeaders;\r\n        rawTrailers: string[];\r\n        setTimeout(msecs: number, callback: Function): NodeJS.Timer;\r\n        /**\r\n         * Only valid for request obtained from http.Server.\r\n         */\r\n        method?: string;\r\n        /**\r\n         * Only valid for request obtained from http.Server.\r\n         */\r\n        url?: string;\r\n        /**\r\n         * Only valid for response obtained from http.ClientRequest.\r\n         */\r\n        statusCode?: number;\r\n        /**\r\n         * Only valid for response obtained from http.ClientRequest.\r\n         */\r\n        statusMessage?: string;\r\n        socket: net.Socket;\r\n        destroy(error?: Error): void;\r\n    }\r\n    /**\r\n     * @deprecated Use IncomingMessage\r\n     */\r\n    export interface ClientResponse extends IncomingMessage { }\r\n\r\n    export interface AgentOptions {\r\n        /**\r\n         * Keep sockets around in a pool to be used by other requests in the future. Default = false\r\n         */\r\n        keepAlive?: boolean;\r\n        /**\r\n         * When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.\r\n         * Only relevant if keepAlive is set to true.\r\n         */\r\n        keepAliveMsecs?: number;\r\n        /**\r\n         * Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity\r\n         */\r\n        maxSockets?: number;\r\n        /**\r\n         * Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256.\r\n         */\r\n        maxFreeSockets?: number;\r\n    }\r\n\r\n    export class Agent {\r\n        maxSockets: number;\r\n        sockets: any;\r\n        requests: any;\r\n\r\n        constructor(opts?: AgentOptions);\r\n\r\n        /**\r\n         * Destroy any sockets that are currently in use by the agent.\r\n         * It is usually not necessary to do this. However, if you are using an agent with KeepAlive enabled,\r\n         * then it is best to explicitly shut down the agent when you know that it will no longer be used. Otherwise,\r\n         * sockets may hang open for quite a long time before the server terminates them.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    export var METHODS: string[];\r\n\r\n    export var STATUS_CODES: {\r\n        [errorCode: number]: string;\r\n        [errorCode: string]: string;\r\n    };\r\n    export function createServer(requestListener?: (request: IncomingMessage, response: ServerResponse) => void): Server;\r\n    export function createClient(port?: number, host?: string): any;\r\n    export function request(options: RequestOptions | string, callback?: (res: IncomingMessage) => void): ClientRequest;\r\n    export function get(options: any, callback?: (res: IncomingMessage) => void): ClientRequest;\r\n    export var globalAgent: Agent;\r\n}\r\n\r\ndeclare module \"cluster\" {\r\n    import * as child from \"child_process\";\r\n    import * as events from \"events\";\r\n    import * as net from \"net\";\r\n\r\n    // interfaces\r\n    export interface ClusterSettings {\r\n        execArgv?: string[]; // default: process.execArgv\r\n        exec?: string;\r\n        args?: string[];\r\n        silent?: boolean;\r\n        stdio?: any[];\r\n        uid?: number;\r\n        gid?: number;\r\n    }\r\n\r\n    export interface ClusterSetupMasterSettings {\r\n        exec?: string;  // default: process.argv[1]\r\n        args?: string[];  // default: process.argv.slice(2)\r\n        silent?: boolean;  // default: false\r\n        stdio?: any[];\r\n    }\r\n\r\n    export interface Address {\r\n        address: string;\r\n        port: number;\r\n        addressType: number | \"udp4\" | \"udp6\";  // 4, 6, -1, \"udp4\", \"udp6\"\r\n    }\r\n\r\n    export class Worker extends events.EventEmitter {\r\n        id: number;\r\n        process: child.ChildProcess;\r\n        suicide: boolean;\r\n        send(message: any, sendHandle?: any, callback?: (error: Error) => void): boolean;\r\n        kill(signal?: string): void;\r\n        destroy(signal?: string): void;\r\n        disconnect(): void;\r\n        isConnected(): boolean;\r\n        isDead(): boolean;\r\n        exitedAfterDisconnect: boolean;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. disconnect\r\n         *   2. error\r\n         *   3. exit\r\n         *   4. listening\r\n         *   5. message\r\n         *   6. online\r\n         */\r\n        addListener(event: string, listener: Function): this;\r\n        addListener(event: \"disconnect\", listener: () => void): this;\r\n        addListener(event: \"error\", listener: (error: Error) => void): this;\r\n        addListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        addListener(event: \"listening\", listener: (address: Address) => void): this;\r\n        addListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        addListener(event: \"online\", listener: () => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"disconnect\", listener: () => void): boolean\r\n        emit(event: \"error\", listener: (error: Error) => void): boolean\r\n        emit(event: \"exit\", listener: (code: number, signal: string) => void): boolean\r\n        emit(event: \"listening\", listener: (address: Address) => void): boolean\r\n        emit(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): boolean\r\n        emit(event: \"online\", listener: () => void): boolean\r\n\r\n        on(event: string, listener: Function): this;\r\n        on(event: \"disconnect\", listener: () => void): this;\r\n        on(event: \"error\", listener: (error: Error) => void): this;\r\n        on(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        on(event: \"listening\", listener: (address: Address) => void): this;\r\n        on(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        on(event: \"online\", listener: () => void): this;\r\n\r\n        once(event: string, listener: Function): this;\r\n        once(event: \"disconnect\", listener: () => void): this;\r\n        once(event: \"error\", listener: (error: Error) => void): this;\r\n        once(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        once(event: \"listening\", listener: (address: Address) => void): this;\r\n        once(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        once(event: \"online\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: Function): this;\r\n        prependListener(event: \"disconnect\", listener: () => void): this;\r\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\r\n        prependListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        prependListener(event: \"listening\", listener: (address: Address) => void): this;\r\n        prependListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        prependListener(event: \"online\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: Function): this;\r\n        prependOnceListener(event: \"disconnect\", listener: () => void): this;\r\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\r\n        prependOnceListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        prependOnceListener(event: \"listening\", listener: (address: Address) => void): this;\r\n        prependOnceListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        prependOnceListener(event: \"online\", listener: () => void): this;\r\n    }\r\n\r\n    export interface Cluster extends events.EventEmitter {\r\n        Worker: Worker;\r\n        disconnect(callback?: Function): void;\r\n        fork(env?: any): Worker;\r\n        isMaster: boolean;\r\n        isWorker: boolean;\r\n        // TODO: cluster.schedulingPolicy\r\n        settings: ClusterSettings;\r\n        setupMaster(settings?: ClusterSetupMasterSettings): void;\r\n        worker: Worker;\r\n        workers: {\r\n            [index: string]: Worker\r\n        };\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. disconnect\r\n         *   2. exit\r\n         *   3. fork\r\n         *   4. listening\r\n         *   5. message\r\n         *   6. online\r\n         *   7. setup\r\n         */\r\n        addListener(event: string, listener: Function): this;\r\n        addListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\r\n        addListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\r\n        addListener(event: \"fork\", listener: (worker: Worker) => void): this;\r\n        addListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\r\n        addListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        addListener(event: \"online\", listener: (worker: Worker) => void): this;\r\n        addListener(event: \"setup\", listener: (settings: any) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"disconnect\", listener: (worker: Worker) => void): boolean;\r\n        emit(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): boolean;\r\n        emit(event: \"fork\", listener: (worker: Worker) => void): boolean;\r\n        emit(event: \"listening\", listener: (worker: Worker, address: Address) => void): boolean;\r\n        emit(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): boolean;\r\n        emit(event: \"online\", listener: (worker: Worker) => void): boolean;\r\n        emit(event: \"setup\", listener: (settings: any) => void): boolean;\r\n\r\n        on(event: string, listener: Function): this;\r\n        on(event: \"disconnect\", listener: (worker: Worker) => void): this;\r\n        on(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\r\n        on(event: \"fork\", listener: (worker: Worker) => void): this;\r\n        on(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\r\n        on(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        on(event: \"online\", listener: (worker: Worker) => void): this;\r\n        on(event: \"setup\", listener: (settings: any) => void): this;\r\n\r\n        once(event: string, listener: Function): this;\r\n        once(event: \"disconnect\", listener: (worker: Worker) => void): this;\r\n        once(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\r\n        once(event: \"fork\", listener: (worker: Worker) => void): this;\r\n        once(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\r\n        once(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        once(event: \"online\", listener: (worker: Worker) => void): this;\r\n        once(event: \"setup\", listener: (settings: any) => void): this;\r\n\r\n        prependListener(event: string, listener: Function): this;\r\n        prependListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\r\n        prependListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\r\n        prependListener(event: \"fork\", listener: (worker: Worker) => void): this;\r\n        prependListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\r\n        prependListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        prependListener(event: \"online\", listener: (worker: Worker) => void): this;\r\n        prependListener(event: \"setup\", listener: (settings: any) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: Function): this;\r\n        prependOnceListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\r\n        prependOnceListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\r\n        prependOnceListener(event: \"fork\", listener: (worker: Worker) => void): this;\r\n        prependOnceListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\r\n        prependOnceListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        prependOnceListener(event: \"online\", listener: (worker: Worker) => void): this;\r\n        prependOnceListener(event: \"setup\", listener: (settings: any) => void): this;\r\n\r\n    }\r\n\r\n    export function disconnect(callback?: Function): void;\r\n    export function fork(env?: any): Worker;\r\n    export var isMaster: boolean;\r\n    export var isWorker: boolean;\r\n    // TODO: cluster.schedulingPolicy\r\n    export var settings: ClusterSettings;\r\n    export function setupMaster(settings?: ClusterSetupMasterSettings): void;\r\n    export var worker: Worker;\r\n    export var workers: {\r\n        [index: string]: Worker\r\n    };\r\n\r\n    /**\r\n     * events.EventEmitter\r\n     *   1. disconnect\r\n     *   2. exit\r\n     *   3. fork\r\n     *   4. listening\r\n     *   5. message\r\n     *   6. online\r\n     *   7. setup\r\n     */\r\n    export function addListener(event: string, listener: Function): Cluster;\r\n    export function addListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\r\n    export function addListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\r\n    export function addListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\r\n    export function addListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\r\n    export function addListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\r\n    export function addListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\r\n    export function addListener(event: \"setup\", listener: (settings: any) => void): Cluster;\r\n\r\n    export function emit(event: string | symbol, ...args: any[]): boolean;\r\n    export function emit(event: \"disconnect\", listener: (worker: Worker) => void): boolean;\r\n    export function emit(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): boolean;\r\n    export function emit(event: \"fork\", listener: (worker: Worker) => void): boolean;\r\n    export function emit(event: \"listening\", listener: (worker: Worker, address: Address) => void): boolean;\r\n    export function emit(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): boolean;\r\n    export function emit(event: \"online\", listener: (worker: Worker) => void): boolean;\r\n    export function emit(event: \"setup\", listener: (settings: any) => void): boolean;\r\n\r\n    export function on(event: string, listener: Function): Cluster;\r\n    export function on(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\r\n    export function on(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\r\n    export function on(event: \"fork\", listener: (worker: Worker) => void): Cluster;\r\n    export function on(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\r\n    export function on(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\r\n    export function on(event: \"online\", listener: (worker: Worker) => void): Cluster;\r\n    export function on(event: \"setup\", listener: (settings: any) => void): Cluster;\r\n\r\n    export function once(event: string, listener: Function): Cluster;\r\n    export function once(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\r\n    export function once(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\r\n    export function once(event: \"fork\", listener: (worker: Worker) => void): Cluster;\r\n    export function once(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\r\n    export function once(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\r\n    export function once(event: \"online\", listener: (worker: Worker) => void): Cluster;\r\n    export function once(event: \"setup\", listener: (settings: any) => void): Cluster;\r\n\r\n    export function removeListener(event: string, listener: Function): Cluster;\r\n    export function removeAllListeners(event?: string): Cluster;\r\n    export function setMaxListeners(n: number): Cluster;\r\n    export function getMaxListeners(): number;\r\n    export function listeners(event: string): Function[];\r\n    export function listenerCount(type: string): number;\r\n\r\n    export function prependListener(event: string, listener: Function): Cluster;\r\n    export function prependListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\r\n    export function prependListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\r\n    export function prependListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\r\n    export function prependListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\r\n    export function prependListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\r\n    export function prependListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\r\n    export function prependListener(event: \"setup\", listener: (settings: any) => void): Cluster;\r\n\r\n    export function prependOnceListener(event: string, listener: Function): Cluster;\r\n    export function prependOnceListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\r\n    export function prependOnceListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\r\n    export function prependOnceListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\r\n    export function prependOnceListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\r\n    export function prependOnceListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\r\n    export function prependOnceListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\r\n    export function prependOnceListener(event: \"setup\", listener: (settings: any) => void): Cluster;\r\n\r\n    export function eventNames(): string[];\r\n}\r\n\r\ndeclare module \"zlib\" {\r\n    import * as stream from \"stream\";\r\n    export interface ZlibOptions { chunkSize?: number; windowBits?: number; level?: number; memLevel?: number; strategy?: number; dictionary?: any; finishFlush?: number }\r\n\r\n    export interface Gzip extends stream.Transform { }\r\n    export interface Gunzip extends stream.Transform { }\r\n    export interface Deflate extends stream.Transform { }\r\n    export interface Inflate extends stream.Transform { }\r\n    export interface DeflateRaw extends stream.Transform { }\r\n    export interface InflateRaw extends stream.Transform { }\r\n    export interface Unzip extends stream.Transform { }\r\n\r\n    export function createGzip(options?: ZlibOptions): Gzip;\r\n    export function createGunzip(options?: ZlibOptions): Gunzip;\r\n    export function createDeflate(options?: ZlibOptions): Deflate;\r\n    export function createInflate(options?: ZlibOptions): Inflate;\r\n    export function createDeflateRaw(options?: ZlibOptions): DeflateRaw;\r\n    export function createInflateRaw(options?: ZlibOptions): InflateRaw;\r\n    export function createUnzip(options?: ZlibOptions): Unzip;\r\n\r\n    export function deflate(buf: Buffer | string, callback: (error: Error, result: Buffer) => void): void;\r\n    export function deflate(buf: Buffer | string, options: ZlibOptions, callback: (error: Error, result: Buffer) => void): void;\r\n    export function deflateSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n    export function deflateRaw(buf: Buffer | string, callback: (error: Error, result: Buffer) => void): void;\r\n    export function deflateRaw(buf: Buffer | string, options: ZlibOptions, callback: (error: Error, result: Buffer) => void): void;\r\n    export function deflateRawSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n    export function gzip(buf: Buffer | string, callback: (error: Error, result: Buffer) => void): void;\r\n    export function gzip(buf: Buffer | string, options: ZlibOptions, callback: (error: Error, result: Buffer) => void): void;\r\n    export function gzipSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n    export function gunzip(buf: Buffer | string, callback: (error: Error, result: Buffer) => void): void;\r\n    export function gunzip(buf: Buffer | string, options: ZlibOptions, callback: (error: Error, result: Buffer) => void): void;\r\n    export function gunzipSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n    export function inflate(buf: Buffer | string, callback: (error: Error, result: Buffer) => void): void;\r\n    export function inflate(buf: Buffer | string, options: ZlibOptions, callback: (error: Error, result: Buffer) => void): void;\r\n    export function inflateSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n    export function inflateRaw(buf: Buffer | string, callback: (error: Error, result: Buffer) => void): void;\r\n    export function inflateRaw(buf: Buffer | string, options: ZlibOptions, callback: (error: Error, result: Buffer) => void): void;\r\n    export function inflateRawSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n    export function unzip(buf: Buffer | string, callback: (error: Error, result: Buffer) => void): void;\r\n    export function unzip(buf: Buffer | string, options: ZlibOptions, callback: (error: Error, result: Buffer) => void): void;\r\n    export function unzipSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n\r\n    // Constants\r\n    export var Z_NO_FLUSH: number;\r\n    export var Z_PARTIAL_FLUSH: number;\r\n    export var Z_SYNC_FLUSH: number;\r\n    export var Z_FULL_FLUSH: number;\r\n    export var Z_FINISH: number;\r\n    export var Z_BLOCK: number;\r\n    export var Z_TREES: number;\r\n    export var Z_OK: number;\r\n    export var Z_STREAM_END: number;\r\n    export var Z_NEED_DICT: number;\r\n    export var Z_ERRNO: number;\r\n    export var Z_STREAM_ERROR: number;\r\n    export var Z_DATA_ERROR: number;\r\n    export var Z_MEM_ERROR: number;\r\n    export var Z_BUF_ERROR: number;\r\n    export var Z_VERSION_ERROR: number;\r\n    export var Z_NO_COMPRESSION: number;\r\n    export var Z_BEST_SPEED: number;\r\n    export var Z_BEST_COMPRESSION: number;\r\n    export var Z_DEFAULT_COMPRESSION: number;\r\n    export var Z_FILTERED: number;\r\n    export var Z_HUFFMAN_ONLY: number;\r\n    export var Z_RLE: number;\r\n    export var Z_FIXED: number;\r\n    export var Z_DEFAULT_STRATEGY: number;\r\n    export var Z_BINARY: number;\r\n    export var Z_TEXT: number;\r\n    export var Z_ASCII: number;\r\n    export var Z_UNKNOWN: number;\r\n    export var Z_DEFLATED: number;\r\n    export var Z_NULL: number;\r\n}\r\n\r\ndeclare module \"os\" {\r\n    export interface CpuInfo {\r\n        model: string;\r\n        speed: number;\r\n        times: {\r\n            user: number;\r\n            nice: number;\r\n            sys: number;\r\n            idle: number;\r\n            irq: number;\r\n        };\r\n    }\r\n\r\n    export interface NetworkInterfaceInfo {\r\n        address: string;\r\n        netmask: string;\r\n        family: string;\r\n        mac: string;\r\n        internal: boolean;\r\n    }\r\n\r\n    export function hostname(): string;\r\n    export function loadavg(): number[];\r\n    export function uptime(): number;\r\n    export function freemem(): number;\r\n    export function totalmem(): number;\r\n    export function cpus(): CpuInfo[];\r\n    export function type(): string;\r\n    export function release(): string;\r\n    export function networkInterfaces(): { [index: string]: NetworkInterfaceInfo[] };\r\n    export function homedir(): string;\r\n    export function userInfo(options?: { encoding: string }): { username: string, uid: number, gid: number, shell: any, homedir: string }\r\n    export var constants: {\r\n        UV_UDP_REUSEADDR: number,\r\n        signals: {\r\n            SIGHUP: number;\r\n            SIGINT: number;\r\n            SIGQUIT: number;\r\n            SIGILL: number;\r\n            SIGTRAP: number;\r\n            SIGABRT: number;\r\n            SIGIOT: number;\r\n            SIGBUS: number;\r\n            SIGFPE: number;\r\n            SIGKILL: number;\r\n            SIGUSR1: number;\r\n            SIGSEGV: number;\r\n            SIGUSR2: number;\r\n            SIGPIPE: number;\r\n            SIGALRM: number;\r\n            SIGTERM: number;\r\n            SIGCHLD: number;\r\n            SIGSTKFLT: number;\r\n            SIGCONT: number;\r\n            SIGSTOP: number;\r\n            SIGTSTP: number;\r\n            SIGTTIN: number;\r\n            SIGTTOU: number;\r\n            SIGURG: number;\r\n            SIGXCPU: number;\r\n            SIGXFSZ: number;\r\n            SIGVTALRM: number;\r\n            SIGPROF: number;\r\n            SIGWINCH: number;\r\n            SIGIO: number;\r\n            SIGPOLL: number;\r\n            SIGPWR: number;\r\n            SIGSYS: number;\r\n            SIGUNUSED: number;\r\n        },\r\n        errno: {\r\n            E2BIG: number;\r\n            EACCES: number;\r\n            EADDRINUSE: number;\r\n            EADDRNOTAVAIL: number;\r\n            EAFNOSUPPORT: number;\r\n            EAGAIN: number;\r\n            EALREADY: number;\r\n            EBADF: number;\r\n            EBADMSG: number;\r\n            EBUSY: number;\r\n            ECANCELED: number;\r\n            ECHILD: number;\r\n            ECONNABORTED: number;\r\n            ECONNREFUSED: number;\r\n            ECONNRESET: number;\r\n            EDEADLK: number;\r\n            EDESTADDRREQ: number;\r\n            EDOM: number;\r\n            EDQUOT: number;\r\n            EEXIST: number;\r\n            EFAULT: number;\r\n            EFBIG: number;\r\n            EHOSTUNREACH: number;\r\n            EIDRM: number;\r\n            EILSEQ: number;\r\n            EINPROGRESS: number;\r\n            EINTR: number;\r\n            EINVAL: number;\r\n            EIO: number;\r\n            EISCONN: number;\r\n            EISDIR: number;\r\n            ELOOP: number;\r\n            EMFILE: number;\r\n            EMLINK: number;\r\n            EMSGSIZE: number;\r\n            EMULTIHOP: number;\r\n            ENAMETOOLONG: number;\r\n            ENETDOWN: number;\r\n            ENETRESET: number;\r\n            ENETUNREACH: number;\r\n            ENFILE: number;\r\n            ENOBUFS: number;\r\n            ENODATA: number;\r\n            ENODEV: number;\r\n            ENOENT: number;\r\n            ENOEXEC: number;\r\n            ENOLCK: number;\r\n            ENOLINK: number;\r\n            ENOMEM: number;\r\n            ENOMSG: number;\r\n            ENOPROTOOPT: number;\r\n            ENOSPC: number;\r\n            ENOSR: number;\r\n            ENOSTR: number;\r\n            ENOSYS: number;\r\n            ENOTCONN: number;\r\n            ENOTDIR: number;\r\n            ENOTEMPTY: number;\r\n            ENOTSOCK: number;\r\n            ENOTSUP: number;\r\n            ENOTTY: number;\r\n            ENXIO: number;\r\n            EOPNOTSUPP: number;\r\n            EOVERFLOW: number;\r\n            EPERM: number;\r\n            EPIPE: number;\r\n            EPROTO: number;\r\n            EPROTONOSUPPORT: number;\r\n            EPROTOTYPE: number;\r\n            ERANGE: number;\r\n            EROFS: number;\r\n            ESPIPE: number;\r\n            ESRCH: number;\r\n            ESTALE: number;\r\n            ETIME: number;\r\n            ETIMEDOUT: number;\r\n            ETXTBSY: number;\r\n            EWOULDBLOCK: number;\r\n            EXDEV: number;\r\n        },\r\n    };\r\n    export function arch(): string;\r\n    export function platform(): NodeJS.Platform;\r\n    export function tmpdir(): string;\r\n    export var EOL: string;\r\n    export function endianness(): \"BE\" | \"LE\";\r\n}\r\n\r\ndeclare module \"https\" {\r\n    import * as tls from \"tls\";\r\n    import * as events from \"events\";\r\n    import * as http from \"http\";\r\n\r\n    export interface ServerOptions {\r\n        pfx?: any;\r\n        key?: any;\r\n        passphrase?: string;\r\n        cert?: any;\r\n        ca?: any;\r\n        crl?: any;\r\n        ciphers?: string;\r\n        honorCipherOrder?: boolean;\r\n        requestCert?: boolean;\r\n        rejectUnauthorized?: boolean;\r\n        NPNProtocols?: any;\r\n        SNICallback?: (servername: string, cb: (err: Error, ctx: tls.SecureContext) => any) => any;\r\n    }\r\n\r\n    export interface RequestOptions extends http.RequestOptions {\r\n        pfx?: any;\r\n        key?: any;\r\n        passphrase?: string;\r\n        cert?: any;\r\n        ca?: any;\r\n        ciphers?: string;\r\n        rejectUnauthorized?: boolean;\r\n        secureProtocol?: string;\r\n    }\r\n\r\n    export interface Agent extends http.Agent { }\r\n\r\n    export interface AgentOptions extends http.AgentOptions {\r\n        pfx?: any;\r\n        key?: any;\r\n        passphrase?: string;\r\n        cert?: any;\r\n        ca?: any;\r\n        ciphers?: string;\r\n        rejectUnauthorized?: boolean;\r\n        secureProtocol?: string;\r\n        maxCachedSessions?: number;\r\n    }\r\n\r\n    export var Agent: {\r\n        new (options?: AgentOptions): Agent;\r\n    };\r\n    export interface Server extends tls.Server { }\r\n    export function createServer(options: ServerOptions, requestListener?: Function): Server;\r\n    export function request(options: RequestOptions | string, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\r\n    export function get(options: RequestOptions | string, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\r\n    export var globalAgent: Agent;\r\n}\r\n\r\ndeclare module \"punycode\" {\r\n    export function decode(string: string): string;\r\n    export function encode(string: string): string;\r\n    export function toUnicode(domain: string): string;\r\n    export function toASCII(domain: string): string;\r\n    export var ucs2: ucs2;\r\n    interface ucs2 {\r\n        decode(string: string): number[];\r\n        encode(codePoints: number[]): string;\r\n    }\r\n    export var version: any;\r\n}\r\n\r\ndeclare module \"repl\" {\r\n    import * as stream from \"stream\";\r\n    import * as readline from \"readline\";\r\n\r\n    export interface ReplOptions {\r\n        prompt?: string;\r\n        input?: NodeJS.ReadableStream;\r\n        output?: NodeJS.WritableStream;\r\n        terminal?: boolean;\r\n        eval?: Function;\r\n        useColors?: boolean;\r\n        useGlobal?: boolean;\r\n        ignoreUndefined?: boolean;\r\n        writer?: Function;\r\n        completer?: Function;\r\n        replMode?: any;\r\n        breakEvalOnSigint?: any;\r\n    }\r\n\r\n    export interface REPLServer extends readline.ReadLine {\r\n        defineCommand(keyword: string, cmd: Function | { help: string, action: Function }): void;\r\n        displayPrompt(preserveCursor?: boolean): void;\r\n\r\n        context: any;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         * 1. exit\r\n         * 2. reset\r\n         **/\r\n\r\n        addListener(event: string, listener: Function): this;\r\n        addListener(event: \"exit\", listener: () => void): this;\r\n        addListener(event: \"reset\", listener: Function): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"exit\"): boolean;\r\n        emit(event: \"reset\", context: any): boolean;\r\n\r\n        on(event: string, listener: Function): this;\r\n        on(event: \"exit\", listener: () => void): this;\r\n        on(event: \"reset\", listener: Function): this;\r\n\r\n        once(event: string, listener: Function): this;\r\n        once(event: \"exit\", listener: () => void): this;\r\n        once(event: \"reset\", listener: Function): this;\r\n\r\n        prependListener(event: string, listener: Function): this;\r\n        prependListener(event: \"exit\", listener: () => void): this;\r\n        prependListener(event: \"reset\", listener: Function): this;\r\n\r\n        prependOnceListener(event: string, listener: Function): this;\r\n        prependOnceListener(event: \"exit\", listener: () => void): this;\r\n        prependOnceListener(event: \"reset\", listener: Function): this;\r\n    }\r\n\r\n    export function start(options?: string | ReplOptions): REPLServer;\r\n}\r\n\r\ndeclare module \"readline\" {\r\n    import * as events from \"events\";\r\n    import * as stream from \"stream\";\r\n\r\n    export interface Key {\r\n        sequence?: string;\r\n        name?: string;\r\n        ctrl?: boolean;\r\n        meta?: boolean;\r\n        shift?: boolean;\r\n    }\r\n\r\n    export interface ReadLine extends events.EventEmitter {\r\n        setPrompt(prompt: string): void;\r\n        prompt(preserveCursor?: boolean): void;\r\n        question(query: string, callback: (answer: string) => void): void;\r\n        pause(): this;\r\n        resume(): this;\r\n        close(): void;\r\n        write(data: string | Buffer, key?: Key): void;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         * 1. close\r\n         * 2. line\r\n         * 3. pause\r\n         * 4. resume\r\n         * 5. SIGCONT\r\n         * 6. SIGINT\r\n         * 7. SIGTSTP\r\n         **/\r\n\r\n        addListener(event: string, listener: Function): this;\r\n        addListener(event: \"close\", listener: () => void): this;\r\n        addListener(event: \"line\", listener: (input: any) => void): this;\r\n        addListener(event: \"pause\", listener: () => void): this;\r\n        addListener(event: \"resume\", listener: () => void): this;\r\n        addListener(event: \"SIGCONT\", listener: () => void): this;\r\n        addListener(event: \"SIGINT\", listener: () => void): this;\r\n        addListener(event: \"SIGTSTP\", listener: () => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"close\"): boolean;\r\n        emit(event: \"line\", input: any): boolean;\r\n        emit(event: \"pause\"): boolean;\r\n        emit(event: \"resume\"): boolean;\r\n        emit(event: \"SIGCONT\"): boolean;\r\n        emit(event: \"SIGINT\"): boolean;\r\n        emit(event: \"SIGTSTP\"): boolean;\r\n\r\n        on(event: string, listener: Function): this;\r\n        on(event: \"close\", listener: () => void): this;\r\n        on(event: \"line\", listener: (input: any) => void): this;\r\n        on(event: \"pause\", listener: () => void): this;\r\n        on(event: \"resume\", listener: () => void): this;\r\n        on(event: \"SIGCONT\", listener: () => void): this;\r\n        on(event: \"SIGINT\", listener: () => void): this;\r\n        on(event: \"SIGTSTP\", listener: () => void): this;\r\n\r\n        once(event: string, listener: Function): this;\r\n        once(event: \"close\", listener: () => void): this;\r\n        once(event: \"line\", listener: (input: any) => void): this;\r\n        once(event: \"pause\", listener: () => void): this;\r\n        once(event: \"resume\", listener: () => void): this;\r\n        once(event: \"SIGCONT\", listener: () => void): this;\r\n        once(event: \"SIGINT\", listener: () => void): this;\r\n        once(event: \"SIGTSTP\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: Function): this;\r\n        prependListener(event: \"close\", listener: () => void): this;\r\n        prependListener(event: \"line\", listener: (input: any) => void): this;\r\n        prependListener(event: \"pause\", listener: () => void): this;\r\n        prependListener(event: \"resume\", listener: () => void): this;\r\n        prependListener(event: \"SIGCONT\", listener: () => void): this;\r\n        prependListener(event: \"SIGINT\", listener: () => void): this;\r\n        prependListener(event: \"SIGTSTP\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: Function): this;\r\n        prependOnceListener(event: \"close\", listener: () => void): this;\r\n        prependOnceListener(event: \"line\", listener: (input: any) => void): this;\r\n        prependOnceListener(event: \"pause\", listener: () => void): this;\r\n        prependOnceListener(event: \"resume\", listener: () => void): this;\r\n        prependOnceListener(event: \"SIGCONT\", listener: () => void): this;\r\n        prependOnceListener(event: \"SIGINT\", listener: () => void): this;\r\n        prependOnceListener(event: \"SIGTSTP\", listener: () => void): this;\r\n    }\r\n\r\n    export interface Completer {\r\n        (line: string): CompleterResult;\r\n        (line: string, callback: (err: any, result: CompleterResult) => void): any;\r\n    }\r\n\r\n    export type CompleterResult = [string[], string];\r\n\r\n    export interface ReadLineOptions {\r\n        input: NodeJS.ReadableStream;\r\n        output?: NodeJS.WritableStream;\r\n        completer?: Completer;\r\n        terminal?: boolean;\r\n        historySize?: number;\r\n    }\r\n\r\n    export function createInterface(input: NodeJS.ReadableStream, output?: NodeJS.WritableStream, completer?: Completer, terminal?: boolean): ReadLine;\r\n    export function createInterface(options: ReadLineOptions): ReadLine;\r\n\r\n    export function cursorTo(stream: NodeJS.WritableStream, x: number, y?: number): void;\r\n    export function moveCursor(stream: NodeJS.WritableStream, dx: number | string, dy: number | string): void;\r\n    export function clearLine(stream: NodeJS.WritableStream, dir: number): void;\r\n    export function clearScreenDown(stream: NodeJS.WritableStream): void;\r\n}\r\n\r\ndeclare module \"vm\" {\r\n    export interface Context { }\r\n    export interface ScriptOptions {\r\n        filename?: string;\r\n        lineOffset?: number;\r\n        columnOffset?: number;\r\n        displayErrors?: boolean;\r\n        timeout?: number;\r\n        cachedData?: Buffer;\r\n        produceCachedData?: boolean;\r\n    }\r\n    export interface RunningScriptOptions {\r\n        filename?: string;\r\n        lineOffset?: number;\r\n        columnOffset?: number;\r\n        displayErrors?: boolean;\r\n        timeout?: number;\r\n    }\r\n    export class Script {\r\n        constructor(code: string, options?: ScriptOptions);\r\n        runInContext(contextifiedSandbox: Context, options?: RunningScriptOptions): any;\r\n        runInNewContext(sandbox?: Context, options?: RunningScriptOptions): any;\r\n        runInThisContext(options?: RunningScriptOptions): any;\r\n    }\r\n    export function createContext(sandbox?: Context): Context;\r\n    export function isContext(sandbox: Context): boolean;\r\n    export function runInContext(code: string, contextifiedSandbox: Context, options?: RunningScriptOptions): any;\r\n    export function runInDebugContext(code: string): any;\r\n    export function runInNewContext(code: string, sandbox?: Context, options?: RunningScriptOptions): any;\r\n    export function runInThisContext(code: string, options?: RunningScriptOptions): any;\r\n}\r\n\r\ndeclare module \"child_process\" {\r\n    import * as events from \"events\";\r\n    import * as stream from \"stream\";\r\n    import * as net from \"net\";\r\n\r\n    export interface ChildProcess extends events.EventEmitter {\r\n        stdin: stream.Writable;\r\n        stdout: stream.Readable;\r\n        stderr: stream.Readable;\r\n        stdio: [stream.Writable, stream.Readable, stream.Readable];\r\n        killed: boolean;\r\n        pid: number;\r\n        kill(signal?: string): void;\r\n        send(message: any, sendHandle?: any): boolean;\r\n        connected: boolean;\r\n        disconnect(): void;\r\n        unref(): void;\r\n        ref(): void;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         * 1. close\r\n         * 2. disconnect\r\n         * 3. error\r\n         * 4. exit\r\n         * 5. message\r\n         **/\r\n\r\n        addListener(event: string, listener: Function): this;\r\n        addListener(event: \"close\", listener: (code: number, signal: string) => void): this;\r\n        addListener(event: \"disconnect\", listener: () => void): this;\r\n        addListener(event: \"error\", listener: (err: Error) => void): this;\r\n        addListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        addListener(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"close\", code: number, signal: string): boolean;\r\n        emit(event: \"disconnect\"): boolean;\r\n        emit(event: \"error\", err: Error): boolean;\r\n        emit(event: \"exit\", code: number, signal: string): boolean;\r\n        emit(event: \"message\", message: any, sendHandle: net.Socket | net.Server): boolean;\r\n\r\n        on(event: string, listener: Function): this;\r\n        on(event: \"close\", listener: (code: number, signal: string) => void): this;\r\n        on(event: \"disconnect\", listener: () => void): this;\r\n        on(event: \"error\", listener: (err: Error) => void): this;\r\n        on(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        on(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\r\n\r\n        once(event: string, listener: Function): this;\r\n        once(event: \"close\", listener: (code: number, signal: string) => void): this;\r\n        once(event: \"disconnect\", listener: () => void): this;\r\n        once(event: \"error\", listener: (err: Error) => void): this;\r\n        once(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        once(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\r\n\r\n        prependListener(event: string, listener: Function): this;\r\n        prependListener(event: \"close\", listener: (code: number, signal: string) => void): this;\r\n        prependListener(event: \"disconnect\", listener: () => void): this;\r\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        prependListener(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: Function): this;\r\n        prependOnceListener(event: \"close\", listener: (code: number, signal: string) => void): this;\r\n        prependOnceListener(event: \"disconnect\", listener: () => void): this;\r\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        prependOnceListener(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\r\n    }\r\n\r\n    export interface SpawnOptions {\r\n        cwd?: string;\r\n        env?: any;\r\n        stdio?: any;\r\n        detached?: boolean;\r\n        uid?: number;\r\n        gid?: number;\r\n        shell?: boolean | string;\r\n    }\r\n    export function spawn(command: string, args?: string[], options?: SpawnOptions): ChildProcess;\r\n\r\n    export interface ExecOptions {\r\n        cwd?: string;\r\n        env?: any;\r\n        shell?: string;\r\n        timeout?: number;\r\n        maxBuffer?: number;\r\n        killSignal?: string;\r\n        uid?: number;\r\n        gid?: number;\r\n    }\r\n    export interface ExecOptionsWithStringEncoding extends ExecOptions {\r\n        encoding: BufferEncoding;\r\n    }\r\n    export interface ExecOptionsWithBufferEncoding extends ExecOptions {\r\n        encoding: string; // specify `null`.\r\n    }\r\n    export function exec(command: string, callback?: (error: Error, stdout: string, stderr: string) => void): ChildProcess;\r\n    export function exec(command: string, options: ExecOptionsWithStringEncoding, callback?: (error: Error, stdout: string, stderr: string) => void): ChildProcess;\r\n    // usage. child_process.exec(\"tsc\", {encoding: null as string}, (err, stdout, stderr) => {});\r\n    export function exec(command: string, options: ExecOptionsWithBufferEncoding, callback?: (error: Error, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\r\n    export function exec(command: string, options: ExecOptions, callback?: (error: Error, stdout: string, stderr: string) => void): ChildProcess;\r\n\r\n    export interface ExecFileOptions {\r\n        cwd?: string;\r\n        env?: any;\r\n        timeout?: number;\r\n        maxBuffer?: number;\r\n        killSignal?: string;\r\n        uid?: number;\r\n        gid?: number;\r\n    }\r\n    export interface ExecFileOptionsWithStringEncoding extends ExecFileOptions {\r\n        encoding: BufferEncoding;\r\n    }\r\n    export interface ExecFileOptionsWithBufferEncoding extends ExecFileOptions {\r\n        encoding: string; // specify `null`.\r\n    }\r\n    export function execFile(file: string, callback?: (error: Error, stdout: string, stderr: string) => void): ChildProcess;\r\n    export function execFile(file: string, options?: ExecFileOptionsWithStringEncoding, callback?: (error: Error, stdout: string, stderr: string) => void): ChildProcess;\r\n    // usage. child_process.execFile(\"file.sh\", {encoding: null as string}, (err, stdout, stderr) => {});\r\n    export function execFile(file: string, options?: ExecFileOptionsWithBufferEncoding, callback?: (error: Error, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\r\n    export function execFile(file: string, options?: ExecFileOptions, callback?: (error: Error, stdout: string, stderr: string) => void): ChildProcess;\r\n    export function execFile(file: string, args?: string[], callback?: (error: Error, stdout: string, stderr: string) => void): ChildProcess;\r\n    export function execFile(file: string, args?: string[], options?: ExecFileOptionsWithStringEncoding, callback?: (error: Error, stdout: string, stderr: string) => void): ChildProcess;\r\n    // usage. child_process.execFile(\"file.sh\", [\"foo\"], {encoding: null as string}, (err, stdout, stderr) => {});\r\n    export function execFile(file: string, args?: string[], options?: ExecFileOptionsWithBufferEncoding, callback?: (error: Error, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\r\n    export function execFile(file: string, args?: string[], options?: ExecFileOptions, callback?: (error: Error, stdout: string, stderr: string) => void): ChildProcess;\r\n\r\n    export interface ForkOptions {\r\n        cwd?: string;\r\n        env?: any;\r\n        execPath?: string;\r\n        execArgv?: string[];\r\n        silent?: boolean;\r\n        uid?: number;\r\n        gid?: number;\r\n    }\r\n    export function fork(modulePath: string, args?: string[], options?: ForkOptions): ChildProcess;\r\n\r\n    export interface SpawnSyncOptions {\r\n        cwd?: string;\r\n        input?: string | Buffer;\r\n        stdio?: any;\r\n        env?: any;\r\n        uid?: number;\r\n        gid?: number;\r\n        timeout?: number;\r\n        killSignal?: string;\r\n        maxBuffer?: number;\r\n        encoding?: string;\r\n        shell?: boolean | string;\r\n    }\r\n    export interface SpawnSyncOptionsWithStringEncoding extends SpawnSyncOptions {\r\n        encoding: BufferEncoding;\r\n    }\r\n    export interface SpawnSyncOptionsWithBufferEncoding extends SpawnSyncOptions {\r\n        encoding: string; // specify `null`.\r\n    }\r\n    export interface SpawnSyncReturns<T> {\r\n        pid: number;\r\n        output: string[];\r\n        stdout: T;\r\n        stderr: T;\r\n        status: number;\r\n        signal: string;\r\n        error: Error;\r\n    }\r\n    export function spawnSync(command: string): SpawnSyncReturns<Buffer>;\r\n    export function spawnSync(command: string, options?: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;\r\n    export function spawnSync(command: string, options?: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;\r\n    export function spawnSync(command: string, options?: SpawnSyncOptions): SpawnSyncReturns<Buffer>;\r\n    export function spawnSync(command: string, args?: string[], options?: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;\r\n    export function spawnSync(command: string, args?: string[], options?: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;\r\n    export function spawnSync(command: string, args?: string[], options?: SpawnSyncOptions): SpawnSyncReturns<Buffer>;\r\n\r\n    export interface ExecSyncOptions {\r\n        cwd?: string;\r\n        input?: string | Buffer;\r\n        stdio?: any;\r\n        env?: any;\r\n        shell?: string;\r\n        uid?: number;\r\n        gid?: number;\r\n        timeout?: number;\r\n        killSignal?: string;\r\n        maxBuffer?: number;\r\n        encoding?: string;\r\n    }\r\n    export interface ExecSyncOptionsWithStringEncoding extends ExecSyncOptions {\r\n        encoding: BufferEncoding;\r\n    }\r\n    export interface ExecSyncOptionsWithBufferEncoding extends ExecSyncOptions {\r\n        encoding: string; // specify `null`.\r\n    }\r\n    export function execSync(command: string): Buffer;\r\n    export function execSync(command: string, options?: ExecSyncOptionsWithStringEncoding): string;\r\n    export function execSync(command: string, options?: ExecSyncOptionsWithBufferEncoding): Buffer;\r\n    export function execSync(command: string, options?: ExecSyncOptions): Buffer;\r\n\r\n    export interface ExecFileSyncOptions {\r\n        cwd?: string;\r\n        input?: string | Buffer;\r\n        stdio?: any;\r\n        env?: any;\r\n        uid?: number;\r\n        gid?: number;\r\n        timeout?: number;\r\n        killSignal?: string;\r\n        maxBuffer?: number;\r\n        encoding?: string;\r\n    }\r\n    export interface ExecFileSyncOptionsWithStringEncoding extends ExecFileSyncOptions {\r\n        encoding: BufferEncoding;\r\n    }\r\n    export interface ExecFileSyncOptionsWithBufferEncoding extends ExecFileSyncOptions {\r\n        encoding: string; // specify `null`.\r\n    }\r\n    export function execFileSync(command: string): Buffer;\r\n    export function execFileSync(command: string, options?: ExecFileSyncOptionsWithStringEncoding): string;\r\n    export function execFileSync(command: string, options?: ExecFileSyncOptionsWithBufferEncoding): Buffer;\r\n    export function execFileSync(command: string, options?: ExecFileSyncOptions): Buffer;\r\n    export function execFileSync(command: string, args?: string[], options?: ExecFileSyncOptionsWithStringEncoding): string;\r\n    export function execFileSync(command: string, args?: string[], options?: ExecFileSyncOptionsWithBufferEncoding): Buffer;\r\n    export function execFileSync(command: string, args?: string[], options?: ExecFileSyncOptions): Buffer;\r\n}\r\n\r\ndeclare module \"url\" {\r\n    export interface UrlObject {\r\n        href?: string;\r\n        protocol?: string;\r\n        slashes?: boolean;\r\n        host?: string;\r\n        auth?: string;\r\n        hostname?: string;\r\n        port?: string | number;\r\n        pathname?: string;\r\n        search?: string;\r\n        path?: string;\r\n        query?: string | { [key: string]: any; };\r\n        hash?: string;\r\n    }\r\n\r\n    export interface Url extends UrlObject {\r\n        port?: string;\r\n        query?: any;\r\n    }\r\n\r\n    export function parse(urlStr: string, parseQueryString?: boolean, slashesDenoteHost?: boolean): Url;\r\n    export function format(urlObject: UrlObject | string): string;\r\n    export function resolve(from: string, to: string): string;\r\n}\r\n\r\ndeclare module \"dns\" {\r\n    // Supported getaddrinfo flags.\r\n    export const ADDRCONFIG: number;\r\n    export const V4MAPPED: number;\r\n\r\n    export interface LookupOptions {\r\n        family?: number;\r\n        hints?: number;\r\n        all?: boolean;\r\n    }\r\n\r\n    export interface LookupOneOptions extends LookupOptions {\r\n        all?: false;\r\n    }\r\n\r\n    export interface LookupAllOptions extends LookupOptions {\r\n        all: true;\r\n    }\r\n\r\n    export interface LookupAddress {\r\n        address: string;\r\n        family: number;\r\n    }\r\n\r\n    export function lookup(hostname: string, family: number, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\r\n    export function lookup(hostname: string, options: LookupOneOptions, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\r\n    export function lookup(hostname: string, options: LookupAllOptions, callback: (err: NodeJS.ErrnoException, addresses: LookupAddress[]) => void): void;\r\n    export function lookup(hostname: string, options: LookupOptions, callback: (err: NodeJS.ErrnoException, address: string | LookupAddress[], family: number) => void): void;\r\n    export function lookup(hostname: string, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\r\n\r\n    export interface MxRecord {\r\n        priority: number;\r\n        exchange: string;\r\n    }\r\n\r\n    export interface NaptrRecord {\r\n        flags: string;\r\n        service: string;\r\n        regexp: string;\r\n        replacement: string;\r\n        order: number;\r\n        preference: number;\r\n    }\r\n\r\n    export interface SoaRecord {\r\n        nsname: string;\r\n        hostmaster: string;\r\n        serial: number;\r\n        refresh: number;\r\n        retry: number;\r\n        expire: number;\r\n        minttl: number;\r\n    }\r\n\r\n    export interface SrvRecord {\r\n        priority: number;\r\n        weight: number;\r\n        port: number;\r\n        name: string;\r\n    }\r\n\r\n    export function resolve(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"A\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"AAAA\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"CNAME\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"MX\", callback: (err: NodeJS.ErrnoException, addresses: MxRecord[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"NAPTR\", callback: (err: NodeJS.ErrnoException, addresses: NaptrRecord[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"NS\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"PTR\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"SOA\", callback: (err: NodeJS.ErrnoException, addresses: SoaRecord) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"SRV\", callback: (err: NodeJS.ErrnoException, addresses: SrvRecord[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"TXT\", callback: (err: NodeJS.ErrnoException, addresses: string[][]) => void): void;\r\n    export function resolve(hostname: string, rrtype: string, callback: (err: NodeJS.ErrnoException, addresses: string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][]) => void): void;\r\n\r\n    export function resolve4(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve6(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolveCname(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolveMx(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: MxRecord[]) => void): void;\r\n    export function resolveNaptr(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: NaptrRecord[]) => void): void;\r\n    export function resolveNs(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolvePtr(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolveSoa(hostname: string, callback: (err: NodeJS.ErrnoException, address: SoaRecord) => void): void;\r\n    export function resolveSrv(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: SrvRecord[]) => void): void;\r\n    export function resolveTxt(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[][]) => void): void;\r\n\r\n    export function reverse(ip: string, callback: (err: NodeJS.ErrnoException, hostnames: string[]) => void): void;\r\n    export function setServers(servers: string[]): void;\r\n\r\n    //Error codes\r\n    export var NODATA: string;\r\n    export var FORMERR: string;\r\n    export var SERVFAIL: string;\r\n    export var NOTFOUND: string;\r\n    export var NOTIMP: string;\r\n    export var REFUSED: string;\r\n    export var BADQUERY: string;\r\n    export var BADNAME: string;\r\n    export var BADFAMILY: string;\r\n    export var BADRESP: string;\r\n    export var CONNREFUSED: string;\r\n    export var TIMEOUT: string;\r\n    export var EOF: string;\r\n    export var FILE: string;\r\n    export var NOMEM: string;\r\n    export var DESTRUCTION: string;\r\n    export var BADSTR: string;\r\n    export var BADFLAGS: string;\r\n    export var NONAME: string;\r\n    export var BADHINTS: string;\r\n    export var NOTINITIALIZED: string;\r\n    export var LOADIPHLPAPI: string;\r\n    export var ADDRGETNETWORKPARAMS: string;\r\n    export var CANCELLED: string;\r\n}\r\n\r\ndeclare module \"net\" {\r\n    import * as stream from \"stream\";\r\n    import * as events from \"events\";\r\n\r\n    export interface Socket extends stream.Duplex {\r\n        // Extended base methods\r\n        write(buffer: Buffer): boolean;\r\n        write(buffer: Buffer, cb?: Function): boolean;\r\n        write(str: string, cb?: Function): boolean;\r\n        write(str: string, encoding?: string, cb?: Function): boolean;\r\n        write(str: string, encoding?: string, fd?: string): boolean;\r\n\r\n        connect(port: number, host?: string, connectionListener?: Function): void;\r\n        connect(path: string, connectionListener?: Function): void;\r\n        bufferSize: number;\r\n        setEncoding(encoding?: string): void;\r\n        write(data: any, encoding?: string, callback?: Function): void;\r\n        destroy(): void;\r\n        setTimeout(timeout: number, callback?: Function): void;\r\n        setNoDelay(noDelay?: boolean): void;\r\n        setKeepAlive(enable?: boolean, initialDelay?: number): void;\r\n        address(): { port: number; family: string; address: string; };\r\n        unref(): void;\r\n        ref(): void;\r\n\r\n        remoteAddress: string;\r\n        remoteFamily: string;\r\n        remotePort: number;\r\n        localAddress: string;\r\n        localPort: number;\r\n        bytesRead: number;\r\n        bytesWritten: number;\r\n        connecting: boolean;\r\n        destroyed: boolean;\r\n\r\n        // Extended base methods\r\n        end(): void;\r\n        end(buffer: Buffer, cb?: Function): void;\r\n        end(str: string, cb?: Function): void;\r\n        end(str: string, encoding?: string, cb?: Function): void;\r\n        end(data?: any, encoding?: string): void;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. close\r\n         *   2. connect\r\n         *   3. data\r\n         *   4. drain\r\n         *   5. end\r\n         *   6. error\r\n         *   7. lookup\r\n         *   8. timeout\r\n         */\r\n        addListener(event: string, listener: Function): this;\r\n        addListener(event: \"close\", listener: (had_error: boolean) => void): this;\r\n        addListener(event: \"connect\", listener: () => void): this;\r\n        addListener(event: \"data\", listener: (data: Buffer) => void): this;\r\n        addListener(event: \"drain\", listener: () => void): this;\r\n        addListener(event: \"end\", listener: () => void): this;\r\n        addListener(event: \"error\", listener: (err: Error) => void): this;\r\n        addListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\r\n        addListener(event: \"timeout\", listener: () => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"close\", had_error: boolean): boolean;\r\n        emit(event: \"connect\"): boolean;\r\n        emit(event: \"data\", data: Buffer): boolean;\r\n        emit(event: \"drain\"): boolean;\r\n        emit(event: \"end\"): boolean;\r\n        emit(event: \"error\", err: Error): boolean;\r\n        emit(event: \"lookup\", err: Error, address: string, family: string | number, host: string): boolean;\r\n        emit(event: \"timeout\"): boolean;\r\n\r\n        on(event: string, listener: Function): this;\r\n        on(event: \"close\", listener: (had_error: boolean) => void): this;\r\n        on(event: \"connect\", listener: () => void): this;\r\n        on(event: \"data\", listener: (data: Buffer) => void): this;\r\n        on(event: \"drain\", listener: () => void): this;\r\n        on(event: \"end\", listener: () => void): this;\r\n        on(event: \"error\", listener: (err: Error) => void): this;\r\n        on(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\r\n        on(event: \"timeout\", listener: () => void): this;\r\n\r\n        once(event: string, listener: Function): this;\r\n        once(event: \"close\", listener: (had_error: boolean) => void): this;\r\n        once(event: \"connect\", listener: () => void): this;\r\n        once(event: \"data\", listener: (data: Buffer) => void): this;\r\n        once(event: \"drain\", listener: () => void): this;\r\n        once(event: \"end\", listener: () => void): this;\r\n        once(event: \"error\", listener: (err: Error) => void): this;\r\n        once(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\r\n        once(event: \"timeout\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: Function): this;\r\n        prependListener(event: \"close\", listener: (had_error: boolean) => void): this;\r\n        prependListener(event: \"connect\", listener: () => void): this;\r\n        prependListener(event: \"data\", listener: (data: Buffer) => void): this;\r\n        prependListener(event: \"drain\", listener: () => void): this;\r\n        prependListener(event: \"end\", listener: () => void): this;\r\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\r\n        prependListener(event: \"timeout\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: Function): this;\r\n        prependOnceListener(event: \"close\", listener: (had_error: boolean) => void): this;\r\n        prependOnceListener(event: \"connect\", listener: () => void): this;\r\n        prependOnceListener(event: \"data\", listener: (data: Buffer) => void): this;\r\n        prependOnceListener(event: \"drain\", listener: () => void): this;\r\n        prependOnceListener(event: \"end\", listener: () => void): this;\r\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\r\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\r\n    }\r\n\r\n    export var Socket: {\r\n        new (options?: { fd?: number; allowHalfOpen?: boolean; readable?: boolean; writable?: boolean; }): Socket;\r\n    };\r\n\r\n    export interface ListenOptions {\r\n        port?: number;\r\n        host?: string;\r\n        backlog?: number;\r\n        path?: string;\r\n        exclusive?: boolean;\r\n    }\r\n\r\n    export interface Server extends events.EventEmitter {\r\n        listen(port: number, hostname?: string, backlog?: number, listeningListener?: Function): Server;\r\n        listen(port: number, hostname?: string, listeningListener?: Function): Server;\r\n        listen(port: number, backlog?: number, listeningListener?: Function): Server;\r\n        listen(port: number, listeningListener?: Function): Server;\r\n        listen(path: string, backlog?: number, listeningListener?: Function): Server;\r\n        listen(path: string, listeningListener?: Function): Server;\r\n        listen(options: ListenOptions, listeningListener?: Function): Server;\r\n        listen(handle: any, backlog?: number, listeningListener?: Function): Server;\r\n        listen(handle: any, listeningListener?: Function): Server;\r\n        close(callback?: Function): Server;\r\n        address(): { port: number; family: string; address: string; };\r\n        getConnections(cb: (error: Error, count: number) => void): void;\r\n        ref(): Server;\r\n        unref(): Server;\r\n        maxConnections: number;\r\n        connections: number;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. close\r\n         *   2. connection\r\n         *   3. error\r\n         *   4. listening\r\n         */\r\n        addListener(event: string, listener: Function): this;\r\n        addListener(event: \"close\", listener: () => void): this;\r\n        addListener(event: \"connection\", listener: (socket: Socket) => void): this;\r\n        addListener(event: \"error\", listener: (err: Error) => void): this;\r\n        addListener(event: \"listening\", listener: () => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"close\"): boolean;\r\n        emit(event: \"connection\", socket: Socket): boolean;\r\n        emit(event: \"error\", err: Error): boolean;\r\n        emit(event: \"listening\"): boolean;\r\n\r\n        on(event: string, listener: Function): this;\r\n        on(event: \"close\", listener: () => void): this;\r\n        on(event: \"connection\", listener: (socket: Socket) => void): this;\r\n        on(event: \"error\", listener: (err: Error) => void): this;\r\n        on(event: \"listening\", listener: () => void): this;\r\n\r\n        once(event: string, listener: Function): this;\r\n        once(event: \"close\", listener: () => void): this;\r\n        once(event: \"connection\", listener: (socket: Socket) => void): this;\r\n        once(event: \"error\", listener: (err: Error) => void): this;\r\n        once(event: \"listening\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: Function): this;\r\n        prependListener(event: \"close\", listener: () => void): this;\r\n        prependListener(event: \"connection\", listener: (socket: Socket) => void): this;\r\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"listening\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: Function): this;\r\n        prependOnceListener(event: \"close\", listener: () => void): this;\r\n        prependOnceListener(event: \"connection\", listener: (socket: Socket) => void): this;\r\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"listening\", listener: () => void): this;\r\n    }\r\n    export function createServer(connectionListener?: (socket: Socket) => void): Server;\r\n    export function createServer(options?: { allowHalfOpen?: boolean; }, connectionListener?: (socket: Socket) => void): Server;\r\n    export function connect(options: { port: number, host?: string, localAddress?: string, localPort?: string, family?: number, allowHalfOpen?: boolean; }, connectionListener?: Function): Socket;\r\n    export function connect(port: number, host?: string, connectionListener?: Function): Socket;\r\n    export function connect(path: string, connectionListener?: Function): Socket;\r\n    export function createConnection(options: { port: number, host?: string, localAddress?: string, localPort?: string, family?: number, allowHalfOpen?: boolean; }, connectionListener?: Function): Socket;\r\n    export function createConnection(port: number, host?: string, connectionListener?: Function): Socket;\r\n    export function createConnection(path: string, connectionListener?: Function): Socket;\r\n    export function isIP(input: string): number;\r\n    export function isIPv4(input: string): boolean;\r\n    export function isIPv6(input: string): boolean;\r\n}\r\n\r\ndeclare module \"dgram\" {\r\n    import * as events from \"events\";\r\n\r\n    interface RemoteInfo {\r\n        address: string;\r\n        family: string;\r\n        port: number;\r\n    }\r\n\r\n    interface AddressInfo {\r\n        address: string;\r\n        family: string;\r\n        port: number;\r\n    }\r\n\r\n    interface BindOptions {\r\n        port: number;\r\n        address?: string;\r\n        exclusive?: boolean;\r\n    }\r\n\r\n    interface SocketOptions {\r\n        type: \"udp4\" | \"udp6\";\r\n        reuseAddr?: boolean;\r\n    }\r\n\r\n    export function createSocket(type: string, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\r\n    export function createSocket(options: SocketOptions, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\r\n\r\n    export interface Socket extends events.EventEmitter {\r\n        send(msg: Buffer | String | any[], port: number, address: string, callback?: (error: Error, bytes: number) => void): void;\r\n        send(msg: Buffer | String | any[], offset: number, length: number, port: number, address: string, callback?: (error: Error, bytes: number) => void): void;\r\n        bind(port?: number, address?: string, callback?: () => void): void;\r\n        bind(options: BindOptions, callback?: Function): void;\r\n        close(callback?: any): void;\r\n        address(): AddressInfo;\r\n        setBroadcast(flag: boolean): void;\r\n        setTTL(ttl: number): void;\r\n        setMulticastTTL(ttl: number): void;\r\n        setMulticastLoopback(flag: boolean): void;\r\n        addMembership(multicastAddress: string, multicastInterface?: string): void;\r\n        dropMembership(multicastAddress: string, multicastInterface?: string): void;\r\n        ref(): this;\r\n        unref(): this;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         * 1. close\r\n         * 2. error\r\n         * 3. listening\r\n         * 4. message\r\n         **/\r\n        addListener(event: string, listener: Function): this;\r\n        addListener(event: \"close\", listener: () => void): this;\r\n        addListener(event: \"error\", listener: (err: Error) => void): this;\r\n        addListener(event: \"listening\", listener: () => void): this;\r\n        addListener(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"close\"): boolean;\r\n        emit(event: \"error\", err: Error): boolean;\r\n        emit(event: \"listening\"): boolean;\r\n        emit(event: \"message\", msg: Buffer, rinfo: AddressInfo): boolean;\r\n\r\n        on(event: string, listener: Function): this;\r\n        on(event: \"close\", listener: () => void): this;\r\n        on(event: \"error\", listener: (err: Error) => void): this;\r\n        on(event: \"listening\", listener: () => void): this;\r\n        on(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\r\n\r\n        once(event: string, listener: Function): this;\r\n        once(event: \"close\", listener: () => void): this;\r\n        once(event: \"error\", listener: (err: Error) => void): this;\r\n        once(event: \"listening\", listener: () => void): this;\r\n        once(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\r\n\r\n        prependListener(event: string, listener: Function): this;\r\n        prependListener(event: \"close\", listener: () => void): this;\r\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"listening\", listener: () => void): this;\r\n        prependListener(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: Function): this;\r\n        prependOnceListener(event: \"close\", listener: () => void): this;\r\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"listening\", listener: () => void): this;\r\n        prependOnceListener(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\r\n    }\r\n}\r\n\r\ndeclare module \"fs\" {\r\n    import * as stream from \"stream\";\r\n    import * as events from \"events\";\r\n\r\n    interface Stats {\r\n        isFile(): boolean;\r\n        isDirectory(): boolean;\r\n        isBlockDevice(): boolean;\r\n        isCharacterDevice(): boolean;\r\n        isSymbolicLink(): boolean;\r\n        isFIFO(): boolean;\r\n        isSocket(): boolean;\r\n        dev: number;\r\n        ino: number;\r\n        mode: number;\r\n        nlink: number;\r\n        uid: number;\r\n        gid: number;\r\n        rdev: number;\r\n        size: number;\r\n        blksize: number;\r\n        blocks: number;\r\n        atime: Date;\r\n        mtime: Date;\r\n        ctime: Date;\r\n        birthtime: Date;\r\n    }\r\n\r\n    interface FSWatcher extends events.EventEmitter {\r\n        close(): void;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. change\r\n         *   2. error\r\n         */\r\n        addListener(event: string, listener: Function): this;\r\n        addListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\r\n        addListener(event: \"error\", listener: (error: Error) => void): this;\r\n\r\n        on(event: string, listener: Function): this;\r\n        on(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\r\n        on(event: \"error\", listener: (error: Error) => void): this;\r\n\r\n        once(event: string, listener: Function): this;\r\n        once(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\r\n        once(event: \"error\", listener: (error: Error) => void): this;\r\n\r\n        prependListener(event: string, listener: Function): this;\r\n        prependListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\r\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: Function): this;\r\n        prependOnceListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\r\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\r\n    }\r\n\r\n    export interface ReadStream extends stream.Readable {\r\n        close(): void;\r\n        destroy(): void;\r\n        bytesRead: number;\r\n        path: string | Buffer;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. open\r\n         *   2. close\r\n         */\r\n        addListener(event: string, listener: Function): this;\r\n        addListener(event: \"open\", listener: (fd: number) => void): this;\r\n        addListener(event: \"close\", listener: () => void): this;\r\n\r\n        on(event: string, listener: Function): this;\r\n        on(event: \"open\", listener: (fd: number) => void): this;\r\n        on(event: \"close\", listener: () => void): this;\r\n\r\n        once(event: string, listener: Function): this;\r\n        once(event: \"open\", listener: (fd: number) => void): this;\r\n        once(event: \"close\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: Function): this;\r\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\r\n        prependListener(event: \"close\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: Function): this;\r\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\r\n        prependOnceListener(event: \"close\", listener: () => void): this;\r\n    }\r\n\r\n    export interface WriteStream extends stream.Writable {\r\n        close(): void;\r\n        bytesWritten: number;\r\n        path: string | Buffer;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. open\r\n         *   2. close\r\n         */\r\n        addListener(event: string, listener: Function): this;\r\n        addListener(event: \"open\", listener: (fd: number) => void): this;\r\n        addListener(event: \"close\", listener: () => void): this;\r\n\r\n        on(event: string, listener: Function): this;\r\n        on(event: \"open\", listener: (fd: number) => void): this;\r\n        on(event: \"close\", listener: () => void): this;\r\n\r\n        once(event: string, listener: Function): this;\r\n        once(event: \"open\", listener: (fd: number) => void): this;\r\n        once(event: \"close\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: Function): this;\r\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\r\n        prependListener(event: \"close\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: Function): this;\r\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\r\n        prependOnceListener(event: \"close\", listener: () => void): this;\r\n    }\r\n\r\n    /**\r\n     * Asynchronous rename.\r\n     * @param callback No arguments other than a possible exception are given to the completion callback.\r\n     */\r\n    export function rename(oldPath: string, newPath: string, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    /**\r\n     * Synchronous rename\r\n     */\r\n    export function renameSync(oldPath: string, newPath: string): void;\r\n    export function truncate(path: string | Buffer, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function truncate(path: string | Buffer, len: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function truncateSync(path: string | Buffer, len?: number): void;\r\n    export function ftruncate(fd: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function ftruncate(fd: number, len: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function ftruncateSync(fd: number, len?: number): void;\r\n    export function chown(path: string | Buffer, uid: number, gid: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function chownSync(path: string | Buffer, uid: number, gid: number): void;\r\n    export function fchown(fd: number, uid: number, gid: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function fchownSync(fd: number, uid: number, gid: number): void;\r\n    export function lchown(path: string | Buffer, uid: number, gid: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function lchownSync(path: string | Buffer, uid: number, gid: number): void;\r\n    export function chmod(path: string | Buffer, mode: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function chmod(path: string | Buffer, mode: string, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function chmodSync(path: string | Buffer, mode: number): void;\r\n    export function chmodSync(path: string | Buffer, mode: string): void;\r\n    export function fchmod(fd: number, mode: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function fchmod(fd: number, mode: string, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function fchmodSync(fd: number, mode: number): void;\r\n    export function fchmodSync(fd: number, mode: string): void;\r\n    export function lchmod(path: string | Buffer, mode: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function lchmod(path: string | Buffer, mode: string, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function lchmodSync(path: string | Buffer, mode: number): void;\r\n    export function lchmodSync(path: string | Buffer, mode: string): void;\r\n    export function stat(path: string | Buffer, callback?: (err: NodeJS.ErrnoException, stats: Stats) => any): void;\r\n    export function lstat(path: string | Buffer, callback?: (err: NodeJS.ErrnoException, stats: Stats) => any): void;\r\n    export function fstat(fd: number, callback?: (err: NodeJS.ErrnoException, stats: Stats) => any): void;\r\n    export function statSync(path: string | Buffer): Stats;\r\n    export function lstatSync(path: string | Buffer): Stats;\r\n    export function fstatSync(fd: number): Stats;\r\n    export function link(srcpath: string | Buffer, dstpath: string | Buffer, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function linkSync(srcpath: string | Buffer, dstpath: string | Buffer): void;\r\n    export function symlink(srcpath: string | Buffer, dstpath: string | Buffer, type?: string, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function symlinkSync(srcpath: string | Buffer, dstpath: string | Buffer, type?: string): void;\r\n    export function readlink(path: string | Buffer, callback?: (err: NodeJS.ErrnoException, linkString: string) => any): void;\r\n    export function readlinkSync(path: string | Buffer): string;\r\n    export function realpath(path: string | Buffer, callback?: (err: NodeJS.ErrnoException, resolvedPath: string) => any): void;\r\n    export function realpath(path: string | Buffer, cache: { [path: string]: string }, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => any): void;\r\n    export function realpathSync(path: string | Buffer, cache?: { [path: string]: string }): string;\r\n    /**\r\n     * Asynchronous unlink - deletes the file specified in {path}\r\n     *\r\n     * @param callback No arguments other than a possible exception are given to the completion callback.\r\n     */\r\n    export function unlink(path: string | Buffer, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    /**\r\n     * Synchronous unlink - deletes the file specified in {path}\r\n     */\r\n    export function unlinkSync(path: string | Buffer): void;\r\n    /**\r\n     * Asynchronous rmdir - removes the directory specified in {path}\r\n     *\r\n     * @param callback No arguments other than a possible exception are given to the completion callback.\r\n     */\r\n    export function rmdir(path: string | Buffer, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    /**\r\n     * Synchronous rmdir - removes the directory specified in {path}\r\n     */\r\n    export function rmdirSync(path: string | Buffer): void;\r\n    /**\r\n     * Asynchronous mkdir - creates the directory specified in {path}.  Parameter {mode} defaults to 0777.\r\n     *\r\n     * @param callback No arguments other than a possible exception are given to the completion callback.\r\n     */\r\n    export function mkdir(path: string | Buffer, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    /**\r\n     * Asynchronous mkdir - creates the directory specified in {path}.  Parameter {mode} defaults to 0777.\r\n     *\r\n     * @param callback No arguments other than a possible exception are given to the completion callback.\r\n     */\r\n    export function mkdir(path: string | Buffer, mode: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    /**\r\n     * Asynchronous mkdir - creates the directory specified in {path}.  Parameter {mode} defaults to 0777.\r\n     *\r\n     * @param callback No arguments other than a possible exception are given to the completion callback.\r\n     */\r\n    export function mkdir(path: string | Buffer, mode: string, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    /**\r\n     * Synchronous mkdir - creates the directory specified in {path}.  Parameter {mode} defaults to 0777.\r\n     *\r\n     * @param callback No arguments other than a possible exception are given to the completion callback.\r\n     */\r\n    export function mkdirSync(path: string | Buffer, mode?: number): void;\r\n    /**\r\n     * Synchronous mkdir - creates the directory specified in {path}.  Parameter {mode} defaults to 0777.\r\n     *\r\n     * @param callback No arguments other than a possible exception are given to the completion callback.\r\n     */\r\n    export function mkdirSync(path: string | Buffer, mode?: string): void;\r\n    /**\r\n     * Asynchronous mkdtemp - Creates a unique temporary directory. Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\r\n     *\r\n     * @param callback The created folder path is passed as a string to the callback's second parameter.\r\n     */\r\n    export function mkdtemp(prefix: string, callback?: (err: NodeJS.ErrnoException, folder: string) => void): void;\r\n    /**\r\n     * Synchronous mkdtemp - Creates a unique temporary directory. Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\r\n     *\r\n     * @returns Returns the created folder path.\r\n     */\r\n    export function mkdtempSync(prefix: string): string;\r\n    export function readdir(path: string | Buffer, callback?: (err: NodeJS.ErrnoException, files: string[]) => void): void;\r\n    export function readdirSync(path: string | Buffer): string[];\r\n    export function close(fd: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function closeSync(fd: number): void;\r\n    export function open(path: string | Buffer, flags: string | number, callback: (err: NodeJS.ErrnoException, fd: number) => void): void;\r\n    export function open(path: string | Buffer, flags: string | number, mode: number, callback: (err: NodeJS.ErrnoException, fd: number) => void): void;\r\n    export function openSync(path: string | Buffer, flags: string | number, mode?: number): number;\r\n    export function utimes(path: string | Buffer, atime: number, mtime: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function utimes(path: string | Buffer, atime: Date, mtime: Date, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function utimesSync(path: string | Buffer, atime: number, mtime: number): void;\r\n    export function utimesSync(path: string | Buffer, atime: Date, mtime: Date): void;\r\n    export function futimes(fd: number, atime: number, mtime: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function futimes(fd: number, atime: Date, mtime: Date, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function futimesSync(fd: number, atime: number, mtime: number): void;\r\n    export function futimesSync(fd: number, atime: Date, mtime: Date): void;\r\n    export function fsync(fd: number, callback?: (err?: NodeJS.ErrnoException) => void): void;\r\n    export function fsyncSync(fd: number): void;\r\n    export function write(fd: number, buffer: Buffer, offset: number, length: number, position: number | null, callback?: (err: NodeJS.ErrnoException, written: number, buffer: Buffer) => void): void;\r\n    export function write(fd: number, buffer: Buffer, offset: number, length: number, callback?: (err: NodeJS.ErrnoException, written: number, buffer: Buffer) => void): void;\r\n    export function write(fd: number, data: any, callback?: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;\r\n    export function write(fd: number, data: any, offset: number, callback?: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;\r\n    export function write(fd: number, data: any, offset: number, encoding: string, callback?: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;\r\n    export function writeSync(fd: number, buffer: Buffer, offset: number, length: number, position?: number | null): number;\r\n    export function writeSync(fd: number, data: any, position?: number | null, enconding?: string): number;\r\n    export function read(fd: number, buffer: Buffer, offset: number, length: number, position: number | null, callback?: (err: NodeJS.ErrnoException, bytesRead: number, buffer: Buffer) => void): void;\r\n    export function readSync(fd: number, buffer: Buffer, offset: number, length: number, position: number | null): number;\r\n    /**\r\n     * Asynchronous readFile - Asynchronously reads the entire contents of a file.\r\n     *\r\n     * @param callback - The callback is passed two arguments (err, data), where data is the contents of the file.\r\n     */\r\n    export function readFile(filename: string, encoding: null, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;\r\n    export function readFile(filename: string, encoding: string, callback: (err: NodeJS.ErrnoException, data: string) => void): void;\r\n    export function readFile(filename: string, encoding: string | null, callback: (err: NodeJS.ErrnoException, data: string | Buffer) => void): void;\r\n    /**\r\n     * Asynchronous readFile - Asynchronously reads the entire contents of a file.\r\n     *\r\n     * @param options An object with optional {encoding} and {flag} properties.  If {encoding} is specified, readFile returns a string; otherwise it returns a Buffer.\r\n     * @param callback - The callback is passed two arguments (err, data), where data is the contents of the file.\r\n     */\r\n    export function readFile(filename: string, options: { encoding: null; flag?: string; }, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;\r\n    export function readFile(filename: string, options: { encoding: string; flag?: string; }, callback: (err: NodeJS.ErrnoException, data: string) => void): void;\r\n    export function readFile(filename: string, options: { encoding: string | null; flag?: string; }, callback: (err: NodeJS.ErrnoException, data: string | Buffer) => void): void;\r\n    /**\r\n     * Asynchronous readFile - Asynchronously reads the entire contents of a file.\r\n     *\r\n     * @param options An object with optional {encoding} and {flag} properties.  If {encoding} is specified, readFile returns a string; otherwise it returns a Buffer.\r\n     * @param callback - The callback is passed two arguments (err, data), where data is the contents of the file.\r\n     */\r\n    export function readFile(filename: string, options: { flag?: string; }, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;\r\n    /**\r\n     * Asynchronous readFile - Asynchronously reads the entire contents of a file.\r\n     *\r\n     * @param callback - The callback is passed two arguments (err, data), where data is the contents of the file.\r\n     */\r\n    export function readFile(filename: string, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;\r\n    /**\r\n     * Synchronous readFile - Synchronously reads the entire contents of a file.\r\n     */\r\n    export function readFileSync(filename: string, encoding: null): Buffer;\r\n    export function readFileSync(filename: string, encoding: string): string;\r\n    export function readFileSync(filename: string, encoding: string | null): string | Buffer;\r\n    /**\r\n     * Synchronous readFile - Synchronously reads the entire contents of a file.\r\n     *\r\n     * @param options An object with optional {encoding} and {flag} properties.  If {encoding} is specified, readFileSync returns a string; otherwise it returns a Buffer.\r\n     */\r\n    export function readFileSync(filename: string, options: { encoding: null; flag?: string; }): Buffer;\r\n    export function readFileSync(filename: string, options: { encoding: string; flag?: string; }): string;\r\n    export function readFileSync(filename: string, options: { encoding: string | null; flag?: string; }): string | Buffer;\r\n    /**\r\n     * Synchronous readFile - Synchronously reads the entire contents of a file.\r\n     *\r\n     * @param options An object with optional {encoding} and {flag} properties.  If {encoding} is specified, readFileSync returns a string; otherwise it returns a Buffer.\r\n     */\r\n    export function readFileSync(filename: string, options?: { flag?: string; }): Buffer;\r\n    export function writeFile(filename: string, data: any, callback?: (err: NodeJS.ErrnoException) => void): void;\r\n    export function writeFile(filename: string, data: any, encoding: string, callback: (err: NodeJS.ErrnoException) => void): void;\r\n    export function writeFile(filename: string, data: any, options: { encoding?: string; mode?: number; flag?: string; }, callback?: (err: NodeJS.ErrnoException) => void): void;\r\n    export function writeFile(filename: string, data: any, options: { encoding?: string; mode?: string; flag?: string; }, callback?: (err: NodeJS.ErrnoException) => void): void;\r\n    export function writeFileSync(filename: string, data: any, encoding: string): void;\r\n    export function writeFileSync(filename: string, data: any, options?: { encoding?: string; mode?: number; flag?: string; }): void;\r\n    export function writeFileSync(filename: string, data: any, options?: { encoding?: string; mode?: string; flag?: string; }): void;\r\n    export function appendFile(filename: string, data: any, encoding: string, callback: (err: NodeJS.ErrnoException) => void): void;\r\n    export function appendFile(filename: string, data: any, options: { encoding?: string; mode?: number; flag?: string; }, callback?: (err: NodeJS.ErrnoException) => void): void;\r\n    export function appendFile(filename: string, data: any, options: { encoding?: string; mode?: string; flag?: string; }, callback?: (err: NodeJS.ErrnoException) => void): void;\r\n    export function appendFile(filename: string, data: any, callback?: (err: NodeJS.ErrnoException) => void): void;\r\n    export function appendFileSync(filename: string, data: any, encoding: string): void;\r\n    export function appendFileSync(filename: string, data: any, options?: { encoding?: string; mode?: number; flag?: string; }): void;\r\n    export function appendFileSync(filename: string, data: any, options?: { encoding?: string; mode?: string; flag?: string; }): void;\r\n    export function watchFile(filename: string, listener: (curr: Stats, prev: Stats) => void): void;\r\n    export function watchFile(filename: string, options: { persistent?: boolean; interval?: number; }, listener: (curr: Stats, prev: Stats) => void): void;\r\n    export function unwatchFile(filename: string, listener?: (curr: Stats, prev: Stats) => void): void;\r\n    export function watch(filename: string, listener?: (event: string, filename: string) => any): FSWatcher;\r\n    export function watch(filename: string, encoding: string, listener?: (event: string, filename: string | Buffer) => any): FSWatcher;\r\n    export function watch(filename: string, options: { persistent?: boolean; recursive?: boolean; encoding?: string }, listener?: (event: string, filename: string | Buffer) => any): FSWatcher;\r\n    export function exists(path: string | Buffer, callback?: (exists: boolean) => void): void;\r\n    export function existsSync(path: string | Buffer): boolean;\r\n\r\n    export namespace constants {\r\n        // File Access Constants\r\n\r\n        /** Constant for fs.access(). File is visible to the calling process. */\r\n        export const F_OK: number;\r\n\r\n        /** Constant for fs.access(). File can be read by the calling process. */\r\n        export const R_OK: number;\r\n\r\n        /** Constant for fs.access(). File can be written by the calling process. */\r\n        export const W_OK: number;\r\n\r\n        /** Constant for fs.access(). File can be executed by the calling process. */\r\n        export const X_OK: number;\r\n\r\n        // File Open Constants\r\n\r\n        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */\r\n        export const O_RDONLY: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */\r\n        export const O_WRONLY: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */\r\n        export const O_RDWR: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */\r\n        export const O_CREAT: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */\r\n        export const O_EXCL: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that if path identifies a terminal device, opening the path shall not cause that terminal to become the controlling terminal for the process (if the process does not already have one). */\r\n        export const O_NOCTTY: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */\r\n        export const O_TRUNC: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */\r\n        export const O_APPEND: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */\r\n        export const O_DIRECTORY: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating reading accesses to the file system will no longer result in an update to the atime information associated with the file. This flag is available on Linux operating systems only. */\r\n        export const O_NOATIME: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */\r\n        export const O_NOFOLLOW: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */\r\n        export const O_SYNC: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */\r\n        export const O_SYMLINK: number;\r\n\r\n        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */\r\n        export const O_DIRECT: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */\r\n        export const O_NONBLOCK: number;\r\n\r\n        // File Type Constants\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */\r\n        export const S_IFMT: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */\r\n        export const S_IFREG: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */\r\n        export const S_IFDIR: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */\r\n        export const S_IFCHR: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */\r\n        export const S_IFBLK: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */\r\n        export const S_IFIFO: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */\r\n        export const S_IFLNK: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */\r\n        export const S_IFSOCK: number;\r\n\r\n        // File Mode Constants\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */\r\n        export const S_IRWXU: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */\r\n        export const S_IRUSR: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */\r\n        export const S_IWUSR: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */\r\n        export const S_IXUSR: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */\r\n        export const S_IRWXG: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */\r\n        export const S_IRGRP: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */\r\n        export const S_IWGRP: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */\r\n        export const S_IXGRP: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */\r\n        export const S_IRWXO: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */\r\n        export const S_IROTH: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */\r\n        export const S_IWOTH: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */\r\n        export const S_IXOTH: number;\r\n    }\r\n\r\n    /** Tests a user's permissions for the file specified by path. */\r\n    export function access(path: string | Buffer, callback: (err: NodeJS.ErrnoException) => void): void;\r\n    export function access(path: string | Buffer, mode: number, callback: (err: NodeJS.ErrnoException) => void): void;\r\n    /** Synchronous version of fs.access. This throws if any accessibility checks fail, and does nothing otherwise. */\r\n    export function accessSync(path: string | Buffer, mode?: number): void;\r\n    export function createReadStream(path: string | Buffer, options?: {\r\n        flags?: string;\r\n        encoding?: string;\r\n        fd?: number;\r\n        mode?: number;\r\n        autoClose?: boolean;\r\n        start?: number;\r\n        end?: number;\r\n        highWaterMark?: number;\r\n    }): ReadStream;\r\n    export function createWriteStream(path: string | Buffer, options?: {\r\n        flags?: string;\r\n        encoding?: string;\r\n        fd?: number;\r\n        mode?: number;\r\n        autoClose?: boolean;\r\n        start?: number;\r\n    }): WriteStream;\r\n    export function fdatasync(fd: number, callback: Function): void;\r\n    export function fdatasyncSync(fd: number): void;\r\n}\r\n\r\ndeclare module \"path\" {\r\n\r\n    /**\r\n     * A parsed path object generated by path.parse() or consumed by path.format().\r\n     */\r\n    export interface ParsedPath {\r\n        /**\r\n         * The root of the path such as '/' or 'c:\\'\r\n         */\r\n        root: string;\r\n        /**\r\n         * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'\r\n         */\r\n        dir: string;\r\n        /**\r\n         * The file name including extension (if any) such as 'index.html'\r\n         */\r\n        base: string;\r\n        /**\r\n         * The file extension (if any) such as '.html'\r\n         */\r\n        ext: string;\r\n        /**\r\n         * The file name without extension (if any) such as 'index'\r\n         */\r\n        name: string;\r\n    }\r\n\r\n    /**\r\n     * Normalize a string path, reducing '..' and '.' parts.\r\n     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\r\n     *\r\n     * @param p string path to normalize.\r\n     */\r\n    export function normalize(p: string): string;\r\n    /**\r\n     * Join all arguments together and normalize the resulting path.\r\n     * Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.\r\n     *\r\n     * @param paths paths to join.\r\n     */\r\n    export function join(...paths: string[]): string;\r\n    /**\r\n     * The right-most parameter is considered {to}.  Other parameters are considered an array of {from}.\r\n     *\r\n     * Starting from leftmost {from} paramter, resolves {to} to an absolute path.\r\n     *\r\n     * If {to} isn't already absolute, {from} arguments are prepended in right to left order, until an absolute path is found. If after using all {from} paths still no absolute path is found, the current working directory is used as well. The resulting path is normalized, and trailing slashes are removed unless the path gets resolved to the root directory.\r\n     *\r\n     * @param pathSegments string paths to join.  Non-string arguments are ignored.\r\n     */\r\n    export function resolve(...pathSegments: any[]): string;\r\n    /**\r\n     * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.\r\n     *\r\n     * @param path path to test.\r\n     */\r\n    export function isAbsolute(path: string): boolean;\r\n    /**\r\n     * Solve the relative path from {from} to {to}.\r\n     * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.\r\n     */\r\n    export function relative(from: string, to: string): string;\r\n    /**\r\n     * Return the directory name of a path. Similar to the Unix dirname command.\r\n     *\r\n     * @param p the path to evaluate.\r\n     */\r\n    export function dirname(p: string): string;\r\n    /**\r\n     * Return the last portion of a path. Similar to the Unix basename command.\r\n     * Often used to extract the file name from a fully qualified path.\r\n     *\r\n     * @param p the path to evaluate.\r\n     * @param ext optionally, an extension to remove from the result.\r\n     */\r\n    export function basename(p: string, ext?: string): string;\r\n    /**\r\n     * Return the extension of the path, from the last '.' to end of string in the last portion of the path.\r\n     * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string\r\n     *\r\n     * @param p the path to evaluate.\r\n     */\r\n    export function extname(p: string): string;\r\n    /**\r\n     * The platform-specific file separator. '\\\\' or '/'.\r\n     */\r\n    export var sep: string;\r\n    /**\r\n     * The platform-specific file delimiter. ';' or ':'.\r\n     */\r\n    export var delimiter: string;\r\n    /**\r\n     * Returns an object from a path string - the opposite of format().\r\n     *\r\n     * @param pathString path to evaluate.\r\n     */\r\n    export function parse(pathString: string): ParsedPath;\r\n    /**\r\n     * Returns a path string from an object - the opposite of parse().\r\n     *\r\n     * @param pathString path to evaluate.\r\n     */\r\n    export function format(pathObject: ParsedPath): string;\r\n\r\n    export module posix {\r\n        export function normalize(p: string): string;\r\n        export function join(...paths: any[]): string;\r\n        export function resolve(...pathSegments: any[]): string;\r\n        export function isAbsolute(p: string): boolean;\r\n        export function relative(from: string, to: string): string;\r\n        export function dirname(p: string): string;\r\n        export function basename(p: string, ext?: string): string;\r\n        export function extname(p: string): string;\r\n        export var sep: string;\r\n        export var delimiter: string;\r\n        export function parse(p: string): ParsedPath;\r\n        export function format(pP: ParsedPath): string;\r\n    }\r\n\r\n    export module win32 {\r\n        export function normalize(p: string): string;\r\n        export function join(...paths: any[]): string;\r\n        export function resolve(...pathSegments: any[]): string;\r\n        export function isAbsolute(p: string): boolean;\r\n        export function relative(from: string, to: string): string;\r\n        export function dirname(p: string): string;\r\n        export function basename(p: string, ext?: string): string;\r\n        export function extname(p: string): string;\r\n        export var sep: string;\r\n        export var delimiter: string;\r\n        export function parse(p: string): ParsedPath;\r\n        export function format(pP: ParsedPath): string;\r\n    }\r\n}\r\n\r\ndeclare module \"string_decoder\" {\r\n    export interface NodeStringDecoder {\r\n        write(buffer: Buffer): string;\r\n        end(buffer?: Buffer): string;\r\n    }\r\n    export var StringDecoder: {\r\n        new (encoding?: string): NodeStringDecoder;\r\n    };\r\n}\r\n\r\ndeclare module \"tls\" {\r\n    import * as crypto from \"crypto\";\r\n    import * as net from \"net\";\r\n    import * as stream from \"stream\";\r\n\r\n    var CLIENT_RENEG_LIMIT: number;\r\n    var CLIENT_RENEG_WINDOW: number;\r\n\r\n    export interface Certificate {\r\n        /**\r\n         * Country code.\r\n         */\r\n        C: string;\r\n        /**\r\n         * Street.\r\n         */\r\n        ST: string;\r\n        /**\r\n         * Locality.\r\n         */\r\n        L: string;\r\n        /**\r\n         * Organization.\r\n         */\r\n        O: string;\r\n        /**\r\n         * Organizational unit.\r\n         */\r\n        OU: string;\r\n        /**\r\n         * Common name.\r\n         */\r\n        CN: string;\r\n    }\r\n\r\n    export interface CipherNameAndProtocol {\r\n        /**\r\n         * The cipher name.\r\n         */\r\n        name: string;\r\n        /**\r\n         * SSL/TLS protocol version.\r\n         */\r\n        version: string;\r\n    }\r\n\r\n    export class TLSSocket extends net.Socket {\r\n        /**\r\n         * Construct a new tls.TLSSocket object from an existing TCP socket.\r\n         */\r\n        constructor(socket:net.Socket, options?: {\r\n          /**\r\n           * An optional TLS context object from tls.createSecureContext()\r\n           */\r\n          secureContext?: SecureContext,\r\n          /**\r\n           * If true the TLS socket will be instantiated in server-mode.\r\n           * Defaults to false.\r\n           */\r\n          isServer?: boolean,\r\n          /**\r\n           * An optional net.Server instance.\r\n           */\r\n          server?: net.Server,\r\n          /**\r\n           * If true the server will request a certificate from clients that\r\n           * connect and attempt to verify that certificate. Defaults to\r\n           * false.\r\n           */\r\n          requestCert?: boolean,\r\n          /**\r\n           * If true the server will reject any connection which is not\r\n           * authorized with the list of supplied CAs. This option only has an\r\n           * effect if requestCert is true. Defaults to false.\r\n           */\r\n          rejectUnauthorized?: boolean,\r\n          /**\r\n           * An array of strings or a Buffer naming possible NPN protocols.\r\n           * (Protocols should be ordered by their priority.)\r\n           */\r\n          NPNProtocols?: string[] | Buffer,\r\n          /**\r\n           * An array of strings or a Buffer naming possible ALPN protocols.\r\n           * (Protocols should be ordered by their priority.) When the server\r\n           * receives both NPN and ALPN extensions from the client, ALPN takes\r\n           * precedence over NPN and the server does not send an NPN extension\r\n           * to the client.\r\n           */\r\n          ALPNProtocols?: string[] | Buffer,\r\n          /**\r\n           * SNICallback(servername, cb) <Function> A function that will be\r\n           * called if the client supports SNI TLS extension. Two arguments\r\n           * will be passed when called: servername and cb. SNICallback should\r\n           * invoke cb(null, ctx), where ctx is a SecureContext instance.\r\n           * (tls.createSecureContext(...) can be used to get a proper\r\n           * SecureContext.) If SNICallback wasn't provided the default callback\r\n           * with high-level API will be used (see below).\r\n           */\r\n          SNICallback?: Function,\r\n          /**\r\n           * An optional Buffer instance containing a TLS session.\r\n           */\r\n          session?: Buffer,\r\n          /**\r\n           * If true, specifies that the OCSP status request extension will be\r\n           * added to the client hello and an 'OCSPResponse' event will be\r\n           * emitted on the socket before establishing a secure communication\r\n           */\r\n          requestOCSP?: boolean\r\n        });\r\n        /**\r\n         * Returns the bound address, the address family name and port of the underlying socket as reported by\r\n         * the operating system.\r\n         * @returns An object with three properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }.\r\n         */\r\n        address(): { port: number; family: string; address: string };\r\n        /**\r\n         * A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false.\r\n         */\r\n        authorized: boolean;\r\n        /**\r\n         * The reason why the peer's certificate has not been verified.\r\n         * This property becomes available only when tlsSocket.authorized === false.\r\n         */\r\n        authorizationError: Error;\r\n        /**\r\n         * Static boolean value, always true.\r\n         * May be used to distinguish TLS sockets from regular ones.\r\n         */\r\n        encrypted: boolean;\r\n        /**\r\n         * Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection.\r\n         * @returns Returns an object representing the cipher name and the SSL/TLS protocol version of the current\r\n         * connection.\r\n         */\r\n        getCipher(): CipherNameAndProtocol;\r\n        /**\r\n         * Returns an object representing the peer's certificate.\r\n         * The returned object has some properties corresponding to the field of the certificate.\r\n         * If detailed argument is true the full chain with issuer property will be returned,\r\n         * if false only the top certificate without issuer property.\r\n         * If the peer does not provide a certificate, it returns null or an empty object.\r\n         * @param detailed - If true; the full chain with issuer property will be returned.\r\n         * @returns An object representing the peer's certificate.\r\n         */\r\n        getPeerCertificate(detailed?: boolean): {\r\n            subject: Certificate;\r\n            issuerInfo: Certificate;\r\n            issuer: Certificate;\r\n            raw: any;\r\n            valid_from: string;\r\n            valid_to: string;\r\n            fingerprint: string;\r\n            serialNumber: string;\r\n        };\r\n        /**\r\n         * Could be used to speed up handshake establishment when reconnecting to the server.\r\n         * @returns ASN.1 encoded TLS session or undefined if none was negotiated.\r\n         */\r\n        getSession(): any;\r\n        /**\r\n         * NOTE: Works only with client TLS sockets.\r\n         * Useful only for debugging, for session reuse provide session option to tls.connect().\r\n         * @returns TLS session ticket or undefined if none was negotiated.\r\n         */\r\n        getTLSTicket(): any;\r\n        /**\r\n         * The string representation of the local IP address.\r\n         */\r\n        localAddress: string;\r\n        /**\r\n         * The numeric representation of the local port.\r\n         */\r\n        localPort: number;\r\n        /**\r\n         * The string representation of the remote IP address.\r\n         * For example, '74.125.127.100' or '2001:4860:a005::68'.\r\n         */\r\n        remoteAddress: string;\r\n        /**\r\n         * The string representation of the remote IP family. 'IPv4' or 'IPv6'.\r\n         */\r\n        remoteFamily: string;\r\n        /**\r\n         * The numeric representation of the remote port. For example, 443.\r\n         */\r\n        remotePort: number;\r\n        /**\r\n         * Initiate TLS renegotiation process.\r\n         *\r\n         * NOTE: Can be used to request peer's certificate after the secure connection has been established.\r\n         * ANOTHER NOTE: When running as the server, socket will be destroyed with an error after handshakeTimeout timeout.\r\n         * @param options - The options may contain the following fields: rejectUnauthorized,\r\n         * requestCert (See tls.createServer() for details).\r\n         * @param callback - callback(err) will be executed with null as err, once the renegotiation\r\n         * is successfully completed.\r\n         */\r\n        renegotiate(options: TlsOptions, callback: (err: Error) => any): any;\r\n        /**\r\n         * Set maximum TLS fragment size (default and maximum value is: 16384, minimum is: 512).\r\n         * Smaller fragment size decreases buffering latency on the client: large fragments are buffered by\r\n         * the TLS layer until the entire fragment is received and its integrity is verified;\r\n         * large fragments can span multiple roundtrips, and their processing can be delayed due to packet\r\n         * loss or reordering. However, smaller fragments add extra TLS framing bytes and CPU overhead,\r\n         * which may decrease overall server throughput.\r\n         * @param size - TLS fragment size (default and maximum value is: 16384, minimum is: 512).\r\n         * @returns Returns true on success, false otherwise.\r\n         */\r\n        setMaxSendFragment(size: number): boolean;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         * 1. OCSPResponse\r\n         * 2. secureConnect\r\n         **/\r\n        addListener(event: string, listener: Function): this;\r\n        addListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\r\n        addListener(event: \"secureConnect\", listener: () => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"OCSPResponse\", response: Buffer): boolean;\r\n        emit(event: \"secureConnect\"): boolean;\r\n\r\n        on(event: string, listener: Function): this;\r\n        on(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\r\n        on(event: \"secureConnect\", listener: () => void): this;\r\n\r\n        once(event: string, listener: Function): this;\r\n        once(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\r\n        once(event: \"secureConnect\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: Function): this;\r\n        prependListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\r\n        prependListener(event: \"secureConnect\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: Function): this;\r\n        prependOnceListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\r\n        prependOnceListener(event: \"secureConnect\", listener: () => void): this;\r\n    }\r\n\r\n    export interface TlsOptions {\r\n        host?: string;\r\n        port?: number;\r\n        pfx?: string | Buffer[];\r\n        key?: string | string[] | Buffer | any[];\r\n        passphrase?: string;\r\n        cert?: string | string[] | Buffer | Buffer[];\r\n        ca?: string | string[] | Buffer | Buffer[];\r\n        crl?: string | string[];\r\n        ciphers?: string;\r\n        honorCipherOrder?: boolean;\r\n        requestCert?: boolean;\r\n        rejectUnauthorized?: boolean;\r\n        NPNProtocols?: string[] | Buffer;\r\n        SNICallback?: (servername: string, cb: (err: Error, ctx: SecureContext) => any) => any;\r\n        ecdhCurve?: string;\r\n        dhparam?: string | Buffer;\r\n        handshakeTimeout?: number;\r\n        ALPNProtocols?: string[] | Buffer;\r\n        sessionTimeout?: number;\r\n        ticketKeys?: any;\r\n        sessionIdContext?: string;\r\n        secureProtocol?: string;\r\n    }\r\n\r\n    export interface ConnectionOptions {\r\n        host?: string;\r\n        port?: number;\r\n        socket?: net.Socket;\r\n        pfx?: string | Buffer\r\n        key?: string | string[] | Buffer | Buffer[];\r\n        passphrase?: string;\r\n        cert?: string | string[] | Buffer | Buffer[];\r\n        ca?: string | Buffer | (string | Buffer)[];\r\n        rejectUnauthorized?: boolean;\r\n        NPNProtocols?: (string | Buffer)[];\r\n        servername?: string;\r\n        path?: string;\r\n        ALPNProtocols?: (string | Buffer)[];\r\n        checkServerIdentity?: (servername: string, cert: string | Buffer | (string | Buffer)[]) => any;\r\n        secureProtocol?: string;\r\n        secureContext?: Object;\r\n        session?: Buffer;\r\n        minDHSize?: number;\r\n    }\r\n\r\n    export interface Server extends net.Server {\r\n        close(callback?: Function): Server;\r\n        address(): { port: number; family: string; address: string; };\r\n        addContext(hostName: string, credentials: {\r\n            key: string;\r\n            cert: string;\r\n            ca: string;\r\n        }): void;\r\n        maxConnections: number;\r\n        connections: number;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         * 1. tlsClientError\r\n         * 2. newSession\r\n         * 3. OCSPRequest\r\n         * 4. resumeSession\r\n         * 5. secureConnection\r\n         **/\r\n        addListener(event: string, listener: Function): this;\r\n        addListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\r\n        addListener(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\r\n        addListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\r\n        addListener(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\r\n        addListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"tlsClientError\", err: Error, tlsSocket: TLSSocket): boolean;\r\n        emit(event: \"newSession\", sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void): boolean;\r\n        emit(event: \"OCSPRequest\", certificate: Buffer, issuer: Buffer, callback: Function): boolean;\r\n        emit(event: \"resumeSession\", sessionId: any, callback: (err: Error, sessionData: any) => void): boolean;\r\n        emit(event: \"secureConnection\", tlsSocket: TLSSocket): boolean;\r\n\r\n        on(event: string, listener: Function): this;\r\n        on(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\r\n        on(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\r\n        on(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\r\n        on(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\r\n        on(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\r\n\r\n        once(event: string, listener: Function): this;\r\n        once(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\r\n        once(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\r\n        once(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\r\n        once(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\r\n        once(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\r\n\r\n        prependListener(event: string, listener: Function): this;\r\n        prependListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\r\n        prependListener(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\r\n        prependListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\r\n        prependListener(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\r\n        prependListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: Function): this;\r\n        prependOnceListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\r\n        prependOnceListener(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\r\n        prependOnceListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\r\n        prependOnceListener(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\r\n        prependOnceListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\r\n    }\r\n\r\n    export interface ClearTextStream extends stream.Duplex {\r\n        authorized: boolean;\r\n        authorizationError: Error;\r\n        getPeerCertificate(): any;\r\n        getCipher: {\r\n            name: string;\r\n            version: string;\r\n        };\r\n        address: {\r\n            port: number;\r\n            family: string;\r\n            address: string;\r\n        };\r\n        remoteAddress: string;\r\n        remotePort: number;\r\n    }\r\n\r\n    export interface SecurePair {\r\n        encrypted: any;\r\n        cleartext: any;\r\n    }\r\n\r\n    export interface SecureContextOptions {\r\n        pfx?: string | Buffer;\r\n        key?: string | Buffer;\r\n        passphrase?: string;\r\n        cert?: string | Buffer;\r\n        ca?: string | Buffer;\r\n        crl?: string | string[]\r\n        ciphers?: string;\r\n        honorCipherOrder?: boolean;\r\n    }\r\n\r\n    export interface SecureContext {\r\n        context: any;\r\n    }\r\n\r\n    export function createServer(options: TlsOptions, secureConnectionListener?: (socket: TLSSocket) => void): Server;\r\n    export function connect(options: ConnectionOptions, secureConnectionListener?: () => void): TLSSocket;\r\n    export function connect(port: number, host?: string, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\r\n    export function connect(port: number, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\r\n    export function createSecurePair(credentials?: crypto.Credentials, isServer?: boolean, requestCert?: boolean, rejectUnauthorized?: boolean): SecurePair;\r\n    export function createSecureContext(details: SecureContextOptions): SecureContext;\r\n}\r\n\r\ndeclare module \"crypto\" {\r\n    export interface Certificate {\r\n        exportChallenge(spkac: string | Buffer): Buffer;\r\n        exportPublicKey(spkac: string | Buffer): Buffer;\r\n        verifySpkac(spkac: Buffer): boolean;\r\n    }\r\n    export var Certificate: {\r\n        new (): Certificate;\r\n        (): Certificate;\r\n    }\r\n\r\n    export var fips: boolean;\r\n\r\n    export interface CredentialDetails {\r\n        pfx: string;\r\n        key: string;\r\n        passphrase: string;\r\n        cert: string;\r\n        ca: string | string[];\r\n        crl: string | string[];\r\n        ciphers: string;\r\n    }\r\n    export interface Credentials { context?: any; }\r\n    export function createCredentials(details: CredentialDetails): Credentials;\r\n    export function createHash(algorithm: string): Hash;\r\n    export function createHmac(algorithm: string, key: string | Buffer): Hmac;\r\n\r\n    type Utf8AsciiLatin1Encoding = \"utf8\" | \"ascii\" | \"latin1\";\r\n    type HexBase64Latin1Encoding = \"latin1\" | \"hex\" | \"base64\";\r\n    type Utf8AsciiBinaryEncoding = \"utf8\" | \"ascii\" | \"binary\";\r\n    type HexBase64BinaryEncoding = \"binary\" | \"base64\" | \"hex\";\r\n    type ECDHKeyFormat = \"compressed\" | \"uncompressed\" | \"hybrid\";\r\n\r\n    export interface Hash extends NodeJS.ReadWriteStream {\r\n        update(data: string | Buffer): Hash;\r\n        update(data: string | Buffer, input_encoding: Utf8AsciiLatin1Encoding): Hash;\r\n        digest(): Buffer;\r\n        digest(encoding: HexBase64Latin1Encoding): string;\r\n    }\r\n    export interface Hmac extends NodeJS.ReadWriteStream {\r\n        update(data: string | Buffer): Hmac;\r\n        update(data: string | Buffer, input_encoding: Utf8AsciiLatin1Encoding): Hmac;\r\n        digest(): Buffer;\r\n        digest(encoding: HexBase64Latin1Encoding): string;\r\n    }\r\n    export function createCipher(algorithm: string, password: any): Cipher;\r\n    export function createCipheriv(algorithm: string, key: any, iv: any): Cipher;\r\n    export interface Cipher extends NodeJS.ReadWriteStream {\r\n        update(data: Buffer): Buffer;\r\n        update(data: string, input_encoding: Utf8AsciiBinaryEncoding): Buffer;\r\n        update(data: Buffer, input_encoding: any, output_encoding: HexBase64BinaryEncoding): string;\r\n        update(data: string, input_encoding: Utf8AsciiBinaryEncoding, output_encoding: HexBase64BinaryEncoding): string;\r\n        final(): Buffer;\r\n        final(output_encoding: string): string;\r\n        setAutoPadding(auto_padding?: boolean): void;\r\n        getAuthTag(): Buffer;\r\n        setAAD(buffer: Buffer): void;\r\n    }\r\n    export function createDecipher(algorithm: string, password: any): Decipher;\r\n    export function createDecipheriv(algorithm: string, key: any, iv: any): Decipher;\r\n    export interface Decipher extends NodeJS.ReadWriteStream {\r\n        update(data: Buffer): Buffer;\r\n        update(data: string, input_encoding: HexBase64BinaryEncoding): Buffer;\r\n        update(data: Buffer, input_encoding: any, output_encoding: Utf8AsciiBinaryEncoding): string;\r\n        update(data: string, input_encoding: HexBase64BinaryEncoding, output_encoding: Utf8AsciiBinaryEncoding): string;\r\n        final(): Buffer;\r\n        final(output_encoding: string): string;\r\n        setAutoPadding(auto_padding?: boolean): void;\r\n        setAuthTag(tag: Buffer): void;\r\n        setAAD(buffer: Buffer): void;\r\n    }\r\n    export function createSign(algorithm: string): Signer;\r\n    export interface Signer extends NodeJS.WritableStream {\r\n        update(data: string | Buffer): Signer;\r\n        update(data: string | Buffer, input_encoding: Utf8AsciiLatin1Encoding): Signer;\r\n        sign(private_key: string | { key: string; passphrase: string }): Buffer;\r\n        sign(private_key: string | { key: string; passphrase: string }, output_format: HexBase64Latin1Encoding): string;\r\n    }\r\n    export function createVerify(algorith: string): Verify;\r\n    export interface Verify extends NodeJS.WritableStream {\r\n        update(data: string | Buffer): Verify;\r\n        update(data: string | Buffer, input_encoding: Utf8AsciiLatin1Encoding): Verify;\r\n        verify(object: string, signature: Buffer): boolean;\r\n        verify(object: string, signature: string, signature_format: HexBase64Latin1Encoding): boolean;\r\n    }\r\n    export function createDiffieHellman(prime_length: number, generator?: number): DiffieHellman;\r\n    export function createDiffieHellman(prime: Buffer): DiffieHellman;\r\n    export function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding): DiffieHellman;\r\n    export function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding, generator: number | Buffer): DiffieHellman;\r\n    export function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding, generator: string, generator_encoding: HexBase64Latin1Encoding): DiffieHellman;\r\n    export interface DiffieHellman {\r\n        generateKeys(): Buffer;\r\n        generateKeys(encoding: HexBase64Latin1Encoding): string;\r\n        computeSecret(other_public_key: Buffer): Buffer;\r\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer;\r\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding, output_encoding: HexBase64Latin1Encoding): string;\r\n        getPrime(): Buffer;\r\n        getPrime(encoding: HexBase64Latin1Encoding): string;\r\n        getGenerator(): Buffer;\r\n        getGenerator(encoding: HexBase64Latin1Encoding): string;\r\n        getPublicKey(): Buffer;\r\n        getPublicKey(encoding: HexBase64Latin1Encoding): string;\r\n        getPrivateKey(): Buffer;\r\n        getPrivateKey(encoding: HexBase64Latin1Encoding): string;\r\n        setPublicKey(public_key: Buffer): void;\r\n        setPublicKey(public_key: string, encoding: string): void;\r\n        setPrivateKey(private_key: Buffer): void;\r\n        setPrivateKey(private_key: string, encoding: string): void;\r\n        verifyError: number;\r\n    }\r\n    export function getDiffieHellman(group_name: string): DiffieHellman;\r\n    export function pbkdf2(password: string | Buffer, salt: string | Buffer, iterations: number, keylen: number, digest: string, callback: (err: Error, derivedKey: Buffer) => any): void;\r\n    export function pbkdf2Sync(password: string | Buffer, salt: string | Buffer, iterations: number, keylen: number, digest: string): Buffer;\r\n    export function randomBytes(size: number): Buffer;\r\n    export function randomBytes(size: number, callback: (err: Error, buf: Buffer) => void): void;\r\n    export function pseudoRandomBytes(size: number): Buffer;\r\n    export function pseudoRandomBytes(size: number, callback: (err: Error, buf: Buffer) => void): void;\r\n    export interface RsaPublicKey {\r\n        key: string;\r\n        padding?: number;\r\n    }\r\n    export interface RsaPrivateKey {\r\n        key: string;\r\n        passphrase?: string,\r\n        padding?: number;\r\n    }\r\n    export function publicEncrypt(public_key: string | RsaPublicKey, buffer: Buffer): Buffer\r\n    export function privateDecrypt(private_key: string | RsaPrivateKey, buffer: Buffer): Buffer\r\n    export function privateEncrypt(private_key: string | RsaPrivateKey, buffer: Buffer): Buffer\r\n    export function publicDecrypt(public_key: string | RsaPublicKey, buffer: Buffer): Buffer\r\n    export function getCiphers(): string[];\r\n    export function getCurves(): string[];\r\n    export function getHashes(): string[];\r\n    export interface ECDH {\r\n        generateKeys(): Buffer;\r\n        generateKeys(encoding: HexBase64Latin1Encoding): string;\r\n        generateKeys(encoding: HexBase64Latin1Encoding, format: ECDHKeyFormat): string;\r\n        computeSecret(other_public_key: Buffer): Buffer;\r\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer;\r\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding, output_encoding: HexBase64Latin1Encoding): string;\r\n        getPrivateKey(): Buffer;\r\n        getPrivateKey(encoding: HexBase64Latin1Encoding): string;\r\n        getPublicKey(): Buffer;\r\n        getPublicKey(encoding: HexBase64Latin1Encoding): string;\r\n        getPublicKey(encoding: HexBase64Latin1Encoding, format: ECDHKeyFormat): string;\r\n        setPrivateKey(private_key: Buffer): void;\r\n        setPrivateKey(private_key: string, encoding: HexBase64Latin1Encoding): void;\r\n    }\r\n    export function createECDH(curve_name: string): ECDH;\r\n    export function timingSafeEqual(a: Buffer, b: Buffer): boolean;\r\n    export var DEFAULT_ENCODING: string;\r\n}\r\n\r\ndeclare module \"stream\" {\r\n    import * as events from \"events\";\r\n\r\n    class internal extends events.EventEmitter {\r\n        pipe<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }): T;\r\n    }\r\n\r\n    namespace internal {\r\n\r\n        export class Stream extends internal { }\r\n\r\n        export interface ReadableOptions {\r\n            highWaterMark?: number;\r\n            encoding?: string;\r\n            objectMode?: boolean;\r\n            read?: (this: Readable, size?: number) => any;\r\n        }\r\n\r\n        export class Readable extends Stream implements NodeJS.ReadableStream {\r\n            readable: boolean;\r\n            constructor(opts?: ReadableOptions);\r\n            _read(size: number): void;\r\n            read(size?: number): any;\r\n            setEncoding(encoding: string): void;\r\n            pause(): this;\r\n            resume(): this;\r\n            isPaused(): boolean;\r\n            pipe<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }): T;\r\n            unpipe<T extends NodeJS.WritableStream>(destination?: T): void;\r\n            unshift(chunk: any): void;\r\n            wrap(oldStream: NodeJS.ReadableStream): Readable;\r\n            push(chunk: any, encoding?: string): boolean;\r\n\r\n            /**\r\n             * Event emitter\r\n             * The defined events on documents including:\r\n             *   1. close\r\n             *   2. data\r\n             *   3. end\r\n             *   4. readable\r\n             *   5. error\r\n             **/\r\n            addListener(event: string, listener: Function): this;\r\n            addListener(event: string, listener: Function): this;\r\n            addListener(event: \"close\", listener: () => void): this;\r\n            addListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n            addListener(event: \"end\", listener: () => void): this;\r\n            addListener(event: \"readable\", listener: () => void): this;\r\n            addListener(event: \"error\", listener: (err: Error) => void): this;\r\n\r\n            emit(event: string | symbol, ...args: any[]): boolean;\r\n            emit(event: \"close\"): boolean;\r\n            emit(event: \"data\", chunk: Buffer | string): boolean;\r\n            emit(event: \"end\"): boolean;\r\n            emit(event: \"readable\"): boolean;\r\n            emit(event: \"error\", err: Error): boolean;\r\n\r\n            on(event: string, listener: Function): this;\r\n            on(event: \"close\", listener: () => void): this;\r\n            on(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n            on(event: \"end\", listener: () => void): this;\r\n            on(event: \"readable\", listener: () => void): this;\r\n            on(event: \"error\", listener: (err: Error) => void): this;\r\n\r\n            once(event: string, listener: Function): this;\r\n            once(event: \"close\", listener: () => void): this;\r\n            once(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n            once(event: \"end\", listener: () => void): this;\r\n            once(event: \"readable\", listener: () => void): this;\r\n            once(event: \"error\", listener: (err: Error) => void): this;\r\n\r\n            prependListener(event: string, listener: Function): this;\r\n            prependListener(event: \"close\", listener: () => void): this;\r\n            prependListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n            prependListener(event: \"end\", listener: () => void): this;\r\n            prependListener(event: \"readable\", listener: () => void): this;\r\n            prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n\r\n            prependOnceListener(event: string, listener: Function): this;\r\n            prependOnceListener(event: \"close\", listener: () => void): this;\r\n            prependOnceListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n            prependOnceListener(event: \"end\", listener: () => void): this;\r\n            prependOnceListener(event: \"readable\", listener: () => void): this;\r\n            prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n\r\n            removeListener(event: string, listener: Function): this;\r\n            removeListener(event: \"close\", listener: () => void): this;\r\n            removeListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n            removeListener(event: \"end\", listener: () => void): this;\r\n            removeListener(event: \"readable\", listener: () => void): this;\r\n            removeListener(event: \"error\", listener: (err: Error) => void): this;\r\n        }\r\n\r\n        export interface WritableOptions {\r\n            highWaterMark?: number;\r\n            decodeStrings?: boolean;\r\n            objectMode?: boolean;\r\n            write?: (chunk: string | Buffer, encoding: string, callback: Function) => any;\r\n            writev?: (chunks: { chunk: string | Buffer, encoding: string }[], callback: Function) => any;\r\n        }\r\n\r\n        export class Writable extends Stream implements NodeJS.WritableStream {\r\n            writable: boolean;\r\n            constructor(opts?: WritableOptions);\r\n            _write(chunk: any, encoding: string, callback: Function): void;\r\n            write(chunk: any, cb?: Function): boolean;\r\n            write(chunk: any, encoding?: string, cb?: Function): boolean;\r\n            setDefaultEncoding(encoding: string): this;\r\n            end(cb?: Function): void;\r\n            end(chunk: any, cb?: Function): void;\r\n            end(chunk: any, encoding?: string, cb?: Function): void;\r\n\r\n            /**\r\n             * Event emitter\r\n             * The defined events on documents including:\r\n             *   1. close\r\n             *   2. drain\r\n             *   3. error\r\n             *   4. finish\r\n             *   5. pipe\r\n             *   6. unpipe\r\n             **/\r\n            addListener(event: string, listener: Function): this;\r\n            addListener(event: \"close\", listener: () => void): this;\r\n            addListener(event: \"drain\", listener: () => void): this;\r\n            addListener(event: \"error\", listener: (err: Error) => void): this;\r\n            addListener(event: \"finish\", listener: () => void): this;\r\n            addListener(event: \"pipe\", listener: (src: Readable) => void): this;\r\n            addListener(event: \"unpipe\", listener: (src: Readable) => void): this;\r\n\r\n            emit(event: string | symbol, ...args: any[]): boolean;\r\n            emit(event: \"close\"): boolean;\r\n            emit(event: \"drain\", chunk: Buffer | string): boolean;\r\n            emit(event: \"error\", err: Error): boolean;\r\n            emit(event: \"finish\"): boolean;\r\n            emit(event: \"pipe\", src: Readable): boolean;\r\n            emit(event: \"unpipe\", src: Readable): boolean;\r\n\r\n            on(event: string, listener: Function): this;\r\n            on(event: \"close\", listener: () => void): this;\r\n            on(event: \"drain\", listener: () => void): this;\r\n            on(event: \"error\", listener: (err: Error) => void): this;\r\n            on(event: \"finish\", listener: () => void): this;\r\n            on(event: \"pipe\", listener: (src: Readable) => void): this;\r\n            on(event: \"unpipe\", listener: (src: Readable) => void): this;\r\n\r\n            once(event: string, listener: Function): this;\r\n            once(event: \"close\", listener: () => void): this;\r\n            once(event: \"drain\", listener: () => void): this;\r\n            once(event: \"error\", listener: (err: Error) => void): this;\r\n            once(event: \"finish\", listener: () => void): this;\r\n            once(event: \"pipe\", listener: (src: Readable) => void): this;\r\n            once(event: \"unpipe\", listener: (src: Readable) => void): this;\r\n\r\n            prependListener(event: string, listener: Function): this;\r\n            prependListener(event: \"close\", listener: () => void): this;\r\n            prependListener(event: \"drain\", listener: () => void): this;\r\n            prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n            prependListener(event: \"finish\", listener: () => void): this;\r\n            prependListener(event: \"pipe\", listener: (src: Readable) => void): this;\r\n            prependListener(event: \"unpipe\", listener: (src: Readable) => void): this;\r\n\r\n            prependOnceListener(event: string, listener: Function): this;\r\n            prependOnceListener(event: \"close\", listener: () => void): this;\r\n            prependOnceListener(event: \"drain\", listener: () => void): this;\r\n            prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n            prependOnceListener(event: \"finish\", listener: () => void): this;\r\n            prependOnceListener(event: \"pipe\", listener: (src: Readable) => void): this;\r\n            prependOnceListener(event: \"unpipe\", listener: (src: Readable) => void): this;\r\n\r\n            removeListener(event: string, listener: Function): this;\r\n            removeListener(event: \"close\", listener: () => void): this;\r\n            removeListener(event: \"drain\", listener: () => void): this;\r\n            removeListener(event: \"error\", listener: (err: Error) => void): this;\r\n            removeListener(event: \"finish\", listener: () => void): this;\r\n            removeListener(event: \"pipe\", listener: (src: Readable) => void): this;\r\n            removeListener(event: \"unpipe\", listener: (src: Readable) => void): this;\r\n        }\r\n\r\n        export interface DuplexOptions extends ReadableOptions, WritableOptions {\r\n            allowHalfOpen?: boolean;\r\n            readableObjectMode?: boolean;\r\n            writableObjectMode?: boolean;\r\n        }\r\n\r\n        // Note: Duplex extends both Readable and Writable.\r\n        export class Duplex extends Readable implements Writable {\r\n            writable: boolean;\r\n            constructor(opts?: DuplexOptions);\r\n            _write(chunk: any, encoding: string, callback: Function): void;\r\n            write(chunk: any, cb?: Function): boolean;\r\n            write(chunk: any, encoding?: string, cb?: Function): boolean;\r\n            setDefaultEncoding(encoding: string): this;\r\n            end(cb?: Function): void;\r\n            end(chunk: any, cb?: Function): void;\r\n            end(chunk: any, encoding?: string, cb?: Function): void;\r\n        }\r\n\r\n        export interface TransformOptions extends DuplexOptions {\r\n            transform?: (chunk: string | Buffer, encoding: string, callback: Function) => any;\r\n            flush?: (callback: Function) => any;\r\n        }\r\n\r\n        export class Transform extends Duplex {\r\n            constructor(opts?: TransformOptions);\r\n            _transform(chunk: any, encoding: string, callback: Function): void;\r\n        }\r\n\r\n        export class PassThrough extends Transform { }\r\n    }\r\n\r\n    export = internal;\r\n}\r\n\r\ndeclare module \"util\" {\r\n    export interface InspectOptions extends NodeJS.InspectOptions {}\r\n    export function format(format: any, ...param: any[]): string;\r\n    export function debug(string: string): void;\r\n    export function error(...param: any[]): void;\r\n    export function puts(...param: any[]): void;\r\n    export function print(...param: any[]): void;\r\n    export function log(string: string): void;\r\n    export function inspect(object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string;\r\n    export function inspect(object: any, options: InspectOptions): string;\r\n    export function isArray(object: any): boolean;\r\n    export function isRegExp(object: any): boolean;\r\n    export function isDate(object: any): boolean;\r\n    export function isError(object: any): boolean;\r\n    export function inherits(constructor: any, superConstructor: any): void;\r\n    export function debuglog(key: string): (msg: string, ...param: any[]) => void;\r\n    export function isBoolean(object: any): boolean;\r\n    export function isBuffer(object: any): boolean;\r\n    export function isFunction(object: any): boolean;\r\n    export function isNull(object: any): boolean;\r\n    export function isNullOrUndefined(object: any): boolean;\r\n    export function isNumber(object: any): boolean;\r\n    export function isObject(object: any): boolean;\r\n    export function isPrimitive(object: any): boolean;\r\n    export function isString(object: any): boolean;\r\n    export function isSymbol(object: any): boolean;\r\n    export function isUndefined(object: any): boolean;\r\n    export function deprecate<T extends Function>(fn: T, message: string): T;\r\n}\r\n\r\ndeclare module \"assert\" {\r\n    function internal(value: any, message?: string): void;\r\n    namespace internal {\r\n        export class AssertionError implements Error {\r\n            name: string;\r\n            message: string;\r\n            actual: any;\r\n            expected: any;\r\n            operator: string;\r\n            generatedMessage: boolean;\r\n\r\n            constructor(options?: {\r\n                message?: string; actual?: any; expected?: any;\r\n                operator?: string; stackStartFunction?: Function\r\n            });\r\n        }\r\n\r\n        export function fail(actual: any, expected: any, message?: string, operator?: string): void;\r\n        export function ok(value: any, message?: string): void;\r\n        export function equal(actual: any, expected: any, message?: string): void;\r\n        export function notEqual(actual: any, expected: any, message?: string): void;\r\n        export function deepEqual(actual: any, expected: any, message?: string): void;\r\n        export function notDeepEqual(acutal: any, expected: any, message?: string): void;\r\n        export function strictEqual(actual: any, expected: any, message?: string): void;\r\n        export function notStrictEqual(actual: any, expected: any, message?: string): void;\r\n        export function deepStrictEqual(actual: any, expected: any, message?: string): void;\r\n        export function notDeepStrictEqual(actual: any, expected: any, message?: string): void;\r\n\r\n        export function throws(block: Function, message?: string): void;\r\n        export function throws(block: Function, error: Function, message?: string): void;\r\n        export function throws(block: Function, error: RegExp, message?: string): void;\r\n        export function throws(block: Function, error: (err: any) => boolean, message?: string): void;\r\n\r\n        export function doesNotThrow(block: Function, message?: string): void;\r\n        export function doesNotThrow(block: Function, error: Function, message?: string): void;\r\n        export function doesNotThrow(block: Function, error: RegExp, message?: string): void;\r\n        export function doesNotThrow(block: Function, error: (err: any) => boolean, message?: string): void;\r\n\r\n        export function ifError(value: any): void;\r\n    }\r\n\r\n    export = internal;\r\n}\r\n\r\ndeclare module \"tty\" {\r\n    import * as net from \"net\";\r\n\r\n    export function isatty(fd: number): boolean;\r\n    export interface ReadStream extends net.Socket {\r\n        isRaw: boolean;\r\n        setRawMode(mode: boolean): void;\r\n        isTTY: boolean;\r\n    }\r\n    export interface WriteStream extends net.Socket {\r\n        columns: number;\r\n        rows: number;\r\n        isTTY: boolean;\r\n    }\r\n}\r\n\r\ndeclare module \"domain\" {\r\n    import * as events from \"events\";\r\n\r\n    export class Domain extends events.EventEmitter implements NodeJS.Domain {\r\n        run(fn: Function): void;\r\n        add(emitter: events.EventEmitter): void;\r\n        remove(emitter: events.EventEmitter): void;\r\n        bind(cb: (err: Error, data: any) => any): any;\r\n        intercept(cb: (data: any) => any): any;\r\n        dispose(): void;\r\n        members: any[];\r\n        enter(): void;\r\n        exit(): void;\r\n    }\r\n\r\n    export function create(): Domain;\r\n}\r\n\r\ndeclare module \"constants\" {\r\n    export var E2BIG: number;\r\n    export var EACCES: number;\r\n    export var EADDRINUSE: number;\r\n    export var EADDRNOTAVAIL: number;\r\n    export var EAFNOSUPPORT: number;\r\n    export var EAGAIN: number;\r\n    export var EALREADY: number;\r\n    export var EBADF: number;\r\n    export var EBADMSG: number;\r\n    export var EBUSY: number;\r\n    export var ECANCELED: number;\r\n    export var ECHILD: number;\r\n    export var ECONNABORTED: number;\r\n    export var ECONNREFUSED: number;\r\n    export var ECONNRESET: number;\r\n    export var EDEADLK: number;\r\n    export var EDESTADDRREQ: number;\r\n    export var EDOM: number;\r\n    export var EEXIST: number;\r\n    export var EFAULT: number;\r\n    export var EFBIG: number;\r\n    export var EHOSTUNREACH: number;\r\n    export var EIDRM: number;\r\n    export var EILSEQ: number;\r\n    export var EINPROGRESS: number;\r\n    export var EINTR: number;\r\n    export var EINVAL: number;\r\n    export var EIO: number;\r\n    export var EISCONN: number;\r\n    export var EISDIR: number;\r\n    export var ELOOP: number;\r\n    export var EMFILE: number;\r\n    export var EMLINK: number;\r\n    export var EMSGSIZE: number;\r\n    export var ENAMETOOLONG: number;\r\n    export var ENETDOWN: number;\r\n    export var ENETRESET: number;\r\n    export var ENETUNREACH: number;\r\n    export var ENFILE: number;\r\n    export var ENOBUFS: number;\r\n    export var ENODATA: number;\r\n    export var ENODEV: number;\r\n    export var ENOENT: number;\r\n    export var ENOEXEC: number;\r\n    export var ENOLCK: number;\r\n    export var ENOLINK: number;\r\n    export var ENOMEM: number;\r\n    export var ENOMSG: number;\r\n    export var ENOPROTOOPT: number;\r\n    export var ENOSPC: number;\r\n    export var ENOSR: number;\r\n    export var ENOSTR: number;\r\n    export var ENOSYS: number;\r\n    export var ENOTCONN: number;\r\n    export var ENOTDIR: number;\r\n    export var ENOTEMPTY: number;\r\n    export var ENOTSOCK: number;\r\n    export var ENOTSUP: number;\r\n    export var ENOTTY: number;\r\n    export var ENXIO: number;\r\n    export var EOPNOTSUPP: number;\r\n    export var EOVERFLOW: number;\r\n    export var EPERM: number;\r\n    export var EPIPE: number;\r\n    export var EPROTO: number;\r\n    export var EPROTONOSUPPORT: number;\r\n    export var EPROTOTYPE: number;\r\n    export var ERANGE: number;\r\n    export var EROFS: number;\r\n    export var ESPIPE: number;\r\n    export var ESRCH: number;\r\n    export var ETIME: number;\r\n    export var ETIMEDOUT: number;\r\n    export var ETXTBSY: number;\r\n    export var EWOULDBLOCK: number;\r\n    export var EXDEV: number;\r\n    export var WSAEINTR: number;\r\n    export var WSAEBADF: number;\r\n    export var WSAEACCES: number;\r\n    export var WSAEFAULT: number;\r\n    export var WSAEINVAL: number;\r\n    export var WSAEMFILE: number;\r\n    export var WSAEWOULDBLOCK: number;\r\n    export var WSAEINPROGRESS: number;\r\n    export var WSAEALREADY: number;\r\n    export var WSAENOTSOCK: number;\r\n    export var WSAEDESTADDRREQ: number;\r\n    export var WSAEMSGSIZE: number;\r\n    export var WSAEPROTOTYPE: number;\r\n    export var WSAENOPROTOOPT: number;\r\n    export var WSAEPROTONOSUPPORT: number;\r\n    export var WSAESOCKTNOSUPPORT: number;\r\n    export var WSAEOPNOTSUPP: number;\r\n    export var WSAEPFNOSUPPORT: number;\r\n    export var WSAEAFNOSUPPORT: number;\r\n    export var WSAEADDRINUSE: number;\r\n    export var WSAEADDRNOTAVAIL: number;\r\n    export var WSAENETDOWN: number;\r\n    export var WSAENETUNREACH: number;\r\n    export var WSAENETRESET: number;\r\n    export var WSAECONNABORTED: number;\r\n    export var WSAECONNRESET: number;\r\n    export var WSAENOBUFS: number;\r\n    export var WSAEISCONN: number;\r\n    export var WSAENOTCONN: number;\r\n    export var WSAESHUTDOWN: number;\r\n    export var WSAETOOMANYREFS: number;\r\n    export var WSAETIMEDOUT: number;\r\n    export var WSAECONNREFUSED: number;\r\n    export var WSAELOOP: number;\r\n    export var WSAENAMETOOLONG: number;\r\n    export var WSAEHOSTDOWN: number;\r\n    export var WSAEHOSTUNREACH: number;\r\n    export var WSAENOTEMPTY: number;\r\n    export var WSAEPROCLIM: number;\r\n    export var WSAEUSERS: number;\r\n    export var WSAEDQUOT: number;\r\n    export var WSAESTALE: number;\r\n    export var WSAEREMOTE: number;\r\n    export var WSASYSNOTREADY: number;\r\n    export var WSAVERNOTSUPPORTED: number;\r\n    export var WSANOTINITIALISED: number;\r\n    export var WSAEDISCON: number;\r\n    export var WSAENOMORE: number;\r\n    export var WSAECANCELLED: number;\r\n    export var WSAEINVALIDPROCTABLE: number;\r\n    export var WSAEINVALIDPROVIDER: number;\r\n    export var WSAEPROVIDERFAILEDINIT: number;\r\n    export var WSASYSCALLFAILURE: number;\r\n    export var WSASERVICE_NOT_FOUND: number;\r\n    export var WSATYPE_NOT_FOUND: number;\r\n    export var WSA_E_NO_MORE: number;\r\n    export var WSA_E_CANCELLED: number;\r\n    export var WSAEREFUSED: number;\r\n    export var SIGHUP: number;\r\n    export var SIGINT: number;\r\n    export var SIGILL: number;\r\n    export var SIGABRT: number;\r\n    export var SIGFPE: number;\r\n    export var SIGKILL: number;\r\n    export var SIGSEGV: number;\r\n    export var SIGTERM: number;\r\n    export var SIGBREAK: number;\r\n    export var SIGWINCH: number;\r\n    export var SSL_OP_ALL: number;\r\n    export var SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: number;\r\n    export var SSL_OP_CIPHER_SERVER_PREFERENCE: number;\r\n    export var SSL_OP_CISCO_ANYCONNECT: number;\r\n    export var SSL_OP_COOKIE_EXCHANGE: number;\r\n    export var SSL_OP_CRYPTOPRO_TLSEXT_BUG: number;\r\n    export var SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: number;\r\n    export var SSL_OP_EPHEMERAL_RSA: number;\r\n    export var SSL_OP_LEGACY_SERVER_CONNECT: number;\r\n    export var SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: number;\r\n    export var SSL_OP_MICROSOFT_SESS_ID_BUG: number;\r\n    export var SSL_OP_MSIE_SSLV2_RSA_PADDING: number;\r\n    export var SSL_OP_NETSCAPE_CA_DN_BUG: number;\r\n    export var SSL_OP_NETSCAPE_CHALLENGE_BUG: number;\r\n    export var SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: number;\r\n    export var SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: number;\r\n    export var SSL_OP_NO_COMPRESSION: number;\r\n    export var SSL_OP_NO_QUERY_MTU: number;\r\n    export var SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: number;\r\n    export var SSL_OP_NO_SSLv2: number;\r\n    export var SSL_OP_NO_SSLv3: number;\r\n    export var SSL_OP_NO_TICKET: number;\r\n    export var SSL_OP_NO_TLSv1: number;\r\n    export var SSL_OP_NO_TLSv1_1: number;\r\n    export var SSL_OP_NO_TLSv1_2: number;\r\n    export var SSL_OP_PKCS1_CHECK_1: number;\r\n    export var SSL_OP_PKCS1_CHECK_2: number;\r\n    export var SSL_OP_SINGLE_DH_USE: number;\r\n    export var SSL_OP_SINGLE_ECDH_USE: number;\r\n    export var SSL_OP_SSLEAY_080_CLIENT_DH_BUG: number;\r\n    export var SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: number;\r\n    export var SSL_OP_TLS_BLOCK_PADDING_BUG: number;\r\n    export var SSL_OP_TLS_D5_BUG: number;\r\n    export var SSL_OP_TLS_ROLLBACK_BUG: number;\r\n    export var ENGINE_METHOD_DSA: number;\r\n    export var ENGINE_METHOD_DH: number;\r\n    export var ENGINE_METHOD_RAND: number;\r\n    export var ENGINE_METHOD_ECDH: number;\r\n    export var ENGINE_METHOD_ECDSA: number;\r\n    export var ENGINE_METHOD_CIPHERS: number;\r\n    export var ENGINE_METHOD_DIGESTS: number;\r\n    export var ENGINE_METHOD_STORE: number;\r\n    export var ENGINE_METHOD_PKEY_METHS: number;\r\n    export var ENGINE_METHOD_PKEY_ASN1_METHS: number;\r\n    export var ENGINE_METHOD_ALL: number;\r\n    export var ENGINE_METHOD_NONE: number;\r\n    export var DH_CHECK_P_NOT_SAFE_PRIME: number;\r\n    export var DH_CHECK_P_NOT_PRIME: number;\r\n    export var DH_UNABLE_TO_CHECK_GENERATOR: number;\r\n    export var DH_NOT_SUITABLE_GENERATOR: number;\r\n    export var NPN_ENABLED: number;\r\n    export var RSA_PKCS1_PADDING: number;\r\n    export var RSA_SSLV23_PADDING: number;\r\n    export var RSA_NO_PADDING: number;\r\n    export var RSA_PKCS1_OAEP_PADDING: number;\r\n    export var RSA_X931_PADDING: number;\r\n    export var RSA_PKCS1_PSS_PADDING: number;\r\n    export var POINT_CONVERSION_COMPRESSED: number;\r\n    export var POINT_CONVERSION_UNCOMPRESSED: number;\r\n    export var POINT_CONVERSION_HYBRID: number;\r\n    export var O_RDONLY: number;\r\n    export var O_WRONLY: number;\r\n    export var O_RDWR: number;\r\n    export var S_IFMT: number;\r\n    export var S_IFREG: number;\r\n    export var S_IFDIR: number;\r\n    export var S_IFCHR: number;\r\n    export var S_IFBLK: number;\r\n    export var S_IFIFO: number;\r\n    export var S_IFSOCK: number;\r\n    export var S_IRWXU: number;\r\n    export var S_IRUSR: number;\r\n    export var S_IWUSR: number;\r\n    export var S_IXUSR: number;\r\n    export var S_IRWXG: number;\r\n    export var S_IRGRP: number;\r\n    export var S_IWGRP: number;\r\n    export var S_IXGRP: number;\r\n    export var S_IRWXO: number;\r\n    export var S_IROTH: number;\r\n    export var S_IWOTH: number;\r\n    export var S_IXOTH: number;\r\n    export var S_IFLNK: number;\r\n    export var O_CREAT: number;\r\n    export var O_EXCL: number;\r\n    export var O_NOCTTY: number;\r\n    export var O_DIRECTORY: number;\r\n    export var O_NOATIME: number;\r\n    export var O_NOFOLLOW: number;\r\n    export var O_SYNC: number;\r\n    export var O_SYMLINK: number;\r\n    export var O_DIRECT: number;\r\n    export var O_NONBLOCK: number;\r\n    export var O_TRUNC: number;\r\n    export var O_APPEND: number;\r\n    export var F_OK: number;\r\n    export var R_OK: number;\r\n    export var W_OK: number;\r\n    export var X_OK: number;\r\n    export var UV_UDP_REUSEADDR: number;\r\n    export var SIGQUIT: number;\r\n    export var SIGTRAP: number;\r\n    export var SIGIOT: number;\r\n    export var SIGBUS: number;\r\n    export var SIGUSR1: number;\r\n    export var SIGUSR2: number;\r\n    export var SIGPIPE: number;\r\n    export var SIGALRM: number;\r\n    export var SIGCHLD: number;\r\n    export var SIGSTKFLT: number;\r\n    export var SIGCONT: number;\r\n    export var SIGSTOP: number;\r\n    export var SIGTSTP: number;\r\n    export var SIGTTIN: number;\r\n    export var SIGTTOU: number;\r\n    export var SIGURG: number;\r\n    export var SIGXCPU: number;\r\n    export var SIGXFSZ: number;\r\n    export var SIGVTALRM: number;\r\n    export var SIGPROF: number;\r\n    export var SIGIO: number;\r\n    export var SIGPOLL: number;\r\n    export var SIGPWR: number;\r\n    export var SIGSYS: number;\r\n    export var SIGUNUSED: number;\r\n    export var defaultCoreCipherList: string;\r\n    export var defaultCipherList: string;\r\n    export var ENGINE_METHOD_RSA: number;\r\n    export var ALPN_ENABLED: number;\r\n}\r\n\r\ndeclare module \"process\" {\r\n    export = process;\r\n}\r\n\r\ndeclare module \"v8\" {\r\n    interface HeapSpaceInfo {\r\n        space_name: string;\r\n        space_size: number;\r\n        space_used_size: number;\r\n        space_available_size: number;\r\n        physical_space_size: number;\r\n    }\r\n\r\n    const enum DoesZapCodeSpaceFlag {\r\n        Disabled = 0,\r\n        Enabled = 1\r\n    }\r\n\r\n    interface HeapInfo {\r\n        total_heap_size: number;\r\n        total_heap_size_executable: number;\r\n        total_physical_size: number;\r\n        total_available_size: number;\r\n        used_heap_size: number;\r\n        heap_size_limit: number;\r\n        malloced_memory: number;\r\n        peak_malloced_memory: number;\r\n        does_zap_garbage: DoesZapCodeSpaceFlag;\r\n    }\r\n\r\n    export function getHeapStatistics(): HeapInfo;\r\n    export function getHeapSpaceStatistics(): HeapSpaceInfo[];\r\n    export function setFlagsFromString(flags: string): void;\r\n}\r\n\r\ndeclare module \"timers\" {\r\n    export function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timer;\r\n    export function clearTimeout(timeoutId: NodeJS.Timer): void;\r\n    export function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timer;\r\n    export function clearInterval(intervalId: NodeJS.Timer): void;\r\n    export function setImmediate(callback: (...args: any[]) => void, ...args: any[]): any;\r\n    export function clearImmediate(immediateId: any): void;\r\n}\r\n\r\ndeclare module \"console\" {\r\n    export = console;\r\n}\r\n\r\n/**\r\n * _debugger module is not documented.\r\n * Source code is at https://github.com/nodejs/node/blob/master/lib/_debugger.js\r\n */\r\ndeclare module \"_debugger\" {\r\n    export interface Packet {\r\n        raw: string;\r\n        headers: string[];\r\n        body: Message;\r\n    }\r\n\r\n    export interface Message {\r\n        seq: number;\r\n        type: string;\r\n    }\r\n\r\n    export interface RequestInfo {\r\n        command: string;\r\n        arguments: any;\r\n    }\r\n\r\n    export interface Request extends Message, RequestInfo {\r\n    }\r\n\r\n    export interface Event extends Message {\r\n        event: string;\r\n        body?: any;\r\n    }\r\n\r\n    export interface Response extends Message {\r\n        request_seq: number;\r\n        success: boolean;\r\n        /** Contains error message if success === false. */\r\n        message?: string;\r\n        /** Contains message body if success === true. */\r\n        body?: any;\r\n    }\r\n\r\n    export interface BreakpointMessageBody {\r\n        type: string;\r\n        target: number;\r\n        line: number;\r\n    }\r\n\r\n    export class Protocol {\r\n        res: Packet;\r\n        state: string;\r\n        execute(data: string): void;\r\n        serialize(rq: Request): string;\r\n        onResponse: (pkt: Packet) => void;\r\n    }\r\n\r\n    export var NO_FRAME: number;\r\n    export var port: number;\r\n\r\n    export interface ScriptDesc {\r\n        name: string;\r\n        id: number;\r\n        isNative?: boolean;\r\n        handle?: number;\r\n        type: string;\r\n        lineOffset?: number;\r\n        columnOffset?: number;\r\n        lineCount?: number;\r\n    }\r\n\r\n    export interface Breakpoint {\r\n        id: number;\r\n        scriptId: number;\r\n        script: ScriptDesc;\r\n        line: number;\r\n        condition?: string;\r\n        scriptReq?: string;\r\n    }\r\n\r\n    export interface RequestHandler {\r\n        (err: boolean, body: Message, res: Packet): void;\r\n        request_seq?: number;\r\n    }\r\n\r\n    export interface ResponseBodyHandler {\r\n        (err: boolean, body?: any): void;\r\n        request_seq?: number;\r\n    }\r\n\r\n    export interface ExceptionInfo {\r\n        text: string;\r\n    }\r\n\r\n    export interface BreakResponse {\r\n        script?: ScriptDesc;\r\n        exception?: ExceptionInfo;\r\n        sourceLine: number;\r\n        sourceLineText: string;\r\n        sourceColumn: number;\r\n    }\r\n\r\n    export function SourceInfo(body: BreakResponse): string;\r\n\r\n    export interface ClientInstance extends NodeJS.EventEmitter {\r\n        protocol: Protocol;\r\n        scripts: ScriptDesc[];\r\n        handles: ScriptDesc[];\r\n        breakpoints: Breakpoint[];\r\n        currentSourceLine: number;\r\n        currentSourceColumn: number;\r\n        currentSourceLineText: string;\r\n        currentFrame: number;\r\n        currentScript: string;\r\n\r\n        connect(port: number, host: string): void;\r\n        req(req: any, cb: RequestHandler): void;\r\n        reqFrameEval(code: string, frame: number, cb: RequestHandler): void;\r\n        mirrorObject(obj: any, depth: number, cb: ResponseBodyHandler): void;\r\n        setBreakpoint(rq: BreakpointMessageBody, cb: RequestHandler): void;\r\n        clearBreakpoint(rq: Request, cb: RequestHandler): void;\r\n        listbreakpoints(cb: RequestHandler): void;\r\n        reqSource(from: number, to: number, cb: RequestHandler): void;\r\n        reqScripts(cb: any): void;\r\n        reqContinue(cb: RequestHandler): void;\r\n    }\r\n\r\n    export var Client : {\r\n        new (): ClientInstance\r\n    }\r\n}\r\n","type":2},{"name":"node_modules/@types/shell-quote/index.d.ts","text":"// Type definitions for shell-quote 1.6\r\n// Project: https://github.com/substack/node-shell-quote\r\n// Definitions by: Jason Cheatham <https://github.com/jason0x43>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n// TypeScript Version: 2.2\r\n\r\nexport function quote(args: string[]): string;\r\nexport function parse(\r\n\tcmd: string,\r\n\tenv?: { [key: string]: string } | ((key: string) => string | object),\r\n\topts?: { [key: string]: string }\r\n): string[];\r\n","type":2},{"name":"node_modules/@types/sinon/index.d.ts","text":"// Type definitions for Sinon 1.16.0\r\n// Project: http://sinonjs.org/\r\n// Definitions by: William Sears <https://github.com/mrbigdog2u>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n\r\n// sinon uses DOM dependencies which are absent in browserless envoronment like node.js\r\n// to avoid compiler errors this monkey patch is used\r\n// see more details in https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11351\r\ninterface Event { }\r\ninterface Document { }\r\n\r\ndeclare namespace Sinon {\r\n    interface SinonSpyCallApi {\r\n        // Properties\r\n        thisValue: any;\r\n        args: any[];\r\n        exception: any;\r\n        returnValue: any;\r\n\r\n        // Methods\r\n        calledOn(obj: any): boolean;\r\n        calledWith(...args: any[]): boolean;\r\n        calledWithExactly(...args: any[]): boolean;\r\n        calledWithMatch(...args: any[]): boolean;\r\n        notCalledWith(...args: any[]): boolean;\r\n        notCalledWithMatch(...args: any[]): boolean;\r\n        returned(value: any): boolean;\r\n        threw(): boolean;\r\n        threw(type: string): boolean;\r\n        threw(obj: any): boolean;\r\n        callArg(pos: number): void;\r\n        callArgOn(pos: number, obj: any, ...args: any[]): void;\r\n        callArgWith(pos: number, ...args: any[]): void;\r\n        callArgOnWith(pos: number, obj: any, ...args: any[]): void;\r\n        yield(...args: any[]): void;\r\n        yieldOn(obj: any, ...args: any[]): void;\r\n        yieldTo(property: string, ...args: any[]): void;\r\n        yieldToOn(property: string, obj: any, ...args: any[]): void;\r\n    }\r\n\r\n    interface SinonSpyCall extends SinonSpyCallApi {\r\n        calledBefore(call: SinonSpyCall): boolean;\r\n        calledAfter(call: SinonSpyCall): boolean;\r\n        calledWithNew(call: SinonSpyCall): boolean;\r\n    }\r\n\r\n    interface SinonSpy extends SinonSpyCallApi {\r\n        // Properties\r\n        callCount: number;\r\n        called: boolean;\r\n        notCalled: boolean;\r\n        calledOnce: boolean;\r\n        calledTwice: boolean;\r\n        calledThrice: boolean;\r\n        firstCall: SinonSpyCall;\r\n        secondCall: SinonSpyCall;\r\n        thirdCall: SinonSpyCall;\r\n        lastCall: SinonSpyCall;\r\n        thisValues: any[];\r\n        args: any[][];\r\n        exceptions: any[];\r\n        returnValues: any[];\r\n\r\n        // Methods\r\n        (...args: any[]): any;\r\n        calledBefore(anotherSpy: SinonSpy): boolean;\r\n        calledAfter(anotherSpy: SinonSpy): boolean;\r\n        calledWithNew(): boolean;\r\n        withArgs(...args: any[]): SinonSpy;\r\n        alwaysCalledOn(obj: any): boolean;\r\n        alwaysCalledWith(...args: any[]): boolean;\r\n        alwaysCalledWithExactly(...args: any[]): boolean;\r\n        alwaysCalledWithMatch(...args: any[]): boolean;\r\n        neverCalledWith(...args: any[]): boolean;\r\n        neverCalledWithMatch(...args: any[]): boolean;\r\n        alwaysThrew(): boolean;\r\n        alwaysThrew(type: string): boolean;\r\n        alwaysThrew(obj: any): boolean;\r\n        alwaysReturned(obj: any): boolean;\r\n        invokeCallback(...args: any[]): void;\r\n        getCall(n: number): SinonSpyCall;\r\n        reset(): void;\r\n        printf(format: string, ...args: any[]): string;\r\n        restore(): void;\r\n    }\r\n\r\n    interface SinonSpyStatic {\r\n        (): SinonSpy;\r\n        (func: any): SinonSpy;\r\n        (obj: any, method: string): SinonSpy;\r\n    }\r\n\r\n    interface SinonStatic {\r\n        spy: SinonSpyStatic;\r\n    }\r\n\r\n    interface SinonStub extends SinonSpy {\r\n        resetBehavior(): void;\r\n        returns(obj: any): SinonStub;\r\n        returnsArg(index: number): SinonStub;\r\n        returnsThis(): SinonStub;\r\n        throws(type?: string): SinonStub;\r\n        throws(obj: any): SinonStub;\r\n        callsArg(index: number): SinonStub;\r\n        callThrough(): SinonStub;\r\n        callsArgOn(index: number, context: any): SinonStub;\r\n        callsArgWith(index: number, ...args: any[]): SinonStub;\r\n        callsArgOnWith(index: number, context: any, ...args: any[]): SinonStub;\r\n        callsArgAsync(index: number): SinonStub;\r\n        callsArgOnAsync(index: number, context: any): SinonStub;\r\n        callsArgWithAsync(index: number, ...args: any[]): SinonStub;\r\n        callsArgOnWithAsync(index: number, context: any, ...args: any[]): SinonStub;\r\n        callsFake(func: (...args: any[]) => void): SinonStub;\r\n        onCall(n: number): SinonStub;\r\n        onFirstCall(): SinonStub;\r\n        onSecondCall(): SinonStub;\r\n        onThirdCall(): SinonStub;\r\n        yields(...args: any[]): SinonStub;\r\n        yieldsOn(context: any, ...args: any[]): SinonStub;\r\n        yieldsTo(property: string, ...args: any[]): SinonStub;\r\n        yieldsToOn(property: string, context: any, ...args: any[]): SinonStub;\r\n        yieldsAsync(...args: any[]): SinonStub;\r\n        yieldsOnAsync(context: any, ...args: any[]): SinonStub;\r\n        yieldsToAsync(property: string, ...args: any[]): SinonStub;\r\n        yieldsToOnAsync(property: string, context: any, ...args: any[]): SinonStub;\r\n        withArgs(...args: any[]): SinonStub;\r\n    }\r\n\r\n    interface SinonStubStatic {\r\n        (): SinonStub;\r\n        (obj: any): SinonStub;\r\n        (obj: any, method: string): SinonStub;\r\n        (obj: any, method: string, func: any): SinonStub;\r\n    }\r\n\r\n    interface SinonStatic {\r\n        stub: SinonStubStatic;\r\n    }\r\n\r\n    interface SinonExpectation extends SinonStub {\r\n        atLeast(n: number): SinonExpectation;\r\n        atMost(n: number): SinonExpectation;\r\n        never(): SinonExpectation;\r\n        once(): SinonExpectation;\r\n        twice(): SinonExpectation;\r\n        thrice(): SinonExpectation;\r\n        exactly(n: number): SinonExpectation;\r\n        withArgs(...args: any[]): SinonExpectation;\r\n        withExactArgs(...args: any[]): SinonExpectation;\r\n        on(obj: any): SinonExpectation;\r\n        verify(): SinonExpectation;\r\n        restore(): void;\r\n    }\r\n\r\n    interface SinonExpectationStatic {\r\n        create(methodName?: string): SinonExpectation;\r\n    }\r\n\r\n    interface SinonMock {\r\n        expects(method: string): SinonExpectation;\r\n        restore(): void;\r\n        verify(): void;\r\n    }\r\n\r\n    interface SinonMockStatic {\r\n        (): SinonExpectation;\r\n        (obj: any): SinonMock;\r\n    }\r\n\r\n    interface SinonStatic {\r\n        expectation: SinonExpectationStatic;\r\n        mock: SinonMockStatic;\r\n    }\r\n\r\n    interface SinonFakeTimers {\r\n        now: number;\r\n        create(now: number): SinonFakeTimers;\r\n        setTimeout(callback: (...args: any[]) => void, timeout: number, ...args: any[]): number;\r\n        clearTimeout(id: number): void;\r\n        setInterval(callback: (...args: any[]) => void, timeout: number, ...args: any[]): number;\r\n        clearInterval(id: number): void;\r\n        tick(ms: number): number;\r\n        reset(): void;\r\n        Date(): Date;\r\n        Date(year: number): Date;\r\n        Date(year: number, month: number): Date;\r\n        Date(year: number, month: number, day: number): Date;\r\n        Date(year: number, month: number, day: number, hour: number): Date;\r\n        Date(year: number, month: number, day: number, hour: number, minute: number): Date;\r\n        Date(year: number, month: number, day: number, hour: number, minute: number, second: number): Date;\r\n        Date(year: number, month: number, day: number, hour: number, minute: number, second: number, ms: number): Date;\r\n        restore(): void;\r\n\r\n\t\t/**\r\n\t\t * Simulate the user changing the system clock while your program is running. It changes the 'now' timestamp\r\n\t\t * without affecting timers, intervals or immediates.\r\n\t\t * @param now The new 'now' in unix milliseconds\r\n\t\t */\r\n\t\tsetSystemTime(now: number): void;\r\n\t\t/**\r\n\t\t * Simulate the user changing the system clock while your program is running. It changes the 'now' timestamp\r\n\t\t * without affecting timers, intervals or immediates.\r\n\t\t * @param now The new 'now' as a JavaScript Date\r\n\t\t */\r\n\t\tsetSystemTime(date: Date): void;\r\n\t}\r\n\r\n    interface SinonFakeTimersStatic {\r\n        (): SinonFakeTimers;\r\n        (...timers: string[]): SinonFakeTimers;\r\n        (now: number, ...timers: string[]): SinonFakeTimers;\r\n    }\r\n\r\n    interface SinonStatic {\r\n        useFakeTimers: SinonFakeTimersStatic;\r\n        clock: SinonFakeTimers;\r\n    }\r\n\r\n    interface SinonFakeUploadProgress {\r\n        eventListeners: {\r\n            progress: any[];\r\n            load: any[];\r\n            abort: any[];\r\n            error: any[];\r\n        };\r\n\r\n        addEventListener(event: string, listener: (e: Event) => any): void;\r\n        removeEventListener(event: string, listener: (e: Event) => any): void;\r\n        dispatchEvent(event: Event): void;\r\n    }\r\n\r\n    interface SinonFakeXMLHttpRequest {\r\n        // Properties\r\n        onCreate: (xhr: SinonFakeXMLHttpRequest) => void;\r\n        url: string;\r\n        method: string;\r\n        requestHeaders: any;\r\n        requestBody: string;\r\n        status: number;\r\n        statusText: string;\r\n        async: boolean;\r\n        username: string;\r\n        password: string;\r\n        withCredentials: boolean;\r\n        upload: SinonFakeUploadProgress;\r\n        responseXML: Document;\r\n        getResponseHeader(header: string): string;\r\n        getAllResponseHeaders(): any;\r\n\r\n        // Methods\r\n        restore(): void;\r\n        useFilters: boolean;\r\n        addFilter(filter: (method: string, url: string, async: boolean, username: string, password: string) => boolean): void;\r\n        setResponseHeaders(headers: any): void;\r\n        setResponseBody(body: string): void;\r\n        respond(status: number, headers: any, body: string): void;\r\n        autoRespond(ms: number): void;\r\n    }\r\n\r\n    interface SinonFakeXMLHttpRequestStatic {\r\n        (): SinonFakeXMLHttpRequest;\r\n    }\r\n\r\n    interface SinonStatic {\r\n        useFakeXMLHttpRequest: SinonFakeXMLHttpRequestStatic;\r\n        FakeXMLHttpRequest: SinonFakeXMLHttpRequest;\r\n    }\r\n\r\n    interface SinonFakeServer {\r\n        // Properties\r\n        autoRespond: boolean;\r\n        autoRespondAfter: number;\r\n        fakeHTTPMethods: boolean;\r\n        getHTTPMethod: (request: SinonFakeXMLHttpRequest) => string;\r\n        requests: SinonFakeXMLHttpRequest[];\r\n        respondImmediately: boolean;\r\n\r\n        // Methods\r\n        respondWith(body: string): void;\r\n        respondWith(response: any[]): void;\r\n        respondWith(fn: (xhr: SinonFakeXMLHttpRequest) => void): void;\r\n        respondWith(url: string, body: string): void;\r\n        respondWith(url: string, response: any[]): void;\r\n        respondWith(url: string, fn: (xhr: SinonFakeXMLHttpRequest) => void): void;\r\n        respondWith(method: string, url: string, body: string): void;\r\n        respondWith(method: string, url: string, response: any[]): void;\r\n        respondWith(method: string, url: string, fn: (xhr: SinonFakeXMLHttpRequest) => void): void;\r\n        respondWith(url: RegExp, body: string): void;\r\n        respondWith(url: RegExp, response: any[]): void;\r\n        respondWith(url: RegExp, fn: (xhr: SinonFakeXMLHttpRequest) => void): void;\r\n        respondWith(method: string, url: RegExp, body: string): void;\r\n        respondWith(method: string, url: RegExp, response: any[]): void;\r\n        respondWith(method: string, url: RegExp, fn: (xhr: SinonFakeXMLHttpRequest) => void): void;\r\n        respond(): void;\r\n        restore(): void;\r\n    }\r\n\r\n    interface SinonFakeServerStatic {\r\n        create(): SinonFakeServer;\r\n    }\r\n\r\n    interface SinonStatic {\r\n        fakeServer: SinonFakeServerStatic;\r\n        fakeServerWithClock: SinonFakeServerStatic;\r\n    }\r\n\r\n    interface SinonExposeOptions {\r\n        prefix?: string;\r\n        includeFail?: boolean;\r\n    }\r\n\r\n    interface SinonAssert {\r\n        // Properties\r\n        failException: string;\r\n        fail: (message?: string) => void; // Overridable\r\n        pass: (assertion: any) => void; // Overridable\r\n\r\n        // Methods\r\n        notCalled(spy: SinonSpy): void;\r\n        called(spy: SinonSpy): void;\r\n        calledOnce(spy: SinonSpy): void;\r\n        calledTwice(spy: SinonSpy): void;\r\n        calledThrice(spy: SinonSpy): void;\r\n        callCount(spy: SinonSpy, count: number): void;\r\n        callOrder(...spies: SinonSpy[]): void;\r\n        calledOn(spy: SinonSpy, obj: any): void;\r\n        alwaysCalledOn(spy: SinonSpy, obj: any): void;\r\n        calledWith(spy: SinonSpy, ...args: any[]): void;\r\n        alwaysCalledWith(spy: SinonSpy, ...args: any[]): void;\r\n        neverCalledWith(spy: SinonSpy, ...args: any[]): void;\r\n        calledWithExactly(spy: SinonSpy, ...args: any[]): void;\r\n        alwaysCalledWithExactly(spy: SinonSpy, ...args: any[]): void;\r\n        calledWithMatch(spy: SinonSpy, ...args: any[]): void;\r\n        alwaysCalledWithMatch(spy: SinonSpy, ...args: any[]): void;\r\n        neverCalledWithMatch(spy: SinonSpy, ...args: any[]): void;\r\n        threw(spy: SinonSpy): void;\r\n        threw(spy: SinonSpy, exception: string): void;\r\n        threw(spy: SinonSpy, exception: any): void;\r\n        alwaysThrew(spy: SinonSpy): void;\r\n        alwaysThrew(spy: SinonSpy, exception: string): void;\r\n        alwaysThrew(spy: SinonSpy, exception: any): void;\r\n        expose(obj: any, options?: SinonExposeOptions): void;\r\n    }\r\n\r\n    interface SinonStatic {\r\n        assert: SinonAssert;\r\n    }\r\n\r\n    interface SinonMatcher {\r\n        and(expr: SinonMatcher): SinonMatcher;\r\n        or(expr: SinonMatcher): SinonMatcher;\r\n    }\r\n\r\n    interface SinonMatch {\r\n        (value: number): SinonMatcher;\r\n        (value: string): SinonMatcher;\r\n        (expr: RegExp): SinonMatcher;\r\n        (obj: any): SinonMatcher;\r\n        (callback: (value: any) => boolean): SinonMatcher;\r\n        any: SinonMatcher;\r\n        defined: SinonMatcher;\r\n        truthy: SinonMatcher;\r\n        falsy: SinonMatcher;\r\n        bool: SinonMatcher;\r\n        number: SinonMatcher;\r\n        string: SinonMatcher;\r\n        object: SinonMatcher;\r\n        func: SinonMatcher;\r\n        array: SinonMatcher;\r\n        regexp: SinonMatcher;\r\n        date: SinonMatcher;\r\n        same(obj: any): SinonMatcher;\r\n        typeOf(type: string): SinonMatcher;\r\n        instanceOf(type: any): SinonMatcher;\r\n        has(property: string, expect?: any): SinonMatcher;\r\n        hasOwn(property: string, expect?: any): SinonMatcher;\r\n    }\r\n\r\n    interface SinonStatic {\r\n        match: SinonMatch;\r\n    }\r\n\r\n    interface SinonSandboxConfig {\r\n        injectInto?: any;\r\n        properties?: string[];\r\n        useFakeTimers?: any;\r\n        useFakeServer?: any;\r\n    }\r\n\r\n    interface SinonSandbox {\r\n        clock: SinonFakeTimers;\r\n        requests: SinonFakeXMLHttpRequest;\r\n        server: SinonFakeServer;\r\n        spy: SinonSpyStatic;\r\n        stub: SinonStubStatic;\r\n        mock: SinonMockStatic;\r\n        useFakeTimers: SinonFakeTimersStatic;\r\n        useFakeXMLHttpRequest: SinonFakeXMLHttpRequestStatic;\r\n        useFakeServer(): SinonFakeServer;\r\n        restore(): void;\r\n    }\r\n\r\n    interface SinonSandboxStatic {\r\n        create(): SinonSandbox;\r\n        create(config: SinonSandboxConfig): SinonSandbox;\r\n    }\r\n\r\n    interface SinonStatic {\r\n        sandbox: SinonSandboxStatic;\r\n    }\r\n\r\n    interface SinonTestConfig {\r\n        injectIntoThis?: boolean;\r\n        injectInto?: any;\r\n        properties?: string[];\r\n        useFakeTimers?: boolean;\r\n        useFakeServer?: boolean;\r\n    }\r\n\r\n    interface SinonTestWrapper extends SinonSandbox {\r\n        (...args: any[]): any;\r\n    }\r\n\r\n    interface SinonStatic {\r\n        config: SinonTestConfig;\r\n        test(fn: (...args: any[]) => any): SinonTestWrapper;\r\n        testCase(tests: any): any;\r\n    }\r\n\r\n    // Utility overridables\r\n    interface SinonStatic {\r\n        createStubInstance(constructor: any): any;\r\n        format(obj: any): string;\r\n        log(message: string): void;\r\n        restore(object: any): void;\r\n    }\r\n}\r\n\r\ndeclare var Sinon: Sinon.SinonStatic;\r\n\r\nexport = Sinon;\r\nexport as namespace sinon;\r\n","type":2},{"name":"node_modules/@types/source-map/index.d.ts","text":"﻿// Type definitions for source-map v0.1.38\r\n// Project: https://github.com/mozilla/source-map\r\n// Definitions by: Morten Houston Ludvigsen <https://github.com/MortenHoustonLudvigsen>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n\r\nexport = SourceMap;\r\nexport as namespace sourceMap;\r\n\r\ndeclare namespace SourceMap {\r\n    interface StartOfSourceMap {\r\n        file?: string;\r\n        sourceRoot?: string;\r\n        skipValidation?: boolean;\r\n    }\r\n\r\n    interface RawSourceMap {\r\n        version: number;\r\n        sources: string[];\r\n        names: string[];\r\n        sourceRoot?: string;\r\n        sourcesContent?: string[];\r\n        mappings: string;\r\n        file: string;\r\n    }\r\n\r\n    interface Position {\r\n        line: number;\r\n        column: number;\r\n    }\r\n\r\n    interface MappedPosition extends Position {\r\n        source: string;\r\n        name?: string;\r\n    }\r\n\r\n    interface MappingItem {\r\n        source: string;\r\n        generatedLine: number;\r\n        generatedColumn: number;\r\n        originalLine: number;\r\n        originalColumn: number;\r\n        name: string;\r\n    }\r\n\r\n    interface Mapping {\r\n        generated: Position;\r\n        original: Position;\r\n        source: string;\r\n        name?: string;\r\n    }\r\n\r\n    interface CodeWithSourceMap {\r\n        code: string;\r\n        map: SourceMapGenerator;\r\n    }\r\n\r\n    class SourceMapConsumer {\r\n        public static GENERATED_ORDER: number;\r\n        public static ORIGINAL_ORDER: number;\r\n\r\n        constructor(rawSourceMap: RawSourceMap);\r\n\r\n        public computeColumnSpans(): void;\r\n\r\n        public originalPositionFor(generatedPosition: Position): MappedPosition;\r\n\r\n        public generatedPositionFor(originalPosition: MappedPosition): Position;\r\n\r\n        public allGeneratedPositionsFor(originalPosition: MappedPosition): Position[];\r\n\r\n        public hasContentsOfAllSources(): boolean;\r\n\r\n        public sourceContentFor(source: string, returnNullOnMissing?: boolean): string;\r\n\r\n        public eachMapping(callback: (mapping: MappingItem) => void, context?: any, order?: number): void;\r\n    }\r\n\r\n    class SourceMapGenerator {\r\n        constructor(startOfSourceMap?: StartOfSourceMap);\r\n\r\n        public static fromSourceMap(sourceMapConsumer: SourceMapConsumer): SourceMapGenerator;\r\n\r\n        public addMapping(mapping: Mapping): void;\r\n\r\n        public setSourceContent(sourceFile: string, sourceContent: string): void;\r\n\r\n        public applySourceMap(sourceMapConsumer: SourceMapConsumer, sourceFile?: string, sourceMapPath?: string): void;\r\n\r\n        public toString(): string;\r\n\r\n        public toJSON(): RawSourceMap;\r\n    }\r\n\r\n    class SourceNode {\r\n        children: SourceNode [];\r\n        sourceContents: any;\r\n        line: number;\r\n        column: number;\r\n        source: string;\r\n        name: string;\r\n\r\n        constructor();\r\n        constructor(line: number, column: number, source: string);\r\n        constructor(\r\n            line: number,\r\n            column: number,\r\n            source: string,\r\n            chunks?: (string | SourceNode)[] | SourceNode | string,\r\n            name?: string\r\n        );\r\n\r\n        public static fromStringWithSourceMap(\r\n            code: string,\r\n            sourceMapConsumer: SourceMapConsumer,\r\n            relativePath?: string\r\n        ): SourceNode;\r\n\r\n        public add(chunk: any): SourceNode;\r\n\r\n        public prepend(chunk: any): SourceNode;\r\n\r\n        public setSourceContent(sourceFile: string, sourceContent: string): void;\r\n\r\n        public walk(fn: (chunk: string, mapping: MappedPosition) => void): void;\r\n\r\n        public walkSourceContents(fn: (file: string, content: string) => void): void;\r\n\r\n        public join(sep: string): SourceNode;\r\n\r\n        public replaceRight(pattern: string, replacement: string): SourceNode;\r\n\r\n        public toString(): string;\r\n\r\n        public toStringWithSourceMap(startOfSourceMap?: StartOfSourceMap): CodeWithSourceMap;\r\n    }\r\n}\r\n","type":2},{"name":"node_modules/@types/statuses/index.d.ts","text":"// Type definitions for statuses v1.2.1\n// Project: https://github.com/jshttp/statuses\n// Definitions by: Tanguy Krotoff <https://github.com/tkrotoff>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n\ninterface Status {\n    [code: number]: string;\n    [msg: string]: any | number;\n\n    codes: Array<number>;\n    redirect: { [code: number]: boolean };\n    empty: { [code: number]: boolean };\n    retry: { [code: number]: boolean };\n\n    (code: number | string): number;\n}\n\ndeclare var status: Status;\nexport = status;\n","type":2},{"name":"node_modules/@types/ws/index.d.ts","text":"// Type definitions for ws\r\n// Project: https://github.com/einaros/ws\r\n// Definitions by: Paul Loyd <https://github.com/loyd>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n\r\n/// <reference types=\"node\" />\r\n\r\n\r\nimport * as events from 'events';\r\nimport * as http from 'http';\r\nimport * as https from 'https';\r\nimport * as net from 'net';\r\n\r\ndeclare class WebSocket extends events.EventEmitter {\r\n    static CONNECTING: number;\r\n    static OPEN: number;\r\n    static CLOSING: number;\r\n    static CLOSED: number;\r\n\r\n    bytesReceived: number;\r\n    readyState: number;\r\n    protocolVersion: string;\r\n    url: string;\r\n    supports: any;\r\n    upgradeReq: http.IncomingMessage;\r\n    protocol: string;\r\n    bufferedAmount: number;\r\n    binaryType: string;\r\n\r\n    CONNECTING: number;\r\n    OPEN: number;\r\n    CLOSING: number;\r\n    CLOSED: number;\r\n\r\n    onopen: (event: { target: WebSocket }) => void;\r\n    onerror: (err: Error) => void;\r\n    onclose: (event: { wasClean: boolean; code: number; reason: string; target: WebSocket }) => void;\r\n    onmessage: (event: { data: any; type: string; target: WebSocket }) => void;\r\n\r\n    constructor(address: string, options?: WebSocket.IClientOptions);\r\n    constructor(address: string, protocols?: string | string[], options?: WebSocket.IClientOptions);\r\n\r\n    close(code?: number, data?: any): void;\r\n    pause(): void;\r\n    resume(): void;\r\n    ping(data?: any, options?: { mask?: boolean; binary?: boolean }, dontFail?: boolean): void;\r\n    pong(data?: any, options?: { mask?: boolean; binary?: boolean }, dontFail?: boolean): void;\r\n    send(data: any, cb?: (err: Error) => void): void;\r\n    send(data: any, options: { mask?: boolean; binary?: boolean }, cb?: (err: Error) => void): void;\r\n    stream(options: { mask?: boolean; binary?: boolean }, cb?: (err: Error, final: boolean) => void): void;\r\n    stream(cb?: (err: Error, final: boolean) => void): void;\r\n    terminate(): void;\r\n\r\n    // HTML5 WebSocket events\r\n    addEventListener(method: 'message', cb?: (event: { data: any; type: string; target: WebSocket }) => void): void;\r\n    addEventListener(method: 'close', cb?: (event: {\r\n        wasClean: boolean; code: number;\r\n        reason: string; target: WebSocket\r\n    }) => void): void;\r\n    addEventListener(method: 'error', cb?: (err: Error) => void): void;\r\n    addEventListener(method: 'open', cb?: (event: { target: WebSocket }) => void): void;\r\n    addEventListener(method: string, listener?: () => void): void;\r\n\r\n    // Events\r\n    on(event: 'error', cb: (err: Error) => void): this;\r\n    on(event: 'close', cb: (code: number, message: string) => void): this;\r\n    on(event: 'message', cb: (data: any, flags: { binary: boolean }) => void): this;\r\n    on(event: 'ping', cb: (data: any, flags: { binary: boolean }) => void): this;\r\n    on(event: 'pong', cb: (data: any, flags: { binary: boolean }) => void): this;\r\n    on(event: 'open', cb: () => void): this;\r\n    on(event: string, listener: () => void): this;\r\n\r\n    addListener(event: 'error', cb: (err: Error) => void): this;\r\n    addListener(event: 'close', cb: (code: number, message: string) => void): this;\r\n    addListener(event: 'message', cb: (data: any, flags: { binary: boolean }) => void): this;\r\n    addListener(event: 'ping', cb: (data: any, flags: { binary: boolean }) => void): this;\r\n    addListener(event: 'pong', cb: (data: any, flags: { binary: boolean }) => void): this;\r\n    addListener(event: 'open', cb: () => void): this;\r\n    addListener(event: string, listener: () => void): this;\r\n}\r\n\r\ndeclare namespace WebSocket {\r\n\r\n    type VerifyClientCallbackSync = (info: { origin: string; secure: boolean; req: http.IncomingMessage }) => boolean;\r\n    type VerifyClientCallbackAsync = (info: { origin: string; secure: boolean; req: http.IncomingMessage }\r\n        , callback: (res: boolean, code?: number, message?: string) => void) => void;\r\n\r\n    export interface IClientOptions {\r\n        protocol?: string;\r\n        agent?: http.Agent;\r\n        headers?: { [key: string]: string };\r\n        protocolVersion?: any;\r\n        host?: string;\r\n        origin?: string;\r\n        pfx?: any;\r\n        key?: any;\r\n        passphrase?: string;\r\n        cert?: any;\r\n        ca?: any[];\r\n        ciphers?: string;\r\n        rejectUnauthorized?: boolean;\r\n    }\r\n\r\n    export interface IPerMessageDeflateOptions {\r\n        serverNoContextTakeover?: boolean;\r\n        clientNoContextTakeover?: boolean;\r\n        serverMaxWindowBits?: number;\r\n        clientMaxWindowBits?: number;\r\n        memLevel?: number;\r\n    }\r\n\r\n    export interface IServerOptions {\r\n        host?: string;\r\n        port?: number;\r\n        server?: http.Server | https.Server;\r\n        backlog?: number;\r\n        verifyClient?: VerifyClientCallbackAsync | VerifyClientCallbackSync;\r\n        handleProtocols?: any;\r\n        path?: string;\r\n        noServer?: boolean;\r\n        disableHixie?: boolean;\r\n        clientTracking?: boolean;\r\n        perMessageDeflate?: boolean | IPerMessageDeflateOptions;\r\n        maxPayload?: number;\r\n    }\r\n\r\n    export class Server extends events.EventEmitter {\r\n        options: IServerOptions;\r\n        path: string;\r\n        clients: WebSocket[];\r\n\r\n        constructor(options?: IServerOptions, callback?: Function);\r\n\r\n        close(cb?: (err?: any) => void): void;\r\n        handleUpgrade(request: http.IncomingMessage, socket: net.Socket,\r\n            upgradeHead: Buffer, callback: (client: WebSocket) => void): void;\r\n\r\n        // Events\r\n        on(event: 'error', cb: (err: Error) => void): this;\r\n        on(event: 'headers', cb: (headers: string[]) => void): this;\r\n        on(event: 'connection', cb: (client: WebSocket) => void): this;\r\n        on(event: string, listener: () => void): this;\r\n\r\n        addListener(event: 'error', cb: (err: Error) => void): this;\r\n        addListener(event: 'headers', cb: (headers: string[]) => void): this;\r\n        addListener(event: 'connection', cb: (client: WebSocket) => void): this;\r\n        addListener(event: string, listener: () => void): this;\r\n    }\r\n\r\n    export function createServer(options?: IServerOptions,\r\n        connectionListener?: (client: WebSocket) => void): Server;\r\n    export function connect(address: string, openListener?: Function): void;\r\n    export function createConnection(address: string, openListener?: Function): void;\r\n}\r\n\r\nexport = WebSocket;\r\n","type":2},{"name":"node_modules/@types/yargs/index.d.ts","text":"// Type definitions for yargs 8.0\n// Project: https://github.com/chevex/yargs\n// Definitions by: Martin Poelstra <https://github.com/poelstra>\n//                 Mizunashi Mana <https://github.com/mizunashi-mana>\n//                 Jeffery Grajkowski <https://github.com/pushplay>\n//                 Jeff Kenney <https://github.com/jeffkenney>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.2\n\n// The following TSLint rules have been disabled:\n// unified-signatures: Because there is useful information in the argument names of the overloaded signatures\n\ndeclare namespace yargs {\n    interface Argv {\n        argv: Arguments;\n        (args?: string[], cwd?: string): Arguments;\n        parse(args: string | string[], context?: object, parseCallback?: ParseCallback): Arguments;\n\n        reset(): Argv;\n\n        locale(): string;\n        locale(loc: string): Argv;\n\n        detectLocale(detect: boolean): Argv;\n\n        terminalWidth(): number;\n\n        alias(shortName: string, longName: string | string[]): Argv;\n        alias(shortNames: string[], longName: string): Argv;\n        alias(aliases: { [shortName: string]: string | string[] }): Argv;\n\n        array(key: string): Argv;\n        array(keys: string[]): Argv;\n\n        default(key: string, value: any, description?: string): Argv;\n        default(defaults: { [key: string]: any }, description?: string): Argv;\n\n        /**\n         * @deprecated since version 6.6.0\n         */\n        demand(key: string, msg: string): Argv;\n        demand(key: string, required?: boolean): Argv;\n        demand(keys: string[], msg: string): Argv;\n        demand(keys: string[], required?: boolean): Argv;\n        demand(positionals: number, required?: boolean): Argv;\n        demand(positionals: number, msg: string): Argv;\n        demand(positionals: number, max: number, msg?: string): Argv;\n\n        demandCommand(min: number, minMsg?: string): Argv;\n        demandCommand(min: number, max?: number, minMsg?: string, maxMsg?: string): Argv;\n\n        demandOption(key: string | string[], msg?: string): Argv;\n        demandOption(key: string | string[], demand?: boolean): Argv;\n\n        /**\n         * @deprecated since version 6.6.0\n         */\n        require(key: string, msg: string): Argv;\n        require(key: string, required: boolean): Argv;\n        require(keys: number[], msg: string): Argv;\n        require(keys: number[], required: boolean): Argv;\n        require(positionals: number, required: boolean): Argv;\n        require(positionals: number, msg: string): Argv;\n\n        /**\n         * @deprecated since version 6.6.0\n         */\n        required(key: string, msg: string): Argv;\n        required(key: string, required: boolean): Argv;\n        required(keys: number[], msg: string): Argv;\n        required(keys: number[], required: boolean): Argv;\n        required(positionals: number, required: boolean): Argv;\n        required(positionals: number, msg: string): Argv;\n\n        requiresArg(key: string): Argv;\n        requiresArg(keys: string[]): Argv;\n\n        describe(key: string | string[], description: string): Argv;\n        describe(descriptions: { [key: string]: string }): Argv;\n\n        option(key: string, options: Options): Argv;\n        option(options: { [key: string]: Options }): Argv;\n        options(key: string, options: Options): Argv;\n        options(options: { [key: string]: Options }): Argv;\n\n        usage(message: string, options?: { [key: string]: Options }): Argv;\n        usage(options?: { [key: string]: Options }): Argv;\n\n        command(command: string | string[], description: string): Argv;\n        command(command: string | string[], description: string, builder: (args: Argv) => Argv): Argv;\n        command(command: string | string[], description: string, builder: { [optionName: string]: Options }): Argv;\n        command(command: string | string[], description: string, builder: { [optionName: string]: Options }, handler: (args: Arguments) => void): Argv;\n        command(command: string | string[], description: string, builder: (args: Argv) => Argv, handler: (args: Arguments) => void): Argv;\n        command(command: string | string[], description: string, module: CommandModule): Argv;\n        command(module: CommandModule): Argv;\n\n        commandDir(dir: string, opts?: RequireDirectoryOptions): Argv;\n\n        completion(): Argv;\n        completion(cmd: string, fn?: AsyncCompletionFunction): Argv;\n        completion(cmd: string, fn?: SyncCompletionFunction): Argv;\n        completion(cmd: string, description?: string, fn?: AsyncCompletionFunction): Argv;\n        completion(cmd: string, description?: string, fn?: SyncCompletionFunction): Argv;\n\n        example(command: string, description: string): Argv;\n\n        check(func: (argv: Arguments, aliases: { [alias: string]: string }) => any, global?: boolean): Argv;\n\n        boolean(key: string): Argv;\n        boolean(keys: string[]): Argv;\n\n        string(key: string): Argv;\n        string(keys: string[]): Argv;\n\n        number(key: string): Argv;\n        number(keys: string[]): Argv;\n\n        choices(choices: { [argName: string]: Choices }): Argv;\n        choices(key: string, values: Choices): Argv;\n\n        config(): Argv;\n        config(explicitConfigurationObject: object): Argv;\n        config(key: string, description?: string, parseFn?: (configPath: string) => object): Argv;\n        config(keys: string[], description?: string, parseFn?: (configPath: string) => object): Argv;\n        config(key: string, parseFn: (configPath: string) => object): Argv;\n        config(keys: string[], parseFn: (configPath: string) => object): Argv;\n\n        conflicts(key: string, value: string): Argv;\n        conflicts(conflicts: { [key: string]: string }): Argv;\n\n        wrap(columns: number): Argv;\n\n        strict(): Argv;\n\n        help(): Argv;\n        help(enableExplicit: boolean): Argv;\n        help(option: string, enableExplicit: boolean): Argv;\n        help(option: string, description?: string, enableExplicit?: boolean): Argv;\n\n        env(prefix?: string): Argv;\n        env(enable: boolean): Argv;\n\n        epilog(msg: string): Argv;\n        epilogue(msg: string): Argv;\n\n        version(version?: string, option?: string, description?: string): Argv;\n        version(version: () => string, option?: string, description?: string): Argv;\n\n        showHelpOnFail(enable: boolean, message?: string): Argv;\n\n        showHelp(consoleLevel?: string): Argv;\n\n        exitProcess(enabled: boolean): Argv;\n\n        global(key: string): Argv;\n        global(keys: string[]): Argv;\n\n        group(key: string, groupName: string): Argv;\n        group(keys: string[], groupName: string): Argv;\n\n        nargs(key: string, count: number): Argv;\n        nargs(nargs: { [key: string]: number }): Argv;\n\n        normalize(key: string): Argv;\n        normalize(keys: string[]): Argv;\n\n        implies(key: string, value: string): Argv;\n        implies(implies: { [key: string]: string }): Argv;\n\n        count(key: string): Argv;\n        count(keys: string[]): Argv;\n\n        fail(func: (msg: string, err: Error) => any): Argv;\n\n        coerce<T, U>(key: string | string[], func: (arg: T) => U): Argv;\n        coerce<T, U>(opts: { [key: string]: (arg: T) => U; }): Argv;\n\n        getCompletion(args: string[], done: (completions: string[]) => void): Argv;\n\n        pkgConf(key: string, cwd?: string): Argv;\n        pkgConf(keys: string[], cwd?: string): Argv;\n\n        recommendCommands(): Argv;\n\n        showCompletionScript(): Argv;\n\n        skipValidation(key: string): Argv;\n        skipValidation(keys: string[]): Argv;\n\n        updateLocale(obj: { [key: string]: string }): Argv;\n\n        updateStrings(obj: { [key: string]: string }): Argv;\n    }\n\n    interface Arguments {\n        /** Non-option arguments */\n        _: string[];\n        /** The script name or node command */\n        $0: string;\n\n        /** All remaining options */\n        [ argName: string ]: any;\n    }\n\n    interface RequireDirectoryOptions {\n        recurse?: boolean;\n        extensions?: string[];\n        visit?: (commandObject: any, pathToFile?: string, filename?: string) => any;\n        include?: RegExp | ((pathToFile: string) => boolean);\n        exclude?: RegExp | ((pathToFile: string) => boolean);\n    }\n\n    interface Options {\n        alias?: string | string[];\n        array?: boolean;\n        boolean?: boolean;\n        choices?: Choices;\n        coerce?: (arg: any) => any;\n        config?: boolean;\n        configParser?: (configPath: string) => object;\n        conflicts?: string | object;\n        count?: boolean;\n        default?: any;\n        defaultDescription?: string;\n        /** @deprecated since version 6.6.0 */\n        demand?: boolean | string;\n        demandOption?: boolean | string;\n        desc?: string;\n        describe?: string;\n        description?: string;\n        global?: boolean;\n        group?: string;\n        implies?: string | object;\n        nargs?: number;\n        normalize?: boolean;\n        number?: boolean;\n        require?: boolean | string;\n        required?: boolean | string;\n        requiresArg?: boolean | string;\n        skipValidation?: boolean;\n        string?: boolean;\n        type?: \"array\" | \"boolean\" | \"count\" | \"number\" | \"string\";\n    }\n\n    interface CommandModule {\n        aliases?: string[] | string;\n        builder?: CommandBuilder;\n        command?: string[] | string;\n        describe?: string | false;\n        handler: (args: any) => void;\n    }\n\n    type ParseCallback = (err: Error | undefined, argv: Arguments, output: string) => void;\n    type CommandBuilder = { [key: string]: Options } | ((args: Argv) => Argv);\n    type SyncCompletionFunction = (current: string, argv: any) => string[];\n    type AsyncCompletionFunction = (current: string, argv: any, done: (completion: string[]) => void) => void;\n    type Choice = string | true | undefined;\n    type Choices = Choice[];\n}\n\ndeclare var yargs: yargs.Argv;\nexport = yargs;\n","type":2}],"files":[{"name":"./src/ApplicationContext.ts","text":"import { deepAssign } from '@dojo/core/lang';\nimport { Injector } from '@dojo/widget-core/Injector';\n\nimport { WorkerProperties } from './widgets/Worker';\nimport { WorkerFormData } from './widgets/WorkerForm';\n\nexport default class ApplicationContext extends Injector {\n\n\tprivate _workerData: WorkerProperties[];\n\n\tprivate _formData: Partial<WorkerFormData> = {};\n\n\tconstructor(workerData: WorkerProperties[] = []) {\n\t\tsuper({});\n\t\tthis._workerData = workerData;\n\t}\n\n\tget workerData(): WorkerProperties[] {\n\t\treturn this._workerData;\n\t}\n\n\tget formData(): Partial<WorkerFormData> {\n\t\treturn this._formData;\n\t}\n\n\tpublic formInput(input: Partial<WorkerFormData>): void {\n\t\tthis._formData = deepAssign({}, this._formData, input);\n\t\tthis.emit({ type: 'invalidate' });\n\t}\n\n\tpublic submitForm(): void {\n\t\tthis._workerData = [ ...this._workerData, this._formData ];\n\t\tthis._formData = {};\n\t\tthis.emit({ type: 'invalidate' });\n\t}\n\n\tget(): ApplicationContext {\n\t\treturn this;\n\t}\n}\n","type":1},{"name":"./src/containers/WorkerFormContainer.ts","text":"import { Container } from '@dojo/widget-core/Container';\n\nimport ApplicationContext from './../ApplicationContext';\nimport WorkerForm, { WorkerFormProperties } from './../widgets/WorkerForm';\n\nfunction getProperties(inject: ApplicationContext, properties: any) {\n\tconst { formData, formInput: onFormInput, submitForm: onFormSave } = inject;\n\n\treturn { formData, onFormInput: onFormInput.bind(inject), onFormSave: onFormSave.bind(inject) };\n}\n\nconst WorkerFormContainer = Container(WorkerForm, 'app-state', { getProperties });\n\nexport default WorkerFormContainer;\n","type":1},{"name":"./src/containers/WorkerContainerContainer.ts","text":"import { Container } from '@dojo/widget-core/Container';\n\nimport ApplicationContext from './../ApplicationContext';\nimport WorkerContainer, { WorkerContainerProperties } from './../widgets/WorkerContainer';\n\nfunction getProperties(inject: ApplicationContext, properties: any) {\n\treturn { workerData: inject.workerData };\n}\n\nconst WorkerContainerContainer = Container(WorkerContainer, 'app-state', { getProperties });\n\nexport default WorkerContainerContainer;\n","type":1},{"name":"./src/index.html","text":"<!DOCTYPE html>\n<html>\n<head>\n\t<title>biz-e-corp</title>\n</head>\n<body>\n\t<my-app></my-app>\n</body>\n</html>\n","type":6},{"name":"./src/main.css","text":"/* Put your styles and imports here */\n","type":5},{"name":"./src/main.css.d.ts","text":"export default {};\n","type":2},{"name":"./src/main.ts","text":"import { ProjectorMixin } from '@dojo/widget-core/mixins/Projector';\nimport { Registry } from '@dojo/widget-core/Registry';\n\nimport ApplicationContext from './ApplicationContext';\nimport App from './widgets/App';\n\nconst root = document.querySelector('my-app') || undefined;\n\nconst applicationContext = new ApplicationContext([\n\t{\n\t\tfirstName: 'Tim',\n\t\tlastName: 'Jones',\n\t\temail: 'tim.jones@bizecorp.org',\n\t\ttasks: [\n\t\t\t'6267 - Untangle paperclips',\n\t\t\t'4384 - Shred documents',\n\t\t\t'9663 - Digitize 1985 archive'\n\t\t]\n\t},\n\t{\n\t\tfirstName: 'Alicia',\n\t\tlastName: 'Fitzgerald'\n\t},\n\t{\n\t\tfirstName: 'Hans',\n\t\tlastName: 'Mueller'\n\t}\n]);\n\nconst registry = new Registry();\nregistry.defineInjector('app-state', applicationContext);\n\nconst Projector = ProjectorMixin(App);\nconst projector = new Projector();\nprojector.setProperties({ registry });\n\nprojector.append(root);\n","type":1},{"name":"./src/styles/worker.css","text":".generalInfo {\n\tbox-sizing: border-box;\n\tdisplay: inline-block;\n\tmargin-bottom: 20px;\n\tpadding-left: 10px;\n\tvertical-align: middle;\n\twidth: 60%;\n}\n\n.image {\n\tmargin: 0 auto 20px;\n\tmax-width: 250px;\n\twidth: 100%;\n}\n\n.imageSmall {\n\tmargin-bottom: 20px;\n\tvertical-align: middle;\n\twidth: 40%;\n}\n\n.label {\n\tfont-weight: bold;\n}\n\n.task {\n\tborder: solid 1px #333;\n\tborder-radius: 0.3em;\n\tmargin-top: 3px;\n\tpadding: 3px;\n\ttext-align: left;\n}\n\n.worker {\n\tflex: 1 1 calc(33% - 20px);\n\tmargin: 0 10px 40px;\n\tmax-width: 350px;\n\tmin-width: 250px;\n\tposition: relative;\n\n\t/* flip transform styles */\n\tperspective: 1000px;\n\ttransform-style: preserve-3d;\n}\n\n.workerFront, .workerBack {\n\tborder: 1px solid #333;\n\tborder-radius: 4px;\n\tbox-sizing: border-box;\n\tpadding: 30px;\n\n\t/* flip transform styles */\n\tbackface-visibility: hidden;\n\ttransition: all 0.6s;\n\ttransform-style: preserve-3d;\n}\n\n.workerBack {\n\tfont-size: 0.75em;\n\theight: 100%;\n\tleft: 0;\n\tposition: absolute;\n\ttop: 0;\n\ttransform: rotateY(-180deg);\n\twidth: 100%;\n}\n\n.workerFront {\n\ttext-align: center;\n\ttransform: rotateY(0deg);\n\tz-index: 2;\n}\n\n.reverse .workerFront {\n\ttransform: rotateY(180deg);\n}\n\n.reverse .workerBack {\n\ttransform: rotateY(0deg);\n}\n","type":5},{"name":"./src/styles/worker.css.d.ts","text":"export const generalInfo: string;\nexport const image: string;\nexport const imageSmall: string;\nexport const label: string;\nexport const task: string;\nexport const worker: string;\nexport const workerFront: string;\nexport const workerBack: string;\nexport const reverse: string;\n","type":2},{"name":"./src/styles/workerContainer.css","text":".container {\n\tdisplay: flex;\n\tflex-flow: row wrap;\n\tjustify-content: center;\n\talign-items: stretch;\n\tmargin: 0 auto;\n\twidth: 100%;\n}\n","type":5},{"name":"./src/styles/workerContainer.css.d.ts","text":"export const container: string;\n","type":2},{"name":"./src/styles/workerForm.css","text":".workerForm {\n\tmargin-bottom: 40px;\n\ttext-align: center;\n}\n\n.workerForm fieldset,\n.workerForm label {\n\tdisplay: inline-block;\n\ttext-align: left;\n}\n\n.workerForm label {\n\tmargin-right: 10px;\n}\n\n.nameField {\n\tborder: 0;\n\tmargin: 0;\n\tpadding: 0;\n}\n\n.nameLabel {\n\tfont: 14px/1 sans-serif;\n\tmargin: 5px 0;\n}\n\n.workerButton {\n\tpadding: 5px 20px;\n}\n","type":5},{"name":"./src/styles/workerForm.css.d.ts","text":"export const workerForm: string;\nexport const nameField: string;\nexport const nameLabel: string;\nexport const workerButton: string;\n","type":2},{"name":"./src/widgets/App.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { v, w } from '@dojo/widget-core/d';\nimport Banner from './Banner';\nimport WorkerContainerContainer from './../containers/WorkerContainerContainer';\nimport WorkerFormContainer from './../containers/WorkerFormContainer';\n\nexport default class App extends WidgetBase {\n\n\tprotected render() {\n\t\treturn v('div', [\n\t\t\tw(Banner, {}),\n\t\t\tw(WorkerFormContainer, {}),\n\t\t\tw(WorkerContainerContainer, {})\n\t\t]);\n\t}\n}\n","type":1},{"name":"./src/widgets/Banner.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { v } from '@dojo/widget-core/d';\n\nexport default class Banner extends WidgetBase {\n\tprotected render() {\n\t\treturn v('h1', { title: 'I am a title!' }, [ 'Biz-E-Bodies' ]);\n\t}\n}\n","type":1},{"name":"./src/widgets/Worker.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { v } from '@dojo/widget-core/d';\nimport { theme, ThemedMixin } from '@dojo/widget-core/mixins/Themed';\nimport * as css from '../styles/worker.css';\n\nexport interface WorkerProperties {\n\tfirstName?: string;\n\tlastName?: string;\n\temail?: string;\n\ttimePerTask?: number;\n\ttasks?: string[];\n}\n\nconst WorkerBase = ThemedMixin(WidgetBase);\n\n@theme(css)\nexport default class Worker extends WorkerBase<WorkerProperties> {\n\tprivate _isFlipped = false;\n\n\tprotected render() {\n\t\treturn v('div', {\n\t\t\tclasses: this.theme([ css.worker, this._isFlipped ? css.reverse : null ])\n\t\t}, [\n\t\t\tthis._renderFront(),\n\t\t\tthis._renderBack()\n\t\t]);\n\t}\n\n\tprivate _renderFront() {\n\t\tconst {\n\t\t\tfirstName = 'firstName',\n\t\t\tlastName = 'lastName'\n\t\t} = this.properties;\n\n\t\treturn v('div', {\n\t\t\tkey: 'front',\n\t\t\tclasses: this.theme(css.workerFront),\n\t\t\tonclick: this.flip\n\t\t}, [\n\t\t\tv('img', {\n\t\t\t\tclasses: this.theme(css.image),\n\t\t\t\tsrc: 'https://dojo.io/tutorials/resources/worker.svg'\n\t\t\t}),\n\t\t\tv('div', [\n\t\t\t\tv('strong', [ `${lastName}, ${firstName}` ])\n\t\t\t])\n\t\t]);\n\t}\n\n\tprivate _renderBack() {\n\t\tconst {\n\t\t\tfirstName = 'firstName',\n\t\t\tlastName = 'lastName',\n\t\t\temail = 'unavailable',\n\t\t\ttimePerTask = 0,\n\t\t\ttasks = []\n\t\t} = this.properties;\n\n\t\treturn v('div', {\n\t\t\tkey: 'back',\n\t\t\tclasses: this.theme(css.workerBack),\n\t\t\tonclick: this.flip\n\t\t\t}, [\n\t\t\t\tv('img', {\n\t\t\t\t\tclasses: this.theme(css.imageSmall),\n\t\t\t\t\tsrc: 'https://dojo.io/tutorials/resources/worker.svg'\n\t\t\t\t}),\n\t\t\t\tv('div', {\n\t\t\t\t\tclasses: this.theme(css.generalInfo)\n\t\t\t\t}, [\n\t\t\t\t\tv('div', {\n\t\t\t\t\t\tclasses : this.theme(css.label)\n\t\t\t\t\t}, ['Name']),\n\t\t\t\t\tv('div', [`${lastName}, ${firstName}`]),\n\t\t\t\t\tv('div', {\n\t\t\t\t\t\tclasses: this.theme(css.label)\n\t\t\t\t\t}, ['Email']),\n\t\t\t\t\tv('div', [`${email}`]),\n\t\t\t\t\tv('div', {\n\t\t\t\t\t\tclasses: this.theme(css.label)\n\t\t\t\t\t}, ['Avg. Time per Task']),\n\t\t\t\t\tv('div', [`${timePerTask}`])\n\t\t\t\t]),\n\t\t\t\tv('div', [\n\t\t\t\t\tv('strong', ['Current Tasks']),\n\t\t\t\t\tv('div', tasks.map(task => {\n\t\t\t\t\t\treturn v('div', {\n\t\t\t\t\t\t\tclasses: this.theme(css.task)\n\t\t\t\t\t\t}, [task]);\n\t\t\t\t\t}))\n\t\t\t\t])\n\t\t\t]\n\t\t);\n\t}\n\n\tflip(): void {\n\t\tthis._isFlipped = !this._isFlipped;\n\t\tthis.invalidate();\n\t}\n}\n","type":1},{"name":"./src/widgets/WorkerContainer.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { w, v } from '@dojo/widget-core/d';\nimport Worker, { WorkerProperties } from './Worker';\nimport { theme, ThemedMixin } from '@dojo/widget-core/mixins/Themed';\nimport * as css from '../styles/workerContainer.css';\n\nexport interface WorkerContainerProperties {\n\tworkerData?: WorkerProperties[];\n}\n\nconst WorkerContainerBase = ThemedMixin(WidgetBase);\n\n@theme(css)\nexport default class WorkerContainer extends WorkerContainerBase<WorkerContainerProperties> {\n\n\tprotected render() {\n\t\tconst {\n\t\t\tworkerData = []\n\t\t} = this.properties;\n\n\t\tconst workers = workerData.map((worker, i) => w(Worker, {\n\t\t\tkey: `worker-${i}`,\n\t\t\t...worker\n\t\t}));\n\n\t\treturn v('div', {\n\t\t\tclasses: this.theme(css.container)\n\t\t}, workers);\n\t}\n}\n","type":1},{"name":"./src/widgets/WorkerForm.ts","text":"import { WidgetBase } from '@dojo/widget-core/WidgetBase';\nimport { TypedTargetEvent } from '@dojo/widget-core/interfaces';\nimport { v, w } from '@dojo/widget-core/d';\nimport { ThemedMixin, theme } from '@dojo/widget-core/mixins/Themed';\nimport Button from '@dojo/widgets/button/Button';\nimport TextInput from '@dojo/widgets/textinput/TextInput';\nimport * as css from '../styles/workerForm.css';\n\nexport interface WorkerFormData {\n\tfirstName: string;\n\tlastName: string;\n\temail: string;\n}\n\nexport interface WorkerFormProperties {\n\tformData: WorkerFormData;\n\tonFormInput: (data: Partial<WorkerFormData>) => void;\n\tonFormSave: () => void;\n}\n\nexport const WorkerFormBase = ThemedMixin(WidgetBase);\n\n@theme(css)\nexport default class WorkerForm extends WorkerFormBase<WorkerFormProperties> {\n\n\tprivate _onSubmit(event: Event) {\n\t\tevent.preventDefault();\n\t\tthis.properties.onFormSave();\n\t}\n\n\tprotected onFirstNameInput({ target: { value: firstName } }: TypedTargetEvent<HTMLInputElement>) {\n\t\tthis.properties.onFormInput({ firstName });\n\t}\n\n\tprotected onLastNameInput({ target: { value: lastName } }: TypedTargetEvent<HTMLInputElement>) {\n\t\tthis.properties.onFormInput({ lastName });\n\t}\n\n\tprotected onEmailInput({ target: { value: email } }: TypedTargetEvent<HTMLInputElement>) {\n\t\tthis.properties.onFormInput({ email });\n\t}\n\n\tprotected render() {\n\t\tconst {\n\t\t\tformData: { firstName, lastName, email }\n\t\t} = this.properties;\n\n\t\treturn v('form', {\n\t\t\tclasses: this.theme(css.workerForm),\n\t\t\tonsubmit: this._onSubmit\n\t\t}, [\n\t\t\tv('fieldset', { classes: this.theme(css.nameField) }, [\n\t\t\t\tv('legend', { classes: this.theme(css.nameLabel) }, [ 'Name' ]),\n\t\t\t\tw(TextInput, {\n\t\t\t\t\tkey: 'firstNameInput',\n\t\t\t\t\tlabel: {\n\t\t\t\t\t\tcontent: 'First Name',\n\t\t\t\t\t\thidden: true\n\t\t\t\t\t},\n\t\t\t\t\tplaceholder: 'Given name',\n\t\t\t\t\tvalue: firstName,\n\t\t\t\t\trequired: true,\n\t\t\t\t\tonInput: this.onFirstNameInput\n\t\t\t\t}),\n\t\t\t\tw(TextInput, {\n\t\t\t\t\tkey: 'lastNameInput',\n\t\t\t\t\tlabel: {\n\t\t\t\t\t\tcontent: 'Last Name',\n\t\t\t\t\t\thidden: true\n\t\t\t\t\t},\n\t\t\t\t\tplaceholder: 'Surname name',\n\t\t\t\t\tvalue: lastName,\n\t\t\t\t\trequired: true,\n\t\t\t\t\tonInput: this.onLastNameInput\n\t\t\t\t})\n\t\t\t]),\n\t\t\tw(TextInput, {\n\t\t\t\tlabel: 'Email address',\n\t\t\t\ttype: 'email',\n\t\t\t\tvalue: email,\n\t\t\t\trequired: true,\n\t\t\t\tonInput: this.onEmailInput\n\t\t\t}),\n\t\t\tw(Button, {}, [ 'Save' ])\n\t\t]);\n\t}\n}\n","type":1},{"name":"./tests/functional/all.ts","text":"import './main';\n","type":1},{"name":"./tests/functional/main.ts","text":"/* Write your app tests here */\n","type":1},{"name":"./tests/unit/all.ts","text":"import './widgets/all';\n","type":1},{"name":"./tests/unit/main.ts","text":"/* Write your app tests here */\n","type":1},{"name":"./tests/unit/widgets/all.ts","text":"import './Banner';\n","type":1},{"name":"./tests/unit/widgets/Banner.ts","text":"import { v } from '@dojo/widget-core/d';\nimport harness, { Harness } from '@dojo/test-extras/harness';\nimport Banner from '../../../src/widgets/Banner';\n\nconst { describe, it, beforeEach, afterEach} = intern.getInterface('bdd');\nlet bannerHarness: Harness<Banner>;\n\ndescribe('Banner', () => {\n\tbeforeEach(() =>  {\n\t\tbannerHarness = harness(Banner);\n\t});\n\n\tafterEach(() => {\n\t\tbannerHarness.destroy();\n\t});\n\n\tit('should render', () => {\n\t\tbannerHarness.expectRender(v('h1', { title: 'I am a title!' }, [ 'Biz-E-Bodies' ]));\n\t});\n});\n","type":1}],"index":"./src/index.html","package":{"name":"biz-e-corp","version":"1.0.0","dependencies":{"@dojo/core":"~0.2.1","@dojo/has":"~0.1.0","@dojo/routing":"~0.2.0","@dojo/shim":"~0.2.2","@dojo/widget-core":"~0.3.0","@dojo/i18n":"~0.2.0","@dojo/widgets":"~0.2.1"},"devDependencies":{"@dojo/cli-build-webpack":"~0.2.0","@dojo/cli-test-intern":"~0.2.0","@dojo/interfaces":"~0.1.0","@dojo/loader":"~0.1.0","@dojo/test-extras":"~0.2.0","@types/glob":"~5.0.0","@types/grunt":"~0.4.0","@types/node":"^6.0.46","@types/sinon":"^1.16.35","chai":"^3.5.0","intern":"~4.1.0","sinon":"^2.0.0","typescript":"~2.4.2"}},"tsconfig":{"compilerOptions":{"declaration":false,"experimentalDecorators":true,"lib":["dom","es5","es2015.promise","es2015.iterable","es2015.symbol","es2015.symbol.wellknown"],"module":"umd","moduleResolution":"node","noImplicitAny":true,"noImplicitThis":true,"outDir":"_build/","removeComments":false,"sourceMap":true,"strictNullChecks":true,"target":"es5","types":["intern"]},"include":["./src/**/*.ts","./tests/**/*.ts"]}}